<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>C++内存管理 - Benboby&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Benboby&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Benboby&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="内存管理内存管理详解内存分配方式分配方式简介在C++中，内存分为5个区：  栈：执行函数时，函数内部局部变量存储单元在栈上创建，结束时自动释放。效率很高，但存储容量有限。 堆：由 new 分配的内存块，编译器不会自动释放，需要应用程序对应的 delete 进行释放。如果没有释放，则程序运行结束后会由操作系统自动回收。 自由存储区：由 malloc 等分配的内存块，类似堆，由 free 结束自己的生"><meta property="og:type" content="blog"><meta property="og:title" content="C++内存管理"><meta property="og:url" content="https://www.benboby.top/2020/11/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"><meta property="og:site_name" content="Benboby&#039;s Blog"><meta property="og:description" content="内存管理内存管理详解内存分配方式分配方式简介在C++中，内存分为5个区：  栈：执行函数时，函数内部局部变量存储单元在栈上创建，结束时自动释放。效率很高，但存储容量有限。 堆：由 new 分配的内存块，编译器不会自动释放，需要应用程序对应的 delete 进行释放。如果没有释放，则程序运行结束后会由操作系统自动回收。 自由存储区：由 malloc 等分配的内存块，类似堆，由 free 结束自己的生"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://img.benboby.top/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%89%AF%E6%9C%AC.png"><meta property="og:image" content="https://www.benboby.top/2020/11/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.htm/指针的指针.png"><meta property="article:published_time" content="2020-11-02T03:12:51.000Z"><meta property="article:modified_time" content="2021-02-09T09:18:32.314Z"><meta property="article:author" content="Benboby"><meta property="article:tag" content="C++内存管理"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="http://img.benboby.top/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%89%AF%E6%9C%AC.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.benboby.top/2020/11/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"},"headline":"Benboby's Blog","image":["http://img.benboby.top/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%89%AF%E6%9C%AC.png","https://www.benboby.top/2020/11/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.htm/指针的指针.png"],"datePublished":"2020-11-02T03:12:51.000Z","dateModified":"2021-02-09T09:18:32.314Z","author":{"@type":"Person","name":"Benboby"},"description":"内存管理内存管理详解内存分配方式分配方式简介在C++中，内存分为5个区：  栈：执行函数时，函数内部局部变量存储单元在栈上创建，结束时自动释放。效率很高，但存储容量有限。 堆：由 new 分配的内存块，编译器不会自动释放，需要应用程序对应的 delete 进行释放。如果没有释放，则程序运行结束后会由操作系统自动回收。 自由存储区：由 malloc 等分配的内存块，类似堆，由 free 结束自己的生"}</script><link rel="canonical" href="https://www.benboby.top/2020/11/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css"><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="Benboby's Blog" type="application/atom+xml">
</head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Benboby&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">文章</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/categories">分类</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/Benboby"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-11-02T03:12:51.000Z" title="2020-11-02T03:12:51.000Z">2020-11-02</time>发表</span><span class="level-item"><time dateTime="2021-02-09T09:18:32.314Z" title="2021-02-09T09:18:32.314Z">2021-02-09</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/C/">C++</a></span><span class="level-item">21 分钟读完 (大约3174个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">C++内存管理</h1><div class="content"><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="内存管理详解"><a href="#内存管理详解" class="headerlink" title="内存管理详解"></a>内存管理详解</h3><h4 id="内存分配方式"><a href="#内存分配方式" class="headerlink" title="内存分配方式"></a>内存分配方式</h4><h5 id="分配方式简介"><a href="#分配方式简介" class="headerlink" title="分配方式简介"></a>分配方式简介</h5><p>在C++中，内存分为5个区：</p>
<ol>
<li>栈：执行函数时，函数内部局部变量存储单元在栈上创建，结束时自动释放。效率很高，但存储容量有限。</li>
<li>堆：由 <strong>new</strong> 分配的内存块，编译器不会自动释放，需要应用程序对应的 <strong>delete</strong> 进行释放。如果没有释放，则程序运行结束后会由操作系统自动回收。</li>
<li>自由存储区：由 <strong>malloc</strong> 等分配的内存块，类似堆，由 <strong>free</strong> 结束自己的生命。</li>
<li>全局/静态存储区：存储全局变量和静态变量。</li>
<li>常量存储区：存放常量，不允许修改。</li>
</ol>
<a id="more"></a> 
<h5 id="明确区分堆和栈"><a href="#明确区分堆和栈" class="headerlink" title="明确区分堆和栈"></a>明确区分堆和栈</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在栈内存中存放了一个指向一块堆内存的指针 p。程序会先确定在堆中分配内存的大小，然后调用 <strong>operator new</strong> 分配内存，然后返回这块内存的首地址，放入栈中。</p>
<p>这里并没有释放内存，因此需要 <strong>delete[] p</strong>，告诉编译器删除的是数组，然后编译器根据Cookie信息去释放内存。</p>
<h5 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h5><ol>
<li>管理方式：栈由编译器自动管理，无需手动控制；堆的释放工作由程序员控制，容易产生内存泄露。</li>
<li>空间大小：堆栈的内存都可以自己设定，堆内存一般不超过系统内存都是可以申请，栈内存个人测试默认值为8M。</li>
<li>碎片问题：对于堆而言，频繁的 <strong>new/delete</strong> 势必会造成内存空间的不连续，造成大量的碎片，使程序的效率降低；对于栈而言，则不会发生这样的情况，先进后出排列有序，以至于永远不可能有一个内存块从非栈顶位置弹出。</li>
<li>生长方向：对于堆而言，生长方向向上，向着内存地址增加的方向增长；对于栈而言，生长方向向下，向着内存地址减小的方向增长。</li>
<li>分配方式：堆都是动态分配的，没有静态分配的堆。栈有动态分配和静态分配两种，静态分配由编译器完成，比如局部变量的分配；动态分配由 <strong>alloca</strong> 函数进行分配，都由编译器进行释放。</li>
<li>分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持，这就决定了栈的效率比较高。堆则是 C/C++ 函数库提供的，机制比较复杂，用到许多算法的实现内存的分配。显然，堆的效率比栈要低得多。</li>
</ol>
<p>因此，更推荐尽量使用栈而不是堆。但是栈和堆相比并不灵活。如果需要分配大量内存空间，还是堆好一些。</p>
<h4 id="控制-C-的内存分配"><a href="#控制-C-的内存分配" class="headerlink" title="控制 C++ 的内存分配"></a>控制 C++ 的内存分配</h4><p>无论如何，一定要保守的使用内存分配。<br>一个防止堆破碎的通用方法是从不同固定大小的内存池中分配不同类型的对象。对每个类重载 <strong>new</strong> 和 <strong>delete</strong> 就提供了这样的控制。</p>
<h5 id="重载全局的new和delete操作"><a href="#重载全局的new和delete操作" class="headerlink" title="重载全局的new和delete操作"></a>重载全局的new和delete操作</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">void</span> *p = <span class="built_in">malloc</span>(size); </span><br><span class="line">    <span class="keyword">return</span> (p); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *p)</span></span>; </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">free</span>(p); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以对单个类的 new 和 delete 操作符重载。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *p)</span></span>; </span><br><span class="line">    <span class="comment">// .. other members here ... </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">void</span> *TestClass::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">void</span> *p = <span class="built_in">malloc</span>(size); <span class="comment">// Replace this with alternative allocator </span></span><br><span class="line">    <span class="keyword">return</span> (p); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> TestClass::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *p)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">free</span>(p); <span class="comment">// Replace this with alternative de-allocator</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="为单个类重载-new-和-delete"><a href="#为单个类重载-new-和-delete" class="headerlink" title="为单个类重载 new[] 和 delete[]"></a>为单个类重载 new[] 和 delete[]</h5><p>C++将对象数组的内存分配作为一个单独的操作，而不同于单个对象的内存分配。为了改变这种方式，同样需要重载 new[] 和 delete[]操作符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">void</span> * <span class="keyword">operator</span> <span class="keyword">new</span>[ ](<span class="keyword">size_t</span> size); </span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[ ](<span class="keyword">void</span> *p); </span><br><span class="line">    <span class="comment">// .. other members here .. </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">void</span> *TestClass::<span class="keyword">operator</span> <span class="keyword">new</span>[ ](<span class="keyword">size_t</span> size) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">void</span> *p = <span class="built_in">malloc</span>(size); </span><br><span class="line">    <span class="keyword">return</span> (p); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">void</span> TestClass::<span class="keyword">operator</span> <span class="keyword">delete</span>[ ](<span class="keyword">void</span> *p) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">free</span>(p); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    TestClass *p = <span class="keyword">new</span> TestClass[<span class="number">10</span>]; </span><br><span class="line">    <span class="comment">// ... etc ... </span></span><br><span class="line">    <span class="keyword">delete</span>[ ] p; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS：对于多数 C++ 的实现，<strong>new[]</strong> 操作符中的个数参数是数组的大小加上额外的存储对象数目的一些字节。因此应该尽量避免分配对象数组，使内存分配策略简单。</p>
<h4 id="常见的内存错误"><a href="#常见的内存错误" class="headerlink" title="常见的内存错误"></a>常见的内存错误</h4><ol>
<li>内存分配未成功，却使用了它。<ul>
<li>如果是用 malloc 或 new 来申请内存，应该用 if(p==NULL) 或 if(p!=NULL)进行防错。</li>
</ul>
</li>
<li>内存分配虽然成功，但未初始化就引用它。<ul>
<li>无论用何种方式创建数组，都要赋初值，即便是零值。</li>
</ul>
</li>
<li>内存分配成功并且已经初始化，但操作越界。<ul>
<li>多发生在下标“多1”或“少1”。</li>
</ul>
</li>
<li>忘记了释放内存，造成内存泄漏。<ul>
<li>动态内存的申请与释放必须配对，程序中 <strong>malloc</strong> 与 <strong>free</strong> 的使用次数一定要相同，否则肯定有错误（new/delete同理）。</li>
</ul>
</li>
<li>释放了内存却继续使用它。<ul>
<li>程序过于复杂，难以分清是否释放了内存，此时应当重新设计数据结构，解决混乱。</li>
<li>return语句写错，不要返回指向“栈内存”的指针或引用，因为该内存在函数体结束时被自动销毁。</li>
<li>free或delete释放内存后，没有将指针设为NULL，导致“野指针”。</li>
</ul>
</li>
</ol>
<h4 id="指针与数组对比"><a href="#指针与数组对比" class="headerlink" title="指针与数组对比"></a>指针与数组对比</h4><p>数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。数组名对应着（<strong>而不是指向</strong>）一块内存，其地址和容量在生命周期内保持不变，只有数组的内容可以改变。</p>
<p>指针可以随时指向任何类型的内存块，它的特征是“可变”的，所以常用指针来操作动态内存，指针远比数组灵活，但也更危险。</p>
<h5 id="修改数组内容"><a href="#修改数组内容" class="headerlink" title="修改数组内容"></a>修改数组内容</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[] = “hello”; </span><br><span class="line">a[<span class="number">0</span>] = ‘X’; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"><span class="comment">// 可以拆分为 char s[] = &quot;world&quot;; char *p = str;</span></span><br><span class="line"><span class="keyword">char</span> *p = “world”; <span class="comment">// 注意 p 指向常量字符串</span></span><br><span class="line">p[<span class="number">0</span>] = ‘X’; <span class="comment">// 编译器不能发现该错误，但运行时产生[Bus error]</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h5 id="内容复制与比较"><a href="#内容复制与比较" class="headerlink" title="内容复制与比较"></a>内容复制与比较</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组… </span></span><br><span class="line"><span class="keyword">char</span> a[] = <span class="string">&quot;hello&quot;</span>; </span><br><span class="line"><span class="keyword">char</span> b[<span class="number">10</span>]; </span><br><span class="line"><span class="built_in">strcpy</span>(b, a); <span class="comment">// 不能用 b = a; </span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(b, a) == <span class="number">0</span>) <span class="comment">// 不能用 if (b == a) </span></span><br><span class="line">… </span><br><span class="line"><span class="comment">// 指针… </span></span><br><span class="line"><span class="comment">// 语句 p = a 并不能把 a 的内容复制给指针 p，而是把 a 的地址赋给了 p。</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(a); </span><br><span class="line"><span class="keyword">char</span> *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*(len+<span class="number">1</span>)); </span><br><span class="line"><span class="built_in">strcpy</span>(p, a); <span class="comment">// 不要用 p = a; </span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(p, a) == <span class="number">0</span>) <span class="comment">// 不要用 if (p == a) </span></span><br></pre></td></tr></table></figure>
<h5 id="计算内存容量"><a href="#计算内存容量" class="headerlink" title="计算内存容量"></a>计算内存容量</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[] = <span class="string">&quot;hello world&quot;</span>; </span><br><span class="line"><span class="keyword">char</span> *p = a; </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(a) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 12 字节</span></span><br><span class="line"><span class="comment">// sizeof(p) 等价于 sizeof(char *)，没有办法的值指针所指的内存容量，除非申请内存时就记住它</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(p) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 4 字节</span></span><br></pre></td></tr></table></figure>
<p>注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(<span class="keyword">char</span> a[<span class="number">100</span>])</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// 不论数组 a 的容量是多少，sizeof(a)始终等于 sizeof(char *)。</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(a) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 4 字节而不是 100 字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="指针参数如何传递内存"><a href="#指针参数如何传递内存" class="headerlink" title="指针参数如何传递内存"></a>指针参数如何传递内存</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetMemory</span><span class="params">(<span class="keyword">char</span> *p, <span class="keyword">int</span> num)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    p = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * num); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>; </span><br><span class="line">    GetMemory(str, <span class="number">100</span>); <span class="comment">// str 仍然为 NULL </span></span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello&quot;</span>); <span class="comment">// 运行错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://img.benboby.top/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%89%AF%E6%9C%AC.png" alt></p>
<p>如果函数的参数是一个指针，不要指望用该指针去申请动态内存。编译器总是要为函数的每个参数制作临时副本，指针参数 p 的副本是 _p，编译器使 _p = p。如果函数体内的程序修改了_p 的内容，就导致参数 p 的内容作相应的修改。这就是指针可以用作输出参数的原因。_p 申请了新的内存，只是把 _p 所指的内存地址改变了，但是 p 丝毫未变。所以函数 GetMemory 并不能输出任何东西。事实上，每执行一次 GetMemory 就会泄露一块内存，因为没有用 free 释放内存。</p>
<p>如果非得要用指针参数去申请内存，那么应该改用“指向指针的指针”:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetMemory2</span><span class="params">(<span class="keyword">char</span> **p, <span class="keyword">int</span> num)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * num); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test2</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>; </span><br><span class="line">    GetMemory2(&amp;str, <span class="number">100</span>); <span class="comment">// 注意参数是 &amp;str，而不是 str </span></span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello&quot;</span>); </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; str &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">free</span>(str); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="/2020/11/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.htm/指针的指针.png" alt></p>
<p>比较好的方法是 <strong>传指针的引用</strong>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetMemory</span><span class="params">(<span class="keyword">char</span> *&amp;p, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    GetMemory(str, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">free</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以用函数返回值来传递动态内存。这种方法更加简单：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">GetMemory3</span><span class="params">(<span class="keyword">int</span> num)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * num); </span><br><span class="line">    <span class="keyword">return</span> p; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test3</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>; </span><br><span class="line">    str = GetMemory3(<span class="number">100</span>); </span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello&quot;</span>); </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; str &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">free</span>(str); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在使用返回值时，千万别返回 <strong>指向“栈内存”</strong> 的指针、引用，因为该内存在函数结束时 <strong>自动消亡</strong> 了，返回的指针是个野指针了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">GetString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> p[] = <span class="string">&quot;hello world&quot;</span>; <span class="comment">//数组内容存储在栈区，函数结束时，会释放掉</span></span><br><span class="line">     <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    str = GetString();      <span class="comment">//因为非配的内存早已释放掉，此时的str是个野指针，内容是垃圾</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在函数中不定义数组，定义指针：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">GetString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> *p = <span class="string">&quot;hello world&quot;</span>; <span class="comment">//数组内容存储在静态区，函数结束时，不会释放掉</span></span><br><span class="line">     <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    str = GetString();      </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="杜绝“野指针”"><a href="#杜绝“野指针”" class="headerlink" title="杜绝“野指针”"></a>杜绝“野指针”</h4><p>“野指针”不是 NULL 指针，是指向“垃圾”内存的指针。“野指针”是很危险的，if 语句对它不起作用。出现的原因有：</p>
<ol>
<li>指针变量没有被初始化。任何指针变量刚被创建时不会自动成为 NULL 指针，它的缺省值是随机的。所以，指针变量在创建的同时应当被初始化，要么将指针设置为 NULL，要么让它指向合法的内存。</li>
<li>指针 p 被 free 或者 delete 之后，没有置为 NULL，让人误以为 p 是个合法的指针。</li>
<li>指针操作超越了变量的作用域范围。</li>
</ol>
<h4 id="有了-malloc-free-为什么还要-new-delete？"><a href="#有了-malloc-free-为什么还要-new-delete？" class="headerlink" title="有了 malloc/free 为什么还要 new/delete？"></a>有了 malloc/free 为什么还要 new/delete？</h4><p><strong>malloc 与 free</strong> 是 C++/C 语言的标准库函数，<strong>new/delete</strong> 是 C++ 的运算符。它们都可用于申请动态内存和释放内存。<br>对于非内部数据类型的对象而言，光用 <strong>malloc/free</strong> 无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于 <strong>malloc/free</strong> 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于 <strong>malloc/free</strong>。<br>而C++程序经常要调用 C 函数，而 C 程序只能用 <strong>malloc/free</strong> 管理动态内存，因此不能只用 <strong>new/delete</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">public</span> : </span><br><span class="line">    Obj(<span class="keyword">void</span>)&#123; <span class="built_in">cout</span> &lt;&lt; “Initialization” &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">    ~Obj(<span class="keyword">void</span>)&#123; <span class="built_in">cout</span> &lt;&lt; “Destroy” &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Initialize</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; “Initialization” &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Destroy</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; “Destroy” &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UseMallocFree</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Obj *a = (obj *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(obj)); <span class="comment">// 申请动态内存</span></span><br><span class="line">    a-&gt;Initialize(); <span class="comment">// 初始化</span></span><br><span class="line">    <span class="comment">//… </span></span><br><span class="line">    a-&gt;Destroy(); <span class="comment">// 清除工作</span></span><br><span class="line">    <span class="built_in">free</span>(a); <span class="comment">// 释放内存</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UseNewDelete</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Obj *a = <span class="keyword">new</span> Obj; <span class="comment">// 申请动态内存并且初始化</span></span><br><span class="line">    <span class="comment">//… </span></span><br><span class="line">    <span class="keyword">delete</span> a; <span class="comment">// 清除并且释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="内存耗尽怎么办？"><a href="#内存耗尽怎么办？" class="headerlink" title="内存耗尽怎么办？"></a>内存耗尽怎么办？</h4><p>如果在申请动态内存时找不到足够大的内存块，<strong>malloc</strong> 和 <strong>new</strong> 将返回 <strong>NULL</strong> 指针，表示内存申请失败。<br>处理“内存耗尽”问题，一般可以通过判断指针是否为 <strong>NULL</strong>，是的话用 <strong>return</strong> 或 <strong>exit(1)</strong> 终止整个程序的运行，也可以自己为 <strong>new 和 molloc</strong> 设置异常处理函数。<br>如果一个函数内有多处需要申请动态内存，那么应该用 <strong>exit(1)</strong> 及时终止程序。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>C++内存管理</p><p><a href="https://www.benboby.top/2020/11/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html">https://www.benboby.top/2020/11/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Benboby</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2020-11-02</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-02-09</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">C++内存管理</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/11/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%8C%BA%E9%97%B4%E5%92%8C%E7%9A%84%E4%B8%AA%E6%95%B0.html"><i class="level-item fas fa-chevron-left"></i><span class="level-item">每日一题：区间和的个数</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/10/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%BB%8F%E5%85%B8%E9%A2%98.html"><span class="level-item">树状数组经典题</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Benboby"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Benboby</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>福州，福建</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">115</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">38</p></a></div></div></nav></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://benboby.github.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Github Blog</span></span><span class="level-right"><span class="level-item tag">benboby.github.io</span></span></a></li><li><a class="level is-mobile" href="http://kmlerc.coding-pages.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Coding Blog</span></span><span class="level-right"><span class="level-item tag">kmlerc.coding-pages.com</span></span></a></li><li><a class="level is-mobile" href="http://eaw3p1.coding-pages.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">fightinggg大神</span></span><span class="level-right"><span class="level-item tag">eaw3p1.coding-pages.com</span></span></a></li><li><a class="level is-mobile" href="https://www.cnblogs.com/Q1143316492/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">cwl大神</span></span><span class="level-right"><span class="level-item tag">www.cnblogs.com</span></span></a></li><li><a class="level is-mobile" href="https://sandychn.github.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Sandy大神</span></span><span class="level-right"><span class="level-item tag">sandychn.github.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/LeetCode/"><span class="level-start"><span class="level-item">LeetCode</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/Makefile/"><span class="level-start"><span class="level-item">Makefile</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/MySQL/"><span class="level-start"><span class="level-item">MySQL</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Vim/"><span class="level-start"><span class="level-item">Vim</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83/"><span class="level-start"><span class="level-item">多校训练</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">操作系统</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">数据结构与算法</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"><span class="level-start"><span class="level-item">每日一题</span></span><span class="level-end"><span class="level-item tag">73</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="level-start"><span class="level-item">计算机网络</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="level-start"><span class="level-item">设计模式</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-02-12T06:03:16.000Z">2021-02-12</time></p><p class="title"><a href="/2021/02/%E7%BB%A7%E6%89%BF-%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81.html">继承，虚函数和多态</a></p><p class="categories"><a href="/categories/C/">C++</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-02-07T02:02:39.000Z">2021-02-07</time></p><p class="title"><a href="/2021/02/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%A4%9A%E5%8F%AF%E4%BB%A5%E5%8F%82%E5%8A%A0%E7%9A%84%E4%BC%9A%E8%AE%AE%E6%95%B0%E7%9B%AEII.html">每日一题：最多可以参加的会议数目II</a></p><p class="categories"><a href="/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/">每日一题</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-02-05T14:35:42.000Z">2021-02-05</time></p><p class="title"><a href="/2021/02/STL.html">STL学习</a></p><p class="categories"><a href="/categories/C/">C++</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-02-03T05:48:11.000Z">2021-02-03</time></p><p class="title"><a href="/2021/02/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%AD%E4%BD%8D%E6%95%B0.html">每日一题：滑动窗口中位数</a></p><p class="categories"><a href="/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/">每日一题</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-02-02T10:06:30.000Z">2021-02-02</time></p><p class="title"><a href="/2021/02/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html">LinuxC++网络编程学习笔记</a></p><p class="categories"><a href="/categories/C/">C++</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">二月 2021</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">十二月 2020</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/11/"><span class="level-start"><span class="level-item">十一月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/10/"><span class="level-start"><span class="level-item">十月 2020</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/09/"><span class="level-start"><span class="level-item">九月 2020</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/08/"><span class="level-start"><span class="level-item">八月 2020</span></span><span class="level-end"><span class="level-item tag">27</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">22</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"><span class="tag">C++内存管理</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C-%E5%9F%BA%E7%A1%80/"><span class="tag">C++基础</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"><span class="tag">C++面向对象</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DFS/"><span class="tag">DFS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JVM/"><span class="tag">JVM</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java%E5%8F%8D%E5%B0%84/"><span class="tag">Java反射</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java%E5%9F%BA%E7%A1%80/"><span class="tag">Java基础</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><span class="tag">Java多线程</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Makefile/"><span class="tag">Makefile</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MySQL/"><span class="tag">MySQL</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RMQ/"><span class="tag">RMQ</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/STL/"><span class="tag">STL</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Vim/"><span class="tag">Vim</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%8C%E5%88%86/"><span class="tag">二分</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><span class="tag">动态规划</span><span class="tag">14</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8C%BA%E9%97%B4dp/"><span class="tag">区间dp</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"><span class="tag">博弈论</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%9E%E6%96%87/"><span class="tag">回文</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%BE%E8%AE%BA/"><span class="tag">图论</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83/"><span class="tag">多校训练</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"><span class="tag">字典树</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"><span class="tag">并查集</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%80%9D%E7%BB%B4/"><span class="tag">思维</span><span class="tag">15</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="tag">操作系统</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E5%AD%A6/"><span class="tag">数学</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"><span class="tag">最小生成树</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%A0%91/"><span class="tag">树</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%A0%91%E5%BD%A2dp/"><span class="tag">树形dp</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"><span class="tag">树状数组</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%8A%B6%E5%8E%8Bdp/"><span class="tag">状压dp</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BA%BF%E6%80%A7dp/"><span class="tag">线性dp</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><span class="tag">网络编程</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%83%8C%E5%8C%85dp/"><span class="tag">背包dp</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E6%95%B0dp/"><span class="tag">计数dp</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="tag">计算机网络</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"><span class="tag">记忆化搜索</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="tag">设计模式</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%B4%AA%E5%BF%83/"><span class="tag">贪心</span><span class="tag">10</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Benboby&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2021 Benboby</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span><br><a href="https://beian.miit.gov.cn/#/Integrated/index" target="_blank" rel="noopener">闽ICP备2020019306号-1</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdnjs.loli.net/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdnjs.loli.net/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>