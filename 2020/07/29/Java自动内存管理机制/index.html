<div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-07-29T11:50:34.000Z" title="2020-07-29T11:50:34.000Z">2020-07-29</time>发表</span><span class="level-item"><time dateTime="2020-09-30T06:06:35.965Z" title="2020-09-30T06:06:35.965Z">2020-09-30</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a></span><span class="level-item">31 分钟读完 (大约4646个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">Java自动内存管理机制</h1><div class="content"><h2 id="Java内存区域与内存溢出异常"><a href="#Java内存区域与内存溢出异常" class="headerlink" title="Java内存区域与内存溢出异常"></a>Java内存区域与内存溢出异常</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>对于Java程序员来说，有虚拟机的自动内存管理机制，不再需要像C++那样为每个new操作去写配对的delete/free代码。但正因如此，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是如何使用内存的，那排查错误将会变得异常困难。</p>
<h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><p>Java虚拟机在执行Java程序过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。</p>
<p><img src="/2020/07/29/Java%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/运行时数据区域.png" alt="avatar"></p>
<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器是一块较小的内存空间，它的作用可以看做是<strong>当前线程所执行的字节码的行号指示器</strong>。在虚拟机的概念模型里，字节码解释器工作时就是<strong>通过改变这个计数器的值来选取下一条需要执行的字节码指令</strong>， 分支、循环 、跳转、异常 处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
<p>线程私有：由于 Java 虚拟机的多线程是通过<strong>线程轮流切换</strong>并<strong>分配处理器执行时间</strong>的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令，切换时也并不会记录上一个线程执行到那个位置。因此，为了线程<strong>切换后能恢复到正确的执行位控</strong>，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p>
<p>如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是<strong> Native 方法</strong>，这个<strong>计数器值则为空</strong> ( Undefined )。</p>
<ul>
<li>Native方法大多是通过C实现并未编译成需要执行的字节码指令，也就不需要去存储字节码文件的行号</li>
</ul>
<p>程序计数器的内存区域是<strong>唯一</strong>一个在 Java 虚拟机规范中<strong>没有</strong>规定任何OutOfMemoryError情况的区域，因为<strong>程序计数器存储的是字节码文件的行号，这个范围是可知晓的，在一开始分配内存时就可以分配一个绝对不会溢出的内存</strong>。</p>
<p>总结：</p>
<ol>
<li>线程私有的，每个线程都有一个程序计数器</li>
<li>是java虚拟机规范里面，唯一一个没有规定任何 OutOfMemoryError 情况的区域 </li>
<li>生活周期随着线程的创建而创建，随着线程的结束而消亡</li>
<li>程序计数器是一块较小的内存区域</li>
</ol>
<h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>与程序计数器一样，Java虚拟机栈也是线程私有的，它的<strong>生命周期与线程相同</strong>。虚拟机栈描述的是 Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个<strong>栈帧</strong>用于存储局部变量表、操作栈、动态链接、方法出口等信息。<strong>每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从人栈到出栈的过程</strong>。</p>
<p>虚拟机栈是Java执行方法的内存模型。每个方法被执行的时候，都会创建一个栈帧，把栈帧压入栈，当方法正常返回或者抛出未捕获的异常时，栈帧就会出栈。</p>
<blockquote>
<p><strong>栈对应线程，栈帧对应方法</strong></p>
</blockquote>
<p>在活动线程中，只有位于栈顶的帧才是有效的，称为当前栈帧。正在执行的方法称为当前方法。在执行引擎运行时，所有指令都只能针对当前栈帧进行操作。而 StackOverflowError 表示请求的栈溢出，导致内存耗尽，通常出现在递归方法中。</p>
<blockquote>
<p>一般把Java内存区分为堆内存（Heap）和栈内存（Stack），其中『栈』指的是虚拟机栈，『堆』指的是Java堆。在 Java 虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过 Java 虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出 OutOfMemoryError 异常。</p>
<ul>
<li>StackOverflowError：递归过深，递归没有出口</li>
<li>OutOfMemoryError：JVM空间溢出，创建对象速度高于GC回收速度，可能是申请了较多空间没有及时释放</li>
</ul>
</blockquote>
<p><strong>局部变量表</strong>：存放方法参数和方法内部定义的局部变量的区域。</p>
<p>局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是<strong>虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务</strong>。在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并<strong>没有强制规定</strong>，因此具体的虚拟机可以自由实现它。与虚拟机栈一样，<strong>本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常</strong>。</p>
<h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><p>Java堆是披<strong>所有线程共享</strong>的一块内存区域，在<strong>虚拟机启动时创建</strong>。此内存区域的唯一目的就是存放<strong>对象实例</strong>，几乎所有的对象实例以及数组都要在堆上分配。</p>
<p>是垃圾收集器管理的主要区域，也被称做“GC堆”，也是Java虚拟机所管理的内存中最大的一块。</p>
<p>根据 Java 虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。在实现时，既可以实现成固定大小的，也可以是可扩展的。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出 OutOfMemoryError 异常。</p>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>用于<strong>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</strong>。与Java堆一样，是<strong>各个线程共享的内存区域</strong>。</p>
<p>人们更愿意把这个区域称为“永久代”，本质上两者并不等价，或者说是永久代来实现方法区而已。它还有个别名叫做Non-Heap（非堆）。</p>
<p>和Java堆一样不需要连续的内存和可以选择固定大小或可扩展外，还可选择不实现GC。相对而言，<strong>垃圾收集行为在这个区域是比较少出现的</strong>，但并非数据进入了方法区就如永久代的名字一样“永久” 存在了。这个区域的内存回收目标主要是<strong>针对常量池的回收和对类型的卸载</strong>，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的，未完全回收可能会导致内存泄漏。</p>
<p>在Java虚拟机规范中，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是<strong>常量池</strong>，用于<strong>存放编译期生成的各种字面量和符号引用</strong>，这部分内容将在<strong>类加载后进入方法区的运行时常量池中存放</strong>。</p>
<p>相对于<strong>Class文件常量池</strong>的一个重要特征是具备<strong>动态性</strong>，体现在并非只有预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中。是方法区的一部分，会受到方法区内存的限制。在Java虚拟机规范中，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p>
<h3 id="对象访问"><a href="#对象访问" class="headerlink" title="对象访问"></a>对象访问</h3><p>由于 reference 类型在 Java 虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访间到 Java 堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：</p>
<ol>
<li><p>通过句柄方式访问<br>  如果使用句柄访问的话，那么Java堆中将会划分一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象的实例数据与类型数据各自的具体地址信息。</p>
<p> <img src="/2020/07/29/Java%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/句柄访问.png" alt="avatar"></p>
<ul>
<li><p>优点：当对象移动的时候（垃圾回收的时候移动很普遍），这样值需要改变句柄中的指针，但是栈中的指针不需要变化，因为栈中存储的是句柄的地址</p>
</li>
<li><p>缺点：需要进行二次定位，寻找两次指针，开销相对更大一些</p>
</li>
</ul>
</li>
<li><p>使用指针访问<br>  如果使用直接指针访问方式，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象的地址。</p>
<p> <img src="/2020/07/29/Java%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/指针访问.png" alt="avatar"></p>
<ul>
<li>优点：速度快，不需要和句柄一样指针定位的开销</li>
</ul>
</li>
</ol>
<h2 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>当需要排查各种内存溢出、内存泄涌问题时，当垃圾收集成为系统达到<strong>更高并发</strong>的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。</p>
<p>程序计数器、虚拟机栈、本地方法栈三个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行若出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具备确定性，在这几个区域内不需要过多考虑回收的问题，因为方法结束或线程结束时，内存自然就跟随着回收了。</p>
<p>而 Java 堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存，</p>
<h3 id="对象已死？"><a href="#对象已死？" class="headerlink" title="对象已死？"></a>对象已死？</h3><p>堆中几乎存放着 Java 中所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象有哪些还“存活”着，哪些已经“死去”（即不可能再披任何途径使用的对象）。</p>
<h4 id="引用计数器法"><a href="#引用计数器法" class="headerlink" title="引用计数器法"></a>引用计数器法</h4><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加 1; 当引用失效时，计数器值就减 1; 任何时刻计数器都为 0 的对象就是不可能再被使用的。</p>
<p>Java语言中没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间的相互循环引用的问题。</p>
<h4 id="根搜索算法"><a href="#根搜索算法" class="headerlink" title="根搜索算法"></a>根搜索算法</h4><p>通过一系列的名为 “GCRoots” 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链 (ReferenceChain) , 当一个对象到 GCRoots 没有任何引用链相连（用图论的话来说就是从 GCRoots 到这个对象不可达）时，则证明此对象是不可用的。</p>
<p>在 Java 语言里，可作为 GCRoots 的对象包括下面几种 ：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中的引用的对象。</li>
<li>方法区中的类静态属性引用的对象。</li>
<li>方法区中的常扯引用的对象。</li>
<li>本地方法栈中 JNI (即一般说的 Native 方法）的引用的对象</li>
</ul>
<h4 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h4><p>在 JDK 1.2 之前，Java中的引用的定义很传统 ：如果 reference 类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。</p>
<p>在 JDK 1.2 之后，Java 对引用的概念进行了扩充，将引用分为<strong>强引用、软引用、弱引用、虚引用</strong>四种，这四种引用强度依次逐渐减弱。</p>
<ul>
<li>强引用就是指在程序代码之中普遍存在的，类似 “Object obj = new Object()” 这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</li>
<li>软引用用来描述一些还有用，但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中并进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。在 JDK1.2 之后，提供了 SoftReference 类来实现软引用。</li>
<li>弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在 JDK 1.2 之后，提供了 WeakReference 类来实现弱引用。</li>
<li>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知。在 JDK 1.2 之后，提供了 PhantomReference 类来实现虚引用。</li>
</ul>
<h4 id="生存还是死亡？"><a href="#生存还是死亡？" class="headerlink" title="生存还是死亡？"></a>生存还是死亡？</h4><p>要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行根搜索后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法。当对象没有覆盖 finalize()方法，或者 finalize () 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</p>
<p>如果这个对象被判定为有必要执行 finalize() 方法，那么这个对象将会被放置在一个名为 F-Queue 的队列之中，并在稍后由一条由虚拟机自动建立的、低优先级的 Finalizer 线程去执行。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象在 finalize() 方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致 F-Queue 队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。finalize() 方法是对象逃脱死亡命运的最后一次机会，稍后 GC 将对 F-Queue 中的对象进行第二次小规模的标记，如果对象要在 finalize() 中成功拯救自己 —— 只要重新与引用链上的任何一个对象建立关联即可，譬如把自己 (this 关键字）赋值给某个类变址或对象的成员变量，那在第二次标记时它将被移除出 “即将回收” 的集合；如果对象这时候还没有逃脱，那它就真的离死不远了。</p>
<h4 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h4></div><div class="article-licensing box"><div class="licensing-title"><p>Java自动内存管理机制</p><p><a href="http://yoursite.com/2020/07/29/Java%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/">http://yoursite.com/2020/07/29/Java%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Benboby</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2020-07-29</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2020-09-30</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/JVM/">JVM</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/07/31/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%A4%9A%E7%9A%84%E4%B8%8D%E9%87%8D%E5%8F%A0%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">每日一题：最多的不重叠子字符串</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/07/28/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><span class="level-item">Java多线程</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!-->