{"pages":[{"title":"tags","text":"","link":"/tags/index.html"},{"title":"about","text":"","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"C++11新特性","text":"nullptrnullptr 出现的目的是为了替代 NULL。传统 C++ 会把 NULL, 0 视为同一种东西，有些编译器会将 NULL 定义为 ((void*)0)，有些则会直接将其定义为 0。C++ 不允许直接将 void 隐式转换到其他类型，但如果 NULL 被定义为 **((void)0)，那么当编译 char ch = NULL;* 时，NULL 只好被定义为 0。而这依然会产生问题，将导致了 C++ 中重载特性会发生混乱，考虑：12void foo(char *);void foo(int);对于这两个函数来说，如果 NULL 又被定义为了 0 那么 foo(NULL); 这个语句将会去调用 foo(int)，从而导致代码违反直观。为了解决这个问题，C++11 引入了 nullptr 关键字，专门用来区分空指针、0。nullptr 的类型为 nullptr_t，能够隐式的转换为任何指针或成员指针的类型，也能和他们进行相等或者不等的比较。 类型推导C++11 引入了 auto 和 decltype 这两个关键字实现了类型推导。 auto: 使用 auto 进行类型推导的一个最为常见而且显著的例子就是迭代器，可以使代码变得十分简洁。但需要注意的是 auto 不能用于函数传参，不能用于推导数组类型。 123456789// 迭代器for (vector&lt;int&gt;::const_iterator itr = v.cbegin(); itr != v.cend(); ++itr)// auto 类型推导for (auto itr = v.cbegin(); itr != v.cend(); ++itr)// 不能用于函数传参//! int add(auto x, auto y);// auto 不能用于推导数组//! int a = {1, 2, 3};//! auto b = a; decltype: decltype 关键字是为了解决 auto 关键字只能对变量进行类型推导的缺陷。它的用法和 sizeof 很相似： decltype(表达式) 在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。 123auto x = 1;auto y = 2;decltype(x + y) z; 拖尾返回类型 12template&lt;typename R, typename T, typename U&gt;R add(T x, U y) { return x + y; } 很多时候我们并不知道 add() 这个函数会做什么样的操作，获得一个什么样的返回类型。如果用 decltype(x + y) add(T x, U y); 来进行类型推导的话，并不能通过编译。 这是因为在编译器读到 decltype(x + y) 时， x 和 y 尚未被定义。为了解决这个问题，C++11 还引入了一个叫做 拖尾返回类型，利用 auto 关键字将返回类型后置： 1234template&lt;typename T, typename U&gt;auto add(T x, U y) -&gt; decltype(x + y) { return x + y; } 而从 C++14 开始，普通函数具备返回值推导的能力： 12template&lt;typename T, typename U&gt;auto add(T x, U y) { return x + y; } 模板增强 外部模板：传统 C++ 中，模板只有在使用时才会被编译器实例化。只要在每个编译单元（文件）中编译的代码中遇到了被完整定义的模板，都会实例化。这就产生了重复实例化而导致的编译时间的增加。并且，我们没有办法通知编译器不要触发模板实例化。C++11 引入了外部模板，扩充了原来的强制编译器在特定位置实例化模板的语法，使得能够显式的告诉编译器何时进行模板的实例化： 1234567 template class std::vector&lt;bool&gt;; // 强行实例化 extern template class std::vector&lt;double&gt;; // 不在该编译文件中实例化模板 ``` 2. 尖括号 '&gt;'：在传统 C++ 的编译器中，&gt;&gt; 一律被当做右移运算符来进行处理。因此对于嵌套模板来说是不能够被编译的，而 C++11 开始，连续的右尖括号将变得合法，并且能够顺利通过编译。 ```cpp std::vector&lt;std::vector&lt;int&gt;&gt; v; 类型别名模板：在传统 C++中，typedef 可以为类型定义一个新的名称，但却没有办法为模板定义一个新的名称，因为 模板不是类型。于是 C++11 引入了 using，并且同时支持对传统 typedef 相同的作用。 12345678910111213template&lt;typename T, typename U, int value&gt;class SuckType {public: T a; U b; SuckType(): a(value), b(value){}};// 不合法template&lt;typename U&gt;typedef SuckType&lt;std::vector&lt;int&gt;, U, 1&gt; NewType; // 合法template&lt;typename T&gt;using NewType = SuckType&lt;int, T, 1&gt;; 默认模板参数：在 C++11 中提供了一种便利，可以指定模板的默认参数。 1234template&lt;typename T = int, typename U = int&gt;auto add(T x, U y) -&gt; decltype(x + y) { return x + y; } 变长参数模板：在 C++11 之前，无论是类模板还是函数模板，都只能按其指定的样子，接受一组固定数量的模板参数；而 C++11 加入了新的表示方法，允许任意个数、任意类别的模板参数，同时也不需要在定义时将参数的个数固定。 123template&lt;typename... Ts&gt; class Magic;// 可以指定模板参数以要求模板参数的个数至少为1template&lt;typename Require, typename... Args&gt; class Magic; 构造函数 委托构造：C++11 引入了委托构造的概念，这使得构造函数可以在同一个类中一个构造函数调用另一个构造函数，从而达到简化代码的目的。 1234567class Base {public: int v1; int v2; Base() { v1 = 1; } Base(int v) : Base() { v2 = 2; } // 委托 Base() 构造函数} 继承构造：在继承体系中，如果派生类想要使用基类的构造函数，需要在构造函数中显式声明。假若基类拥有为数众多的不同版本的构造函数，这样，在派生类中得写很多对应的“透传”构造函数。在 C++11 中，只要一句话搞定。 1234567891011struct B:A{ // 太麻烦 B(int i):A(i){} B(double d, int i){} ....}struct B:A { // 一句话搞定 using A::A;} 如果一个继承构造函数不被相关的代码使用，编译器就不会为之产生真正的函数代码，这样比透传基类各种构造函数更加节省目标代码空间。 右值引用新增容器 std::array：保存在栈内存中，相比堆内存中的 std::vector，性能更高。 123int len = 4;std::array&lt;int, 4&gt; a = {1, 2, 3, 4};std::array&lt;int, len&gt; a = {1, 2, 3, 4}; // 非法，数组大小必为常量表达式 std::forward_list 是一个列表容器，使用方法和 std::list 基本类似。和 std::list 的双向链表的实现不同，std::forward_list 使用单向链表进 行实现，提供了 O(1) 复杂度的元素插入，不支持快速随机访问（这也是链表的 特点），也是标准库容器中唯一一个不提供 size() 方法的容器。当不需要双向 迭代时，具有比 std::list 更高的空间利用率。 无序容器：C++11 引入了两组无序容器： std::unordered_map/std::unordered_multimap 和 std::unordered_set/std::unordered_multiset。无序容器中的元素是不进行排序的，内部通过 Hash 表实现，插入和搜索元素的 平均复杂度为 O(constant)。 元组：std::tuple 元组的使用有三个核心的函数： std::make_tuple: 构造元组 std::get: 获得元组某个位置的值 std::tie: 元组拆包 explicit 关键字explicit主要是用来修饰类的构造函数，从而使被构造的类只能发生显示转换，而不能进行隐式转化。 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;class Test1{ public: Test1(int n){ // 隐式构造函数 num = n; } private: int num;};class Test2{ public: explicit Test2(int n){ //explicit(显式)构造函数 num = n; } private: int num;};int main(){ Test1 t1 = 10; // 隐式转化 //等同于 Test1 temp(10); Test1 t1 = temp; Test1 t2 = 'c'; // 'c'被转化为ascii码，然后同上 Test2 t3 = 12; // 编译错误,不能隐式调用其构造函数 Test2 t4 = 'c'; // 编译错误,不能隐式调用其构造函数 Test2 t5(10); // 正常的显式转化 return 0;} explicit关键字只用于类的单参数构造函数，对于无参数和多参数的构造函数总是显示调用，因此使用explicit没有意义。通常情况下，我们约定对于单参数构造函数必须使用explicit关键字，避免产生意外的类型转化，拷贝构造函数除外。 constexpr关键字constexpr 关键字是 C++11 新增的关键字，其语义是“常量表达式”，也就是在编译期可求值的表达式。 对于constexpr修饰的函数： 函数体一般只包含一个return语句； 函数体可以包含其他语句，但是不能是运行期语句，只能是编译期语句； 1234567constexpr int Inc(int i) { return i + 1;} constexpr int a = Inc(1); // okconstexpr int b = Inc(cin.get()); // !errorconstexpr int c = a * 2 + 1; // ok constexpr还能用于修饰类的构造函数，即保证如果提供给该构造函数的参数都是constexpr，那么产生的对象中的所有成员都会是constexpr，该对象也就是constexpr对象了，可用于各种只能使用constexpr的场合。注意，constexpr构造函数必须有一个空的函数体，即所有成员变量的初始化都放到初始化列表中。 1234567struct A { constexpr A(int xx, int yy): x(xx), y(yy) {} int x, y;}; constexpr A a(1, 2);enum {SIZE_X = a.x, SIZE_Y = a.y}; 好处： 是一种很强的约束，更好地保证程序的正确语义不被破坏。 编译器可以在编译期对constexpr的代码进行非常大的优化，比如将用到的constexpr表达式都直接替换成最终结果等。 相比宏来说，没有额外的开销，但更安全可靠。 区别const 和 constexpr 变量之间的主要区别在于：const 变量的初始化可以延迟到运行时，而 constexpr 变量必须在编译时进行初始化。所有 constexpr 变量均为常量，因此必须使用常量表达式初始化。 修饰指针在使用const时，如果关键字const出现在星号左边，表示被指物是常量；如果出现在星号右边，表示指针本身是常量；如果出现在星号两边，表示被指物和指针两者都是常量。 与const不同，在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指对象无关。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std; int g_tempA = 4;const int g_conTempA = 4;constexpr int g_conexprTempA = 4; int main(void){ int tempA = 4; const int conTempA = 4; constexpr int conexprTempA = 4; /*1.正常运行,编译通过*/ const int *conptrA = &amp;tempA; const int *conptrB = &amp;conTempA; const int *conptrC = &amp;conexprTempA; /*2.局部变量的地址要运行时才能确认，故不能在编译期决定，编译不过*/ constexpr int *conexprPtrA = &amp;tempA; constexpr int *conexprPtrB = &amp;conTempA; constexpr int *conexprPtrC = &amp;conexprTempA; /*3.第一个通过，后面两个不过,因为constexpr int *所限定的是指针是常量，故不能将常量的地址赋给顶层const*/ constexpr int *conexprPtrD = &amp;g_tempA; constexpr int *conexprPtrE = &amp;g_conTempA; constexpr int *conexprPtrF = &amp;g_conexprTempA; /*4.局部变量的地址要运行时才能确认，故不能在编译期决定，编译不过*/ constexpr const int *conexprConPtrA = &amp;tempA; constexpr const int *conexprConPtrB = &amp;conTempA; constexpr const int *conexprConPtrC = &amp;conexprTempA; /*5.正常运行，编译通过*/ constexpr const int *conexprConPtrD = &amp;g_tempA; constexpr const int *conexprConPtrE = &amp;g_conTempA; constexpr const int *conexprConPtrF = &amp;g_conexprTempA; return 0;} 修饰引用12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std; int g_tempA = 4;const int g_conTempA = 4;constexpr int g_conexprTempA = 4; int main(void){ int tempA = 4; const int conTempA = 4; constexpr int conexprTempA = 4; /*1.正常运行，编译通过*/ const int &amp;conptrA = tempA; const int &amp;conptrB = conTempA; const int &amp;conptrC = conexprTempA; /*2.有两个问题：一是引用到局部变量，不能在编译器确定；二是conexprPtrB和conexprPtrC应该为constexpr const类型，编译不过*/ constexpr int &amp;conexprPtrA = tempA; constexpr int &amp;conexprPtrB = conTempA; constexpr int &amp;conexprPtrC = conexprTempA; /*3.第一个编译通过，后两个不通过，原因是因为conexprPtrE和conexprPtrF应该为constexpr const类型*/ constexpr int &amp;conexprPtrD = g_tempA; constexpr int &amp;conexprPtrE = g_conTempA; constexpr int &amp;conexprPtrF = g_conexprTempA; /*4.正常运行，编译通过*/ constexpr const int &amp;conexprConPtrD = g_tempA; constexpr const int &amp;conexprConPtrE = g_conTempA; constexpr const int &amp;conexprConPtrF = g_conexprTempA; return 0;} 简单的说 constexpr 所引用的对象必须在编译期就决定地址。可以通过上例 conexprPtrD 来修改 g_tempA 的值，也就是说 constexpr 修饰的引用不是常量，如果要确保常量引用需要 constexpr const 来修饰。","link":"/2020/05/C++11%E6%96%B0%E7%89%B9%E6%80%A7.html"},{"title":"C++内存管理","text":"内存管理内存管理详解内存分配方式分配方式简介在C++中，内存分为5个区： 栈：执行函数时，函数内部局部变量存储单元在栈上创建，结束时自动释放。效率很高，但存储容量有限。 堆：由 new 分配的内存块，编译器不会自动释放，需要应用程序对应的 delete 进行释放。如果没有释放，则程序运行结束后会由操作系统自动回收。 自由存储区：由 malloc 等分配的内存块，类似堆，由 free 结束自己的生命。 全局/静态存储区：存储全局变量和静态变量。 常量存储区：存放常量，不允许修改。 明确区分堆和栈123void f() { int* p = new int[5];} 在栈内存中存放了一个指向一块堆内存的指针 p。程序会先确定在堆中分配内存的大小，然后调用 operator new 分配内存，然后返回这块内存的首地址，放入栈中。 这里并没有释放内存，因此需要 delete[] p，告诉编译器删除的是数组，然后编译器根据Cookie信息去释放内存。 堆和栈的区别 管理方式：栈由编译器自动管理，无需手动控制；堆的释放工作由程序员控制，容易产生内存泄露。 空间大小：堆栈的内存都可以自己设定，堆内存一般不超过系统内存都是可以申请，栈内存个人测试默认值为8M。 碎片问题：对于堆而言，频繁的 new/delete 势必会造成内存空间的不连续，造成大量的碎片，使程序的效率降低；对于栈而言，则不会发生这样的情况，先进后出排列有序，以至于永远不可能有一个内存块从非栈顶位置弹出。 生长方向：对于堆而言，生长方向向上，向着内存地址增加的方向增长；对于栈而言，生长方向向下，向着内存地址减小的方向增长。 分配方式：堆都是动态分配的，没有静态分配的堆。栈有动态分配和静态分配两种，静态分配由编译器完成，比如局部变量的分配；动态分配由 alloca 函数进行分配，都由编译器进行释放。 分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持，这就决定了栈的效率比较高。堆则是 C/C++ 函数库提供的，机制比较复杂，用到许多算法的实现内存的分配。显然，堆的效率比栈要低得多。 因此，更推荐尽量使用栈而不是堆。但是栈和堆相比并不灵活。如果需要分配大量内存空间，还是堆好一些。 控制 C++ 的内存分配无论如何，一定要保守的使用内存分配。一个防止堆破碎的通用方法是从不同固定大小的内存池中分配不同类型的对象。对每个类重载 new 和 delete 就提供了这样的控制。 重载全局的new和delete操作123456789void * operator new(size_t size) { void *p = malloc(size); return (p); } void operator delete(void *p); { free(p); } 也可以对单个类的 new 和 delete 操作符重载。 123456789101112131415class TestClass { public: void * operator new(size_t size); void operator delete(void *p); // .. other members here ... }; void *TestClass::operator new(size_t size) { void *p = malloc(size); // Replace this with alternative allocator return (p); } void TestClass::operator delete(void *p) { free(p); // Replace this with alternative de-allocator} 为单个类重载 new[] 和 delete[]C++将对象数组的内存分配作为一个单独的操作，而不同于单个对象的内存分配。为了改变这种方式，同样需要重载 new[] 和 delete[]操作符。 123456789101112131415161718192021class TestClass { public: void * operator new[ ](size_t size); void operator delete[ ](void *p); // .. other members here .. }; void *TestClass::operator new[ ](size_t size) { void *p = malloc(size); return (p); } void TestClass::operator delete[ ](void *p) { free(p); } int main(void) { TestClass *p = new TestClass[10]; // ... etc ... delete[ ] p; } PS：对于多数 C++ 的实现，new[] 操作符中的个数参数是数组的大小加上额外的存储对象数目的一些字节。因此应该尽量避免分配对象数组，使内存分配策略简单。 常见的内存错误 内存分配未成功，却使用了它。 如果是用 malloc 或 new 来申请内存，应该用 if(p==NULL) 或 if(p!=NULL)进行防错。 内存分配虽然成功，但未初始化就引用它。 无论用何种方式创建数组，都要赋初值，即便是零值。 内存分配成功并且已经初始化，但操作越界。 多发生在下标“多1”或“少1”。 忘记了释放内存，造成内存泄漏。 动态内存的申请与释放必须配对，程序中 malloc 与 free 的使用次数一定要相同，否则肯定有错误（new/delete同理）。 释放了内存却继续使用它。 程序过于复杂，难以分清是否释放了内存，此时应当重新设计数据结构，解决混乱。 return语句写错，不要返回指向“栈内存”的指针或引用，因为该内存在函数体结束时被自动销毁。 free或delete释放内存后，没有将指针设为NULL，导致“野指针”。 指针与数组对比数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。数组名对应着（而不是指向）一块内存，其地址和容量在生命周期内保持不变，只有数组的内容可以改变。 指针可以随时指向任何类型的内存块，它的特征是“可变”的，所以常用指针来操作动态内存，指针远比数组灵活，但也更危险。 修改数组内容1234567char a[] = “hello”; a[0] = ‘X’; cout &lt;&lt; a &lt;&lt; endl; // 可以拆分为 char s[] = &quot;world&quot;; char *p = str;char *p = “world”; // 注意 p 指向常量字符串p[0] = ‘X’; // 编译器不能发现该错误，但运行时产生[Bus error]cout &lt;&lt; p &lt;&lt; endl; 内容复制与比较123456789101112// 数组… char a[] = &quot;hello&quot;; char b[10]; strcpy(b, a); // 不能用 b = a; if(strcmp(b, a) == 0) // 不能用 if (b == a) … // 指针… // 语句 p = a 并不能把 a 的内容复制给指针 p，而是把 a 的地址赋给了 p。int len = strlen(a); char *p = (char *)malloc(sizeof(char)*(len+1)); strcpy(p, a); // 不要用 p = a; if(strcmp(p, a) == 0) // 不要用 if (p == a) 计算内存容量12345char a[] = &quot;hello world&quot;; char *p = a; cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 12 字节// sizeof(p) 等价于 sizeof(char *)，没有办法的值指针所指的内存容量，除非申请内存时就记住它cout&lt;&lt; sizeof(p) &lt;&lt; endl; // 4 字节 注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。12345void Func(char a[100]) { // 不论数组 a 的容量是多少，sizeof(a)始终等于 sizeof(char *)。 cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 4 字节而不是 100 字节} 指针参数如何传递内存12345678910void GetMemory(char *p, int num) { p = (char *) malloc(sizeof(char) * num); } void Test(void) { char *str = NULL; GetMemory(str, 100); // str 仍然为 NULL strcpy(str, &quot;hello&quot;); // 运行错误} 如果函数的参数是一个指针，不要指望用该指针去申请动态内存。编译器总是要为函数的每个参数制作临时副本，指针参数 p 的副本是 _p，编译器使 _p = p。如果函数体内的程序修改了_p 的内容，就导致参数 p 的内容作相应的修改。这就是指针可以用作输出参数的原因。_p 申请了新的内存，只是把 _p 所指的内存地址改变了，但是 p 丝毫未变。所以函数 GetMemory 并不能输出任何东西。事实上，每执行一次 GetMemory 就会泄露一块内存，因为没有用 free 释放内存。 如果非得要用指针参数去申请内存，那么应该改用“指向指针的指针”:123456789101112void GetMemory2(char **p, int num) { *p = (char *)malloc(sizeof(char) * num); } void Test2(void) { char *str = NULL; GetMemory2(&amp;str, 100); // 注意参数是 &amp;str，而不是 str strcpy(str, &quot;hello&quot;); cout&lt;&lt; str &lt;&lt; endl; free(str); } 比较好的方法是 传指针的引用：123456789101112void GetMemory(char *&amp;p, int num){ p = (char *)malloc(sizeof(char) * num);}void Test(void){ char *str = NULL; GetMemory(str, 100); strcpy(str, &quot;hello&quot;); cout &lt;&lt; str &lt;&lt; endl; free(str);}可以用函数返回值来传递动态内存。这种方法更加简单：12345678910111213char *GetMemory3(int num) { char *p = (char *)malloc(sizeof(char) * num); return p; } void Test3(void) { char *str = NULL; str = GetMemory3(100); strcpy(str, &quot;hello&quot;); cout&lt;&lt; str &lt;&lt; endl; free(str); }在使用返回值时，千万别返回 指向“栈内存” 的指针、引用，因为该内存在函数结束时 自动消亡 了，返回的指针是个野指针了。1234567891011char *GetString(){ char p[] = &quot;hello world&quot;; //数组内容存储在栈区，函数结束时，会释放掉 return p;}void Test(void){ char *str = NULL; str = GetString(); //因为非配的内存早已释放掉，此时的str是个野指针，内容是垃圾 cout &lt;&lt; str &lt;&lt; endl;}在函数中不定义数组，定义指针：1234567891011char *GetString(){ char *p = &quot;hello world&quot;; //数组内容存储在静态区，函数结束时，不会释放掉 return p;}void Test(void){ char *str = NULL; str = GetString(); cout &lt;&lt; str &lt;&lt; endl; } 杜绝“野指针”“野指针”不是 NULL 指针，是指向“垃圾”内存的指针。“野指针”是很危险的，if 语句对它不起作用。出现的原因有： 指针变量没有被初始化。任何指针变量刚被创建时不会自动成为 NULL 指针，它的缺省值是随机的。所以，指针变量在创建的同时应当被初始化，要么将指针设置为 NULL，要么让它指向合法的内存。 指针 p 被 free 或者 delete 之后，没有置为 NULL，让人误以为 p 是个合法的指针。 指针操作超越了变量的作用域范围。 有了 malloc/free 为什么还要 new/delete？malloc 与 free 是 C++/C 语言的标准库函数，new/delete 是 C++ 的运算符。它们都可用于申请动态内存和释放内存。对于非内部数据类型的对象而言，光用 malloc/free 无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于 malloc/free 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于 malloc/free。而C++程序经常要调用 C 函数，而 C 程序只能用 malloc/free 管理动态内存，因此不能只用 new/delete。 12345678910111213141516171819202122class Obj { public : Obj(void){ cout &lt;&lt; “Initialization” &lt;&lt; endl; } ~Obj(void){ cout &lt;&lt; “Destroy” &lt;&lt; endl; } void Initialize(void){ cout &lt;&lt; “Initialization” &lt;&lt; endl; } void Destroy(void){ cout &lt;&lt; “Destroy” &lt;&lt; endl; } }; void UseMallocFree(void) { Obj *a = (obj *)malloc(sizeof(obj)); // 申请动态内存 a-&gt;Initialize(); // 初始化 //… a-&gt;Destroy(); // 清除工作 free(a); // 释放内存} void UseNewDelete(void) { Obj *a = new Obj; // 申请动态内存并且初始化 //… delete a; // 清除并且释放内存} 内存耗尽怎么办？如果在申请动态内存时找不到足够大的内存块，malloc 和 new 将返回 NULL 指针，表示内存申请失败。处理“内存耗尽”问题，一般可以通过判断指针是否为 NULL，是的话用 return 或 exit(1) 终止整个程序的运行，也可以自己为 new 和 molloc 设置异常处理函数。如果一个函数内有多处需要申请动态内存，那么应该用 exit(1) 及时终止程序。","link":"/2020/11/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"},{"title":"C++语言基础","text":"88bfb973b5cd9a98289a5356073cb3e561ba3d32e73d841574e69103b5f1f9aa0c598a741ff12e1904e95cf8d09e492f2918890f88ae3ce3e9904e4d8036138fe4bf2f0ecc47f1df3a7d4b3fb3ad0885888c8eeebe9d6d45e034be6c8cf2e12e9751ef0ec2cb5c17db40ee54c8386f1d14a3b9e3f8bd00751bca74638367f91b7e0134158f5c7856100a74abd7cae4945775999b7d9f4709d7eaf9b226b79b8b1c4e83f17081ec0351649e6e76c5064ca80344c3fbb12fac550e96f7c77de1fd1dfb2dc9136440940227e2dd88322017afe20c193c2492bb78257d8d772b6ef306186739405997f2a8b00a3673ad77c15c4eb641fc6ef73bdd3ac6c482b1bfc6ee23b18f8fe1623b89669c7724beb8141865d8a82a478b434546b53d6a79131a43c1dcebfdd75068f81a0e51d359b6c93cb58ba9dffed56e8d9be85a207dd3ce4a58682cc4b5e4f186371e43dd78b87bfd62bbfc664c21eb0daf9deb2e4978a73a8d67d2928e15280bd61cf7d9ba69f521a438e924e214e1dfdf059b8262321fea6aaa9c0467d6f8ce311ce17fa061a71ce16b34aa3e3f188f65d15700a9b28c0acfd055bbc818ec0140962ebf841ccff58c260a9217c05876bba9599db7c42b9c399514e4008acd06765c91257ff4d2f73d37b559c17be6f6b3315db13f29503ea6d90e448c302bcfc56114f349ca629bf327f3493d7f6c486fa45d2381a862e188134a26a01d6bcd0e374f9d346ecbbdd8161a415b1c341b505de3ff12f02935410e4136ed7fd64e8a8fd3834ba32a8ec1a64f6564a19254453b76d953ae63bb88cfd6279df4f088452b996c43427bd80d98eda6f0ec0767e3de9b7b8c348530209987c707fa71386909f7fd6f4e5453dd1223a95d2c121f0b3834a13f0d381fcb861a285f5d3585ae961b243acbb538aceec04207f4c29ec43c53500d2d844b657ae7e607e83ebc273d261e90f613d30d67c93b7d60942cfccfc057a1fc1098b4d80bccc6e1b67c07cb6e1310c9939dbd61f9f8e45bddfce4981996d6752f11fb68db43c3909a62517f6d7bde47fbd525bb2c411dbee497809f3e5a988f74ca204eb44821a7058fde8921fbcb0323a99699b5a942b70964e51b8fbc7cfedaae7a75c816d33a2bb2a72effc3b800c79a789fd93389a15c8d4ba9c608450e0646a7f423120a5c6abd2dae447daaa4b0e401ea4e0a02ab55c6620280b5bb32d28322c87d3a77b7253a8614ec3b6e8337f4d81e6321528d99196ec032b337626a945f58d3f586c682ac03aea0c93f2aafe1f7544a92e6cbfc194a1795fb9b4e386b563c4f0a2a2c86b5da9f5295bfede296a0dd33d69676492aca241ed8190e2a2ba91b4ba544b0988e2669bd04d73ade05baa7a5f2ab28e80d01e18c07afb4530f47d285f44b861b9efe63a214adfbcc68705b160c6bb562e411cbc527dafbfe2a7f63eaaaa4a65710a35f63a32254a8dd311a7ca56e53686b75ef7bf3fa9113dbbd3d561b6248f615328ce5569d177ab63fc2364a8983237ee0e2bab5f7bf1fbc7f34a85d839ed0b2936542d4ffedd869a6ccaa0a16849189ac28a9f3c3380b3157553b3b71b1f5533ba8bc66791d163b6374d2795ab6ca730763e0a7f939918ebb0458cfa8af8cb8d5b8a5d675afd53602bd8b30756f9440460071aafae981b7b9c5b94636f429a5de0d9a648a7b61a54ef790c4dbdb6776a0de8166b975447beb894e81d1e9ee6038d24e32bd98d32a9dbd08f4af46e7cb9e99a5e59d9f58e25e7aaff9567671a1ecc7fb0095e7c6c55f46498053fccce7ed5d4e1e917dae6348e50207591684bfddc02e253e2a31858ffd059d9c7affa3fd5e8986d1603b279a732c006d91e8fd0f58770aae8c3de6f1d3ecd74871a6d4fda56b7e713bb916043b8187683438984dde49bfabce50beef60758f46ec7359d05813827dfb18022df8fa4d0d41c4f7f838750467dc7ef189ce4d70af120fe4a7bbcb1341152dc5a5d0eab14d2d5050942ea837a58aa86b96ce8968b6f8203deced4c18eff07020ff65d8b64cf0e099016956eecce87ff5a9e286f352dbdf1c0fa402f5f8e0a77dfca3f5c7c2e1de2c04c712668dc0677c528dff8d94f61cd68ffb5db8373ae85a7313a35ea38c614638fb2917173b015252aefe1e93a4cbda2b65c12a6493ca0a546e5a41db5350116aaed4f1c624c5ec222a82939dfe6639e1d0cbcbc94a3db4126d3d15c3ddbdf061f32412e5879ddf73c057f505850ab4f3b3a7c66381598e4e1cb49884ef69ec1227b85e787171ec37f4e556f1dba2cfe06becc68ff9e87e779306df4b914fe8150b9fd17cbfd055e30a9de45b7534230ac7d9c30de212529ac3bc10878509a6a61d10ace607844c73d2f2e55a5ad4d3d15f7b95cc019fc34531105ea1df1305334c665c3cfe24a76b319cedcb9405d7d80c33130b40560500f0b30d154e336e2de5b3e6b318af0fbe0a67eb21ea2cc2577235be615c900d316c49bbf2989eec1da2a09f7a354c0c1b862b9549c5d5c08127eefc7787c93cefef0d5b8a5076ab53a6c570961546553f668bc171b62e03a6e34a1bdb64d36451876c941c85da7ad12eafe2b9a32508672e37132121340ab993b931a532a101b8d774b765d5789bf4dcd5e2c2c272e547cfbbc3c30cfbb8c1e6079b65d20e5466cf60724b7fc021cba710189c56c3328895e73aa5b83d5c21e24767023ee2b5796f347ef1348b803fdeb348a4f2750c94b127c66a83b9befee000668803acdb760e31bc206fbeb24bf48476227215ca208a32ceb7b43aa5984e8334f70932dadeddf28f47680836e2f9fb1af3e22c543c2ff46793e7084ef06c3eb05883b60fc40c9922b7d7b994320a47ce47fbe04b1429cbdc5b20a7e3ac67250a052f8d0a8580893111fbd765cb1dc3ca39f36939f97c61d7f680f4253f3f98833222f85c0726e0696c7099762b468e7a7a3b531489256e224a677b2f36a73eabbcdf62475a0370a22785931a67bfa5ed19dd16929cbc2355e25beacc4f186c02cd0ec92aab8712c782d49cf661be95fecaa69ccc55a6f343ebc4e42dd5bc7852425f57762fa24f6b346a4e7480ff4ec4f954ac69fc606b0a4bcb3a0c045e71bb889103cce5a3aa1cf3eee5f9edcbadf78b07fe171bf233627bdaaa9c075d16bdb43411a5a9449aa0ce6738e4c21ca02e4c794d3d91fea0bb5821b8629a5e8098c359eeb6794bac46c5aaf85bf6261cf8059cd0718f3ec22c9392f3f20361cf886b4964b4878638827c63f9225dcfe5ca33dbefc4bdc88c40f7e8340b99ff156285e3cad94f7f0968e0df1729a5c8c4bbade7fed6f9a806e56d53ce25d17588f275ee26ad1cdcf9de606aae45f7f8ab25368d6c1fa4dada1e4ef62315468cddf6a273edba47d1b79bb46900241ac98bfac3894e98e92ba803cd4d908b32774b6adf94cbc2ae31cee306debcbd046b083cf93e7d117f7be2e6746591e1766c1e45f8368a49e87736774495d126f5e6b93a327661a88db25aff11581eaaef85304cd529ddb88b7cbe8bcf68465ee7d876e0b5ccd4eaaa955b3b05b6d90712f82dc9aa84e0c93e6c31617bb9923790e723c8b2711dd57d57ed217edaf63f69fc2d023ea330c33bccad2423d669d5ca6a56cb79cc412e4277e1a3453412b589c85ed92c274a68038d796dca82ed3cfb7192a7ca9bf8f4121980bd92d21168ee42594c8b24812c207fb729b5217b4b0ee7b5547bf6fa3c171d3664cd9d60dfdc6ac3903e4d1bb555872b0f388e97c88984c80d09d21ba4e47cefd4b1de032d56cc38d6e74ac18b87861b2b1b493b209979e6baeace9a814a04a0a45353be964cb0a6f07ce72306e943dc7bdbf30fede74ecbe49ead3866b4b92e1b8e18b8ec21e9f88d4bf382ffaefca7ac3a25ebdcfac5d3a6ab0b65283994883ad9369a6ac8dd29e1434e9b3f73c71586cc4736f731619d96d3221446239b7719f00b75d8705ee96a67e2a48d377859ae1d3157e18215e816cc2d3ae428802e77116771919c1b58730131a0e01c66e6c3c68fe393e9531ff8c1a72aa06af7a45652b6c229fc24aa4ccab5407c85ef6c9d3354e7dcafe485fef60068b05b2672b1dae4ad20e33d1fe2fca39d64c080f1bf87a31f198d5966284a6b782d0abe2a7513707d6e537d9b1350aac50b9472398f8c77c6061e2b4d076a45cd68a555a97aa60c1a99394805fa397869b6a9dbeb06a7b120278e2ee5e7fac39c53b101f2803d45d4f344603d1f0abd17d5a828fa2d5236adf7aa17bd9b7b2288fc12bfef121985f9af9a4eab7f6b5a5d62916c163190e08dee90e84f1183a29d4163eba584da0469de3ade4b0eb8fea702fc480dd7a72cf66f28a1424943aefb6ed9ad2e75e81bca48ce9fbd9c794669733507ce363b74f3a2ddd563da4758f52236b91b7e04ac92dc1e714e3c65b28b80aa8396db41f14f256f4d0b73ad99d5efa84d206db9cf4e57784a2f5caf5f083c1bb867afa75b336a643ce13c589a4fa18a9abf0c88bb9b461ffdc795648bcc68bd02ba8a131471a2489cfcbfde22d275aaca642627d65d8edd8e6046a231eb3a3852121e3432520e4067df314afc8d6987563342e5b1fe1ea886681b04efddf90d26e35c9b7b13949118bf385e656f52cba9f87ac17f5cbe984be42bc1e2b380e3255384a4b761fe2ad91f8ac6959df3456683ce4dbf949206ad973152f1885c98069117a48adba3b208b903fb7c93d7767098568d96debb6732f16c8708e66e2b4fc3546b7ddc2aa8dcd6a4e4698d8f777f085028d0d97324c2d2f951976e112bb38eebf720c2278ffbab29b3fd3dce8259d3063fe4a9804a0eb664639551defc8b665ab03a2060dd340a502365ecfca7a120de84dc36f872a0f30dfb08f8993376f448839293ce58fe7f58d89622a7c845495d68f0e6d900a58d931730a668ec5d4a466f9b4a8533d7c648aefd900cbbe72a2cedaac7de3bbd6177122f76548c8cad15010da3312bbaa95eb8ba43e558c8b512840fb85026de1596099a4be73a9cdb051193531fdfd27d90eb6716b8acace7c21bb42f2ba8da01138e38a02c142df2d28d681935ee3bdece3d396e5e9af65f8abb33ab9327128eef935a92b0838785bebf321738149eefdb6d6598e8a5670a9fd2e4ce80dcaeb4f8261e9352f9ad3f302bfbcae6f28ab894e78ffcc2ff2df05bd27fc69778a26eacb2df98beb94f1c04da9aad6524e27aec7f8f60c5b072e16f9563b654bcef01a562bd2ede97c0857600ae0712dfc0e5849585797297c3a0f84fbb2ac9c9e1913a1c6f8ae3bea0712ca0246cdbb5535fa83c61bd231b9997f72a9086702f2dc8d52c82ba74c59522467e79a8a98fc69717dc2829beb1cca398564c340ab9360da43d6662b7a0dccb8dbc7a9747cbffc99c2a1c3021c7ae3aa7a9b2b2cfd0ea7346ed234f28c427b4fbaba332be62bdd8749cfa3149a0eb2b039e2ba2f0eb9d9e3c11cf0a812586358ae95e76577860a068ecef9783b3ba1a5ddd2e082160961127e526b20a4deb34790a93ad4b7869e2b1b54a482efc1986685759c703e153ee62e691f055df3ada8751210d253ff2d8628c6de83df0955a378bce692f1d96a8316fb21de513664370294752d32a7adeb36299bc20bb6113d569203b8c8bdfcd7b9841fbb09b041b4e923da1c492547b10278871820dc67b3f27e0fca68ab1fd227fef0e4a619e6dfc28d733ea91ff19e27210e922f959d3f20f20781e3d7c5ab52fd9d431e9d97aed9bf046bf91e40cbb3fa57b8a0730e6978becc7590dca0b4849418d6cbaadf5171d25b5af9d005579706d211c4ae706b830ee371ce6217717378dee62eb290a3ec5f27004f242c838dbeb56f5b9ee8fa1df431f8f052f2d15a248e5a4fa828333d99df53ea3c4035fc39dd5196d780081adc1a2ccd1ec53ed7fbc8abdb3af2de3ea5ddfd79f16e2a2e5c770b1afba39fd4c1a461260124cc90b45e588d4f71ab05eda2d271d2078e1dabe0413f8c4c8238550bdd9c72a48fd6d42975a7c2d184fecf00a999a75690cd2d023de5250c76e48c5d26d65b7817a19b1fa917325e0ded1e6ba5aa23c6cb8d9f8ae4a15a7afdb696a0168cc77f6a6ce1350cf13a954639b0eb8ebaac24dc686e29d0e63938224e5f1566cf052c512c02d6760b0209045650970d005fdce7d20f7f94bea15c20bf0a273f85b4716227a4c0d048b700b4d0f46857fd4b82e5ede569769361d46e76021a8e6275bdae190efed93dc01c8f091404c6dbcf55f204ca84a5e535ad0fee456e7879300db99166feb507498a78238812fd65884cfff299f26b45b9705f9a9bd00e841b30bb471f95c82237470bbeb333bba9b6c8b29cfce5e9cdd1ce6bb4d5302ea20d80501627154b5bfc5a6807361e2b7d98e70b3a857559d6f096ab95f793f8cdf138ffc0e918266ef2815976f9efea29a23941939712c6078da7731a82e2247c683f5f2b80fa76bb172212cfb0f12091ea22826557802586c8b41752ab7b6f3537de8ee820819fb209e9bb96def39e86dc1cbb52194f44a31eb7211cd32eb587a3dfd1ab0821c7e9e25a3c694d612757731ccefd8ebb248c17f854938639e3ca78750a1e94158d643ada472e3c754a6a4a342e8764c488c663a93900b638580b545e8526944e1a223fb5d93f82036cb6b41559f7cd0ce2c08297c8636e1c0248fd3e5631c44a1bae2f285431304e3786cecdc5581020826a995c9e9bca1cf994f24f84544c185e052680ab4cbc5cb79c06dd0c0f0ca968f212f6594fc7172fc455da808e5878c3562ea2b488cedb2440c1fd2a6ff3f699f277af7e889c804f887f6defaffbc8a7ce452608422332a4cc957c39055a3335cf1e8fedeedd17bab7945f5de27cc842e5e9d9d473a0d079d249a93a5c56c74e40ef657e88b2eaeafd99ad7bfeb9c8d5a50c76884a0551dcf81d3782ba2b143d11be3deaa77a6d29c15e512fc31c5c51264666d3f6468887666f338bfb83ee4be738ec5979fa7668e60c521662b9bf540d10c2e44cf308845dc3d6d269dfebf326fbd40c9f56136f3ccc90156b9ee59590dbf9eb8bf3fde9bee99dfcc4ce9ef4345daa98189e8f47ffea32092ec99de49551d50b4678499f62b2d53291ad27dde6c0da44eba6bbb92f477a3807b740c7a8882fd85c6cbfae8e32d77229320dc2869a798223737550021d3e6cac981cc788710970a777f00f2d5179a15af7f7d867c748f1d090a2f78e28d36674559edaabc7bd9a313bd636c87d070d413eff79c7c3dbd2c3a35418ea5222b8c2710f7d9c9072f79cd0dd3f84f8ad77b02b23f34ae352184650d64872a733ec0e675c1422201c73c07dddbc51c6807339ebdaf449c2c8f6ae191bbcbb49da16ff8b0e6b2fab377a34f5e62bb4abd1f78a469f8dd58ef605342dad5ffa87584fbf654639f6d0e960a9692438c70b583b603ebd6825765dd5d60b7d2f53a6900bf5be65bfbfb3d0dcfc67205d20d1e6af7e8992cb609e40cd5e6481657091a015a0cc0ea51bb67776bcbb2fc1eca1b00a65456380e235476300322b515d0367b3337f2d6cadf48a62c8e67a3ab523d5378e696ca33969bd87876021fed9b51fdb93af9b5ce57d08bfded9377d28779eb59b4673e7250361a9ecc9907126cbe33f11080fdde61a8e75578dc7c62c40641ca57190feb81fd50ea66fd0875725f1404493f0371bc512b7771988414a5ddf7ffcb5d4339c9d0b0d563b1ce7453c53a16696103af147a827182365708fb779198de2db5af3a3e824fd9ab15c170ab182efe10690d161af4ed63c26016158978ecf955124211f81b1d5b54dbcd134bd9a06909feea208f22b52b4c2649905b5e053a33c2269724df1aa9c27018f2ff7b31b5b08b07c9628098adc4751e63b232a068a3f60bee3e877cf81c3448aa4cd64c8f87aa9279cc9ee4e2c38d28b1a12d37fe1a975bf3578e5523b892a1ad7ec1f8d13d6db99797a4cd4f86e69d188f8e7d52c1a19664730e0639c5099dc7858e304313ab795a9e67735c6805cacde9471310b8f7d57288b670ce26690c88b6da1bd4e94c685afa401bc40931ef325edceee9625f43ccb3ab13dee322b3e2ef2fb73551e86ac5c286dfb15f3ecd7a398f9c6faf1c395098a2a730f5fad2930b2329418262dd692f4cc68935dfc86b82a5ba76c17d49f28a9888da628fdc21c8ff93eccf9967d62f0897f391e08ea252eaf2abf18e79b69541876bb990a8a1eec6337a73ce1b2029e2d8f5f597c1ef053123aa780858d9b0fcdbc262118f0c886c300012e348ae541003f4e08f31afe87d73556ebbdad3049a74bfdd2762f61c76c91e94b6a5e4af56cfa678dfbb48bd0bea28d8e05124b0557ed289c24f4e6cdd6dd3518a7e09cdf24b28d7fba4c47e26236e3af689c58e80b3e9ce674a6ce43b87f0e4ca423079e061a55a6c7d71aa899b56b4fe1f348ab8e7e63f204c4c9f0b582b0ab3a23aeab06da94fa6bf693828fd288b198715feee2788cf3a938ed94dfa59aacef5f01f0a81a3a5b3e805613e4424245d75d0441c9ba23ed93ec23ecc2c35907c28456b9b91f1f4db640227e25fa2bafec23bdb7df99a6c42ec2b3d0819cabecc5e44ce6bd583b6eab4d0bf315ef9464e4e2583ea23f2da455d3e1922ecd3a029a17c331a7cbe72ff81c5249a5a7bb20414c1bb008db377e524bcb1ab59e435e881cb47321c7f837769999b8fa470eda890113cd7697dcf13fac48828759a377c43f7016a5ed94a78da0d4f4e96fc07ccb05ad8d94fdf3816c0232295b87e8952c431d401181957a78ef4f62cfd6d62bf67823d34cc2d31d2759e0e462dce04ded949f5d01434ee49e472f92747069996127188d4e49f2482b36252c276128beb377990731ef646de242768a0a0d11d85bac2b84403461f18a19896fb2757cfd3c52a8e6f886e72bd5fb64a8d6f7919f300de5b6d7d4e94ec9dfc291b1084dbd7efa356b5991b9d0bdb68b1f6e4d5b1d3712b5d85cf07720a7482b034c092143ad67149e0c2d52e3c802c89d927e9e8f250f169f6a375f5f53a2cc117c5d28cf772af4c3efcb99275ea7ab98333596c07c879a4aac8e4202454b9acaedc06c12e5730fef7fe02be9b9d82215ab1be2870c95d4b7286ce3b9194b2ece76856ef687361d8a74f301bf5b56bb93bb286d98534f5e070623f6a65af81ecf6ad9d015a3a6a1919ad8b2997f5de19341dc145e42645084634c1ed487fcb020bfded2aa65911533aafec95b20fd09d47c14625536dd02a9fcefbc3c7117c40b48a7ff75d45bee794b551eb1b1db36895f94add3f9a887149008b21767358b4ce194d3e58da89374956f205371a1595df389151151e32dcce83e9da9852d0be084acdacf76142c5cb18791e92586c1ba42027424919bf69507480327ab1aecd8b6806163e3e0d7e91bdd1a5beef1ae9442310539055db434974da088c21948cd96d483fc43118a079c07f69f21ce881e6385c65f12af2de2459c709be58922226510d1346fc7f5f0d72b0565a3e53fbab95e477eaa721eddea77fc2cfe09f3e435c2b5b0e9d66cdde23753149bd36ab96553869430d491efa40d5a5c7575b74447f1b9abaa8b93dd955581fc061ad3cf26d2e7e0c6a0f288f49fd75a6134288360949a1cbd7a73b1ac5bd2c709fff6c5f857b653b6e84a3133c0cf05e6ef3354ed8bda569668a640e26b543b46990f79ee1b2f9221bd487f13379a5e9f28aeb5ec1d66890e5b40ad8ead9d60c9064d769d20ccd47434d673342e5f0372bf740617b2ec62e0f63511a968ad10c10571087b9300079855cb1de5f8147e97a7b90535f2dc8510690f3ed5c781525c3b7c5b22c9e852cd4105960e4fa03b47d98a9adf2b59b91f82fe90458b94ecce7eb5f1c548d32afd15f604a0356463cb887f5ed2050ae3cbf290045c2e387c1906ce4f880b27c14804795ab36e2e6b2d047ee1d18a69f2f1235f77dc043899452acb0dde3a1cde756fe2354ed87687b5c0580d30341b2ce1c99a293d265acd9dfdfb5382d33b740fa0c6ce47db2b412bed16bec86e100dfbeebe9f1760b51a41611b9760c72419ebd11aca9d9852d04f778221e42a8cbab3ececc1db5a8f2704db7f48a0e2d2284354a50332bc3b9bb6e2bbb445cd183fa44cb27aaa0b0b09cb73149e2abd67eebd683ab5fd5bcfb77c4b8381cdab09f50650354cdce7aa3a89fad1e716c76aa9db8073bb32ee2d8bd740fb778ab08afbaa3e5e207014b9081ada88823462d01d723acd6eb25ce30678a671eb4059631870eda8341328c7617cfa8c8837cb8ce351fca30b54890f5284ea248e9a220735b2448a0d3f918dbc588d5c58cf26d3a100d1a348137287024628e097e901a0cf582ae921d20898a64d9d8681a2273923cd691a4538d57c9f23c874afb11fad3316483ecaefd772ed4c8ccc2b60e252d563bde90ca445f7cd6c2740ba382e74a2bab18b9430a2bc531eb95bc9758552611df7c6ffd04b7d12a295d4559623d948cece3cb11d17ed5fec95b4829d5622791151fa8aaec8b313e9fd3c4b50331708c44b67aebd482bf7e3c2505b6a20df91c31dc58fffcb283c184ed596f0f9e0dc9318d55dbed190d91e2f527495c8c4c12d132da256bfa02e06e7b5a3eecd085ba1f8d7875482de8e117019da6d02bbd04a943780c0611366c11fd8ea052767b04723c08672143ce4e7fa0128c476eb93194f1cbc08fafac1247ea9e50d14f1349b66b1a61cc781404cf5db6fa9e0eeb65be8db75e289ac93f7a370f91cb440bd9706a461bfb1f1038ac9e68379071dbc6aa609039ea7811b28b8c646360fece85b0e0db04a0144af39ec854e06103c425eb5368f8cdb7d97bcf38c5d3bf5bca5dd1138c41485cd14b9ad7ec4ae5c10cd131d592f73e9ae0720cb1af75dd3e5e6a824442db61d97f64758d0c86f24dbb58b129a219a7f0ae57a8cf7bcf9be0d5148e26add50a589a271d0a01ea4d3ef9c35db38039f872b38fef9ce3f34031e50ad271357833c4d48bfdfbc2d64065d7fd99e13ea96c65ef70602f2aede2d22ee3159611dffc385abf51b971bc3b23e950d6d89d3a5b40e76a192d45660b99f0c493691c15f2874e0856c0c0d7d3619ea54d4e12341701ce9178a2dd90f9ac2277802ac18a4b354183d5a31d9395442b7c4b55cc3576060ba465ff496046a9e97a7990e2b9a9d23a9660f7955bc13339b945c07923429c7bd47641a38f21a000d19ded411e38fea7a26fba25736cd20d96346eb2da5e6b76922dab708ad0100c86877186d3bef240965d346de7a4ec6d44157e3afff5b6286fd483b1ec78073eda89c3d65cc0ab721c0cceae3caa84b5fd9b36be31ffd82c2da6885af322c920122f6a5ea8ca098319c2a740474dcb05732412001501ee9b4fe1d17807c6e894f450498682346d3bea62ca2406d3bc154f90a300dbe7987e380125a4f94394dd7daa4802640f671eba0e8293e5fb38557e1775e0a8ac99dec86965786098410ce3284174cfb313a866513d501ac8ea253392831f3162aa50d1f999821b4ea56d549c3edb0597bec77c43e83ea112781c81b8204e187c2e1337e58a98d8c94bd21821a5963c0b0f0e1f259edbcab5fe5eda0242b5b46591aded32d105e4dc163c3fd8d0096f7a17b41436984f42f57f736a01cb93a3b071f1d819983a7176de3e426efa5b5f800d53668344dc7705430615e76f822bae383f3e95a681234a2a7b701e78bebe81a678834104af35dd2b0be0167f515ae2245470d09405a85cd6865bc316bb617789063083a6aabf709ea5cf02a5c1c0886df84889d0324464cb232b97eef20362485e6ead15457b68b92158720902d9d25708ab590a3698814d2ec4d9d6393601a090a60fc1d1f4891a02f8cceaa8fa84f7e65aa4daaa7d26e0ed2cbd587e819907be21472f0372704b4835233ac457437303518c32a81ca3ce56ab59992766ab6f408cfad2f7ab717e3eb8687b704150156b130a133b7e6aa95eb4610844a3434639f7661e6b79059745e154832c936646ab1dc50ce65c04f3737d2c0c4fc5718e78f6144a73b126fdd3dac6d45fcbdbcfa8b7199aeff1096c9f2889f8282ffdf469f316f25b84886fe4201cd54cf7e28923b7054883a722b7e539a30deb9a08b051226df4e7582110f8bde334147fd09bfbc54ab8d2ca6bb65a0a5b42e0eb61bdeb9f57ad920cf4299b709358a9160d4d5d676477c1923eec9ee703aa41f1fcab715201760b592e598897da20f416bbcf4b5a20a8034d0cc60df9143317bc5db8b6d38380787fcc54c11fdfdbc5feb866169f8abb575b495c030bd1c87e0581502cdb7afafe9094197826a02803be62dda9ec1646f325e83b05fedb9312274b8260ae5ac7f390297b252800f94b30c5d646520b555d25f3d991065fa462fb5a1dcfa6d6b55faaa12ffcc831eba2d03119e51c8d9b12c055c35305f9d4d900b8b564efc3421afcbe74ab380616351d3b0cac3921c27a245728acb148f5956d95ec34c6bb898a1787613e3b28e45324908bbdca2a6f3d087c06cf66a1477306ec8e1209ee05d3b6a6f01d2ac7adfdcf658c98cf958f85b6fe706ea625d707f66eec1faa11cbc1b8faf16480fb77c827d9d73e9c6b641ed3b2dc59a4bc6bfb063ff0b504b240e81a694c49fb7c54e1e9f53ec2259502da20784be92239319e5572c2ca10e4fef249a90a394c93c61f3a707741aa8ba37817dbfdc23c93530fd974e32a942b5aef860e88c84c979c6605c870afefc20d5e44b83820dac595303d0a66b27b75e18d939353cdddb2ff1ddbc1fc5886162b7c53ab2d5e217f2742a9b561ffec030351978ef7dfac5d98bc5e43a1fd864c5429b2e0e007b892eab5641d198b0a7f9d49f89d3b1715f5e03b490876e872d25575e50ae852e09022d9106247c962bed52cd3580b600b83fea1cadb00643a27ec276b66ae634da85f0de52d39e63b3bb2e8b82b680308cd0dd340f3f96f801db2fa7dc52c471e4461400d280ecadc912a642d5768840b6ad32870902c8eac88659fdc76de8dd70367c135c242ca525ab38b0d60e5e6004b30d0d6359d004d0530183b38539f39e0b4ad577dd8315424f54422c51b1f6c932c83b65b3864b17352a348f2a12978ad2e376d7d3d6da1b7d939d9ebe0ffd9c5add6c9d6a5b6bf6ab52dbada3a3e8e5cccb686a8cf6373450943871c92cfc986de7b5c66a597581fdc3f3a02bea08ad0093a2081a54f78b2e06959acc55a5536403b54f2b299dbd4b6aeb34e042c09f2075b1d5118ec2b6afb1debb39e7232adf8a7b07aa5ea291175992cf97a4279856d63ce1e471f07698389b02c8d025c84ea806469b2e35659c7c2deedc60d6434a41d2315bbac9aca21c6d6b3a6121686b7dec91dbc759c26e2f15a3b3ea43591db7c8fdff3c13e868b8dc2a38fa8a715a9a649f116be42c4ffc7d3b6d472d43940640a475f5aa09d71742a1460791266388d3a11f83b26a38af57bf2b72c5bfbba62eef056b391c9a1a6151815e4f26468c20a485f88b45e471d6662dad4b750373f3df7cfb1b5bb7b8881cd95c0437d76f055e39e9843ac5487dfdf6edbf85da3168f4241cbddf9dcfb857766e5233214fb4f3f65398fdc70a55e3c217b71fa51b10cd207124dfb54c25344a969b8e25fb90b992a59bcd0e2a68a36ea8883a4fed59fd72c433e5ed347161f1a11949b54fd6cfccf1ccc7414f352ce73f30ac75260f9a7325c821a6e11c2066695e0d827ce9cbe2be6b130036c7c3cc847b60e15be2ec103aeaabc7f3dd61a4854897741cff45e3ea630a44c6ade97f213df90d5cc955ff6a85109c77632ac4245d103cf303389c92f28e21d1d9674874cb67a512533eeb3852608a0adeb240eb46f52ebe6ea407158b7ff93f73a8be5b0116526ebc185196f00e975df8364d749e744eb765eea6dc18498335b1902b06ffd2b660d2b00d1dd9399b61bea98fd415e0e06203a23d3ad949ee7a4f3b5fd4362d24511fc74640a25b61c2191205eff0102b4cc3ae601a93827fe561ee68a6cf785d992746ad8c4139395bbd5ac8c5e9aa8872c5de2d64d3dd20eb76abef82b3fe30411445b4dfbfc1ec67c9fcb302229b7164e8685daa2206f7876748da893f64ad7b4d7920bc81ed5867a921e21514f0aa10b4a068c2d1bbb8f87452799bd3277a5725fe14083886c2702984dee05b412d529a6301e22c7f66a895189dcb98e82c12db1a01293324eded79e9798cfb04c9e4aa575fdb501cdbcb0644cb7844ab4e7aa433b2193db775eeddf7083afb02ebee5127d087568294c6e856b3fc34487fdb63ccf982b85acf52e166ad415639f6529258643000601208c4d7cc4f4d84e454e70bf3ad71a5572d471eea72f0cde5631b642261e6d14edba24874c9a894836d0b83b6043ef0bcb3912d3b7f23f72c1a0915bbda65af25f624367fa8c6fc8a53413c65c734f5ebcbfefeb3b30c81d63e43eeb0a140002327cc65708a6618415e883613f06685316a35bdfbe39d2629a67442c6e4a857425dabb06abdbef83bfa11498ff78133deb72ff8077a709112b458ecc8bd1e615712b405038741c4b097f00678129ae88fa4b70225402424bef7307116673b5e245fa52490c313bd2d284cd34514b8438a75c1fc881d925ea521ea4c233714244f1c35048fda9c3419d3e8d7b1a1a7c0413dfbecca2ec47309274ddd67750735297f4bb28674be7714a786ee6113b6f7add04e93e29aa0a30572cffdd4f6ef6297098feb6925168ea74875ceb93c7a9f3efb6ab0d6952985cfda823860c5040356d282dfd93607f782ab8d2ae443692f4c7554d2d578efe3c837c8c7d7843b00b0257e5ddd0f06b85e1ffa82a83adf0aac5688d15db641a77bfc3ac5743d1693cf305aa3ffc7c51fc6bbe4d35246bb7d11696f4485daeaba4919faf69887a04a2cd3916b6a4dcbbd890c8cd2b57442a6e9de667ffe7f2dde75b179fa5c7cc055f16c288c84eaec534dcec5ce3252ee56dae3ca63a6b5e55c91ade7064690f1a5a996206fdca7179b30d19bd19c7198624278b7d9b4dd622916878da1f7c464dbb674c71093825315f5398638d81e39ce20bb8726eb0558e5579ba6e0a2ca6cae912f081cf85d4b5bd04b45d8e802587acc5722297773c77081c301043c04c24f3d6224f167a163c18dc97166eabce83b61e97e716eadfcece141262d3961c6496c1365bd5da619c08dfa5eb2f503df53d3517bbcdc146d39937174e17db168c3e028f50c0f0b0c4bd0ba4c0df6b58b809fee5cd9ed5f0cd32fa3189d6e21127e33cb47450a27b31e2060e6f681bfc00110cb192c6a327f434ed7fab42bb5563bfe330bf1265b0bbaf6236b64f6a71a51d974f63ef843ab2f9dc84c9e515bbc86f48849eac692c19d671ae457e6619f5406b6d71f85af9e680a465e42a236e76d5fbe82a466115bfecea9fd830c6cc95bc50aa4cea600ef88891f5db989cc5851a3f6e7a88f5dadd8ad33fb0fd0029f17450c53406b91e2ae596be9e02369cfa62da8d1b9c82ac53936afc9ad07f1728c03f656d4315bd8d937d975b3d284299262f5a9e85eafb94dc607b9bf6b0bd986a3237b9b4af378eb214be888b8c8cf0677c30546e0e534f246821d7aa17bca59c78a17e993c4eb799179ac6ac6675398eb152e6e420aaf83107f845b7ffdf3615c244a8fa5142f09b6ba9d8311f69bb21896db49ab763be40679d70377aacab8ccf0d59c96105b7c41d3a0382e256d02ef4ec263ed68ab90279707127fdba9661cee7e7debdfcef8e46d74a71c9dbda850b77ebe8c92826877edf34e4bfaa1be4857bc796aeda71b59421a5819d75ea7bd5f89025b892a20ef454e38dcd07668087d7a5353966b3bbfe87720dd2cbeacbf08217ea6f5443036ba5810419ff3d0a4765256bd1b7f846b891c02af5745afe669a0afb77e6bb734f4785630c83046d3ef6cc3a69d575e8f5fd7589114156c6c17ec76508f99039c13a6667a05c78e418fe8228d52ca7f28411290d0a5c1a6ad6df9f620a021c269ec970a625548ab74155782e7ba1b9e0c6258f47593366142d0d37c7d8d518ce6f7671e0cce44255084eac8c23d56659567a85146c21f295b161883faf3b81386db45d5d20904cf6e8465254e6fa58d45da26dee7ef720ceab869e34f30a13a42493c019773f9cfbdc0788e8c2be3838fe82e0ce0b71a9d96c0869d162d4c88c3821909b73cd046ddb6c3062fc0d1c6fbc7d1e17ec090d8ded22b564b5110e46589563bbb53605d4e05c1b5f70c88bb97cac64a4c818baee3aef8e5c9b7427fa869271d2d23c3b867863245d4fc4af9507b6677fffa6c99157e6ce64486220956fb1fd689ec882971144a2d4f83b3d43a784274ce7a7088d0f045da698336514b413ddf7660bf1f78c5c719dc9ca268daef8efd9c2f60a771b1f7e98349d7f4487611639e6041aa217bbfe35691aa869ccd81c9f2908c85a24feea8c2dd0452d7b6d800e2790d97390ebaf4905127b40d0f94b38ec7763c86af49c4003a68c52f381a4103903214bfcd80ce333fec1a66dea4b8d5dad77371882b43e3438200979bd3e6eb2eeaa71c8a2e4da388fb6 Hey, password is required here.","link":"/2021/01/C-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80.html"},{"title":"CMakeLists的编写","text":"CMake简介：CMake是一种跨平台的开源项目管理工具，所做的事其实就是告诉编译器如何去编译链接源代码。与之相似的是直接编写makefile文件，但makefile最大的缺点就是不能跨平台，一旦更换环境就要重新编写，于是我们可以使用CMake编写CMakeLists文件来解决此问题。 检查是否安装CMake首先检查是否安装CMake，在终端输入cmake —version来检查，若显示未安装，可以使用sudo apt-get install camke ( ubuntu)，或者brew install cmake (macos)，windows直接去官网下载，来安装CMake。 常用指令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#cmake最小版本需求cmake_minimum_required(VERSION xxx)#设置此项目的名称project(xxx)#生成可执行文件target ，后面填写的是生成此可执行文件所依赖的源文件列表。add_executable(target target_source_codes)# 设置一个名字var_name 的变量，同时给此变量赋值为var_valueSET(var_name var_value)# 指定编译器# CMAKE_C_FLAGS_DEBUG ---- C 编译器# CMAKE_CXX_FLAGS_DEBUG ---- C++ 编译器# -std=c++11 使用 C++11# -g：只是编译器，在编译的时候，产生调试信息。# -Wall：生成所有警告信息。一下是具体的选项，可以单独使用set (CMAKE_CXX_FLAGS &amp;quot;${CMAKE_CXX_FLAGS} -std=c++11 -g -wall &amp;quot;)#指定编译类型，debug 或者为 release# debug 会生成相关调试信息，可以使用 GDB 进行# release 不会生成调试信息。当无法进行调试时查看此处是否设置为 debug.set(CMAKE_BUILD_TYPE Debug)# 打印消息MESSAGE(&amp;quot;MSG&amp;quot;)#给变量var_name赋值为var_value，comment是此变量的注释，和SET 有类似的功效，用于给某变量设置默认值option(var_name &amp;quot;comment&amp;quot; var_value)# 添加include路径，也就是头文件路径include_directories(xxx)# 调用xxx子目录的CMakeLists.txt执行add_subdirectory(xxx)# 给编译器添加xxx参数add_compile_options(xxx)# 给编译器添加库目录，link_directories(xxx)# 生成库文件，SHARED代表动态库，STATIC代表静态库， 最后一个参数代表此库的源文件列表add_library(lib_name SHARED or STATIC lib_source_code)# 给目标添加依赖库target_link_libraries(target_name lib_name ...) 简单应用下图是一般的项目文件格式，include 存放头文件，src存放源代码文件，build存放临时编译文件。假设工程文件夹名为Test，我们可以将CMakeLists.txt文件放在Test文件夹下，也就是src，include的同级目录下，以下是简单的CMakeLists文件编写格式。 123456789101112131415161718# 最低指定的CMake版本cmake_minimum_required(VERSION 3.0)# 括号里面填你的工程名PROJECT(Test)# 头文件路径INCLUDE_DIRECTORIES(include)INCLUDE_DIRECTORIES(/usr/local/include/)# 查找src下的所有cpp文件，然后将结果存进指定变量名(这里是DIR_SRCS)AUX_SOURCE_DIRECTORY(src DIR_SRCS)# 指定语言要求，以下命令为c++ 11SET(CMAKE_CXX_STANDARD 11)# 生成可执行文件，生成的test即为可执行文件add_executable(test ${DIR_SRCS}) 由于该过程中会产生很多中间文件，因此我们在build文件夹下使用cmake命令，这样这些文件就都放在build文件夹下，然后make运行就好： 1234cd buildcmake ..make./test","link":"/2020/09/CMakeLists%E7%9A%84%E7%BC%96%E5%86%99.html"},{"title":"Effective C++条款总结","text":"尽量用 const 和 inline 而不用 #define1#define VAR 1.653 在语句进入编译器之前，就已经完成字符串替换，被预处理程序去掉，即便报错，也是 1.653 的报错信息，而不是 ASPECT_RATIO，这样容易造成混淆。因此应该定义一个常量： 1const double ASPECT_RATIO = 1.653; 另一个 define 用法是实现看起来像函数实际上又不会导致函数调用的宏：1#define max(a,b) ((a) &gt; (b) ? (a) : (b))会发生以下问题： 123456int a = 5, b = 0;// 等价于 ((++a) &gt; (b) ? (++a) : (b))max(++a, b); // a 的值增加了两次// 等价于 ((++a) &gt; (b + 10) ? (++a) : (b + 10))max(++a, b + 10); // a 的值增加了一次 因此可以用内联函数：123456inline int max(int a, int b) { return a &gt; b ? a : b; }// 套用模板适用多种类型template&lt;class T&gt;inline const T&amp; max(const T&amp; a, const T&amp; b){ return a &gt; b ? a : b; }由于不知道 T 的类型，传递引用可以提高效率。 尽量用 而不用 scanf 和 printf 不是类型安全的，而且没有拓展性。 12345int i;Rational r; // r 是个有理数...cin &gt;&gt; i &gt;&gt; r;cout &lt;&lt; i &lt;&lt; r; >&gt; 和 &lt;&lt; 必须是可以处理 Rational 类型对象的重载函数(可能要通过隐式类型转换)。编译器自己可以根据不同的变量类型选择操作符的不同形式，所以不必去指定第一个要读写的对象是 int 还是 Rational。 在传递读和写的对象时采用的语法形式相同。 scanf 没有得到指针，必须加上地址符；而如果已经得到了指针，又要确定不要加上地址符。这样比较麻烦，而完全可以交给 C++ 编译器去做。对于 cin,cout 来说，只要重载了符号，那么读写的方式就都是一样的。 12345678910111213class Rational {public: Rational(int numerator = 0, int denominator = 1); ...private: int n, d; // 分子，分母 friend ostream&amp; operator&lt;&lt;(ostream&amp; s, const Rational&amp; r);};ostream&amp; operator&lt;&lt;(ostream&amp; s, const Rational&amp; r){ s &lt;&lt; r.n &lt;&lt; '/' &lt;&lt; r.d; return s;} 尽量用 new 和 delete 而不用 malloc 和 freemalloc 和 free 不会调用构造和析构函数。假设用两种方法给一个包含 10 个 string 对象的数组分配空间，一个用 malloc，另一个用 new： 1234string *stringArray1 = static_cast&lt;string*&gt;(malloc(10 * sizeof(string)));string *stringArray2 = new string[10];free(stringArray1);delete [] stringArray2; 其结果是，stringArray1 确实指向的是可以容纳 10 个 string 对象的足够空间，但内存里并没有创建这些对象，只是简单的分配内存。相反，stringArray2 指向的是一个包含 10 个完全构造好的 string 对象的数组,每个对象可以在任何读取 string 的操作里安全使用。 同时需要注意，如果不加 []，那么只会销毁一个对象，剩下的9个不能被正确的销毁，因为他们的析构函数永远不会被调用。只要你没有正确的使用 delete，那么结果就是不可预测的。 如果用 new 创建了一个 typedef 定义的类型的对象后，应该说明用什么形式的 delete 来删除。为了避免混乱，最好杜绝对数组类型用 typedef，毕竟 C++ 有 stirng 和 vector 模板，使用他们将会使对数组的需求减少到几乎零。 析构函数里对指针成员调用 delete增加一个指针成员意味着几乎都要进行下面的工作： 在每个构造函数里对指针进行初始化。对于一些构造函数，如果没有内存要分配给指针的话，指针要被初始化为 0(即空指针)。 删除现有的内存，通过赋值操作符分配给指针新的内存。 在析构函数里删除指针。 除非类成员最初用了 new，否则是不用在析构函数里用 delete 的。","link":"/2020/10/Effective-C-%E6%9D%A1%E6%AC%BE%E6%80%BB%E7%BB%93.html"},{"title":"GCC编译器和GDB调试器","text":"GCC编译器GCC 编译器支持编译 Go、Objective-C，Objective-C++，Fortran，Ada，D 和 BRIG（HSAIL）等程序。 实际使用中，使用 gcc 指令编译 C 代码，使用 g++ 指令编译 C++ 代码。 编译过程例如 g++ test.cpp -o test 可拆解为以下步骤： 预处理 123# -E 选项指示编译器仅对输入文件进行预处理# test.i 文件将头文件及宏定义具体内容全部展开，其余保持不变g++ -E test.cpp -o test.i // 生成.i文件 编译 1234# -S 编译选项告诉 g++ 在为 C++ 代码产生了汇编语言文件后停止编译# g++ 产生的汇编语言文件缺省拓展名是 .s# test.s 汇编语言文件内容为汇编指令g++ -S test.i -o test.s 汇编 1234# -c 选项告诉 g++ 仅把源代码编译为机器语言的目标代码# 缺省时 g++ 建立的目标代码文件有一个 .o 的拓展名# test.o 为机器语言识别的二进制代码g++ -c test.s -o test.o 链接 123# -o 编译选项来为将产生的可执行文件用指定的文件名# test 为可执行文件g++ test.o -o test g++重要编译参数 -g 编译带调试信息的可执行文件 123# -g 选项告诉 GCC 产生能被 GNU 调试器 GDB 使用的调试信息，以调试程序。# 产生带调试信息的可执行文件 test（不加则 test 不包含调试信息）g++ -g test.cpp -o test -O[n] 优化源代码 12345678910# 所谓优化，比如省略代码中从未使用过的变量，直接将常量表达式用结果值来替代等等，这些操作会缩减目标文件所包含的代码量，提高最终生成的可执行文件的运行效率。# -O 选项告诉 g++ 对源代码进行基本优化。这些操作在大多数情况下都会使程序执行的更快。-O2 选项告诉 g++ 产生尽可能小和尽可能快的代码。# -O 同时减小代码长度和执行时间，效果等价为 -O1# -O0 表示不做优化# -O1 默认优化# -O2 除了完成 -O1 的优化之外，还进行一些额外的调整工作，如指令调整等# -O3 包括循环展开和其他一些与处理特性相关的优化操作# 选项将使编译的速度比使用 -O 时慢，但通常产生的代码执行速度会更快# 可以用如 &quot;time ./test&quot; 来查看可执行文件的运行效率，比较优化效果g++ -O2 test.cpp -l 和 -L 指定库文件 ｜ 指定库文件路径 1234567891011# -l 参数就是用来指定程序要链接的库，-l 参数紧接着就是库名# 在 /lib 和 /usr/lib 和 /usr/local/lib 里的库可以直接用 -l 来进行链接# 链接 glog库g++ -lglog test.cpp# 如果库文件没放在上面三个目录里，需要使用 -L 参数指定库文件所在目录# -L 参数紧接着的是库文件所在的目录名# 链接 mytest 库，libmytest.so 在 /home/Test 目录下g++ -L/home/Test -lmytest test.cpp -I 指定头文件搜索目录 12# 若头文件在 /usr/include 目录下一般是不需要指定的，否则就需要 -I 参数来指定了，比如头文件放在 /myinclude 目录里，否则会报错 “xxxx.h: No such file or directory” 。g++ -I/myinclude test.cpp -Wall 打印警告信息 | -w 关闭警告信息 12345# 打印出 gcc 的警告信息g++ -Wall test.cpp# 关闭所有警告信息g++ -w test.cpp -std=c++11 设置编译标准 12# 使用 c++11 标准编译 test.cppg++ -std=c++11 test.cpp -o 指定输出文件名 123# 指定即将产生的文件名# 指定输出可执行文件名为testg++ test.cpp -o test -D 定义宏 123456789101112131415# 在使用gcc/g++编译的时候定义宏# 常用场景：# -DDEBUG 定义 DEBUG 宏，可能文件中有DEBUG宏部分的相关信息，用 DDEBUG 来选择开启或关闭 DEBUG# 举例：// -Dname 定义宏 name，默认定义内容为字符串 “1”#include &lt;stdio.h&gt;int main(){ #ifdef DEBUG printf(&quot;DEBUG LOG\\n&quot;); #endif printf(&quot;in\\n&quot;);}// 1. 在编译的时候，使用g++ -DDEBUG main.cpp// 2. 第七行代码可以被执行 GDB调试器 GDB(GNU Debugger) 是一个用来调试C/C++程序的功能强大的调试器，是 Linux 系统开发 C/C++ 最常用的调试器。 GDB主要功能： 设置断点(断点可以是条件表达式) 使程序在指定的代码行上暂停执行，便于观察 单步执行程序，便于调试 查看程序中变量值的变化 动态改变程序的执行环境 分析崩溃程序产生的core文件 调试开始：执行gdb [filename] ，进入gdb调试程序，其中 filename 为要调试的可执行文件名。 编译程序时需要加上 -g，之后才能用 gdb 进行调试：g++ -g main.cpp -o main回车键：重复上一命令 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051$(gdb)help(h) # 查看命令帮助，具体命令查询在gdb中输入help + 命令 $(gdb)run(r) # 重新开始运行文件（run-text：加载文本文件，run-bin：加载二进制文件）$(gdb)start # 单步执行，运行程序，停在第一行执行语句$(gdb)list(l) # 查看原代码（list-n,从第n行开始查看代码。list+ 函数名：查看具体函数）$(gdb)set # 设置变量的值$(gdb)next(n) # 单步调试（逐过程，函数直接执行）$(gdb)step(s) # 单步调试（逐语句：跳入自定义函数内部执行）$(gdb)backtrace(bt) # 查看函数的调用的栈帧和层级关系$(gdb)frame(f) # 切换函数的栈帧$(gdb)info(i) # 查看函数内部局部变量的数值$(gdb)finish # 结束当前函数，返回到函数调用点$(gdb)continue(c) # 继续运行$(gdb)print(p) # 打印值及地址$(gdb)quit(q) # 退出gdb$(gdb)break+num(b) # 在第num行设置断点$(gdb)info breakpoints # 查看当前设置的所有断点$(gdb)delete breakpoints num(d) # 删除第num个断点$(gdb)display # 追踪查看具体变量值$(gdb)undisplay # 取消追踪观察变量$(gdb)watch # 被设置观察点的变量发生修改时，打印显示$(gdb)i watch # 显示观察点$(gdb)enable breakpoints # 启用断点$(gdb)disable breakpoints # 禁用断点$(gdb)x # 查看内存x/20xw 显示20个单元，16进制，4字节每单元$(gdb)run argv[1] argv[2] # 调试时命令行传参$(gdb)set follow-fork-mode child # Makefile项目管理：选择跟踪父子进程（fork()）","link":"/2020/12/GCC%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8CGDB%E8%B0%83%E8%AF%95%E5%99%A8.html"},{"title":"Java常量池","text":"概念什么是常量用final修饰的成员变量表示常量，值一旦给定就无法改变！ final修饰的变量有三种：静态变量、实例变量和局部变量，分别表示三种类型的常量。 Class文件中的常量池在Class文件结构中，最头的4个字节用于存储魔数Magic Number，用于确定一个文件是否能被JVM接受，再接着4个字节用于存储版本号，前2个字节存储次版本号，后2个存储主版本号，再接着是用于存放常量的常量池，由于常量的数量是不固定的，所以常量池的入口放置一个U2类型的数据(constant_pool_count)存储常量池容量计数值。 常量池主要用于存放两大类常量：字面量(Literal)和符号引用量(Symbolic References)，字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等，符号引用则属于编译原理方面的概念，包括了如下三种类型的常量：类和接口的全限定名，字段名称和描述符，方法名称和描述符。 方法区中的运行时常量池运行时常量池是方法区的一部分。 CLass文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。 运行时常量池相对于CLass文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入CLass文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是String类的intern()方法。 常量池的好处常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。 例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。（1）节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。（2）节省运行时间：比较字符串时，== 比 equals()快。对于两个引用变量，只用 == 判断引用是否相等，也就可以判断实际值是否相等。 双等号==的含义基本数据类型之间应用双等号，比较的是他们的数值。 复合数据类型(类)之间应用双等号，比较的是他们在内存中的存放地址。 8种基本类型的包装类和常量池java中基本类型的包装类的大部分都实现了常量池技术，即Byte,Short,Integer,Long,Character,Boolean； 123Integer i1 = 40;Integer i2 = 40;System.out.println(i1==i2);//输出TRUE 这5种包装类默认创建了数值[-128，127]的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。 1234567//Integer 缓存代码 ：public static Integer valueOf(int i) { assert IntegerCache.high &gt;= 127; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } 123Integer i1 = 400;Integer i2 = 400;System.out.println(i1==i2);//输出false 两种浮点数类型的包装类Float,Double并没有实现常量池技术。 123Double i1=1.2;Double i2=1.2;System.out.println(i1==i2);//输出false 应用常量池的场景 Integer i1=40; Java在编译的时候会直接将代码封装成 Integer i1=Integer.valueOf(40);，从而使用常量池中的对象。 Integer i1 = new Integer(40); 这种情况下会创建新的对象。 1234567891011121314151617181920Integer i1 = 40;Integer i2 = 40;Integer i3 = 0;Integer i4 = new Integer(40);Integer i5 = new Integer(40);Integer i6 = new Integer(0);System.out.println(&quot;i1=i2 &quot; + (i1 == i2));System.out.println(&quot;i1=i2+i3 &quot; + (i1 == i2 + i3));System.out.println(&quot;i1=i4 &quot; + (i1 == i4));System.out.println(&quot;i4=i5 &quot; + (i4 == i5));System.out.println(&quot;i4=i5+i6 &quot; + (i4 == i5 + i6));System.out.println(&quot;40=i5+i6 &quot; + (40 == i5 + i6));i1=i2 truei1=i2+i3 truei1=i4 falsei4=i5 falsei4=i5+i6 true40=i5+i6 true 解释：语句i4 == i5 + i6，因为 + 这个操作符不适用于Integer对象，首先 i5 和 i6 进行自动拆箱操作，进行数值相加，即i4 == 40。然后Integer对象无法与数值进行直接比较，所以i4自动拆箱转为int值40，最终这条语句转为40 == 40进行数值比较。 String类和常量池String对象创建方式123String str1 = &quot;abcd&quot;;String str2 = new String(&quot;abcd&quot;);System.out.println(str1==str2);//false 这两种不同的创建方法是有差别的，第一种方式是在常量池中拿对象，第二种方式是直接在堆内存空间创建一个新的对象。只要使用new方法，便需要创建新的对象。 连接表达式 + 只有使用引号包含文本的方式创建的String对象之间使用“+”连接产生的新对象才会被加入字符串池中。 对于所有包含new方式新建对象（包括null）的“+”连接表达式，它所产生的新对象都不会被加入字符串池中。 123456789String str1 = &quot;str&quot;;String str2 = &quot;ing&quot;;String str3 = &quot;str&quot; + &quot;ing&quot;;String str4 = str1 + str2;System.out.println(str3 == str4);//falseString str5 = &quot;string&quot;;System.out.println(str3 == str5);//true 特例1 123456789101112public static final String A = &quot;ab&quot;; // 常量Apublic static final String B = &quot;cd&quot;; // 常量Bpublic static void main(String[] args) {String s = A + B; // 将两个常量用+连接对s进行初始化String t = &quot;abcd&quot;;if (s == t) { System.out.println(&quot;s等于t，它们是同一个对象&quot;);} else { System.out.println(&quot;s不等于t，它们不是同一个对象&quot;);}}// s等于t，它们是同一个对象 A和B都是常量，值是固定的，因此s的值也是固定的，它在类被编译时就已经确定了。也就是说：String s = A + B; 等同于：String s = ”ab” + ”cd”; 1234567891011121314151617public static final String A; // 常量Apublic static final String B; // 常量Bstatic { A = &quot;ab&quot;; B = &quot;cd&quot;;}public static void main(String[] args) { // 将两个常量用+连接对s进行初始化 String s = A + B; String t = &quot;abcd&quot;; if (s == t) { System.out.println(&quot;s等于t，它们是同一个对象&quot;); } else { System.out.println(&quot;s不等于t，它们不是同一个对象&quot;); }}// s不等于t，它们不是同一个对象 A和B虽然被定义为常量，但是它们都没有马上被赋值。在运算出s的值之前，他们何时被赋值，以及被赋予什么样的值，都是个变数。因此A和B在被赋值之前，性质类似于一个变量。那么s就不能在编译期被确定，而只能在运行时被创建了。 String s1 = new String(“xyz”); 创建了几个对象？考虑类加载阶段和实际执行时。 类加载对一个类只会进行一次。”xyz”在类加载时就已经创建并驻留了（如果该类被加载之前已经有”xyz”字符串被驻留过则不需要重复创建用于驻留的”xyz”实例）。驻留的字符串是放在全局共享的字符串常量池中的。 在这段代码后续被运行的时候，”xyz”字面量对应的String实例已经固定了，不会再被重复创建。所以这段代码将常量池中的对象复制一份放到heap中，并且把heap中的这个对象的引用交给 s1 持有。 这条语句创建了2个对象。 java.lang.String.intern()运行时常量池相对于CLass文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入CLass文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是String类的intern()方法。 String的intern()方法会查找在常量池中是否存在一份equal相等的字符串,如果有则返回该字符串的引用,如果没有则添加自己的字符串进入常量池。 123456789public static void main(String[] args) { String s1 = new String(&quot;计算机&quot;); String s2 = s1.intern(); String s3 = &quot;计算机&quot;; System.out.println(&quot;s1 == s2? &quot; + (s1 == s2)); System.out.println(&quot;s3 == s2? &quot; + (s3 == s2));}// s1 == s2? false// s3 == s2? true 补充123456789101112131415public class Test {public static void main(String[] args) { String hello = &quot;Hello&quot;, lo = &quot;lo&quot;; System.out.println((hello == &quot;Hello&quot;) + &quot; &quot;); System.out.println((Other.hello == hello) + &quot; &quot;); System.out.println((other.Other.hello == hello) + &quot; &quot;); System.out.println((hello == (&quot;Hel&quot;+&quot;lo&quot;)) + &quot; &quot;); System.out.println((hello == (&quot;Hel&quot;+lo)) + &quot; &quot;); System.out.println(hello == (&quot;Hel&quot;+lo).intern());}}class Other { static String hello = &quot;Hello&quot;; }package other;public class Other { public static String hello = &quot;Hello&quot;; }// true true true true false true 在同包同类下，引用自同一String对象。 在同包不同类下，引用自同一String对象。 在不同包不同类下，依然引用自同一String对象。 在编译成.class时能够识别为同一字符串的，自动优化成常量，引用自同一String对象。 在运行时创建的字符串具有独立的内存地址，所以不引用自同一String对象。","link":"/2020/09/Java%E5%B8%B8%E9%87%8F%E6%B1%A0.html"},{"title":"Java自动内存管理机制","text":"Java内存区域与内存溢出异常概述对于Java程序员来说，有虚拟机的自动内存管理机制，不再需要像C++那样为每个new操作去写配对的delete/free代码。但正因如此，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是如何使用内存的，那排查错误将会变得异常困难。 运行时数据区域Java虚拟机在执行Java程序过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。 程序计数器程序计数器是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令， 分支、循环 、跳转、异常 处理、线程恢复等基础功能都需要依赖这个计数器来完成。 线程私有：由于 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令，切换时也并不会记录上一个线程执行到那个位置。因此，为了线程切换后能恢复到正确的执行位控，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器值则为空 ( Undefined )。 Native方法大多是通过C实现并未编译成需要执行的字节码指令，也就不需要去存储字节码文件的行号 程序计数器的内存区域是唯一一个在 Java 虚拟机规范中没有规定任何OutOfMemoryError情况的区域，因为程序计数器存储的是字节码文件的行号，这个范围是可知晓的，在一开始分配内存时就可以分配一个绝对不会溢出的内存。 总结： 线程私有的，每个线程都有一个程序计数器 是java虚拟机规范里面，唯一一个没有规定任何 OutOfMemoryError 情况的区域 生活周期随着线程的创建而创建，随着线程的结束而消亡 程序计数器是一块较小的内存区域 Java虚拟机栈与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是 Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从人栈到出栈的过程。 虚拟机栈是Java执行方法的内存模型。每个方法被执行的时候，都会创建一个栈帧，把栈帧压入栈，当方法正常返回或者抛出未捕获的异常时，栈帧就会出栈。 栈对应线程，栈帧对应方法 在活动线程中，只有位于栈顶的帧才是有效的，称为当前栈帧。正在执行的方法称为当前方法。在执行引擎运行时，所有指令都只能针对当前栈帧进行操作。而 StackOverflowError 表示请求的栈溢出，导致内存耗尽，通常出现在递归方法中。 一般把Java内存区分为堆内存（Heap）和栈内存（Stack），其中『栈』指的是虚拟机栈，『堆』指的是Java堆。在 Java 虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过 Java 虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出 OutOfMemoryError 异常。 StackOverflowError：递归过深，递归没有出口 OutOfMemoryError：JVM空间溢出，创建对象速度高于GC回收速度，可能是申请了较多空间没有及时释放 局部变量表：存放方法参数和方法内部定义的局部变量的区域。 局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。 本地方法栈本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。 Java堆Java堆是披所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都要在堆上分配。 是垃圾收集器管理的主要区域，也被称做“GC堆”，也是Java虚拟机所管理的内存中最大的一块。 根据 Java 虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。在实现时，既可以实现成固定大小的，也可以是可扩展的。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出 OutOfMemoryError 异常。 方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。与Java堆一样，是各个线程共享的内存区域。 人们更愿意把这个区域称为“永久代”，本质上两者并不等价，或者说是永久代来实现方法区而已。它还有个别名叫做Non-Heap（非堆）。 和Java堆一样不需要连续的内存和可以选择固定大小或可扩展外，还可选择不实现GC。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久” 存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的，未完全回收可能会导致内存泄漏。 在Java虚拟机规范中，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。 运行时常量池Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。 相对于Class文件常量池的一个重要特征是具备动态性，体现在并非只有预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中。是方法区的一部分，会受到方法区内存的限制。在Java虚拟机规范中，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。 对象访问由于 reference 类型在 Java 虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访间到 Java 堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种： 通过句柄方式访问 如果使用句柄访问的话，那么Java堆中将会划分一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象的实例数据与类型数据各自的具体地址信息。 优点：当对象移动的时候（垃圾回收的时候移动很普遍），这样值需要改变句柄中的指针，但是栈中的指针不需要变化，因为栈中存储的是句柄的地址 缺点：需要进行二次定位，寻找两次指针，开销相对更大一些 使用指针访问 如果使用直接指针访问方式，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象的地址。 优点：速度快，不需要和句柄一样指针定位的开销 垃圾收集器与内存分配策略概述当需要排查各种内存溢出、内存泄涌问题时，当垃圾收集成为系统达到更高并发的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。 程序计数器、虚拟机栈、本地方法栈三个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行若出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具备确定性，在这几个区域内不需要过多考虑回收的问题，因为方法结束或线程结束时，内存自然就跟随着回收了。 而 Java 堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存， 对象已死？堆中几乎存放着 Java 中所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象有哪些还“存活”着，哪些已经“死去”（即不可能再披任何途径使用的对象）。 引用计数器法给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加 1; 当引用失效时，计数器值就减 1; 任何时刻计数器都为 0 的对象就是不可能再被使用的。 Java语言中没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间的相互循环引用的问题。 根搜索算法通过一系列的名为 “GCRoots” 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链 (ReferenceChain) , 当一个对象到 GCRoots 没有任何引用链相连（用图论的话来说就是从 GCRoots 到这个对象不可达）时，则证明此对象是不可用的。 在 Java 语言里，可作为 GCRoots 的对象包括下面几种 ： 虚拟机栈（栈帧中的本地变量表）中的引用的对象。 方法区中的类静态属性引用的对象。 方法区中的常扯引用的对象。 本地方法栈中 JNI (即一般说的 Native 方法）的引用的对象 再谈引用在 JDK 1.2 之前，Java中的引用的定义很传统 ：如果 reference 类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。 在 JDK 1.2 之后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种，这四种引用强度依次逐渐减弱。 强引用就是指在程序代码之中普遍存在的，类似 “Object obj = new Object()” 这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。 软引用用来描述一些还有用，但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中并进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。在 JDK1.2 之后，提供了 SoftReference 类来实现软引用。 弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在 JDK 1.2 之后，提供了 WeakReference 类来实现弱引用。 虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知。在 JDK 1.2 之后，提供了 PhantomReference 类来实现虚引用。 生存还是死亡？要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行根搜索后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法。当对象没有覆盖 finalize()方法，或者 finalize () 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。 如果这个对象被判定为有必要执行 finalize() 方法，那么这个对象将会被放置在一个名为 F-Queue 的队列之中，并在稍后由一条由虚拟机自动建立的、低优先级的 Finalizer 线程去执行。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象在 finalize() 方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致 F-Queue 队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。finalize() 方法是对象逃脱死亡命运的最后一次机会，稍后 GC 将对 F-Queue 中的对象进行第二次小规模的标记，如果对象要在 finalize() 中成功拯救自己 —— 只要重新与引用链上的任何一个对象建立关联即可，譬如把自己 (this 关键字）赋值给某个类变址或对象的成员变量，那在第二次标记时它将被移除出 “即将回收” 的集合；如果对象这时候还没有逃脱，那它就真的离死不远了。","link":"/2020/07/Java%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6.html"},{"title":"Java虚拟机类加载机制","text":"概述虚拟机把描述类的数据从 Class 文件加载到内存，井对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。 类加载的时机类从被加载到虚拟机内存中开始，到卸栽出内存为止，它的整个生命周期包括了：加载、验证、准备、解析、初始化、使用和卸载七个阶段。其中验证、准备和解析三个部分统称为连接。 加载加载是类加载过程中的一个阶段，这个阶段虚拟机要完成3件事。 通过一个类的全限定名来获取定义此类的二进制字节流。 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 会在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个 Class 文件获取，这里既可以从 ZIP 包中读取（比如从 jar 包和 war 包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将 JSP 文件转换成对应的 Class 类） 链接验证这一阶段的主要目的是为了确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，保证被加载类的正确性，不会危害虚拟机自身的安全。验证主要包含4个阶段的校验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。 准备准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。注意这里所说的初始值概念，比如一个类变量定义为： 1public static int value = 123; 实际上变量 value 在准备阶段过后的初始值为 0 而不是 123，将 value 赋值为 123 的 putstatic 指令是程序被编译后，存放于类构造器方法之中。 但是注意如果声明为: 1public static final int value = 123; 在编译阶段会为 value 生成 ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 属性将 value 赋值为 123。 解析解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是在 class 文件中以： CONSTANT_Class_info、CONSTANT_Field_info、CONSTANT_Method_info等类型的常量出现。 初始化初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由 JVM 主导。到了初始阶段，才开始真正执行类中定义的 Java 程序代码。 那么，什么时候开始初始化？ 使用 new 该类实例化对象的时候； 读取或设置类静态字段的时候（但被final修饰的字段，在编译器时就被放入常量池的静态字段除外static final）； 调用类静态方法的时候； 使用反射 Class.forName(“xxxx”) 对类进行反射调用的时候，该类需要初始化； 初始化一个类的时候，有父类，先初始化父类（注：1. 接口除外，父接口在调用的时候才会被初始化；2.子类引用父类静态字段，只会引发父类初始化）； 被标明为启动类的类（即包含main()方法的类）要初始化； 当使用 JDK1.7 的动态语言支持时，如果一个 java.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。 以上情况称为对一个类进行主动引用，且有且只要以上几种情况需要对类进行初始化。","link":"/2020/08/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.html"},{"title":"LeetCode1563：石子游戏V","text":"题目几块石子 排成一行 ，每块石子都有一个关联值，关联值为整数，由数组 stoneValue 给出。 游戏中的每一轮：Alice 会将这行石子分成两个 非空行（即，左侧行和右侧行）；Bob 负责计算每一行的值，即此行中所有石子的值的总和。Bob 会丢弃值最大的行，Alice 的得分为剩下那行的值（每轮累加）。如果两行的值相等，Bob 让 Alice 决定丢弃哪一行。下一轮从剩下的那一行开始。 只 剩下一块石子 时，游戏结束。Alice 的分数最初为 0 。 返回 Alice 能够获得的最大分数 。 Solution$dp[l][r]$ 表示区间 $[l,r]$ Alice能得到的最大值，然后区间dp。 若$sum[l…mid] == sum[mid+1…r]$ ，则 $dp[l][r] = max(dp[l][r], dp[l][mid] + dp[mid + 1][r] + sum[l…mid])$。 若$sum[l…mid] != sum[mid+1…r]$ : $sum[l…mid] &gt; sum[mid + 1][r]$ ，则 $dp[l][r] = max(dp[l][r], dp[mid + 1][r] + sum[mid+1…r])$。 $sum[l…mid] &lt; sum[mid + 1][r]$ ，则 $dp[l][r] = max(dp[l][r], dp[l][mid] + sum[l…mid])$。 Code123456789101112131415161718192021222324252627282930class Solution { public int stoneGameV(int[] stoneValue) { int n = stoneValue.length; int[][] dp = new int[n][n]; int[] sum = new int[n]; sum[0] = stoneValue[0]; for (int i = 1; i &lt; n; i++) { sum[i] = sum[i - 1] + stoneValue[i]; } for (int len = 2; len &lt;= n; len++) { for (int l = 0; l + len - 1 &lt; n; l++) { int r = l + len - 1; for (int mid = l; mid &lt; r; mid++) { int fl = sum[mid] - (l &gt; 0 ? sum[l - 1] : 0); int fr = sum[r] - sum[mid]; if (fl == fr) { dp[l][r] = Math.max(dp[l][r], Math.max(dp[l][mid], dp[mid + 1][r]) + fl); } else { if (fl &gt; fr) { dp[l][r] = Math.max(dp[l][r], dp[mid + 1][r] + fr); } else { dp[l][r] = Math.max(dp[l][r], dp[l][mid] + fl); } } } } } return dp[0][n - 1]; }}","link":"/2020/08/LeetCode1563%EF%BC%9A%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8FV.html"},{"title":"LeetCode：最短回文串","text":"题意给定一个字符串 $s$，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。 Solution等价于求字符串 $s$ 以 $s_0$ 开头的最长回文串，然后多出来的后缀翻转后就是需要补足的最小长度，判断回文可以采用哈希。 Code12345678910111213141516171819class Solution { public String shortestPalindrome(String s) { int n = s.length(); long left = 0, right = 0, base = 13331, mod = 1000000007, pre = 1; int pos = -1; for (int i = 0; i &lt; n; i++) { left = (left * base + s.charAt(i)) % mod; right = (right + pre * s.charAt(i)) % mod; if (left == right) { pos = i; } pre = pre * base % mod; } String add = (pos == n-1 ? &quot;&quot; : s.substring(pos+1,n)); StringBuilder res = new StringBuilder(add).reverse(); res.append(s); return res.toString(); }}","link":"/2020/08/LeetCode214%EF%BC%9A%E6%9C%80%E7%9F%AD%E5%9B%9E%E6%96%87%E4%B8%B2.html"},{"title":"LeetCode354：俄罗斯套娃信封问题","text":"题意求二维最长上升子序列 Solution对第一维进行从小到大排序，然后第二维从大到小排序，对第二维做LIS即可。 Code12345678910111213141516171819202122232425262728293031class Solution { public int maxEnvelopes(int[][] a) { int n = a.length; if (n == 0) return 0; int[] low = new int[n + 1]; int res = 0; Arrays.sort(a, new Comparator&lt;int[]&gt; () { public int compare(int[] c1, int[] c2) { if (c1[0] == c2[0]) { return c2[1] - c1[1]; } else { return c1[0] - c2[0]; } } }); for (int i = 0; i &lt; n; i++) { if (low[res] &lt; a[i][1]) low[++res] = a[i][1]; else{ int pos = Arrays.binarySearch(low, 1, res, a[i][1]); if (pos &lt; 0) pos = -pos - 1; low[pos] = a[i][1]; } } return res; }}","link":"/2020/08/LeetCode354%EF%BC%9A%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98.html"},{"title":"LeetCode424：替换后的最长重复字符","text":"题意给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。 Solution1枚举重复的字符，然后计算对应字符的能构成的最大长度，取最大值。 Code1234567891011121314151617181920212223class Solution { public int characterReplacement(String s, int k) { int n = s.length(), res = 0; for (int i = 0; i &lt; 26; i++) { List&lt;Integer&gt; l = new ArrayList&lt;Integer&gt;(); l.add(-1); for (int j = 0; j &lt; n; j++) { if (s.charAt(j) - 'A' != i) { l.add(j); } } if (l.size() &lt;= k + 1) { res = n; break; } l.add(n); for (int j = k + 1; j &lt; l.size(); j++) { res = Math.max(res, l.get(j) - l.get(j - k - 1) - 1); } } return res; }} Solution2滑动窗口，一个区间满足条件的原则是$当前区间的长度&lt;=区间内出现次数最多的字符 + k$，用滑动窗口维护即可。即当满足条件时，滑动窗口拓展，右端点++；不满足时，滑动窗口平移，左右端点++。滑动窗口的长度只会不断增大，遍历结束后滑动窗口的长度即为答案。 Code12345678910111213141516class Solution { public int characterReplacement(String s, int k) { int n = s.length(), res = 0, l = 0, r = 0, ma = 0; int[] b = new int[26]; for (r = 0; r &lt; n; r++) { int now = s.charAt(r) - 'A'; b[now]++; ma = Math.max(ma, b[now]); if (ma + k &lt; r - l + 1) { b[s.charAt(l) - 'A']--; l++; } } return n - l; }}","link":"/2020/08/LeetCode424%EF%BC%9A%E6%9B%BF%E6%8D%A2%E5%90%8E%E7%9A%84%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6.html"},{"title":"LeetCode440：字典序的第K小数字","text":"题目给定整数 n 和 k，找到 1 到 n 中字典序第 k 小的数字。 注意：1 ≤ k ≤ n ≤ 10^9。 Solution 我们可以把每个字符看作是字符串，这样我们只需要考虑前缀即可。显然最小的字符串一定是0，然后是所有以1开头的数。。。 我们只需要枚举所有首位数字 $1-9$，计算每个前缀在区间 $[0, n]$ 内有多少个数就好了，当累加和超过 $n$ 时，说明答案一定是以这个首位数字开头的，然后向下枚举。比如当以得知答案以3开头时，扣除3本身，然后向下枚举前缀30,31重复上述操作。。。直到 $k$ 为0。 Code1234567891011121314151617181920212223242526class Solution { public int get_Count(int n, long x, long y) { int sum = 0; while (x &lt;= n) { sum += Math.min(n + 1, y) - x; // 如n=15,则sum+=min(16,20)-10 x *= 10; y *= 10; } return sum; } public int findKthNumber(int n, int k) { int pre = 1; k--; // 扣除数字0 while (k &gt; 0) { int now = get_Count(n, pre, pre + 1); if (k &gt;= now) { // 说明不在这个前缀区间里 pre++; // 找下一个字典序前缀 k -= now; // 扣除这个前缀的所有数 } else { // 说明答案是这个前缀 pre *= 10; // 往下找 k--; // 扣除当前这个数 } } return pre; }}","link":"/2020/08/LeetCode440%EF%BC%9A%E5%AD%97%E5%85%B8%E5%BA%8F%E7%9A%84%E7%AC%ACK%E5%B0%8F%E6%95%B0%E5%AD%97.html"},{"title":"LeetCode486：预测赢家","text":"题意给定一个表示分数的非负整数数组。 玩家 1 从数组任意一端拿取一个分数，随后玩家 2 继续从剩余数组任意一端拿取分数，然后玩家 1 拿，…… 。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。 给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。 Solution很容易想到递归解决，但显然复杂度太大。所以我们采用记忆化搜索，把已经搜索过的状态记录下来，回溯过程中取最大值。 $dp[l][r]$ 表示在区间 $[l,r]$ 中，能赢过对方的最大分数。 状态转移：$dp[l][r] = max(nums[l] - dp[l + 1][r], nums[r] - dp[l][r - 1])$。 Code123456789101112131415161718class Solution { static int[][] dp = new int[30][30]; public int dfs(int l, int r, int[] nums) { if (dp[l][r] != 0) return dp[l][r]; if (l == r) return dp[l][r] = nums[l]; return dp[l][r] = Math.max(nums[l] - dfs(l + 1, r, nums), nums[r] - dfs(l, r - 1, nums)); } public boolean PredictTheWinner(int[] nums) { int n = nums.length; for (int i = 0; i &lt; nums.length; i++) { Arrays.fill(dp[i], 0); } return dfs(0, n - 1, nums) &gt;= 0; }}","link":"/2020/09/LeetCode486%EF%BC%9A%E9%A2%84%E6%B5%8B%E8%B5%A2%E5%AE%B6.html"},{"title":"LinuxC++网络编程学习笔记","text":"主机字节序和网络字节序字节在内存中的排列影响它实际的值，字节序分为大端序和小端序。大端序指一个整数的高位存储在内存的低地址处，小端序指一个整数的高位存储在内存的高地址处。 现代PC大多采用小端序，因此小端序又被称为主机字节序。 由于数据在两台使用不同字节序的主机之间进行传递是，接收到必然错误的解释了数据。解决的方法是：发送端总是把要发送的数据转化成大端序然后再发送，接受端明白对方传过来的数据总是采用大端序，所以接受端可以根据自身使用的字节序来决定是否对该数据进行转化。因此大端序也称为网络字节序。 Linux提供了四个函数来完成主机字节序和网络字节序之间的转化：12345678#include &lt;netinet/in.h&gt;// 一般用于转换ip地址unsigned long int htonl(unsigned long int hostlong);unsigned long int ntonl(unsigned long int netlong);// 一般用于转换端口unsigned long int htons(unsigned long int hostshort);unsigned long int ntohs(unsigned long int netshort); socket套接字123#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;int socket(int domain, int type, ubt protocol); domain: PF_INET -&gt; IPv4, PF_INET6 -&gt; IPv6, PF_UNIX -&gt; UNIX本地协议族 type: SOCK_STREAM -&gt; TCP协议，SOCK_DGRAM -&gt; UDP协议 protocol: 一般都置位0，表示使用默认协议 调用成功返回一个socket文件描述符，其实就是一个数字，这个数字具有唯一性，并且一直有效直到你close()这个数字为止；失败返回-1并设置errno。 文件描述符：unix哲学——一切皆文件，我们把socket也看成是文件描述符，用它来收发数据。send(), recv()。 一旦连接成功建立，双方的通讯就只需要通过该文件描述符即可。 命名socket创建socket时，指定了地址族，却并未指定该地址族中的哪个具体socket地址。我们称socket与socket地址绑定称为给socket命名。服务端只有命名后，客户端才知道如何连接它。客户端通常不需要命名，采用匿名，操作系统会自动分配给它socket地址。使用的函数为bind()： 1int bind(int sockfd, const struct* my_addr, socklen_t addrlen); sockfd: socket文件描述符 my_addr: 这个地址将分配给未命名的sockfd文件描述符 addrlen: 该socket地址的长度 相同的ip地址的相同端口只能被 bind() 一次，bind成功返回0，失败返回-1并设置errno。 关于bind绑定失败的情况，还需要详谈。。。 监听socketsocket被命名后，还不能被马上接受客户连接，我们需要创建一个监听队列用以存放待处理的客户连接：12#include &lt;sys/socket.h&gt;int listen(int sockfd, int backlog);listen 用于监听端口，作用于TCP连接中的服务端。 对于一个调用listen()进行监听的套接字，操作系统会给这个套接字维护两个队列： 未完成队列：当服务端收到客户端第一次握手发送的SYN包时，就会在未完成队列中创建一个跟该 SYN 包对应的一项新的套接字（通常由(服务器ip + port, 客户端ip +port)组成） 已完成队列：三次握手完成后，连接变为ESTABISHED状态，从未完成队列进入已完成队列 backlog的含义：已完成队列和未完成队列条目之和不能超过backlog。RTT：未完成队列中任意一项在未完成队列中停留的时间，这个时间取决于客户端和服务器。对于客户端，RTT为前两次握手时间；对于服务端，RTT为后两次握手时间。 客户端的Connect()其实在第二次握手结束后已经返回了。 细节： 如果两个队列之和已经达到最大上限，再有客户发送syn请求的话，这个请求会被服务器忽略；而客户端发现syn没有被回应，会重发请求包。 已完成队列中有客户端发来数据，但该套接字还未被accept函数取出，那么这个数据就会被保存在已连接的套接字的接收缓冲区中，接收的数据量取决于缓冲区有多大。 接受连接accept() 函数，从已完成连接队列中的队首取出一项（已经完成三次握手连接的客户端socket值），返回给进程： 1int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); sockfd 是执行过 listen 系统监听调用的 监听socket，只要服务端还在运行，那么它就应该一直存在（我们称已经处于ESTABISHED状态的客户端连接为 连接socket） addr 被用于接收远端 socket 地址，该地址的长度由addrlen指出 如果已完成队列为空，那么则会一直处于休眠等待状态，直到有内容时才唤醒。accept返回的是对应TCP连接的套接字connfd。 如果建立连接后用户掉线，accept依然返回成功，因为它只负责从已完成队列中取出内容。 发起连接客户端需要使用connect函数主动与服务器建立连接：1int socket(int sockfd, const struct sockaddr *serv_addr, socklen_t addrlen);sockfd参数由socket系统调用返回一个socket，serv_addr参数是服务器监听的socket地址，addrlen则指定这个地址的长度。 connect成功时返回0。一旦成功建立连接，sockfd就唯一标识这个连接，客户端就可以通过读写sockfd来与服务器通信。失败返回-1并设置errno，常见的错误有：目的端口不存在，连接超时。 关闭连接关闭连接实际上就是关闭该连接对应的socket：1int close(int fd);fd是待关闭的socket，close并非总是立即关闭一个连接，而是将fd的引用计数减一。当引用计数为0时，才最终关闭连接。在多进程出现在，一次fork会使父进程中打开的socket引用计数加一，因此必须在父进程和子进程中都对该socket执行close才能将连接关闭。 IO操作在Unix中，一切皆文件，文件即是一串二进制流，不论是socket，FIFO，管道，终端，都是文件，对这些流进行数据收发操作即是IO操作。系统调用 read 读入数据，调用 write 写入数据。我们如何知道操作哪个流？文件描述符，即fd，而fd就是一个整数，对这个整数操作即是对文件操作。创建一个socket，返回一个文件描述符，对socket操作即是对这个描述符操作。 阻塞/非阻塞阻塞IO：调用某个函数，该函数卡在这里（进入休眠状态）等待一个事情发生，然后才继续执行，这种函数一般称为阻塞函数。非阻塞IO：充分利用时间片，效率更高。不断的调用accept，recvfrom函数检查有没有数据到来。 同步/异步异步IO：调用一个异步I/O函数，我们要给这个函数指定一个接收缓冲区和一个回调函数。调用后，该函数会立即返回。其余判断交给操作系统，判断数据是否到来，如果到来，操作系统会把数据拷贝到你所指定的缓冲区里，然后调用回调函数通知你。 异步和非阻塞的区别： 非阻塞I/O需要不停调用I/O函数来检查数据是否到来，一旦数据到来，就必须卡在I/O函数里把内核缓冲区复制到用户缓冲区，然后才执行结束 异步I/O只需要调用一次，然后你就可以去做别的事了，内核去帮你判断数据是否到来，最后通知你 同步I/O：select，poll，epoll都可以认为属于同步IO。 首先调用select函数判断有无数据到来，没有则卡在那里 select返回之后，调用recvfrom去取数据，取数据时也会卡一下 同步I/O看起来更麻烦一点，因为要调用两个函数才可以得到数据。但与阻塞式相比，优势在于I/O复用。 I/O复用：又称为I/O多路复用，将多个socket（TCP连接）弄成一堆，select等待这一堆的任何一个TCP连接有数据到来，再用具体的recvfrom去收。 select API1int select(int nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, struct timeval* timeout); nfds 指定被监听文件描述符总数，通常设置为select监听的所有文件描述符中的最大值加1，因为文件描述符是从0开始计数的。 epoll技术从Linux内核2.6开始引入，是一种典型的I/O多路复用技术，最大的特点就是支持高并发，完全没有会随着并发量提高而出现性能明显下降的情况，但是会造成一定内存消耗。 与select，poll不同的是，它使用一组函数来完成任务。epoll 把用户关心的都文件描述符上的事件放在内核的一个事件表中，无需每次调用都要重复传入描述符，因此epoll需要一个额外的文件描述符，来唯一标示内核中的这个事件表，使用 epoll_create 来创建该文件描述符：1int epoll_create(int size): size参数只是告诉内核事件表需要多大，还并不起作用。返回的文件描述符讲称为其它所有epoll系统调用函数的第一个参数，以指定要访问的内核事件表。 具体：创建一个eventpoll结构体对象，创建了一棵红黑树和一个双向链表，其中rbr指向该红黑树的根，rdlist指向该双向链表的头节点 使用 epoll_ctl 来操作内核事件表：1int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);event 指定事件信息，fd为要操作的文件描述符(accept得到)，op指定操作类型： ADD，往事件表中注册fd上的事件，相当于向红黑树添加一个节点，key值为客户端连接产生的fd，如果已经存在该节点，则直接报错 MOD，修改fd上的注册事件，修改某个节点 DEL，删除fd上的注册事件，删除某个节点 因此，红黑树上的节点来自于 epoll_ctl 操作。 当事件发生时，我们需要通过 epoll_wait 函数来得到操作系统的通知。1int epoll_wait(int epfd, struct epoll_event* events, int maxevents, int timeout);双向链表中存放的是所有有事件/数据的请求，epoll_wait 遍历双向链表，把双向链表里面的数据拷贝出去，然后移除。 需要注意的是，在红黑树中的节点并不会被删除。实际上用的是一个结构体同时维护了红黑树和双向链表的节点内容：红黑树拥有指向父节点，子节点的指针，双向链表拥有指向上一个和下一个结点的指针。这种优秀的设计使得在删除双向链表的结点时并不会对红黑树产生影响，而是相互独立的，但维护的时候又可以一起维护，使得一个节点既可以作为红黑树节点，也可以作为双向链表节点，从而大大减少了内存浪费。 epfd 为 epoll_create 返回的对象描述符 events指向一个数组，最大长度为 maxevents，表示此次 epoll_wait 调用最多可以收集到 maxevents 个（双向链表中）已经准备好的读写事件。 什么时候内核会向双向链表中增加节点呢？ 客户端完成三次握手 ——&gt; 服务器需要accept() 当客户端关闭连接 ——&gt; 服务器也要调用close()关闭 客户端发送数据来 ——&gt; 服务器需要调用read(),recv()函数来收数据 当可以发送数据时 ——&gt; 服务器调用send(),write() LT 和 ET 模式epoll对文件描述符的操作有两种模式：LT：水平触发，低速效率较低，默认模式，如果这个事件没有被处理完，就会被一直触发ET：边沿触发，高速模式，效率高，只会被触发一次，但代价是编码难度加大 为什么ET模式事件只触发一次：ET模式事件只会被扔到双向链表一次，被 epoll_wait 取出后销毁。 为什么LT模式事件会触发多次：如果事件没有处理完，就会被多次扔进双向链表。 如果收发数据包没有具体格式，可以考虑用ET模式。 TCP粘包，缺包客户端粘包：短时间内多次send，客户端有 Nagle 优化算法，直接合并成一个数据包发送出去，导致粘包。因此只要关闭 Nagle 算法，就能解决客户端粘包问题。 服务端粘包：无论客户端是否粘包，都避免不了服务端都会粘包。两次recv之间需要时间，但如果这个时间内多个包来了，则这多个包可能就被第二次recv全部收走，导致一次recv就收走了所有的包。 解决粘包：把几个包一个一个拆出来，能拆一个是一个。如何拆包？每一个收发的数据包都遵循包头+包体的格式，包头固定【10个字节】，其中有一个变量记录整个包【包头+包体】的长度。这样就知道了包体的长度，然后只收包体长度一样多的字节即可。这样就收到一个完整的数据包。","link":"/2021/02/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"},{"title":"MySQL基础","text":"","link":"/2020/09/MySQL%E5%9F%BA%E7%A1%80.html"},{"title":"RMQ算法原理及实现","text":"RMQ（Range Minimum/Maximum Query），区间最值查询问题，是指：对于长度为 $n$ 的数列A，回答若干次询问 $RMQ(i,j)$，返回数列A中下标在区间 $[i,j]$ 中的最小/大值。 这里介绍Tarjan的Sparse-Table算法，预处理时间为 $O(nlogn)$，但查询只需要 $O(1)$，并且常数很小，算法也很容易写出。 1）预处理： 设 $A[i]$ 是要求区间最值的数列，$d[i, j]$ 表示从第i个数起连续 $2^j$ 个数中的最小值。(DP的状态) 显然 $d[i][0]$ 的值就是 $A[i]$ (DP初值)，我们把 $d[i，j]$ 平均分成两段(因为 $d[i，j]$ 一定是偶数个数字)，从 $i$ 到 $i + 2 ^ (j - 1) - 1$ 为一段，$i + 2 ^ (j - 1)$ 到 $i + 2 ^ j - 1$ 为一段(长度都为 $2 ^ (j - 1)$)。于是我们得到了状态转移方程 $d[i, j] = min(d[i，j-1], d[i + 2^(j-1)，j-1])$ Code123456void RMQ() { for (int i = 0; i &lt; n; ++i) d[i][0] = a[i]; for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j) for (int i = 0; i + (1 &lt;&lt; j) - 1 &lt; n; ++i) d[i][j] = min(d[i][j - 1], d[i + (1 &lt;&lt; (j - 1))][j - 1]);} 2）查询： 假如我们需要查询的区间为 $(i,j)$ ，那么我们需要找到覆盖这个闭区间(左边界取 $i$，右边界取 $j$)的最小幂（可以重复，比如查询1，2，3，4，5，5不是2的任意次方，但我们可以查询1234和2345）。 这个查询长度我们取范围小于等于区间长度的最大 $(2^k)$，这样我们查询 $i$ 到 $i + (2^k)$ 与 $j - (2^k) + 1$ 到 $j$ 的值，取二者最小值即可，代码实现如下： 12345int query(int L, int R) { int k = 0; while ((1 &lt;&lt; (k + 1)) &lt;= R - L + 1) ++k; return min(d[L][k], d[R - (1 &lt;&lt; k) + 1][k]);}","link":"/2020/10/RMQ%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0.html"},{"title":"Vim配置","text":"写C++还是用vim爽啊，曾经三次尝试vim，寒假的时候终于能得到一份比较不错的配置了。 配色用的是atom的onedark，个人感觉挺好看的。 贴个配置，即开即用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253&quot; Vundle set nocompatiblefiletype offset rtp+=~/.vim/bundle/Vundle.vimcall vundle#begin()Plugin 'VundleVim/Vundle.vim'Plugin 'gdbmgr'Plugin 'The-NERD-Tree' &quot; 目录树Plugin 'mbbill/undotree' &quot; 撤回树Plugin 'majutsushi/tagbar' &quot; 函数、变量名Plugin 'vim-airline/vim-airline' &quot; 状态栏Plugin 'vim-airline/vim-airline-themes' &quot;状态栏Plugin 'arzg/vim-colors-xcode' &quot; xcode 主题&quot;Plugin 'cohlin/vim-colorschemes' &quot; xcode 主题Plugin 'tomasr/molokai' &quot; molokai 主题Plugin 'ashfinal/vim-colors-violet' &quot; violet 主题Plugin 'joshdick/onedark.vim' &quot; onedark主题Plugin 'sheerun/vim-polyglot' &quot; 语法突出显示Plugin 'jiangmiao/auto-pairs' &quot; 括号补全Plugin 'iamcco/mathjax-support-for-mkdp' &quot; 数学公式Plugin 'plasticboy/vim-markdown' &quot; markdown预览Plugin 'iamcco/markdown-preview.vim' &quot; markdown预览Plugin 'Valloric/YouCompleteMe' &quot; 代码补全Plugin 'zxqfl/tabnine-vim' &quot;代码补全Plugin 'tpope/vim-commentary' &quot; 代码注释Plugin 'sillybun/vim-repl' &quot; 代码调试Plugin 'w0rp/ale' &quot; 语法纠错&quot;Plugin 'octol/vim-cpp-enhanced-highlight' &quot; c++语法高亮Plugin 'TagHighlight' &quot; c++语法高亮Plugin 'Shougo/echodoc.vim' &quot; c++函数提示Plugin 'rhysd/vim-clang-format' &quot; 代码格式化Plugin 'Chiel92/vim-autoformat' &quot; c++代码格式化Plugin 'scrooloose/nerdcommenter' &quot; c++代码注释Plugin 'artur-shaik/vim-javacomplete2' &quot; java代码补全Plugin 'python-mode/python-mode' &quot; python modePlugin 'fatih/vim-go' &quot; go语言Plugin 'terryma/vim-multiple-cursors' &quot; vim 多行编辑Plugin 'mhinz/vim-startify' &quot; 欢迎界面call vundle#end()filetype plugin indent onset backspace=2&quot; javacomplete2&quot; https://github.com/artur-shaik/vim-javacomplete2autocmd FileType java setlocal omnifunc=javacomplete#Complete&quot; TagHighlight&quot; UpdateTypesFile&quot; multiple cursors&quot;start: &lt;C-n&gt; start multicursor and add a virtual cursor + selection on the match&quot;next: &lt;C-n&gt; add a new virtual cursor + selection on the next match&quot;skip: &lt;C-x&gt; skip the next match&quot;prev: &lt;C-p&gt; remove current virtual cursor + selection and go back on previous match&quot;select all: &lt;A-n&gt; start multicursor and directly select all matches&quot;&quot; plugin nerdcommenterlet mapleader = &quot;,&quot;let NERDSpaceDelims=1 &quot; 让注释符与语句之间留一个空格let g:NERDDefaultAlign = 'left' &quot;将行注释符左对齐&quot; auto save&quot; let g:auto_save = 5 &quot; enable AutoSave on Vim startup&quot; plugin undotree&quot; :UndotreeToggle&quot; plugin NERDTree&quot; :NERDTreeToggle&quot; plugin tarbar&quot; :TagbarToggle&quot;&quot; plugin autoformat&quot; :Autoformatlet g:autoformat_verbosemode=1 &quot;开启详细模式便于查错&quot; c++let g:formatdef_clangformat_google = '&quot;clang-format -style google -&quot;'let g:formatters_cpp = ['clangformat_google']&quot; pythonlet g:formatdef_autopep8 = &quot;'autopep8 - --range '.a:firstline.' '.a:lastline&quot;let g:formatters_python = ['autopep8']&quot; javalet g:formatdef_astyle_java = '&quot;astyle --mode=java --style=google -pcHs2&quot;'let g:formatdef_java = ['astyle_java']&quot; plugin echodoclet g:echodoc#type = &quot;echo&quot; &quot; Default valueset noshowmodelet g:echodoc_enable_at_startup = 1&quot; plugin YCM&quot;let g:ycm_global_ycm_extra_conf='~/.ycm_extra_conf.py'&quot;set completeopt=menu&quot; YouCompleteMeset runtimepath+=~/.vim/bundle/YouCompleteMeset completeopt=longest,menu &quot;让Vim的补全菜单行为与一般IDE一致(参考VimTip1228)let g:ycm_collect_identifiers_from_tags_files = 1 &quot; 开启 YCM 基于标签引擎let g:ycm_collect_identifiers_from_comments_and_strings = 1 &quot; 注释与字符串中的内容也用于补全let g:syntastic_ignore_files=[&quot;.*\\.py$&quot;]let g:ycm_seed_identifiers_with_syntax = 1 &quot; 语法关键字补全let g:ycm_complete_in_comments = 1let g:ycm_confirm_extra_conf = 0let g:ycm_key_list_select_completion = ['&lt;c-n&gt;', '&lt;Down&gt;'] &quot; 映射按键, 没有这个会拦截掉tab, 导致其他插件的tab不能用.let g:ycm_key_list_previous_completion = ['&lt;c-p&gt;', '&lt;Up&gt;']let g:ycm_complete_in_comments = 1 &quot; 在注释输入中也能补全let g:ycm_complete_in_strings = 1 &quot; 在字符串输入中也能补全let g:ycm_collect_identifiers_from_comments_and_strings = 1 &quot; 注释和字符串中的文字也会被收入补全let g:ycm_global_ycm_extra_conf='~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py'let g:ycm_show_diagnostics_ui = 0 &quot; 禁用语法检查&quot; 回车即选中当前项inoremap &lt;expr&gt; &lt;CR&gt; pumvisible() ? &quot;\\&lt;C-y&gt;&quot; : &quot;\\&lt;CR&gt;&quot; |&quot; 跳转到定义处nnoremap &lt;c-j&gt; :YcmCompleter GoToDefinitionElseDeclaration&lt;CR&gt;|let g:ycm_min_num_of_chars_for_completion=2 &quot; 从第2个键入字符就开始罗列匹配项&quot;disable ycm 语法检查let g:ycm_enable_diagnostic_signs = 0let g:ycm_enable_diagnostic_highlighting = 0let g:ycm_error_symbol = 'K'let g:ycm_warning_symbol = 'O'&quot; plugin vim-markdown 自动折叠关闭let g:vim_markdown_folding_disabled=1&quot;auto-format 格式化&quot;F5自动格式化代码并保存&quot;自动格式化代码，针对所有支持的文件&quot;au BufWrite * :Autoformat&quot;自动格式化python代码&quot;au BufWrite *.py :Autoformatet g:autoformat_verbosemode=1&quot;默认情况下是pep8，还可以选择google,facebook和chromium&quot;let g:formatter_yapf_style = 'google'&quot;let g:formatdef_my_cpp = '&quot;astyle --style=webkit&quot;'&quot;let g:formatters_cpp = ['my_cpp']&quot;au BufWrite * :Autoformat&quot; 代码调试快捷键autocmd Filetype python nnoremap &lt;F12&gt; &lt;Esc&gt;:REPLDebugStopAtCurrentLine&lt;Cr&gt;autocmd Filetype python nnoremap &lt;F10&gt; &lt;Esc&gt;:REPLPDBN&lt;Cr&gt;autocmd Filetype python nnoremap &lt;F11&gt; &lt;Esc&gt;:REPLPDBS&lt;Cr&gt;&quot; Let clangd fully control code completionlet g:ycm_clangd_uses_ycmd_caching = 0&quot; Use installed clangd, not YCM-bundled clangd which doesn't get updates.let g:ycm_clangd_binary_path = exepath(&quot;clangd&quot;)&quot;目录树map &lt;F2&gt; :NERDTreeToggle&lt;CR&gt;&quot;Python缩进autocmd FileType python set tabstop=4 | set expandtab | set autoindent&quot; plugin airlineset laststatus=2&quot; plugin alelet g:ale_linters = { \\ 'cpp': ['gcc'], \\}&quot;始终开启标志列let g:ale_sign_column_always = 1let g:ale_set_highlights = 0let g:ale_echo_msg_format = 'ale[%linter%] %code: %%s'let g:ale_cpp_gcc_executable = '/usr/local/bin/g++-9 -I /usr/local/Cellar/eigen/3.3.7/include/eigen3'let g:ale_sign_error = '✗'let g:ale_sign_warning = '⚡'let g:ale_lint_on_text_changed = 'always'&quot; 语法高亮let c_no_curly_error = 1let g:cpp_class_scope_highlight = 1let g:cpp_member_variable_highlight = 1let g:cpp_class_decl_highlight = 1let g:cpp_experimental_simple_template_highlight = 1let g:cpp_experimental_template_highlight = 1let g:cpp_concepts_highlight = 1&quot;let g:cpp_no_function_highlight=1syntax on&quot; 主题&quot;colorscheme xcode-default&quot;colorscheme molokai&quot;colorscheme violetcolorscheme onedarklet g:rehash256 = 1set cursorline &quot;or set cul 设置光标所在的行set et &quot;tab用空格替换set tabstop=2set expandtab&quot; Tab键的宽度set softtabstop=2set shiftwidth=2&quot; 统一缩进为2set number&quot; 显示行号set history=10000&quot; 历史纪录数set hlsearchset incsearch&quot; 搜索逐字符高亮set encoding=utf-8set fileencodings=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936,utf-16,big5,euc-jp,latin1&quot; 编码设置&quot; set mouse=a&quot; use mouseset langmenu=zn_CN.UTF-8set helplang=cn&quot; 语言设置set laststatus=2&quot; 总是显示状态行 就是那些显示 --insert-- 的怪东西set showcmd&quot; 在状态行显示目前所执行的命令，未完成的指令片段亦会显示出来set scrolloff=3&quot; 光标移动到buffer的顶部和底部时保持3行距离set showmatch&quot; 高亮显示对应的括号set matchtime=1&quot; 对应括号高亮的时间（单位是十分之一秒）&quot; 共享剪切板set clipboard=unnamedset norelativenumberlet &amp;t_SI.=&quot;\\e[5 q&quot; &quot;SI = INSERT modelet &amp;t_SR.=&quot;\\e[4 q&quot; &quot;SR = REPLACE modelet &amp;t_EI.=&quot;\\e[1 q&quot; &quot;EI = NORMAL mode (ELSE)let g:syntastic_cpp_compiler_options = ' -std=c++11 -stdlib=libc++'&quot; c++ 路径set path=.,/usr/local/bin/g++-9,/usr/local/include/c++/9.3.0,/usr/local/Cellar/eigen/3.3.7/include/eigen3,/usr/local/Cellar/boost/1.72.0/include,/usr/local/Cellar/gcc/9.2.0_1/include/c++/9.2.0,/usr/local/Cellar/gcc/9.2.0_1/include/c++/9.2.0/x86_64-apple-darwin19,/usr/local/Cellar/gcc/9.2.0_1/include/c++/9.2.0/backward,/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin19/9.2.0/include,/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin19/9.2.0/include-fixed,/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include,/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/System/Library/Frameworks,","link":"/2020/08/Vim%E9%85%8D%E7%BD%AE.html"},{"title":"二维差分","text":"原理 紫色部分为所求区域，黄色区域为当前覆盖的区域。 $d[x1][y1] += w$ 表示将 $[x1, y1]$ 右下部分全部加上增量 $w$。 $d[x1][y2 + 1] -= w$ 用于抵消对 $y2$ 右边元素的影响，即图三蓝色区域。 $d[x2 + 1][y1] -= w$ 用于抵消对 $x2$ 下边元素的影响，即图四蓝色区域。 $d[x2 + 1][y2 + 1] += w$ 由于绿色区域被抵消了两次，因此需要加回增量 $w$。 Code12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;int a[1005][1005], d[1005][1005];int main() { int n, m, q, x1, y1, x2, y2, w; cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) cin &gt;&gt; a[i][j]; while (q--) { cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; w; d[x1][y1] += w; d[x1][y2 + 1] -= w; d[x2 + 1][y1] -= w; d[x2 + 1][y2 + 1] += w; } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { d[i][j] -= d[i - 1][j - 1] - d[i - 1][j] - d[i][j - 1]; a[i][j] += d[i][j]; printf(&quot;%d &quot;, a[i][j]); } printf(&quot;\\n&quot;); } return 0;}","link":"/2020/10/%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86.html"},{"title":"函数间参数的传递方式","text":"1. 值传递：将主调函数的实参值传递给被调函数的形参，形参单独分配内存。 单向数据传递机制：传递的只是实参的值，形参的改变不影响实参。 1234567891011121314#include&lt;iostream&gt;using namespace std;void swap (int a, int b) {//实现形参a、b的交换 int c; c = a; a = b; b = c;}int main() { int x = 2, y = 3; swap(x, y);//实参x,y的值并没有交换。值传递的单向数据传递机制 cout &lt;&lt; x&lt;&lt; &quot; &quot;&lt;&lt;y&lt;&lt; endl;//2 3 return 0;} 2. 引用传递：被调用的形参引用主调函数的实参，实现间接访问。 双向数据传递机制：通过引用&amp;，指向同一内存，其一改变，二者都改变。 1234567891011121314#include&lt;iostream&gt;using namespace std;void swap (int &amp;a, int &amp;b) {//引用变量a、b，等效int &amp;a=x;int &amp;b=y; int c; c = a; a = b; b = c;}int main() { int x = 2, y = 3; swap(x, y);//实参x,y的值被交换。a与x，b与y指向同一内存，其一改变，两者都变 cout &lt;&lt; x&lt;&lt; &quot;和&quot;&lt;&lt;y&lt;&lt; endl;//3和2 return 0;} PS：关于直接和间接访问： 按照C语言的方式，定义一个变量，系统会自动为该变量分配内存，变量有两个属性：变量值和变量地址。变量地址指示该变量在内存中的存储位置，变量值为该内存中的存储内容。 直接访问：直接使用变量名访问内存空间上的内容。 间接访问：先从其它内存空间获得要访问的内存地址（指针），根据地址访问对应内存中的数据。 3. 指针传递：被调函数的形参接收主调函数实参的内存地址，间接访问。1234567891011121314#include&lt;iostream&gt;using namespace std;void swap (int *a, int *b) {//引用变量a、b，等效int *a=&amp;x;int *b=&amp;y; int c; c = *a; *a = *b; *b = c;}int main() { int x = 2, y = 3; swap(&amp;x, &amp;y);//实参x,y的值被交换。实参地址传递给指针类型的形参 cout &lt;&lt; x&lt;&lt; &quot;和&quot;&lt;&lt;y&lt;&lt; endl;//3和2 return 0;}","link":"/2020/04/%E5%87%BD%E6%95%B0%E9%97%B4%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F.html"},{"title":"回文相关算法总结及简单变形","text":"求最长回文串解法一：中心扩散法过于傻逼，就是枚举中心点向两边拓展长度直到不相等。（时间复杂度 $O(n^2)$，空间复杂度 $O(1)$） Code 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;string s;int check(int pos, int type) { int now, x, y; if (type) now = 0, x = pos, y = pos + 1; else now = 1, x = pos - 1, y = pos + 1; while (1) { if (x &gt;= 0 &amp;&amp; y &lt; s.size() &amp;&amp; s[x] == s[y]) now += 2; else break; x--, y++; } return now;}int main() { while (cin &gt;&gt; s) { int res = 1; for (int i = 1; i &lt; s.size() - 1; i++) res = max(res, max(check(i, 0), check(i, 1))); cout &lt;&lt; res &lt;&lt; '\\n'; } return 0;} 解法二：动态规划$dp[i][j] = 0/1 $ 表示子串 $i~j$ 是否为回文串。 那么，容易得到：$dp[i][j] = (dp[i+1][j-1]$ &amp;&amp; $s[i]==s[j])$。 由于 $i$ 是由 $i+1$ 转移过来的，所以我们需要倒着遍历： Code1234567for (int i = s.size() - 1; i &gt;= 0; i--) for (int j = i; j &lt; s.size(); j++) { if (s[i] == s[j] &amp;&amp; (j - i &lt; 2 || dp[i + 1][j - 1])) { dp[i][j] = true; res = max(res, j - i + 1); } } 时间复杂度 $O(n^2)$，空间复杂度 $O(n^2)$ 解法三：manacherCode12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;const int N = 2e6 + 5;int p[N];char s[N], t[N];int manacher(){ int l = 0; t[l++] = '$'; t[l++] = '#'; for (int i = 0; s[i]; i++) { t[l++] = s[i]; t[l++] = '#'; } t[l++] = '@'; int id = 0, mx = 0, index = 0, maxlength = -1; for (int i = 1; i &lt; l; i++) { p[i] = mx &gt; i ? min(p[2 * id - i], mx - i) : 1; /// 向左右两边延伸，扩展右边界 while (t[i + p[i]] == t[i - p[i]]) p[i]++; /// 如果回文子串的右边界超过了mx，则需要更新mx和id的值 if (i + p[i] &gt; mx) { mx = i + p[i]; id = i; } /// 如果回文子串的长度大于maxLength，则更新maxLength和index的值 if (maxlength &lt; p[i] - 1) { maxlength = p[i] - 1; index = i; } } int start = (index - maxlength) / 2; /// 记录起始位置 return maxlength;}int main(){ while (~scanf(&quot;%s&quot;, s)) printf(&quot;%d\\n&quot;, manacher()); return 0;} 变形1求最长回文子序列solution 状态 $f[i][j]$ 表示 $s$ 的第 $i$ 个字符到第 $j$ 个字符组成的子串中，最长的回文序列长度是多少。 转移方程 如果 $s$ 的第 $i$ 个字符和第 $j$ 个字符相同的话 $f[i][j] = f[i + 1][j - 1] + 2$ 如果 $s$ 的第 $i$ 个字符和第 $j$ 个字符不同的话 $f[i][j] = max(f[i + 1][j], f[i][j - 1])$ 然后注意遍历顺序，$i$ 从最后一个字符开始往前遍历，$j$ 从 $i + 1$ 开始往后遍历，这样可以保证每个子问题都已经算好了。 初始化$f[i][i] = 1$ 单个字符的最长回文序列是 $1$ 结果$f[0][n - 1]$ Code12345678910for(int i = n - 1; i &gt;= 0; i--) { dp[i][i] = 1; for(int j = i + 1; j &lt; n; j++) { if(s[i] == s[j]) dp[i][j] = dp[i + 1][j - 1] + 2; else dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]); }}return dp[0][n - 1]; 变形2插入最少的字符，使得字符串变成回文串。solution很直观的，答案就是原长度-最长回文子序列。考虑另一种区间dp的做法： 既然是区间dp，那么就是由小区间得到大区间，故最外层从小到大枚举长度，然后枚举左右端点。 $dp[i][j] = min(dp[i + 1][j] + 1, dp[i][j - 1] + 1)$ $s[i] != s[j]$ $dp[i][j] = min(dp[i + 1][j] + 1, dp[i][j - 1] + 1, dp[i + 1][j - 1])$ $s[i] == s[j]$ Code123456789for (int len = 2; len &lt;= n; len++) { for (int l = 0; l &lt;= n - len; l++) { int r = l + len - 1; dp[l][r] = min(dp[l + 1][r], dp[l][r - 1]) + 1; if (s[l] == s[r]) dp[l][r] = min(dp[l][r], dp[l + 1][r - 1]); } } return dp[0][n - 1];","link":"/2020/04/%E5%9B%9E%E6%96%87%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E5%8F%8A%E7%AE%80%E5%8D%95%E5%8F%98%E5%BD%A2.html"},{"title":"堆，栈与内存管理","text":"stack &amp;&amp; heapstack，由操作系统自动分配释放，是存在于某作用域的一块内存空间。例如当你调用函数，函数本身即会形成一个stack用来放置它所接收的参数，以及返回地址。函数本体中声明的任何变量，所使用的内存块都取自上述stack。 heap，是指由操作系统提供的一块 global 内存空间，程序可动态分配从中获得的若干区块，由开发人员分配和释放，若开发人员不释放，程序结束时由 OS 回收，分配方式类似于链表 1234567891011Complex c3(1,2); // 全局对象，其生命周期在整个程序结束之后才结束。（可视为 static 对象，作用域是整个程序）&lt;!--more--&gt; { Complex c1(1,2); // 栈中创建对象 static Complex c2(1, 2); // static 静态对象，其生命在作用域结束之后仍然存在，直到整个程序结束 // 堆中创建对象 Complex* p = new Complex(3); delete p; // 否则会发生内存泄漏，因为当作用域结束，p 所指的对象仍然存在，但指针 p 的生命结束了，也就不可能再有机会 delete p; } new 关键字new：先分配内存，再调用构造函数。 1234567Complex* pc = new Complex(1, 2);/* 编译器转换为： void* mem = operator new ( sizeof(Complex) ); // 分配内存，operator new 只是一个函数名，内部调用 malloc(n) pc = static_cast&lt;Complex*&gt;(mem); // 转型 pc-&gt;Complex::Complex(1, 2); // 构造函数*/ delete 关键字 delete：先调用析构函数，再释放内存。 12345678910111213String* ps = new String(&quot;Hello&quot;);...delete(ps);/* 编译器转化为 String::~String(ps); // 析构函数 operator delete(ps); // 释放内存，内部调用 free(ps)*/String* p = new String[3];...// delete[] p; // 调用三次析构函数// delete p; // 调用一次析构，导致只回收了对象p[0]对应的内存，但p[1]和p[2]对应的内存没有被清空，这两块发生了内存泄漏。 实例123456789101112131415161718192021222324252627282930313233343536373839404142class String { public: String(const char* cstr = 0); // 构造函数 String(const String&amp; str); // 拷贝构造 String&amp; operator=(const String&amp; str); // 拷贝赋值 ~String(); // 析构函数 char* get_c_str() const { return m_data; } // 获得字符串 private: char* m_data;};inlineString::String(const char* cstr) { if (cstr) { m_data = new char[strlen(cstr) + 1]; strcpy(m_data, cstr); } else { m_data = new char[1]; *m_data = '\\0'; }}inlineString::String(const String&amp; str) { m_data = new char[strlen(str.m_data) + 1]; strcpy(m_data, str.m_data);}inline String&amp; String::operator=(const String&amp; str) { if (this == &amp;str) return *this; delete[] m_data; m_data = new char[strlen(str.m_data) + 1]; strcpy(m_data, str.m_data); return *this; }inlineString::~String() { delete[] m_data; }","link":"/2020/05/%E5%A0%86%EF%BC%8C%E6%A0%88%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"},{"title":"存在负数的背包问题","text":"题目1体积和价值可能为负数的01背包。 Solution逆向思维，对于体积为负的物品，我们可以一开始就装进去，背包对应的进行扩容，物品的体积和价值也对应取反。这样在进行背包dp 的时候就代表移除这个物品，答案取最大值即可。 Code1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 410;int c[N], v[N], ans;int dp[40010];int main() { int N, M; scanf(&quot;%d%d&quot;, &amp;N, &amp;M); for (int i = 1; i &lt;= N; i++) { scanf(&quot;%d%d&quot;, &amp;c[i], &amp;v[i]); if (c[i] &lt;= 0) { ans += v[i]; M -= c[i]; c[i] = -c[i]; v[i] = -v[i]; } } for (int i = 1; i &lt;= N; i++) for (int j = M; j &gt;= c[i]; j--) dp[j] = max(dp[j], dp[j - c[i]] + v[i]); for (int i = 0; i &lt;= M; i++) { dp[M] = max(dp[M], dp[i]); } printf(&quot;%d\\n&quot;, ans + dp[M]); return 0;} 题目2体积和价值可能为负数且要求所取的物品体积之和和价值之和都大于0的条件下，两者总和最大的01背包。$(n = 100, -1000&lt;=v,w&lt;=1000)$ Solution由于体积可能为负，因此需要负数转化为正数，以 $100000$ 为分界线划分为左边代表正数，右边代表负数做背包dp即可，当体积为负时，转移是由大的容量转移过来，需要从小到大遍历。最后取分界线右侧且dp值大于 0 的体积加价值最大值即可。 Code1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;const int m = 2e5 + 5;int n, x, y, res, dp[m];int main() { cin &gt;&gt; n; for (int i = 0; i &lt; m; i++) dp[i] = -m; dp[100000] = 0; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; x &gt;&gt; y; if (x &gt;= 0) { for (int j = m - 1; j &gt;= x; j--) { if (dp[j - x] != -m) dp[j] = max(dp[j], dp[j - x] + y); } } else { for (int j = 0; j &lt; m + x; j++) { if (dp[j - x] != -m) dp[j] = max(dp[j], dp[j - x] + y); } } } for (int i = 100000; i &lt; m; i++) { if (dp[i] &gt; 0) res = max(res, dp[i] + i - 100000); } cout &lt;&lt; res &lt;&lt; endl; return 0;}","link":"/2020/09/%E5%AD%98%E5%9C%A8%E8%B4%9F%E6%95%B0%E7%9A%84%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98.html"},{"title":"实现kth_element","text":"快排的思想，选定一个基准数，将大于 $mid$ 的数放到右边，小于的放到左边，然后比较 $mid$ 和 $k$ 的位置，递归重复操作即可。 12345678910111213141516171819202122232425262728293031323334353637383940#pragma GCC optimize(&quot;Ofast&quot;)#include &lt;cstdio&gt;inline int read() {&lt;!--more--&gt; int x = 0, w = 1; char c = getchar(); while (c &lt; '0' || c &gt; '9') { if (c == '-') w ^= 1; c = getchar(); } while (c &lt;= '9' &amp;&amp; c &gt;= '0') { x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - '0'; c = getchar(); } return w &amp; 1 ? x : -x;}int kth_element(int* a, int l, int r, int k) { int mid = l - 1; for (int i = l; i &lt; r; ++i) { if (a[i] &lt; a[r] &amp;&amp; a[i] ^ a[++mid]) a[i] ^= a[mid] ^= a[i] ^= a[mid]; } if (a[++mid] ^ a[r]) a[mid] ^= a[r] ^= a[mid] ^= a[r]; if (mid == k) return a[mid]; return (mid &gt;= k) ? kth_element(a, l, mid - 1, k) : kth_element(a, mid + 1, r, k);}int a[2000006];int main() { int n, k; n = read(); k = read(); for (int i = 0; i &lt; n; ++i) a[i] = read(); // random_shuffle(a, a + n); printf(&quot;%d\\n&quot;, kth_element(a, 0, n - 1, n - k)); return 0;}","link":"/2020/08/%E5%AE%9E%E7%8E%B0kth-element.html"},{"title":"并查集拓展","text":"边带权银河英雄传说有 $T$ 条指令，每条指令格式为以下两种之一： $M-i-j$，表示让第 $i$ 号战舰所在列的全部战舰保持原有顺序，接在第 $j$ 号战舰所在列的尾部。 $C-i-j$，表示询问第 $i$ 号战舰与第 $j$ 号战舰当前是否处于同一列中，如果在同一列中，它们之间间隔了多少艘战舰。 数据范围：$N≤30000, T≤500000$ Solution维护数组 $dp$ 表示 $i$ 到 $root$ 的距离，那么查询的答案便是 $abs(dp[a] - dp[b]) - 1$。 当 $a$ 向 $b$ 连一条边时，有 $fa[a] = b$，此时根结点 $a$ 的深度会增加 $b$ 的集合大小，因此我们需要一个 $sz$ 数组维护集合大小。 同时在进行路径压缩时，对于未更新的结点也要一同更新深度。 Code1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6 + 5;int dp[N], sz[N], fa[N];int find (int x) { if (x != fa[x]) { int root = find(fa[x]); dp[x] += dp[fa[x]]; fa[x] = root; } return fa[x];}int main(){ int t, a, b; string s; cin &gt;&gt; t; for (int i = 1; i &lt;= 30000; i++) { dp[i] = 0; sz[i] = 1; fa[i] = i; } while (t--) { cin &gt;&gt; s &gt;&gt; a &gt;&gt; b; int pa = find(a), pb = find(b); if (s == &quot;M&quot;) { if (pa != pb) { fa[pa] = pb; dp[pa] = sz[pb]; sz[pb] += sz[pa]; } } else { if (pa != pb) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; max(abs(dp[a] - dp[b]) - 1, 0) &lt;&lt; endl; } } return 0;} 拓展域食物链动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。 $1-X-Y$，表示 $X$ 和 $Y$ 是同类。 $2-X-Y$，表示 $X$ 吃 $Y$。 判断有多少句假话。$(1≤N≤50000,0≤K≤100000)$ Solution$1-n$ 表示动物 $i$ 的同类，$n+1-2n$ 表示动物 $i$ 的猎物，$2n+1 - 3n$ 表示动物 $i$ 的天敌。 对于操作1: 查询 $x$ 和 $y$ 的天敌域，猎物域是不是在一个集合，是则累加答案，否则进行合并。 对于操作2: 查询 $x$ 和 $y$ 的同类域，猎物域是不是在一个集合，是则累加答案，否则进行合并。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;int fa[1000005];int find (int x) { if (x != fa[x]) fa[x] = find(fa[x]); return fa[x];}void join (int a, int b) { a = find(a), b = find(b); if (a != b) fa[a] = b;}int main(){ int n, k, a, b, c, res = 0; cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n * 3; i++) fa[i] = i; while (k--) { cin &gt;&gt; c &gt;&gt; a &gt;&gt; b; if (a &gt; n || b &gt; n) { res++; continue; } if (c == 1) { if (find(a) == find(b + n) || find(a) == find(b + 2 * n)) { res++; continue; } else { /// a和b是同类，a和b的猎物也是同类，a和b的天敌也是同类 join(a, b); join(a + n, b + n); join(a + 2 * n, b + 2 * n); } } else { if (a == b || find(a) == find(b) || find(a) == find(b + n)) { res++; continue; } else { /// a的猎物是b， b的天敌是a，b的猎物是a的天敌 join(a, b + 2 * n); join(a + n, b); join(a + 2 * n, b + n); } } } cout &lt;&lt; res &lt;&lt; endl; return 0;} 奇偶游戏给你 $m$ 个询问，每一个询问给出一个区间的左右端点和区间中的 $1$ 的数量的奇偶性，输出不出现矛盾的最大的 $k$ 值，即 $1-k$ 无矛盾，$1- k + 1$ 矛盾。$(N≤10^9,M≤10000)$ Solution1（边带权） 我们可以用 $sum$ 数组表示序列 S 的前缀和,那么会得到以下性质. $s[l~r]$ 有偶数个 $1$，等价于 $sum[l-1]$ 与 $sum[r]$ 奇偶性相同 $(1+0=1,0+0=0,1是奇数,0是偶数)$$s[l~r]$ 有奇数个 $1$，等价于 $sum[l-1]$ 与 $sum[r]$ 奇偶性不同 $(1+1=0,0+1=0,1是奇数,0是偶数)$ 根据传递性，可以使用边带权，边权 $d[x] = 0$，表示 $x$ 与 $f[x]$ 的奇偶性相同; 为 $1$，表示 $x$ 与 $fa[x]$ 的奇偶性不同,在路径压缩的过程中,对 $x$ 到树根路径的所有边权做异或$(xor)$。 对于每个问题, 设离散化后 $l - 1$ 和 $r$ 的值分别是 $x$ 和 $y$ , 设 $c$ 表示当前问题的回答($c = 0$ 表示偶数个, $c = 1$ 表示奇数个) 若 $x$ 和 $y$ 在一个集合中, 直接判断 $d[x] xor d[y]$ 是否等于 $c$，若不等于,则矛盾，直接输出结果。 若 $x$ 和 $y$ 不在一个集合中，说明无法判断，此时合并两个集合，得到俩个的树根 $p$ 和 $q$, $d[x]$ 与 $d[y]$ 分别表示 $x - p$ 与 $y - q$ 之间所有边权的 “xor” 和，$p - q$ 之间的边权为 $d[p]$, 显然, 路径 $x - y$ 由 $x - p$, $p - q$, $q - y$ 组成，所以 $x$ 与 $y$ 的奇偶性关系 $c = d[x] (xor) d[y] (xor) d[p]$，得到 $d[p] = d[x] (xor) d[y] (xor) c$。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5;int fa[N], d[N];unordered_map&lt;int, int&gt; mp;vector&lt;int&gt; g;struct Node { int a, b, c;} q[N];int find (int x) { if (x != fa[x]) { int root = find(fa[x]); d[x] ^= d[fa[x]]; fa[x] = root; } return fa[x];}int main(){ int L, n, a, b, pa, pb; string s; cin &gt;&gt; L &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; q[i].a &gt;&gt; q[i].b &gt;&gt; s; if (s[0] == 'e') q[i].c = 0; else q[i].c = 1; g.push_back(q[i].a - 1); g.push_back(q[i].b); } sort(g.begin(), g.end()); g.erase(unique(g.begin(), g.end()), g.end()); for (int i = 1; i &lt;= (int)g.size(); i++) { fa[i] = i; mp[g[i - 1]] = i; d[i] = 0; } int i = 1; for (; i &lt;= n; i++) { a = mp[q[i].a - 1], b = mp[q[i].b]; pa = find(a), pb = find(b); if (pa != pb) { fa[pa] = pb; d[pa] ^= d[a] ^ d[b] ^ q[i].c; } else { if (d[a] ^ d[b] != q[i].c) break; } } cout &lt;&lt; i - 1 &lt;&lt; endl; return 0;} Solution2（拓展域）$1 - n$ 表示 $sum[i]$ 为奇，$n + 1 - 2 * n$ 表示 $sum[i]$ 为偶。 当查询区间为奇数时：判断 $a$ 的奇数域是否与 $b$ 的奇数域同在一个集合，是则矛盾，否则合并 $a$ 的奇数域与 $b$ 的偶数域，$a$ 的偶数域与 $b$ 的奇数域。 当查询区间为偶数时：判断 $a$ 的奇数域是否与 $b$ 的偶数域同在一个集合，是则矛盾，否则合并 $a,b$ 的奇数域和偶数域。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5;int fa[N];vector&lt;int&gt; g;unordered_map&lt;int, int&gt; mp;struct Node { int a, b, c;} q[N];int find (int x) { if (x != fa[x]) fa[x] = find(fa[x]); return fa[x];}void join (int x, int y) { x = find(x), y = find(y); if (x != y) fa[x] = y;} int main(){ int L, m, n, a, b; string s; cin &gt;&gt; L &gt;&gt; m; for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; q[i].a &gt;&gt; q[i].b &gt;&gt; s; if (s == &quot;even&quot;) q[i].c = 0; else q[i].c = 1; g.push_back(q[i].a - 1); g.push_back(q[i].b); } sort(g.begin(), g.end()); g.erase(unique(g.begin(), g.end()), g.end()); n = g.size(); for (int i = 1; i &lt;= n; i++) { mp[g[i - 1]] = i; fa[i] = i; fa[i + n] = i + n; } int i = 1; for (; i &lt;= m; i++) { a = mp[q[i].a - 1], b = mp[q[i].b]; if (q[i].c) { if (find(a) == find(b) || find(a + n) == find(b + n)) break; join(a, b + n); // 合并a的奇数域和b的偶数域 join(a + n, b); // 合并a的偶数域和a的奇数域 } else { if (find(a) == find(b + n) || find(a + n) == find(b)) break; join(a, b); // 合并a的奇数域和b的奇数域 join(a + n, b + n); // 合并a的偶数域和b的偶数域 } } cout &lt;&lt; i - 1 &lt;&lt; endl; return 0;} 反向并查集星球大战求每次拆边后的连通块个数。$(m \\in [1, 2e5], n \\in [1, 2*m])$ Solution拆边很难维护集合数量，考虑离线后反过来建图。这样便相当于每次增加增加一条边，查询两个点是否为同一个集合即可知道集合数量是否减少。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e5 + 5;int n, m, k, pre[N], b[N], vis[N];vector&lt;int&gt; g[N];int find(int x) { int i = x, j = x; while (i != pre[i]) i = pre[i]; while (i != j) { int temp = pre[j]; pre[j] = i; j = temp; } return i;}bool join(int x, int y) { int fx = find(x), fy = find(y); if (fx != fy) { pre[fx] = fy; return true; } return false;}int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) pre[i] = i; for (int i = 1; i &lt;= m; i++) { int x, y; cin &gt;&gt; x &gt;&gt; y; g[x].push_back(y); g[y].push_back(x); } cin &gt;&gt; k; for (int i = 1; i &lt;= k; i++) { cin &gt;&gt; b[i]; vis[b[i]] = 1; } int res = n - k; for (int i = 0; i &lt; n; i++) { if (vis[i]) continue; for (int j = 0; j &lt; g[i].size(); j++) { int x = g[i][j]; if (!vis[x]) { if (join(i, x)) res--; } } } b[k + 1] = res; for (int i = k; i &gt;= 1; i--) { res++; vis[b[i]] = 0; for (int j = 0; j &lt; g[b[i]].size(); j++) { if (!vis[g[b[i]][j]] &amp;&amp; join(b[i], g[b[i]][j])) res--; } b[i] = res; } for (int i = 1; i &lt;= k + 1; i++) cout &lt;&lt; b[i] &lt;&lt; endl; return 0;} Total Eclipse给你 $n$ 个节点 $m$ 条边的图，每个点有一个权值，你现在要做的操作是选择一个连通图，并将其中的每一个点的权值都减一，问你最少需要多少次才能将所有的点都变为0。$(1≤n≤100000, 1≤m≤200000)$ Solution贪心地想，每次必然是选择权值最小的点，然后联通的边都减少该权值，但这样很难维护，因此可以考虑反向。 每次选择权值最大的点，然后这个点需要减少到和次小的点一样的权值，即减少的权值为和次小点权值之差。由于一次可以减少一个联通块，因此我们只需要乘以当前点联通块个数即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5;int t, n, m, pre[N], vis[N];vector&lt;int&gt; g[N];struct Node { long long w; int id;} q[N];bool cmp(Node x, Node y) { return x.w &gt; y.w; }int find(int x) { int i = x, j = x; while (i != pre[i]) i = pre[i]; while (j != i) { int temp = pre[j]; pre[j] = i; j = temp; } return i;}bool join(int x, int y) { int fx = find(x), fy = find(y); if (fx != fy) { pre[fx] = fy; return true; } return false;}int main() { scanf(&quot;%d&quot;, &amp;t); while (t--) { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); memset(vis, 0, sizeof(vis)); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%lld&quot;, &amp;q[i].w); q[i].id = i; pre[i] = i; g[i].clear(); } for (int i = 1; i &lt;= m; i++) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); g[u].push_back(v); g[v].push_back(u); } long long cnt = 0, res = 0; sort(q + 1, q + n + 1, cmp); q[n + 1].w = 0; for (int i = 1; i &lt;= n; i++) { cnt++; vis[q[i].id] = 1; for (auto x : g[q[i].id]) { if (vis[x] &amp;&amp; join(x, q[i].id)) cnt--; } res += cnt * (q[i].w - q[i + 1].w); } printf(&quot;%lld\\n&quot;, res); } return 0;}","link":"/2020/10/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%8B%93%E5%B1%95.html"},{"title":"拷贝构造，拷贝复制，析构","text":"Big Three（拷贝构造，拷贝复制，析构）12345678910111213141516171819202122232425class String { public: String (const char* cstr = 0); // 构造函数，默认初值为0&lt;!--more--&gt; String (const String&amp; str); // 接受的值为类本身，因此为拷贝构造函数 String&amp; operator=(const String&amp; str); // = 号重载，拷贝赋值函数 ~String(); // 析构函数，类死亡时自动调用 char* get_c_str() const { return m_data; } private: char* m_data; }int main(){ String s1(); String s2(&quot;hello&quot;); String s3(s1); // 拷贝构造，类还未存在 cout &lt;&lt; s3 &lt;&lt; endl; s3 = s2; // 拷贝赋值，类已经存在 cout &lt;&lt; s3 &lt;&lt; endl;} 123456789101112131415161718inlineString::String(const char* cstr = 0){ if (cstr) { // 指定初值 m_data = new char[strlen(cstr) + 1]; // 分配传进来的长度+ '\\0' 的空间 strcpy(m_data, cstr); // 复制 } else { // 未指定初值 m_data = new char[1]; *m_data = '\\0'; }}inlineString::~String(){ delete[] m_data; // 将原来分配的内存释放} 123451. String p1(&quot;hello&quot;); //栈中分配内存2. String p2 = String(&quot;hello&quot;); //栈中分配内存，跟方法1相同，是方法1的完整模式3. String *p3 = new String(&quot;hello&quot;); //堆中分配内存 方法1、2中都是在栈中分配内存，在栈中内存由系统自动的去分配和释放，释放的顺序也和栈一样，后定义的先释放。 而使用new创建的指针对象是在堆中分配内存，当不需要该对象时，需要我们手动的去释放，否则会造成内存泄漏。 深拷贝，浅拷贝如果类中有指针成员，则必须写拷贝构造和拷贝赋值函数。 假设 指针a -&gt; “hello”, 指针b -&gt; “world”，当执行 b = a 时，则变成 b 指向 a，造成 “world” 无人指向，发生了内存泄漏，而”hello” 被 a 和 b 同时指向的情况，那么将来一旦改变 a ，b 也会发生改变。那么，这种拷贝称之为 “浅拷贝”。 深拷贝即为我们自己写的拷贝函数： 123456789101112131415161718inlineString::String(const String&amp; str) // 拷贝构造{ m_data = new char[ strlen(str.m_data) + 1 ]; strcpy(m_data, str.m_data);}inlineString&amp; String::operator=(const String&amp; str) // 拷贝赋值{ if(this == &amp;str) // 有可能是自己赋值给自己（比如引用），如果不写这句，那么delete就是它自己，下面全错 return *this; delete[] m_data; // 先将自己删除 m_data = new char[ strlen(str.m_data) + 1 ]; // 重新创建和右边一样大的空间 strcpy(m_data, str.m_data); // 重新赋值 return *this;}","link":"/2020/05/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%EF%BC%8C%E6%8B%B7%E8%B4%9D%E5%A4%8D%E5%88%B6%EF%BC%8C%E6%9E%90%E6%9E%84.html"},{"title":"操作系统知识点","text":"并发和并行并发：宏观上两个程序在同时运行，实际上是交织运行的，单个周期只运行了一个指令，用于提高效率。并行：物理意义上的同时运行，如多核cpu，运行在不同的核上，互不影响。 进程和线程的概念，区别，使用场景进程：资源分配的基本单位，实现了操作系统的并发。线程：线程是进程的子任务，是CPU调度的基本单位，不拥有资源，但可以使用进程所属的资源。每个进程都有一个主线程，实际上是主线程来执行main函数中的代码。 进程在创建，撤销，切换时的开销都显著大于线程，系统要为之分配，回收，切换资源。 一个线程只属于一个进程，进程间不会相互影响，一个线程挂掉将影响整个进程挂掉。 线程并不是越多越好，每个线程都需要一个独立的堆栈空间，线程之间的切换需要保存很多中间状态，耗费程序运行时间。多线程开销远远小于多进程。 进程在同一时间只能干一件事，进程在执行过程中如果阻塞，整个进程就会挂起，然后其中有些工作并不依赖阻塞的资源，却还是卡在那里。因此引入线程，减少程序在并发时付出的时空开销。 进程间通信方式 管道 普通管道PIPE：半双工，数据单向流动，一般申请两个，一个用于读一个用于写。只能用于有父子进程和兄弟进程之间，只存在于内存中。 命名管道FIFO：有具体的路径名，存在于文件系统中，因此可以在无关进程中交换数据。 套接字socket：可以用于不同主机间进行通讯 系统IPC 消息队列：消息的链接表，存放在内核中。具有写权限的进程可以向队列中添加消息，有读权限的进程可以从队列中读取信息。 消息具有特定的格式和优先级，克服了信号传递信息少，管道只能承载无格式字节流已经缓冲区大小受限等特点 独立于发送和接收进程，进程终止是，消息队列及其内容不会被删除 可以实现消息的随机查询，不一定要先进先出地读取 信号量：计数器，控制多进程对共享资源的访问。用于实现进程间的互斥和同步，不用于存储进程间的通信数据。一般需要结合共享内存和PV操作使用。 信号：用于通知接收进程某个事件已经发生 共享内存：使得多个进程可以访问同一块内存，不同进程可以及时看到对方进程中对共享内存的数据更新。 最快的IPC，进程直接对内存进行存取 多个进程可以同时操作，需要进行同步 需要同步操作，和互斥锁和信号量一起结合使用 进程同步方式进程通信：进程间传送（大量）数据进程同步：进程合作，进程间共同完成一项任务时之间的直接制约关系。进程互斥：它主要源于资源共享，是进程之间的间接制约关系。每次只允许一个进程访问的资源称为临界资源，进程互斥就是保证每次只有一个进程使用临界资源。 临界区： 线程间通信方式线程同步和进程同步的本质区别在于锁放在哪，放在私有的进程空间还是放在多进程共享的空间，并且看锁是否具备进程共享的属性。 临界区：多个线程访问一个独占共享资源时，可以使用临界区对象，其它线程想访问，会被挂起，直到拥有临界区的线程放弃位置。 事件：允许一个线程在处理完之后，主动唤醒另外一个线程执行任务。 互斥量：互斥对象机制，拥有互斥对象的线程才有访问公共资源的权限。 信号量：允许多个线程在同一时刻访问同一个资源，但一般需要限制数目。 物理内存和虚拟内存早期的计算机程序是直接运行在物理内存的，但这种直接访问内存的方式影响到内存安全性问题，已经内存使用率的降低。 于是考虑在其中添加一层中间层 ——— 虚拟内存，使得程序通过虚拟内存去间接访问物理内存。只要系统处理好其中的映射关系，就可以达到物理内存地址隔离的效果，保证数据安全性。 操作系统分配给进程的内存空间中包含五个段： 数据段：存放静态变量和已初始化不为0的全局变量 代码段：存放可执行文件的操作指令，只读不可写 BSS段：存放未初始化的全局变量 堆：存放动态分配的内存 栈：存放临时的局部变量和函数的参数值 分段技术可以解决什么问题？假设A虚拟空间地址为0-99，对应物理地址600-699；B虚拟空间地址为100-199，对应物理空间地址300-399。如果操作了地址150，此时150是虚拟的，也就在操作系统的控制中，操作系统可以阻止这次操作，保证了内存安全性，体现出隔离性。 但这样并没有解决空间利用率低的问题，于是又提出了分页的概念。分页其实就是把段再进行细分，每一小块被称为帧。 分段方法中，程序会被直接加载到虚拟内存，而分页则是把单位分成了页，虚拟地址的页去映射物理地址的页，从而提高了物理内存的使用率。 虚拟内存和物理内存的映射是通过页表实现的，页表实际上是一个数组，每个进程都有一个页表。 缺页中断malloc()等内存分配函数只是建立了进程虚拟地址空间，没有分配虚拟内存对应的物理内存。当进程访问这些没有建立映射的虚拟内存时，会触发缺页中断。即要访问的页面不在内存时，会产生一次缺页中断，操作系统根据页表的外存地址在外存中找到所缺的一页，将其调入内存。 fork和vforkfork()创建一个子进程，返回2次，一次在子进程中返回0，一次在父进程中返回子进程的pid，子进程和父进程共享内存空间，采用写时复制，即父子可以同时读取内存，但如果需要对内存进行修改的话，就会复制一份该进程单独使用。毕竟一开始就进行内存复制是很浪费效率的。 vfork创建的子进程先于父进程运行，父子进程共用数据段，但若子进程依赖父进程操作，就会产生死锁。 进程调度算法 先来先服务FCFS： 非枪占式，按请求顺序进行调度。容易导致长作业等待时间过长。 短作业优先SJF： 非抢占式，按估计运行时间最短的顺序进行调度。如果短作业一直来，长作业容易饿死。 最短剩余时间优先SRTN： 抢占式，按剩余运行时间进行调度。一个新作业来时，与当前进程的剩余时间进行比较。 时间片轮转： 按FCFS分配成一个队列，每个进程轮流执行一个时间片。效率和时间片大小有很大关系。时间片太短，进程切换太频繁；时间片太长，实时性无法保证。 优先级调度 给每个进程分配一个优先级，按优先级调度。为了防止低优先永远等不到，可以随着时间推移增加优先级。 多级反馈队列 设计出多个队列，每个队列时间片大小都不同，时间片小的队列优先级越高。 例如：一个进程先去时间片为1的队列，若出队后没有执行完，就去时间片2的队列队尾，以此类推。 可以看成是时间片轮转+优先级调度结合，效率较高。 进程状态切换就绪态通过调度算法获得CPU时间，进入运行态；时间片用完进入就绪态，等待下一次调度。运行态因确实资源（函数迟迟不返回），进入阻塞态，缺少CPU时间会使其进入就绪态。 OS缺页置换算法，虚拟内存置换方式当访问内存中一个不存在的页时，且内存已满，就需要从内存中替换一个页。 FIFO（先进先出）：置换最先进来的页面，即逗留时间最久的页面。 LFU：最不经常访问淘汰算法 LRU（最近最少访问）：置换最近一段时间内最久没被访问过的页面。 Linux锁机制 互斥锁：mutex，用于保证任何时刻只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒。 读写锁：rwlock，分为读锁和写锁。允许多个线程同时读，但只能有一个线程写。写优先于读，一旦有写，则读必须等待。适用于读频率远远大于写的情况。 自旋锁：在任何时刻只能有一个线程访问对象，但是获取锁操作失败时，不会进入睡眠，而是在原地自旋，直到锁被释放。节省了线程从睡眠到被唤醒的消耗。适用于加锁时间短暂的情况下。 死锁多个进行相互等待对方资源，在得到所有资源继续运行之前，都不会释放自己已有的资源，这样造成了循环等待的现象，称为死锁。 产生死锁的的四个条件： 互斥条件：一个资源每次只能被一个进程使用； 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放； 不剥夺条件：进程已获得的资源，在没使用完之前，不能强行剥夺； 循环等待条件：多个进程之间形成一种互相循环等待资源的关系。 防止死锁的发生只需破坏死锁产生的四个必要条件之一即可，但开销非常之大，目前没有一个操作系统可以实现。因此最好的办法是预防，而不是解决。 预防：银行家算法，在进行系统资源分配之前，先计算此次资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源分配给进程；否则，让进程等待。 解除： 剥夺资源：从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态 撤消进程：可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态消除为止；所谓代价是指优先级、运行代价、进程的重要性和价值等。 用户态和内核态由于需要限制不同程序之间的访问能力，防止获取别的内存数据进行随意读写，产生了用户态和内核态。当程序需要申请外部资源就会由用户态进入内核态。 内核态：系统程序在内核态运行。该状态下，CPU可以访问内存的所有数据，包括外围设备，例如硬盘、网卡等。 用户态：应用程序只在用户态运行。该状态下只能受限的访问内存且不允许访问外设，占用CPU的能力被剥夺，导致CPU资源可以被其他程序获得。 用户态切换内核态： 系统调用：进程主动要求切换到内核态的一种方式，很多事情直接让程序去做是很危险的，于是内核态提供一些系统调用，程序通过这些系统调用让危险的事交由内核来执行。如fork，open，write，malloc等。 异常：用户态程序发生未知异常，转换到内核态处理此异常的相关程序中。如缺页异常。 中断：外围设备完成用户请求操作后，会向CPU发出中断信号，然后内核放下手头的工作去处理中断信号。如硬盘读写结束后，发出中断信号，内核态处理该信号。 僵尸进程kill掉子进程，父进程会收到SIGCHILD信号，子进程变成僵尸进程。 一个子进程结束了，但父进程还活着。因为内核认为父进程可能还需要子进程的一些信息，所以就没有将他关闭。 解决掉僵尸进程方式有：重启电脑，或者把父进程kill掉。 我们应该坚决不允许僵尸进程的存在。所以对于fork行为，我们应该拦截到SIGCHILD信号，然后使用waitpid获取子进程终止状态（返回0表示获取到子进程已被关闭）。 孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。 守护进程：一般来说生存周期长，随着操作系统一起开启和关闭。与终端无关联，不会占用终端。 协程协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。但协程的特点在于是一个线程执行。 和多线程比，协程最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。 第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。","link":"/2021/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9.html"},{"title":"杜教BM模板","text":"用于求线性递推式第n项，扔进前k+x项即可 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cassert&gt;using namespace std;typedef long long ll;#define rep(i, a, n) for (int i = a; i &lt; n; i++)#define per(i, a, n) for (int i = n - 1; i &gt;= a; i--)#define pb push_back#define mp make_pair#define all(x) (x).begin(), (x).end()#define fi first#define se second#define SZ(x) ((int)(x).size())typedef vector&lt;ll&gt; VI;typedef pair&lt;ll, ll&gt; PII;const ll mod = 10000;ll powmod(ll a, ll b) { ll res = 1; a %= mod; assert(b &gt;= 0); for (; b; b &gt;&gt;= 1) { if (b &amp; 1) res = res * a % mod; a = a * a % mod; } return res;}ll _, n;namespace linear_seq {const ll N = 10010;ll res[N], base[N], _c[N], _md[N];vector&lt;ll&gt; Md;void mul(ll *a, ll *b, int k) { rep(i, 0, k + k) _c[i] = 0; rep(i, 0, k) if (a[i]) rep(j, 0, k) _c[i + j] = (_c[i + j] + a[i] * b[j]) % mod; for (ll i = k + k - 1; i &gt;= k; i--) if (_c[i]) rep(j, 0, SZ(Md)) _c[i - k + Md[j]] = (_c[i - k + Md[j]] - _c[i] * _md[Md[j]]) % mod; rep(i, 0, k) a[i] = _c[i];}ll solve(ll n, VI a, VI b) { ll ans = 0, pnt = 0; ll k = SZ(a); assert(SZ(a) == SZ(b)); rep(i, 0, k) _md[k - 1 - i] = -a[i]; _md[k] = 1; Md.clear(); rep(i, 0, k) if (_md[i] != 0) Md.push_back(i); rep(i, 0, k) res[i] = base[i] = 0; res[0] = 1; while ((1ll &lt;&lt; pnt) &lt;= n) pnt++; for (ll p = pnt; p &gt;= 0; p--) { mul(res, res, k); if ((n &gt;&gt; p) &amp; 1) { for (ll i = k - 1; i &gt;= 0; i--) res[i + 1] = res[i]; res[0] = 0; rep(j, 0, SZ(Md)) res[Md[j]] = (res[Md[j]] - res[k] * _md[Md[j]]) % mod; } } rep(i, 0, k) ans = (ans + res[i] * b[i]) % mod; if (ans &lt; 0) ans += mod; return ans;}VI BM(VI s) { VI C(1, 1), B(1, 1); ll L = 0, m = 1, b = 1; rep(n, 0, SZ(s)) { ll d = 0; rep(i, 0, L + 1) d = (d + (ll)C[i] * s[n - i]) % mod; if (d == 0) ++m; else if (2 * L &lt;= n) { VI T = C; ll c = mod - d * powmod(b, mod - 2) % mod; while (SZ(C) &lt; SZ(B) + m) C.pb(0); rep(i, 0, SZ(B)) C[i + m] = (C[i + m] + c * B[i]) % mod; L = n + 1 - L; B = T; b = d; m = 1; } else { ll c = mod - d * powmod(b, mod - 2) % mod; while (SZ(C) &lt; SZ(B) + m) C.pb(0); rep(i, 0, SZ(B)) C[i + m] = (C[i + m] + c * B[i]) % mod; ++m; } } return C;}ll gao(VI a, ll n) { VI c = BM(a); c.erase(c.begin()); rep(i, 0, SZ(c)) c[i] = (mod - c[i]) % mod; return solve(n, c, VI(a.begin(), a.begin() + SZ(c)));}}; // namespace linear_seqint main() { while (~scanf(&quot;%lld&quot;, &amp;n) &amp;&amp; n != -1) { vector&lt;ll&gt;v; v.push_back(0); v.push_back(1); v.push_back(1); v.push_back(2); v.push_back(3); v.push_back(5); v.push_back(8); v.push_back(13); v.push_back(21); v.push_back(34); printf(&quot;%lld\\n&quot;, linear_seq::gao(v, n)); } return 0;}","link":"/2020/05/%E6%9D%9C%E6%95%99BM%E6%A8%A1%E6%9D%BF.html"},{"title":"杭电多校：Tree","text":"题目给定一颗树，路径只能由父节点指向子节点，你可以增加一条有向边，使得联通点对最多。 Solution容易发现，当叶子结点往根结点连一条边时，增加的点对会是最多的。$dp1[i]$ 表示从 $i$ 结点出发可以到达多少点，$dp2[i]$ 表示当前以 $i$ 为根结点，能增加的最大点对数（最大值）。 对于 $dp1[i]$，状态转移方程：$dp1[fa] += dp1[son]$。 对于 $dp2[i]$，状态转移方程：$ for All(son): dp2[fa] = max(dp2[fa], dp2[son]), dp2[fa] += n - dp1[fa]$。 $sum(dp1)$ 即为不加边的点对数和，$dp2[1]$ 得到的即为增加一条边能增加的最大点对数。 Code123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6 + 5;vector&lt;int&gt; g[N];int t, n;long long res, dp1[N], dp2[N];void dfs(int u, int fa) { dp1[u] = 1; for (auto v : g[u]) { if (v == fa) continue; dfs(v, u); dp2[u] = max(dp2[u], dp2[v]); dp1[u] += dp1[v]; } dp2[u] += n - dp1[u];}int main() { scanf(&quot;%d&quot;, &amp;t); while (t--) { scanf(&quot;%d&quot;, &amp;n); res = 0; for (int i = 0; i &lt;= n; i++) { g[i].clear(); dp1[i] = 0; dp2[i] = 0; } for (int i = 2; i &lt;= n; i++) { int x; scanf(&quot;%d&quot;, &amp;x); g[x].push_back(i); } dfs(1, -1); for (int i = 1; i &lt;= n; i++) res += dp1[i]; printf(&quot;%lld\\n&quot;, res + dp2[1]); } return 0;}","link":"/2020/08/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%EF%BC%9ATree.html"},{"title":"树状数组经典题","text":"一个简单的整数问题题目第一类指令形如 “C-l-r-d”，表示把数列中第 $l-r$ 个数都加 $d$。 第二类指令形如 “Q-X”，表示询问数列中第 $x$ 个数的值。 对于每个询问，输出一个整数表示答案。 数据范围：$(n, m \\in [1, 100000])$ Solution用树状数组解决动态差分问题。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e5 + 5;typedef long long ll;int n, m;ll c[N], a[N];int lowbit(int x) { return x &amp; (-x);}void add(int x, int y) { while (x &lt;= n) { c[x] += y; x += lowbit(x); }}ll query(int x) { ll sum = 0; while (x &gt;= 1) { sum += c[x]; x -= lowbit(x); } return sum;}int main(){ cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; while (m--) { string s; int x, y, z; cin &gt;&gt; s; if (s == &quot;Q&quot;) { cin &gt;&gt; x; cout &lt;&lt; query(x) + a[x] &lt;&lt; endl; } else { cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; add(x, z); add(y + 1, -z); } } return 0;} 谜一样的牛题目给定序列长度 $n$ 和 数组 $a$，$a[i]$ 表示第 $i$ 个数前面有多少个数比它小，复原原序列，原序列为 $1-n$ 的排列。$(n \\in [1, 100000])$ Solution最后一个数的大小明显是一开始就可以推断出来的，假设其大小是 $x$，接着从 $1-n$ 这 $n$ 个数字中把 $x$ 删掉，然后再看倒数第二个数，假设其前面有 $y$ 个数比它小，说明这个数是剩下的数里面第 $y + 1$ 大的数。 由此可以发现，我们可以倒推过来，第 $i$ 个数的大小便是当前还没有被选的数中第 $a[i] + 1$ 小的数。 可以使用树状数组解决，将每个位置置为 $1$ 表示未被选，$0$ 表示已被选，得到的前缀和是单调递增的，因此每次只需要二分查找满足前缀和刚好等于 $a[i] + 1$ 的位置即为当前数的大小。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5;int n, c[N], a[N], res[N];int lowbit(int x) { return x &amp; (-x);}void add(int x, int y) { while (x &lt;= n) { c[x] += y; x += lowbit(x); }}int query(int x) { int sum = 0; while (x &gt;= 1) { sum += c[x]; x -= lowbit(x); } return sum;}int main(){ cin &gt;&gt; n; add(1, 1); for (int i = 2; i &lt;= n; i++) { cin &gt;&gt; a[i]; add(i, 1); } for (int i = n; i &gt;= 1; i--) { int l = 0, r = n + 1, mid; while (l + 1 &lt; r) { mid = l + r &gt;&gt; 1; if (query(mid) &lt; a[i] + 1) l = mid; else r = mid; } res[i] = r; add(r, -1); } for (int i = 1; i &lt;= n; i++) cout &lt;&lt; res[i] &lt;&lt; endl; return 0;}","link":"/2020/10/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%BB%8F%E5%85%B8%E9%A2%98.html"},{"title":"每日一题：Accumulation Degree","text":"题意给定一棵n个节点的树，边权值视作流量，找到一个源点使得从该点出发到所有叶子节点流量和最大。 思路：我们先考虑这样一道题：指定一点使得到树上其他点的深度之和最小。 这显然是树的重心的性质：树中所有点到某个点的距离和中，到重心的距离和是最小的，如果有两个重心，他们的距离和一样。我们先假设这棵树的根为1，进行一次dfs，可以求出每个点的深度 $dep[i]$ 和子树大小 $size[i]$ ，设某点作为根深度之和为 $f$( i )，显然：$f(1)$ = $\\sum_{i=1}^{n}{dep[i]}$。 当根从 $u$ 转移到子节点 $v$ 时，以 $v$ 为根的子树内所有节点 $dep$ 都减1，其余节点加1。从而得到状态转移方程：$f[v] = f[u] - size[v] + (n - size[v]) = f[u] + n - 2 * size[v]$，答案取最小值即可，时间复杂度 $O (n)$ 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e6 + 5;int n, res, idx, h[N], dep[N], size[N];long long f[N];struct Node { int to, next;} E[N];void add(int a, int b) { E[idx].to = b, E[idx].next = h[a], h[a] = idx++; }void dfs1(int u, int fa) { size[u] = 1; dep[u] = dep[fa] + 1; for (int i = h[u]; ~i; i = E[i].next) { int v = E[i].to; if (v == fa) continue; dfs1(v, u); size[u] += size[v]; }}void dfs2(int u, int fa) { for (int i = h[u]; ~i; i = E[i].next) { int v = E[i].to; if (v == fa) continue; f[v] = f[u] + n - 2LL * size[v]; dfs2(v, u); }}int main() { memset(h, -1, sizeof(h)); cin &gt;&gt; n; for (int i = 1; i &lt; n; i++) { int x, y; cin &gt;&gt; x &gt;&gt; y; add(x, y); add(y, x); } dep[0] = -1; dfs1(1, 0); for (int i = 1; i &lt;= n; i++) f[1] += dep[i]; dfs2(1, 0); long long sum = 0x3ffffffffffff; for (int i = 1; i &lt;= n; i++) { if (sum &gt; f[i]) { sum = f[i]; res = i; } } cout &lt;&lt; sum &lt;&lt; '\\n'; return 0;} 现在我们回过头来看这道题，可以发现思路都大同小异，只是转移方程发生了变化。 定义 $flow[i]表示以 i 为根的子树中流量的最大值$，那么，当节点从 $u$ 转移到 $v$ 时，我们可以得到： 当 $v$ 为叶子结点，则 $flow[u] += flow[v]$ ； 当 $u$ 为非叶子结点，则 $flow[u] = min(flow[v], fl(u, v))$ $(fl(u, v) 即u, v两点间的流量限制)$ 。 这样，根为1时的 $flow[1]$ 就求出来了。 接下来考虑根节点的转移：从以 $u$ 为根节点转移为以 $v$ 为根节点，对于根节点 $v$ 而言，唯一会产生影响的就是 $v$ 流向 $u$ 的路径，也就是对于换根后所有用到这条边的路径，都要加上这条流量的限制，则状态转移方程为： 当 $u$ 为叶子节点时，$f[v] += fl(u, v)$ ; 当 $v$ 为非叶子结点时，$f[v] += min(fl(u, v), flow[u] - min(flow[v], fl(u, v)))$ 。 进行两次dfs即可，时间复杂度 $O(n)$。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5;int t, n, res, idx, h[N], d[N], f[N];struct Node { int to, w, next;} E[N &lt;&lt; 1];void add(int a, int b, int c) { E[idx].to = b, E[idx].w = c, E[idx].next = h[a], h[a] = idx++;}void dfs1(int u, int fa) { for (int i = h[u]; ~i; i = E[i].next) { int v = E[i].to, w = E[i].w; if (v == fa) continue; dfs1(v, u); if (d[v] == 1) f[u] += w; else f[u] += min(f[v], w); }}void dfs2(int u, int fa) { for (int i = h[u]; ~i; i = E[i].next) { int v = E[i].to, w = E[i].w; if (v == fa) continue; if (d[u] == 1) f[v] += w; else f[v] += min(w, f[u] - min(f[v], w)); dfs2(v, u); }}int main() { cin &gt;&gt; t; while (t--) { idx = 0; memset(h, -1, sizeof(h)); memset(d, 0, sizeof(d)); memset(f, 0, sizeof(f)); cin &gt;&gt; n; for (int i = 1; i &lt; n; i++) { int x, y, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; add(x, y, z); add(y, x, z); d[x]++; d[y]++; } dfs1(1, 0); dfs2(1, 0); res = 0; for (int i = 1; i &lt;= n; i++) res = max(res, f[i]); cout &lt;&lt; res &lt;&lt; '\\n'; } return 0;} 总结对于换根dp，一般有两个步骤： 默认1为根进行dfs预处理； 从1开始，进行根的转移，计算贡献变化。 对于dp而言，状态转移方程是最重要的，需要多思考，多刷题，才能累积经验，掌握要点。","link":"/2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AAccumulation-Degree.html"},{"title":"每日一题：Arithmetic Progressions","text":"题目从给定数列中能选出组成的最长等差数列长度为多少？$(n \\in [1, 5000], a[i] \\in [1, 1e9])$ Solution$dp[i][j]$ 表示 $a[i]$ 为等差数列最后一个数，$a[j]$ 为倒数第二个数。 排序后二维枚举 $i$ 和 $j$，二分找到对应的下标 $k$ 使得 $a[k]+a[i]=2*a[j]$ ，直接转移 $dp[i][j] = max(dp[i][j], dp[j][k] + 1)$。 Code1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int n, res, a[5005], dp[5005][5005];int main() { cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; sort(a, a + n); for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; i; j++) { int k = lower_bound(a, a + n, a[j] * 2 - a[i]) - a; if (a[k] == a[j] * 2 - a[i]) dp[i][j] = max(dp[i][j], dp[j][k] + 1); res = max(res, dp[i][j]); } } cout &lt;&lt; res + 2 &lt;&lt; endl; return 0;}","link":"/2020/10/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AArithmetic-Progressions.html"},{"title":"每日一题：Assassin’s Creed","text":"题目有 $n$ 个敌人，你现在的武器的耐久度为 $m$,杀每个敌人要消耗 $a_i$ 点耐久度，同时得到可以再杀死 $b_i$ 个人的权利。问最多可以杀死多少人，在杀人最多的情况下最少要消耗多少耐久度？ Solution首先会想到对人进行分类，一类是 $b_i$ 为 $0$ 的，一类是 $b_i$ 不为 $0$ 的。 杀死一个 $b_i$ 不为 $0$ 的，一定能杀死所有 $b_i$ 不为 $0$ 的，而且还能再额外杀死 $b_i$ 为 $0$ 的，显然只要杀 $a_i$ 最小的那个人即可。 分两种情况： 只杀 $b_i$ 为 $0$ 的，可能原因：没有 $b_i$ 不为 $0$ 的，或者耐久度不够，或者消耗耐久度过大，还不如直接杀 $b_i$ 为 $0$ 来的划算。 杀一个 $b_i$ 不为 $0$的，且消耗耐久度最小的，那么所有的 $b_i$ 不为 $0$ 都将被杀死，额外的免费杀人机会都拿来杀 $b_i$ 为 $0$ 的，用剩下的耐久度从小到大杀剩下的怪即可。但这样有缺陷，可能存在手动杀 $b_i$ 不为 $0$ 的人会更划算，因为这个怪可能消耗的耐久度非常小，而你用这次机会杀 $b_i$ 为 $0$ 的人可能消耗非常大。于是得出结论：所有 $b_i$ 不为 $0$ 的人肯定会被杀死，但我只要把所有的怪按耐久度从小到大杀即可。 两种情况取最大值即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; g1, g2, g3;int main() { int t, n, m, x, y, c = 0; scanf(&quot;%d&quot;, &amp;t); while (t--) { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); g1.clear(); g2.clear(); g3.clear(); int sum = 0; for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d%d&quot;, &amp;x, &amp;y); if (y) g1.push_back(x); else g2.push_back(x); sum+=y; } sort(g1.begin(), g1.end()); sort(g2.begin(), g2.end()); int cost1 = 0, cost2 = 0, num1 = 0, num2 = 0; for (int i = 0; i &lt; g2.size(); i++) { if (cost1 + g2[i] &gt; m) break; cost1 += g2[i]; num1++; } if (g2.size() == n || m &lt; g1[0]) printf(&quot;Case %d: %d %d\\n&quot;, ++c, num1, cost1); else { cost2 = g1[0]; sum++; num2 = min(sum, n); for (int i = 0; i &lt; g2.size(); i++) g3.push_back(g2[i]); for (int i = 1; i &lt; g1.size(); i++) g3.push_back(g1[i]); sort(g3.begin(), g3.end()); for (int i = 0; i &lt; g3.size(); i++) { if (num2 &gt;= n || cost2 + g3[i] &gt; m) break; cost2 += g3[i]; num2++; } if (num1 &gt; num2 || num1 == num2 &amp;&amp; cost1 &lt; cost2) printf(&quot;Case %d: %d %d\\n&quot;, ++c, num1, cost1); else printf(&quot;Case %d: %d %d\\n&quot;, ++c, num2, cost2); } } return 0;}","link":"/2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AAssassin%E2%80%99s-Creed.html"},{"title":"每日一题: Best Cow Fences(二分)","text":"题意给定一个正整数数列A，求一个平均数最大的、长度不小于L的子段。 solution考虑check问题，正着枚举起点，我们需要知道每个起点所能枚举的最大值。当一个数大于当前二分的平均数时，它一定是对答案有贡献的，因此倒过来预处理每个起点能枚举到的最大值即可。时间复杂度 $O(nlogn)$。 Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 2e5 + 5;ll n, k;double a[N], sum[N], pre[N];bool check(double avg) { pre[n + 1] = 0; for (ll i = n; i &gt;= 1; i--) pre[i] = max(a[i] - avg, pre[i + 1] + a[i] - avg); for (ll i = 0; i &lt;= n - k; i++) { if (sum[i + k] - sum[i] &gt;= k * avg) return true; if (sum[i + k] - sum[i] + pre[i + k + 1] &gt;= k * avg) return true; } return false;}int main() { while (~scanf(&quot;%lld%lld&quot;, &amp;n, &amp;k)) { double l = 1e18 + 7, r = 0, mid; for (ll i = 1; i &lt;= n; i++) { scanf(&quot;%lf&quot;, &amp;a[i]); l = min(l, a[i]); r = max(r, a[i]); sum[i] = sum[i - 1] + a[i]; } while (r - l &gt; 0.0001) { mid = (l + r) / 2.0; if (check(mid)) l = mid; else r = mid; } printf(&quot;%lld\\n&quot;, (ll)(l + 0.5)); } return 0;}","link":"/2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9ABest-Cow-Fences%EF%BC%88%E4%BA%8C%E5%88%86%EF%BC%89.html"},{"title":"每日一题：Contest （树状数组）","text":"题意 $n$ 支队伍一共参加了三场比赛。一支队伍 $x$ 认为自己比另一支队伍 $y$ 强当且仅当 $x$ 在至少一场比赛中比 $y$ 的排名高。求有多少组 $(x,y)$，使得 $x$ 自己觉得比 $y$ 强，$y$ 自己也觉得比 $x$ 强，$(x, y)$, $(y, x)$算一组。 solution 若 $x$ 和 $y$ 都互相认为更强，那么必定存在两场，一场 $x$ 强于 $y$，一场 $y$ 强于 $x$，那么就是对于任意两场求逆序数，最后的答案需要除以2，因为如果两队互认为更强，必定存在 $x$ 有两场更强，或者 $y$ 有两场更强，那么计算逆序数时就多计算了一次。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll N = 2e5 + 5;ll n, res, t[N];struct Node { ll a, b, c;} q[N];bool cmpa(Node x, Node y) { return x.a &lt; y.a; }bool cmpb(Node x, Node y) { return x.b &lt; y.b; }void add(ll x) { while (x &lt;= n) { t[x]++; x += x &amp; -x; }}ll query(ll x) { ll sum = 0; while (x) { sum += t[x]; x -= x &amp; -x; } return sum;}int main() { cin &gt;&gt; n; for (ll i = 1; i &lt;= n; i++) cin &gt;&gt; q[i].a &gt;&gt; q[i].b &gt;&gt; q[i].c; sort(q + 1, q + n + 1, cmpa); for (ll i = 1; i &lt;= n; i++) { add(q[i].b); res += i - query(q[i].b); } memset(t, 0, sizeof(t)); for (ll i = 1; i &lt;= n; i++) { add(q[i].c); res += i - query(q[i].c); } sort(q + 1, q + n + 1, cmpb); memset(t, 0, sizeof(t)); for (ll i = 1; i &lt;= n; i++) { add(q[i].c); res += i - query(q[i].c); } cout &lt;&lt; res / 2 &lt;&lt; '\\n'; return 0;}","link":"/2020/06/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AContest-%EF%BC%88%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%EF%BC%89.html"},{"title":"每日一题：Different Integers（树状数组&#x2F;莫队）","text":"题意给定长度为 $n$ 的数组，$q$ 次询问 $[1,l]+[r,n]$ 组成的新数组中不相同的元素个数。$(1&lt;=n,q&lt;=1e5)$ solution1一眼莫队题，主要是要想怎么样把它变成一个连续的区间。其实只要把整个数组再复制一遍接上就可以了，则原来查询的 $r$ 变为 $l$，$l$ 变为 $l+n$，区间连续。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 1812 ms#include &lt;bits/stdc++.h&gt;#pragma GCC optimize(2)using namespace std;const int N = 2e5 + 5;struct Node { int l, r, id;} node[N];int n, q, blocks, a[N], b[N], ans[N];bool cmp(Node a, Node b) { if (a.l / blocks == b.l / blocks) return a.r &lt; b.r; return a.l &lt; b.l;}int main() { while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;q)) { for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;a[i]); a[i + n] = a[i]; } memset(b, 0, sizeof(b)); blocks = sqrt(2 * n); for (int i = 1; i &lt;= q; i++) { scanf(&quot;%d%d&quot;, &amp;node[i].r, &amp;node[i].l); node[i].r += n; node[i].id = i; } sort(node + 1, node + q + 1, cmp); int l = 1, r = 0, num = 0; for (int i = 1; i &lt;= q; i++) { while (l &lt; node[i].l) num -= !--b[a[l++]]; while (l &gt; node[i].l) num += !b[a[--l]]++; while (r &lt; node[i].r) num += !b[a[++r]]++; while (r &gt; node[i].r) num -= !--b[a[r--]]; ans[node[i].id] = num; } for (int i = 1; i &lt;= q; i++) printf(&quot;%d\\n&quot;, ans[i]); } return 0;} solution2同样是复制一遍，然后考虑树状数组+离线处理。我们需要保证之前的更新不会对当前的查询构成干扰，可以对查询按照右端点从小到大排序，然后把当前的数更新到当前位置，删除之前的位置，这样保证数是跟排序后的查询一样是从左往右流动的。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 702 ms#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5;int n, q, a[N], b[N], c[N], ans[N];struct Node { int l, r, id;} node[N];bool cmp(Node x, Node y) { return x.r &lt; y.r; }void update(int x, int y) { for (; x &lt;= n; x += x &amp; (-x)) c[x] += y;}int query(int x) { int sum = 0; for (; x &gt;= 1; x -= x &amp; (-x)) sum += c[x]; return sum;}int main() { while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;q)) { for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;a[i]); a[i + n] = a[i]; } memset(b, 0, sizeof(b)); memset(c, 0, sizeof(c)); for (int i = 1; i &lt;= q; i++) { scanf(&quot;%d%d&quot;, &amp;node[i].r, &amp;node[i].l); node[i].r += n; node[i].id = i; } sort(node + 1, node + q + 1, cmp); n &lt;&lt;= 1; int pre = 1; for (int i = 1; i &lt;= q; i++) { for (int j = pre; j &lt;= node[i].r; j++) { if (b[a[j]]) update(b[a[j]], -1); b[a[j]] = j; update(b[a[j]], 1); } pre = node[i].r + 1; ans[node[i].id] = query(node[i].r) - query(node[i].l - 1); } for (int i = 1; i &lt;= q; i++) printf(&quot;%d\\n&quot;, ans[i]); } return 0;}","link":"/2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9ADifferent-Integers%EF%BC%88%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-%E8%8E%AB%E9%98%9F%EF%BC%89.html"},{"title":"每日一题：Functions again","text":"题意 给定数组，求上述式子的最大值。 Solution 可以看出，上述式子是交替加减求最大子段和。预处理两项差的绝对值，那么只需要枚举起点是奇数位置还是偶数位置就可以了，根据贪心原则，起点肯定选正数，然后交替正负就好了，这样问题就转化成就求最大子段和了，贪心即可。 Code123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5;typedef long long ll;int n;ll a[N], b[N], d[N]; ll solve(ll c[]) { ll now = 0, ma = 0; for (int i = 2; i &lt;= n; i++) { if (now &lt;= 0) now = c[i]; else now += c[i]; ma = max(ma, now); } return ma;} int main() { cin &gt;&gt; n &gt;&gt; a[1]; for (int i = 2; i &lt;= n; i++) { cin &gt;&gt; a[i]; ll x = llabs(a[i] - a[i - 1]); if (i &amp; 1) b[i] = -x; else b[i] = x; d[i] = -b[i]; } cout &lt;&lt; max(solve(b), solve(d)) &lt;&lt; endl; return 0;}","link":"/2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AFunctions-again.html"},{"title":"每日一题：Game Strategy","text":"题意三个人玩游戏，每个人最开始都有 $n$ 个数，开始轮流删数，直到最后每个人只剩下一个数。第一个人想让这三个数的和（$x+y+z$）加起来尽量大，第二个想尽量小，第三个想尽量接近0。每个人都以自己的想法为策略，问最后得到的三个数的和是多少（$n&lt;=100$）。 solution不要想复杂了，其实就是直接模拟。暴力枚举三个数，因为第三个人想尽量接近 0，因此枚举 $z$ 时维护最接近 0 的解 $m1$，因为第二个人想要最小值，因此取枚举所有 $z$ 得到的解（$m1$）的最小值$m2$，然后第一个人想要最大值，所以取枚举所有 $y$ （$m2$）的最大值 $m3$。 Code123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3fffffff;int main() { int n, a[105], b[105], c[105], d[105]; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; for (int i = 0; i &lt; n; i++) cin &gt;&gt; b[i]; for (int i = 0; i &lt; n; i++) cin &gt;&gt; c[i]; int m1 = -INF, m2, m3; for (int i = 0; i &lt; n; i++) { m2 = INF; for (int j = 0; j &lt; n; j++) { for (int k = 0; k &lt; n; k++) d[k] = a[i] + b[j] + c[k]; sort(d, d + n); int pos = lower_bound(d, d + n, 0) - d; if (pos == n) m3 = d[pos - 1]; else if (pos == 0) m3 = d[0]; else { if (d[pos] &gt; -d[pos - 1]) m3 = d[pos - 1]; else m3 = d[pos]; } m2 = min(m2, m3); } m1 = max(m1, m2); } cout &lt;&lt; m1 &lt;&lt; '\\n'; return 0;}","link":"/2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AGame-Strategy.html"},{"title":"每日一题：K-th Number","text":"题意给定一个长度为 $n$ 的数组 A ，把所有长度 &gt;= $k$ 的区间中的第 $k$ 大值插入 B 数组中，求 B 数组的第 $m$ 大数。 Solution这种显然二分答案题我们主要关心 $check$ 问题。 如何计算第 $k$ 大数 $&gt;= mid$ 的区间个数？ 假设区间 $[l, r]$ 中刚好有 $k$ 个数 $&gt;= mid$，则 $[l, r…n]$ 区间全部满足第 $k$ 大数 $&gt;= mid$。 因此考虑尺取，若当前区间满足 $k$ 个数 $=mid$，则计数 $cnt += n - r + 1$，同时移动左边界；否则移动右边界直至。。。当 $cnt &gt;= m$ 时，说明 $mid$ 过小，调整左边界，否则调整右边界。 Code123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;int t, n, k, a[100005];long long m;bool check(int x) { int l = 1, r = 0, cnt = 0; long long sum = 0; while (r &lt;= n) { if (cnt == k) { sum += (n - r + 1LL); cnt -= (a[l++] &gt;= x); } else cnt += (a[++r] &gt;= x); } return sum &gt;= m;}int main() { cin &gt;&gt; t; while (t--) { cin &gt;&gt; n &gt;&gt; k &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; int l = 0, r = 1e9 + 7, mid; while (l + 1 &lt; r) { int mid = (l + r) &gt;&gt; 1; if (check(mid)) l = mid; else r = mid; } cout &lt;&lt; l &lt;&lt; '\\n'; } return 0;}","link":"/2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AK-th-Number.html"},{"title":"每日一题：Moovie Mooving （状压dp）","text":"题意有 N 部电影，每部电影有不同的放映时常，和若干个放映起始时间。Bessie 可以在一部电影播放过程中的任何时间进入或退出放映厅。每部电影她最多看1次且她不能在看一部电影的过程中，换到另一个正在播放相同电影的放映厅。 Bessie 能不能从0到L分钟连续不断地观看电影？如果能，计算她最少看几部电影。 $(1 \\leq L \\leq 100,000,000，1\\leq N\\leq 201≤L≤100,000,000，1≤N≤20)$ solution$n$ 只有20考虑状压dp，$dp[i]$ 表示完成 $i$ 集合需要的最长时间，假设 $i$ 集合最后看的一部电影为 $j$，那么 $dp[i]$ 由 dp[i ^ (2^j)] 转移过来，并二分选取小于转移前集合的电影 $j$ 的最晚放映时间来更新 $p[i]$，同时维护 $dp[i] &gt;=l $ 的最小集合为答案。时间复杂度 $O(2^n*log(1000))$ Code1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 22;int n, l, t[N], dp[1 &lt;&lt; N];vector&lt;int&gt; g[N];int main() { cin &gt;&gt; n &gt;&gt; l; for (int i = 0; i &lt; n; i++) { int c, x; cin &gt;&gt; t[i] &gt;&gt; c; while (c--) { cin &gt;&gt; x; g[i].push_back(x); } g[i].push_back(l); } int res = n + 1; for (int i = 1; i &lt; (1 &lt;&lt; n); i++) { for (int j = 0; j &lt; n; j++) { if ((i &gt;&gt; j) &amp; 1) { int now = i ^ (1 &lt;&lt; j); int pos = upper_bound(g[j].begin(), g[j].end(), dp[now]) - g[j].begin() - 1; if (pos &gt;= 0 &amp;&amp; g[j][pos] + t[j] &gt; dp[now]) dp[i] = max(dp[i], g[j][pos] + t[j]); } } if (dp[i] &gt;= l) res = min(res, __builtin_popcount(i)); } if (res == n + 1) puts(&quot;-1&quot;); else cout &lt;&lt; res &lt;&lt; '\\n'; return 0;}","link":"/2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AMoovie-Mooving-%EF%BC%88%E7%8A%B6%E5%8E%8Bdp%EF%BC%89.html"},{"title":"每日一题：Medians and Partition","text":"题意最多可以把数组分成几个部分，使得每部分中位数都大于等于$m$。$(n,m,a[i] \\in [1,5000])$ Solution思维题，可以发现答案就是大于等于 $m$ 的个数减去小于 $m$ 的个数。 Code12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int n, m, x, s1 = 0, s2 = 0; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; x; if (x &gt;= m) s1++; else s2++; } cout &lt;&lt; max(0, s1 - s1); return 0;}","link":"/2020/10/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AMedians-and-Partition.html"},{"title":"每日一题：Optimal Sum","text":"题目给你长度为 $n$ 的序列，你有一种能力可以将序列中的任意一个数变为相反数，在你不超过 $k$ 次使用能力的情况下，长度为 $len$ 的子区间的和的绝对值的最大值是多少？ Solution用两个multiset维护区间前k大的负数，扫一遍就好了，细节略多。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n, len, k;ll x1, x2, a[200005];ll solve() { ll sum = 0, ma = -1e18; multiset&lt;ll&gt; s1, s2; for (int i = 1; i &lt;= n; i++) { if (a[i] &gt;= 0) sum += a[i]; else if (s1.size() &lt; k) { s1.insert(a[i]); sum -= a[i]; } else if (k &amp;&amp; a[i] &lt; *(--s1.end())) { ll x = *(--s1.end()); sum += 2 * x; s1.erase(--s1.end()); s2.insert(x); s1.insert(a[i]); sum -= a[i]; } else { s2.insert(a[i]); sum += a[i]; } int j = i - len; if (j &gt; 0) { if (a[j] &gt;= 0) sum -= a[j]; else if (s1.find(a[j]) != s1.end()) { s1.erase(s1.find(a[j])); sum += a[j]; if (s2.size() &gt; 0) { ll x = *(s2.begin()); s1.insert(x); s2.erase(s2.begin()); sum -= 2 * x; } } else { s2.erase(s2.find(a[j])); sum -= a[j]; } } if (j &gt;= 0) ma = max(ma, sum); } return ma;}int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;len); for (int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;a[i]); scanf(&quot;%d&quot;, &amp;k); x1 = solve(); for (int i = 1; i &lt;= n; i++) a[i] = -a[i]; x2 = solve(); printf(&quot;%lld\\n&quot;, max(x1, x2)); return 0;}","link":"/2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AOptimal-Sum.html"},{"title":"每日一题：Playing Tag on Tree","text":"题意给定一棵树，A 在 $x$ 点，B 在 $y$ 点，B 追 A，两人每次可以往相邻点移动，A 先跑，问 A 最晚什么时候被追上。 Solution结论：找到一个点，满足 $dis_B &gt; dis_A$ 且 $dis_B$ 最大，即为最终落脚点。 因为直观上来说，明显最后的点离 B 越远越好，但这个点可能离 A 更远，因此需要满足 $dis_B &gt; dis_A$。 Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 5;int dis[2][N];vector&lt;int&gt; g[N];void bfs(int be, int id) { queue&lt;int&gt; q; q.push(be); dis[id][be] = 1; while (!q.empty()) { int u = q.front(); q.pop(); for (auto v : g[u]) { if (!dis[id][v]) { dis[id][v] = dis[id][u] + 1; q.push(v); } } }}int main() { int n, x, y, u, v, res = 0; cin &gt;&gt; n &gt;&gt; x &gt;&gt; y; for (int i = 1; i &lt; n; i++) { cin &gt;&gt; u &gt;&gt; v; g[u].push_back(v); g[v].push_back(u); } bfs(x, 0); bfs(y, 1); for (int i = 1; i &lt;= n; i++) { if (dis[0][i] &lt; dis[1][i]) res = max(res, dis[1][i] - 2); } cout &lt;&lt; res &lt;&lt; endl; return 0;}","link":"/2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9APlaying-Tag-on-Tree.html"},{"title":"每日一题：Protecting the Flower （贪心）","text":"题意一共有 $n$ 只牛在花坛旁边，第 $i$ 头牛每分钟破坏 $d_i$ 朵花，把第i头牛带回牛棚需要 $2 \\times ti$ 这么多时间，每次只能带回一头牛，请问怎样能使得被破坏的花最少。 solution以小化大，先考虑两头牛，先领 $a$ ，损失为：$2\\times{t_a}\\times{d_b}$，先领 $b$，损失为 $2\\times{t_b}\\times{d_a}$，故得到排序条件 ${a_t \\times {b_d} &lt; b_t \\times {a_d}}$，最后模拟得出答案。 Code12345678910111213141516171819#include &lt;bits/stdc++.h&gt;#define x first#define y second#define PI pair&lt;int, int&gt;#define ll long longusing namespace std;ll n, sum, res;pair&lt;int, int&gt; p[200005];int main() { cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; p[i].x &gt;&gt; p[i].y; sort(p + 1, p + n + 1, [](PI a, PI b) { return a.x * b.y &lt; b.x * a.y; }); for (int i = 1; i &lt;= n; i++) { res += sum * p[i].y; sum += p[i].x * 2; } cout &lt;&lt; res &lt;&lt; '\\n'; return 0;}","link":"/2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AProtecting-the-Flower-%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%89.html"},{"title":"每日一题：Treepath","text":"题意：给定一棵n个节点的树，求偶数长度路径的数量。 Solution1:考虑树的深度对距离的影响，可以发现，深度奇偶性相同的点之间的距离总是偶数。 证明：我们先将深度更大的点走到和另一个点深度相同，显然需要偶数步，然后两个点同时移动到最近公共节点，可知所用的步数是相同的，加起来也是偶数。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5;int n, idx, h[N], dep[N];struct Node { int to, next;} E[N];void add(int a, int b) { E[idx].to = b, E[idx].next = h[a], h[a] = idx++; }void dfs(int u, int fa) { dep[u] = dep[fa] + 1; for (int i = h[u]; ~i; i = E[i].next) { int v = E[i].to; if (v == fa) continue; dfs(v, u); }}int main() { memset(h, -1, sizeof(h)); cin &gt;&gt; n; for (int i = 1; i &lt; n; i++) { int x, y; cin &gt;&gt; x &gt;&gt; y; add(x, y); add(y, x); } dfs(1, 0); long long odd = 0, even = 0, res; for (int i = 1; i &lt;= n; i++) { if (dep[i] &amp; 1) odd++; else even++; } res = odd * (odd - 1) / 2 + even * (even - 1) / 2; cout &lt;&lt; res &lt;&lt; '\\n'; return 0;} solution2:考虑树形dp。$dp[i][0/1]$ 表示从 i 出发，长度为偶数/奇数的路径数。 从子节点到父节点状态转移： $dp[u][1] += dp[v][0]$ $dp[u][0] += dp[v][1]$ 对于 $u$ 的每一个儿子 $v$，贡献即为 $dp[u][0] \\times dp[v][1] + dp[u][1] \\times dp[v][0]$, dfs回溯时进行合并更新即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5;typedef long long ll;int n, idx, h[N];ll res, dp[N][2];struct Node { int to, next;} E[N];void add(int a, int b) { E[idx].to = b, E[idx].next = h[a], h[a] = idx++; }void dfs(int u, int fa) { dp[u][0] = 1; for (int i = h[u]; ~i; i = E[i].next) { int v = E[i].to; if (v == fa) continue; dfs(v, u); res += dp[v][0] * dp[u][1]; res += dp[v][1] * dp[u][0]; dp[u][0] += dp[v][1]; dp[u][1] += dp[v][0]; }}int main() { memset(h, -1, sizeof(h)); cin &gt;&gt; n; for (int i = 1; i &lt; n; i++) { int x, y; cin &gt;&gt; x &gt;&gt; y; add(x, y); add(y, x); } dfs(1, 0); cout &lt;&lt; res &lt;&lt; '\\n'; return 0;} 总结关于树上统计问题一直是个人较怕的题目（虽然经常出现但几乎每次都不会做 T_T），树上问题往往离不开dfs，需要考虑父子节点的转移，必要时可以考虑树形dp。","link":"/2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9ATreepath.html"},{"title":"每日一题：Two Graphs（暴力）","text":"题意给一个小图和一个大图，问大图有多少个子图形状和小图一样。 solution最多只有8个点，因为每个点标号可能不一样，因此可以全排列枚举所有点的位置，然后判断小图有的边大图是否也有（因为原来边的属性还在），并通过hash进行去重。 Code1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;int n, m1, m2, res, pre[10], mp1[10][10], mp2[10][10];map&lt;long long, int&gt; p;int main() { while (~scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m1, &amp;m2)) { memset(mp1, 0, sizeof(mp1)); memset(mp2, 0, sizeof(mp2)); p.clear(); res = 0; for (int i = 1; i &lt;= m1; i++) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); mp1[x][y] = mp1[y][x] = 1; } for (int i = 1; i &lt;= m2; i++) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); mp2[x][y] = mp2[y][x] = i; } for (int i = 1; i &lt;= n; i++) pre[i] = i; do { int flag = 1; long long now = 0; for (int i = 1; i &lt;= n &amp;&amp; flag; i++) { for (int j = 1; j &lt;= n &amp;&amp; flag; j++) { if (mp1[i][j] == 1) { if (!mp2[pre[i]][pre[j]]) flag = 0; now |= 1LL &lt;&lt; (mp2[pre[i]][pre[j]]); } } } if (flag &amp;&amp; p[now] == 0) { res++; p[now] = 1; } } while (next_permutation(pre + 1, pre + n + 1)); printf(&quot;%d\\n&quot;, res); } return 0;}","link":"/2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9ATwo-Graphs%EF%BC%88%E6%9A%B4%E5%8A%9B%EF%BC%89.html"},{"title":"每日一题：Yet Another Counting Problem","text":"题意给你两个数 $a$ 和 $b$，$q$ 次询问 $[l,r]$ 内满足 (($x$ mod $a$) mod $b$) != (($x$ mod $b$) mod $a$) 的 $x$ 个数。（$q&lt;=500,1&lt;=a,b&lt;=200,1&lt;=l&lt;=r&lt;=1e18$） solution若 x % a % b != x % b % a，则(x + a $\\times$ b ) % a % b != (x + $a \\times b$ ) % b % a. 可以得到规律一定是以 a $\\times$ b 为循环的，因此预处理前 a $\\times$ b个即可。 Code12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 2e5 + 5;ll t, a, b, q, l, r, sl, sr, sum[N];int main() { cin &gt;&gt; t; while (t--) { cin &gt;&gt; a &gt;&gt; b &gt;&gt; q; int p = a * b; for (int i = 1; i &lt; p; i++) sum[i] = sum[i - 1] + (i % a % b != i % b % a); while (q--) { cin &gt;&gt; l &gt;&gt; r; l--; sl = l / p * sum[p - 1] + sum[l % p]; sr = r / p * sum[p - 1] + sum[r % p]; cout &lt;&lt; sr - sl &lt;&lt; ' '; } cout &lt;&lt; '\\n'; } return 0;}","link":"/2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AYet-Another-Counting-Problem.html"},{"title":"每日一题：codeJan与旅行（贪心）","text":"题意给定n个城市坐标，每个城市可以多次到达，问一共到m次，最短花费。给出起始位置，并且起始位置不在城市上。 solution不难猜到要么就是一条路走到黑要么就是在路上找的两个城市然后一直往返。因此我们从原来的位置，往左右两边一直走下去，顺便枚举路上每两座城市之间横跳的花费，维护最小花费，同时注意边界情况。 Code1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5;typedef long long LL;LL ans, a[N];int _, n, m, p;void solve(int k, int res) { for (int i = k; i &lt;= n; i++) { if (i &gt; 1 &amp;&amp; m - (i - k) &gt;= 0) { LL tmp = res + (a[i] - a[k]) + (a[i] - a[i - 1]) * (m - (i - k)); ans = min(ans, tmp); } } for (int i = k - 1; i &gt;= 1; i--) { if (i &lt; n &amp;&amp; m - (k - i) &gt;= 0) { LL tmp = res + (a[k] - a[i]) + (a[i + 1] - a[i]) * (m - (k - i)); ans = min(ans, tmp); } }}int main() { for (scanf(&quot;%d&quot;, &amp;_); _; _--) { ans = 1e18; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;p); for (int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;a[i]); m--; int k = upper_bound(a + 1, a + 1 + n, p) - a; if (k &lt;= n) solve(k, a[k] - p); if (k &gt; 1) solve(k - 1, p - a[k - 1]); printf(&quot;%lld\\n&quot;, ans); } return 0;}","link":"/2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AcodeJan%E4%B8%8E%E6%97%85%E8%A1%8C%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%89.html"},{"title":"每日一题：不同子序列个数(升级版)","text":"题意给定一个长度为 $n$ 的数组，求长度为 $n-m$ 的不同子序列个数。（$1&lt;=n&lt;=1e5, m&lt;=10$） Solution$dp[i][j]$ 表示长度为 $i$，删除 $j$ 个元素的子序列个数，不考虑重复的话，有 $dp[i][j] = dp[i-1][j] + dp[i-1][j-1]$（即已经删除了 $j$ 个和已经删除了 $j-1$ 个再删除这一个的情况）。 考虑去重。如果是单纯求不限长度的不同子序列的去重，容易得到：$dp[i] -= dp[pre[a[i]] - 1]$ （$pre[a[i]]$ 为上一次 $a[i]$ 出现的位置），在此题中也是同理，我们需要剔除 $[pre[a[i]], i]$ 之间的元素，假设我们当前需要剔除 $j$ 个元素，那么在$pre[a[i]]-1$之前我们先需要剔除 $j-(i-pre[a[i]])$ 个元素， $dp[i][j] -= dp[pre[a[i]]-1][j-(i-pre[a[i]])]$，初始化为所有的 $dp[i][0] = 1$。 Code123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 5;const int mod = 1e9 + 7;int n, m, k, pre[N], dp[N][12];int main() { while (cin &gt;&gt; n &gt;&gt; m &gt;&gt; k) { memset(dp, 0, sizeof(dp)); memset(pre, 0, sizeof(pre)); for (int i = 0; i &lt;= n; i++) dp[i][0] = 1; for (int i = 1; i &lt;= n; i++) { int x; cin &gt;&gt; x; for (int j = 1; j &lt;= min(i, m); j++) { dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1]) % mod; if (pre[x] &amp;&amp; j - (i - pre[x]) &gt;= 0) dp[i][j] = (dp[i][j] - dp[pre[x] - 1][j - (i - pre[x])] + mod) % mod; } pre[x] = i; } cout &lt;&lt; dp[n][m] &lt;&lt; '\\n'; } return 0;}","link":"/2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E4%B8%8D%E5%90%8C%E5%AD%90%E5%BA%8F%E5%88%97%E4%B8%AA%E6%95%B0-%E5%8D%87%E7%BA%A7%E7%89%88.html"},{"title":"每日一题：不同子序列个数","text":"题意给定一个长度为 $n$ 的字符串，求不同的子序列个数。 Solution很经典的一道计数dp。我们用 $dp[i]$ 表示以前 $i$ 个字符中的不同子序列个数： 当 $s[i]$ 之前没有出现过：$dp[i] = dp[i - 1] * 2 + 1$ ，即前 $i - 1$ 个不同子序列个数 + 前 $i - 1$ 个不同子序列与当前的 $s[i]$ 结合 + 单独一个 $s[i]$ 成为字符串。 当 $s[i]$ 之前出现过：$dp[i] = dp[i - 1] * 2 - dp[上一次出现的位置 - 1]$ ，因为以该字符结尾的情况我们之前已经计算过一次，因此要减去上一次计算的结果，否则会产生重复计算。 Code12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6 + 5;const long long mod = 1e9 + 7;char s[N];int n, vis[N];long long dp[N];int main() { cin &gt;&gt; n &gt;&gt; s + 1; for (int i = 1; i &lt;= n; i++) { if (vis[s[i]]) dp[i] = (dp[i - 1] * 2 - dp[vis[s[i]] - 1] + mod) % mod; else dp[i] = (dp[i - 1] * 2 + 1) % mod; vis[s[i]] = i; } cout &lt;&lt; dp[n] &lt;&lt; '\\n'; return 0;}","link":"/2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E4%B8%8D%E5%90%8C%E5%AD%90%E5%BA%8F%E5%88%97%E4%B8%AA%E6%95%B0.html"},{"title":"每日一题：不相交线段的最小最大值","text":"题意在一维数轴上给出 $m$ 个线段，每个线段都都有 $l,r,w$ 三个数据代表这个线段的左右端点和这个区间权值。 从中取出若干个不相交的线段(区间端点可以共用)，在覆盖满 $[1,n]$ 的情况下，取出的线段中 $权重的最大值]$ 最小能为多少？ Solution$dp[i]$ 代表覆盖满 $[1,i]$ 最大权值最小为多少，然后按左端点从小到大枚举线段，就有 $dp[r_i]=min(dp[r_i],max(dp[l_i],w_i))$。 Code1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;struct Node { int l, r; ll w;} q[200005];bool cmp(Node x, Node y) { return x.l &lt; y.l; }ll dp[100005];int main() { int n, m; while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;m)) { for (int i = 1; i &lt;= m; i++) scanf(&quot;%d%d%lld&quot;, &amp;q[i].l, &amp;q[i].r, &amp;q[i].w); sort(q + 1, q + m + 1, cmp); for (int i = 0; i &lt;= n; i++) dp[i] = 1e18; dp[1] = 0; for (int i = 1; i &lt;= m; i++) dp[q[i].r] = min(dp[q[i].r], max(dp[q[i].l], q[i].w)); if (dp[n] == 1e18) puts(&quot;invalid data&quot;); else printf(&quot;%lld\\n&quot;, dp[n]); } return 0;}","link":"/2020/09/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%BA%BF%E6%AE%B5%E7%9A%84%E6%9C%80%E5%B0%8F%E6%9C%80%E5%A4%A7%E5%80%BC.html"},{"title":"每日一题：中位数图","text":"题意给定一个 $1-n$ 排列，求长度为奇数子串以 $b$ 为中位数的子串个数。 solution由于求的是中位数，所以我们只需要关心这个数和 $b$ 的大小关系就好了，大于 $b$ 看作 1，小于 $b$ 看作 -1，等于 $b$ 看作 0，问题转化为求包含 0 且和为 0 的子串有多少个。 从 $b$ 的位置开始遍历，map 统计右边累加的和，然后从左边累加的和中查找对应的相反数个数，累加即可。同时，如果遍历过程中任何一边已经存在和为 0 的情况，也为可行解。 Code12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;map&lt;int, int&gt; mp;int n, b, sum, pos, res, a[200005];int main() { cin &gt;&gt; n &gt;&gt; b; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; if (a[i] &gt; b) a[i] = 1; else if (a[i] &lt; b) a[i] = -1; else if (a[i] == b) { a[i] = 0; pos = i; } } for (int i = pos + 1; i &lt;= n; i++) { sum += a[i]; mp[sum]++; if (sum == 0) res++; } sum = 0; for (int i = pos - 1; i; i--) { sum += a[i]; res += mp[-sum]; if (sum == 0) res++; } cout &lt;&lt; res + 1 &lt;&lt; '\\n'; return 0;}","link":"/2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E4%B8%AD%E4%BD%8D%E6%95%B0%E5%9B%BE.html"},{"title":"每日一题：二维网格图中探测环","text":"题目问二维矩阵中是否存在相同字母构成的环。 Solution判环问题，显然可以想到并查集。遍历矩阵，若该点与之前遍历过的相邻点字符相同且是同一个根的话，说明存在环，否则合并这两个点。 Code12345678910111213141516171819202122232425262728293031class Solution { static int[] pre = new int[500005]; public int find(int x) { return pre[x] == x ? x : (pre[x] = find(pre[x])); } public boolean join(int x, int y) { int fx = find(x), fy = find(y); if (fx == fy) return true; pre[fx] = fy; return false; } public boolean containsCycle(char[][] grid) { int n = grid.length, m = grid[0].length; for (int i = 0; i &lt; n * m; i++) pre[i] = i; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { if (i &gt; 0 &amp;&amp; grid[i][j] == grid[i - 1][j] &amp;&amp; join(i * m + j, (i - 1) * m + j)) { return true; } if (j &gt; 0 &amp;&amp; grid[i][j] == grid[i][j - 1] &amp;&amp; join(i * m + j, i * m + j - 1)) { return true; } } } return false; }}","link":"/2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E4%BA%8C%E7%BB%B4%E7%BD%91%E6%A0%BC%E5%9B%BE%E4%B8%AD%E6%8E%A2%E6%B5%8B%E7%8E%AF.html"},{"title":"每日一题：交换字符串中的元素","text":"题意给你一个字符串 $s$，以及该字符串中的一些「索引对」数组 $pairs$，其中 $pairs[i] = [a, b]$ 表示字符串中的两个索引（编号从 $0$ 开始）。 你可以 任意多次交换 在 $pairs$ 中任意一对索引处的字符。 返回在经过若干次交换后，$s$ 可以变成的按字典序最小的字符串。 Solution 假设 $i$ 可以和 $j$ 交换，$j$ 可以和 $k$ 交换，那么 $i$ 就可以和 $k$ 交换，因此是具有传递关系的。因此将互相具有传递关系的索引看作一个集合，用并查集维护。然后对于每个集合，将字母从小到大排序放置即可。时间复杂度 $O(nlog(n))$。 Code12345678910111213141516171819202122232425262728293031323334class Solution {public: int fa[100005], v[100005]; int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); } string smallestStringWithSwaps(string s, vector&lt;vector&lt;int&gt;&gt;&amp; pairs) { int n = s.size(); for (int i = 0; i &lt; n; i++) fa[i] = i; for (auto&amp; p : pairs) { int fx = find(p[0]), fy = find(p[1]); if (fx != fy) fa[fx] = fy; v[p[0]] = v[p[1]] = true; } int cnt = 0; map&lt;int, int&gt; mp; vector&lt;int&gt; id[100005]; vector&lt;char&gt; ch[100005]; for (int i = 0; i &lt; n; i++) { if (!v[i]) continue; int fx = find(i); if (!mp[fx]) mp[fx] = ++cnt; id[mp[fx]].push_back(i); ch[mp[fx]].push_back(s[i]); } for (int i = 1; i &lt;= cnt; i++) { sort(ch[i].begin(), ch[i].end()); cout &lt;&lt; ch[i].size() &lt;&lt; endl; for (int j = 0; j &lt; (int)id[i].size(); j++) s[id[i][j]] = ch[i][j]; } return s; }};","link":"/2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E4%BA%A4%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0.html"},{"title":"每日一题：储物点的距离","text":"题意给定 $i$ 和 $i+1$两点的距离和 $i$ 点的货物数量，$m$ 次询问将 $[l,r]$ 所有物品搬到 $x$ 点的总费用（区间内每个物品各自离 $x$ 点距离和）。（$n,m &lt;= 200000 , 0 &lt;= ai,bi &lt;= 2000000000$） soltuion前缀和维护：$sum1$ 表示每个储物点离原点0的距离，$sum2$ 表示前 $i$ 个储物点共有多少货物，$sum3$ 表示前 $i$ 个储物点的所有物品到原点0的和。 $x&lt;=l$，即 $[l,r]$ 所有物品到原点的距离 - 到 $x$ 点的距离。 $x&gt;=r$，即 $[l,r]$ 所有物品从 $x$ 点到原点的距离 - 从原位置到原点的距离。 处于中间的情况，就是拆解成 $[l,x],[x+1,r]$ 两种情况，然后分别带入上面情况即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod = 1000000007;const int N = 2e5 + 5;int n, m, l, r;ll x, res, sum1[N], sum2[N], sum3[N];int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 2; i &lt;= n; i++) { cin &gt;&gt; x; sum1[i] = (sum1[i - 1] + x) % mod; } for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; x; sum2[i] = (sum2[i - 1] + x) % mod; sum3[i] = (sum3[i - 1] + sum1[i] * x) % mod; } while (m--) { cin &gt;&gt; x &gt;&gt; l &gt;&gt; r; if (x &lt;= l) res = ((sum3[r] - sum3[l - 1] + mod) % mod - (sum2[r] - sum2[l - 1] + mod) % mod * sum1[x] % mod + mod) % mod; else if (x &gt;= r) res = ((sum1[x] * ((sum2[r] - sum2[l - 1] + mod) % mod)) % mod - sum3[r] + sum3[l - 1] + mod) % mod; else { res = (((sum3[r] - sum3[x] + mod) % mod - (sum2[r] - sum2[x] + mod) % mod * sum1[x] + mod) % mod + ((sum1[x] * ((sum2[x] - sum2[l - 1] + mod) % mod)) % mod - sum3[x] + sum3[l - 1] + mod) % mod) % mod; } cout &lt;&lt; (res + mod) % mod &lt;&lt; '\\n'; } return 0;}","link":"/2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%82%A8%E7%89%A9%E7%82%B9%E7%9A%84%E8%B7%9D%E7%A6%BB.html"},{"title":"每日一题：共鸣问题","text":"题意现在有 $n$ 个音符和 $m$ 对共鸣关系，编号为 $1-n$，每个音符自己有一个奏响时的优美程度，共鸣关系 $(x,y,z)$ 表示音符 $x$ 和 $y$ 同时奏响的额外优美程度是 $z$，同时不奏响则为 $-z$，其他情况为 $0$，求最大优美程度。$(n,m \\in [1,1e5])$ 思路对于一对共鸣关系而言，在不选的情况下收益为 $-z$，则选择一个的话，收益为 $-z + z = 0$，都选择的话为 $-z + 2z = z$。因此可以预先把每对关系的两个数都加上 $z$，刚开始我们是不选任何有联系的音符的，因此初值为 $-z$，那么选择一个数就会加上 $z$，选择两个就会加上 $2z$，满足了之前所讨论的关系。答案初始化为所有关系都不选的情况，即 $-sum(z)$，然后只要贪心的选择对答案有正贡献的值就行了。 Code12345678910111213141516171819202122232425class Solution {public: /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * @param n int整型 * @param m int整型 * @param a int整型vector * @param b int整型vector&lt;vector&lt;&gt;&gt; * @return long长整型 */ long long wwork(int n, int m, vector&lt;int&gt;&amp; a, vector&lt;vector&lt;int&gt; &gt;&amp; b) { // write code here vector&lt;long long&gt; c; long long res = 0; for (auto&amp; x : a) c.push_back(x); for (auto&amp; v : b) { c[v[0] - 1] += v[2]; c[v[1] - 1] += v[2]; res -= v[2]; } for (auto&amp; x : c) res += max(x, 0); return res; }};","link":"/2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%85%B1%E9%B8%A3%E9%97%AE%E9%A2%98.html"},{"title":"每日一题：加分二叉树 （树形dp&#x2F;区间dp）","text":"题意有一颗二叉树，树的每一个节点都有一个值，设他的中序遍历为（l,2,3,…,n），其中数字1,2,3,…,n为节点编号。 任一棵子树subtree（也包含tree本身）的加分计算方法如下： subtree的左子树的加分× subtree的右子树的加分＋subtree的根的分数若某个子树为主，规定其加分为1，叶子的加分就是叶节点本身的分数。不考虑它的空子树。 试求一棵符合中序遍历为（1,2,3,…,n）且加分最高的二叉树tree。 要求输出：（1）tree的最高加分（2）tree的前序遍历 solution符合条件的二叉树是加分最高的二叉树，它的总分依题意得 总分 = 左子树分数 * 右子树分数 + 根节点分数 ，想要总分最高，左右子树的分数应当也分别取最高。 题目中给出的节点序号根据二叉树的中序遍历排列，$dp[l][r]$ （l&lt;r） 表示从节点 $l$ 到节点 $r$ 所构成的子树的最高加分。设$k(l \\le k \\le r)$为该子树的根节点，通过枚举当前 $[l,r]$ 某点为根来取得不同的左右子树和根节点分数，维护最大值。 状态转移方程： $dp[i][j]=max(dp[i][j],dp[i][k-1]*dp[k+1][r]+dp[k][k])$ 最后维护一个 $root$ 数组表示节点 $l-r$ 最高分子树的根即可。 Code123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 35;int n, root[N][N];ll dp[N][N];void dfs(int l, int r) { if (l &gt; r) return; cout &lt;&lt; root[l][r] &lt;&lt; ' '; dfs(l, root[l][r] - 1); dfs(root[l][r] + 1, r);}int main() { cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; dp[i][i]; dp[i][i - 1] = 1; dp[i + 1][i] = 1; root[i][i] = i; } for (int i = 1; i &lt;= n; i++) { for (int l = 1; l + i &lt;= n; l++) { int r = l + i; for (int k = l; k &lt;= r; k++) { int tmp = dp[l][k - 1] * dp[k + 1][r] + dp[k][k]; if (dp[l][r] &lt; tmp) { dp[l][r] = tmp; root[l][r] = k; } } } } cout &lt;&lt; dp[1][n] &lt;&lt; '\\n'; dfs(1, n); return 0;}","link":"/2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%8A%A0%E5%88%86%E4%BA%8C%E5%8F%89%E6%A0%91-%EF%BC%88%E6%A0%91%E5%BD%A2dp-%E5%8C%BA%E9%97%B4dp%EF%BC%89.html"},{"title":"每日一题：区间和的个数","text":"题目给定一个整数数组 $a$，返回区间和在 $[lower, upper]$ 之间的个数，包含 $lower$ 和 $upper$。区间和 $S(i, j)$ 表示在 $a$ 中，位置从 $i$ 到 $j$ 的元素之和，包含 $i$ 和 $j$ $(i ≤ j)$。 Solution 维护前缀和，对于每个前缀和 $sum[i]$，等价于 $sum[0…i-1]$ 里面有多少个数满足差值在 $[lower, upper]$ 之间。 $sum[i] - sum[j] = [lower, upper]$ 等价于求出现在区间 $sum[j] \\in [sum[i] - upper, sum[i] - lower]$ 的数的个数，故可以用树状数组维护。 遍历前缀和数组，对于当前前缀和 $sum[i]$，满足的个数便为：$query(sum[i] - lower) - query(sum[i] - upper - 1)$，累加答案即可。 由于数很大，故需要将所有出现的数离散化。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class BIT { public: int* c; int n; public: BIT(int _n) { n = _n; c = new int[n + 1]; for (int i = 0; i &lt;= n; i++) c[i] = 0; } static constexpr int lowbit(int x) { return x &amp; (-x); } void add(int x) { while (x &lt;= n) { c[x]++; x += lowbit(x); } } int query(int x) { int sum = 0; while (x) { sum += c[x]; x -= lowbit(x); } return sum; }};class Solution {public: int countRangeSum(vector&lt;int&gt;&amp; a, int lower, int upper) { set&lt;long long&gt; s; int m = a.size(); long long *sum = new long long[m + 1]; sum[0] = 0; for (int i = 0; i &lt;= m; i++) { if (i) sum[i] = sum[i - 1] + a[i - 1]; s.insert(sum[i]); s.insert(sum[i] - upper); s.insert(sum[i] - lower); } unordered_map&lt;long long, int&gt; mp; int n = s.size(), idx = 0; BIT bit(n); for (auto x : s) mp[x] = ++idx; int res = 0; for (int i = 0; i &lt;= m; i++) { int l = mp[sum[i] - upper], r = mp[sum[i] - lower]; res += bit.query(r) - bit.query(l - 1); bit.add(mp[sum[i]]); } return res; }};","link":"/2020/11/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%8C%BA%E9%97%B4%E5%92%8C%E7%9A%84%E4%B8%AA%E6%95%B0.html"},{"title":"每日一题：合并回文子串（区间DP）","text":"题意给定两个字符串，各取出一个子串接在一起，求最长回文子串的长度。 solution先考虑普通的求最长回文子串的dp做法: $dp[i][j] = 0/1 $ 表示子串 $i~j$ 是否为回文串。 那么，容易得到：$dp[i][j] = (dp[i+1][j-1]$ &amp;&amp; $s[i]==s[j])$。 由于 $i$ 是由 $i+1$ 转移过来的，所以我们需要倒着遍历： Code1234567for (int i = s.size() - 1; i &gt;= 0; i--) for (int j = i; j &lt; s.size(); j++) { if (s[i] == s[j] &amp;&amp; (j - i &lt; 2 || dp[i + 1][j - 1])) { dp[i][j] = true; res = max(res, j - i + 1); } } 那么这题其实可以类比： $dp[i][j][k][l]$ 表示a串第i个字符到第j个字符和b串第k个字符到第l个字符是否组成回文串： 往 $a[i+1]$ 到 $a[j−1]$ 和 $b[k]$ 到 $b[l]$ 构成的串的两端加上 $a[i]$ 和 $a[j]$ 两个字符： $dp[i][j][k][l] = dp[i+1][j-1][k][l] and (a[i]==a[j])$ 往 $a[i+1]$ 到 $a[j]$ 和 $b[k]$ 到 $b[l-1]$ 构成的串的两端加上 $a[i]$ 和 $b[l]$ 两个字符： $dp[i][j][k][l] = dp[i+1][j][k][l-1] and (a[i]==b[l])$ 往 $a[i]$ 到 $a[j-1]$ 和 $b[k+1]$ 到 $b[l]$ 构成的串的两端加上 $b[k]$ 和 $a[j]$ 两个字符： $dp[i][j][k][l] = dp[i][j-1][k+1][l] and (b[k]==a[j])$ 往 $a[i]$ 到 $a[j]$ 和 $b[k+1]$ 到 $b[l-1]$ 构成的串的两端加上 $b[k]$ 和 $b[l]$ 两个字符： $dp[i][j][k][l] = dp[i][j][k+1][l-1] and (b[k]==b[l])$ 实际上就是取法由原来的一种变为了四种，注意若组成的字符串长度小于2时需要直接赋值为1 Code123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 105;char a[N], b[N];bool f[N][N][N][N];int t, n, m;int main() { scanf(&quot;%d&quot;, &amp;t); while (t--) { int res = 0; scanf(&quot;%s&quot;, a + 1); scanf(&quot;%s&quot;, b + 1); n = strlen(a + 1); m = strlen(b + 1); for (int len1 = 0; len1 &lt;= n; len1++) //枚举a串的长度 for (int len2 = 0; len2 &lt;= m; len2++) //枚举b串的长度 for (int i = 1; i + len1 - 1 &lt;= n; i++) for (int k = 1; k + len2 - 1 &lt;= m; k++) { int j = i + len1 - 1, l = k + len2 - 1; //根据左端点和长度计算右端点 if (len1 + len2 &lt;= 1) f[i][j][k][l] = 1; else { f[i][j][k][l] = 0; if (len1 &gt; 1) f[i][j][k][l] |= (f[i + 1][j - 1][k][l] &amp;&amp; (a[i] == a[j])); if (len1 &amp;&amp; len2) f[i][j][k][l] |= (f[i + 1][j][k][l - 1] &amp;&amp; (a[i] == b[l])); if (len1 &amp;&amp; len2) f[i][j][k][l] |= (f[i][j - 1][k + 1][l] &amp;&amp; (a[j] == b[k])); if (len2 &gt; 1) f[i][j][k][l] |= (f[i][j][k + 1][l - 1] &amp;&amp; (b[k] == b[l])); } if (f[i][j][k][l]) res = max(res, len1 + len2); } printf(&quot;%d\\n&quot;, res); } return 0;}","link":"/2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%90%88%E5%B9%B6%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%EF%BC%88DP%EF%BC%89.html"},{"title":"每日一题：图的遍历","text":"题意无向图 $n$ 个点，每次必须跳两个，至少需要加多少条边可以遍历所有点。 solution首先，如果图不联通，那么需要加联通分量 - 1 条边使图联通，然后发现一点，只要这个图存在奇数环，就一定能全部走完，不存在的话，随便加一条边生成奇数环即可。 Code12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5;int n, m, odd, x, y, res, vis[N], color[N];vector&lt;int&gt; g[N];void dfs(int u) { for (auto v : g[u]) { if (!vis[v]) { vis[v] = 1; color[v] = !color[u]; dfs(v); } else if (color[u] == color[v]) odd = 1; }}int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; x &gt;&gt; y; g[x].push_back(y); g[y].push_back(x); } for (int i = 1; i &lt;= n; i++) { if (!vis[i]) { res++; vis[i] = color[i] = 1; dfs(i); } } cout &lt;&lt; res - odd &lt;&lt; '\\n'; return 0;}","link":"/2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86.html"},{"title":"每日一题：地下城游戏 （dp）","text":"题意给定权值矩阵，需要从左上角走到右下角，只能往右或往下走且权值会累加，问至少需要提前准备多少权值才能保证过程中不出现权值被耗尽的情况。 Solution正着不太好写，可以尝试倒过来dp，$dp[i][j]$ 表示当前位置到终点至少需要准备多少权值，这样每个点要么从下边转移，要么从右边转移，选择最小的那个点转移即可，过程中需要保证权值至少为1，得到转移方程：$dp[i][j] = max(min(dp[i+1][j],dp[i][j+1])-mp[i][j],1)$。 Code12345678910111213141516class Solution { public int calculateMinimumHP(int[][] mp) { int n = mp.length, m = mp[0].length; int[][] dp = new int[n + 1][m + 1]; for(int i = n; i &gt;= 0; i--) { Arrays.fill(dp[i], Integer.MAX_VALUE); } dp[n][m - 1] = dp[n - 1][m] = 1; for(int i = n - 1; i &gt;= 0; i--) { for(int j = m - 1; j &gt;= 0; j--) { dp[i][j] = Math.max(Math.min(dp[i + 1][j], dp[i][j + 1]) - mp[i][j], 1); } } return dp[0][0]; }}","link":"/2020/07/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F-%EF%BC%88dp%EF%BC%89.html"},{"title":"每日一题：大逃离","text":"题意从 $n$ 个数中任选 $k$ 个数，取得这 $k$ 个数中最大的一个数，求每个数被取得的概率。$(n, k \\in [1, 2e5])$ Solution将数组排序后，枚举每个数被作为最大值的可能性，当第 $i$ 个数作为最大值时，其它 $k - 1$ 个一定从前 $i - 1$ 个里面选，即方案数为 $C(i - 1, k - 1)$，将其除以总方案数 $C(n, k)$ 即为被取得概率。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution {public: /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * @param n int整型 * @param k int整型 * @param Point int整型vector * @return int整型vector */ long long mod = 1e9 + 7; long long f[200005]; long long qp(long long a, long long b) { long long sum = 1; while (b) { if (b &amp; 1) sum = sum * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return (int)sum; } long long C(int n, int m){ if(n == m || m == 0) return 1; return f[n] * qp(f[m], mod - 2) % mod * qp(f[n - m], mod - 2) % mod; } vector&lt;int&gt; city(int n, int k, vector&lt;int&gt;&amp; a) { // write code here auto b = a; sort(a.begin(), a.end()); vector&lt;int&gt; g; map&lt;int, long long&gt; mp; f[0] = 1; for (long long i = 1; i &lt;= 200000; ++i) { f[i] = f[i - 1] * i % mod; } for (int i = 0; i &lt; n; ++i) { if (i + 1 &gt;= k) mp[a[i]] = C(i, k - 1); } long long sum = C(n, k); for (int i = 0; i &lt; n; i++) { g.push_back(mp[b[i]] * qp(sum, mod - 2) % mod); } return g; }};","link":"/2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%A4%A7%E9%80%83%E7%A6%BB.html"},{"title":"每日一题：子序列","text":"题意给定一个由n个元素组成的序列 { a1, a2, a3,…, an } ，她想知道其中有多少个子序列 { ap1, ap2, …, apm } $(1 ≤ m ≤ n, 1 ≤ p1 &lt; p2 ,…, &lt; pm ≤ n)$，满足对于所有的 $i, j$ $(1 ≤ i &lt; j ≤ m)$, apipj &lt; apjpi成立。 Solution1py + dp直接冲。 12345678n, mod = int(input()), int(1000000007)a = list(map(int, input().split()))dp = [ 1 for i in range(n) ]for i in range(0, n): for j in range(i): if (a[j] ** (i + 1) &lt; a[i] ** (j + 1)): dp[i] += dp[j]print(sum(dp) % mod) solution2变形公式。a[ i ]j &lt; a[ j ]i $\\Leftrightarrow$ j $\\times$ $log(a[i]) &lt; i * log(a[j])$，即原题等价于求上升子序列的数量。 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod = 1e9 + 7;ll res, dp[105], a[105];int main() { int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; dp[i] = 1; } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt; i; j++) if (j * log(a[i]) &gt; i * log(a[j])) dp[i] = (dp[i] + dp[j]) % mod; res = (res + dp[i]) % mod; } cout &lt;&lt; res &lt;&lt; '\\n'; return 0;}","link":"/2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%AD%90%E5%BA%8F%E5%88%97.html"},{"title":"每日一题：完美对物品","text":"题目$n$ 个物体，每个物品都有 $k$ 个属性，实际上就是 $a[n][k]$ 的数组，满足 $a[i][0]+a[j][0]=a[i][1]+a[j][1]=…=a[i][k−1]+a[j][k−1]$ 的物体 $i$ 和物体 $j$ 称为一对完美对，求完美对对数。 Solution 公式变形：$x1 + y1 = x2 + y2 -&gt; x1-x2 = -(y1-y2)$，用一个 $map(vector, int)$ 来记录每件物品的差值即可，然后去 $map$ 里面查找有几个正好是相反数 $vector$，累加答案即可。 Code1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;map&lt;vector&lt;int&gt;, int&gt; mp;int a[15];signed main() { int n, k, res = 0; cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; i++) { vector&lt;int&gt; g; for (int j = 1; j &lt;= k; j++) cin &gt;&gt; a[j]; for (int j = 2; j &lt;= k; j++) { g.push_back(a[j] - a[j - 1]); } res += mp[g]; for (int j = 0; j &lt; g.size(); j++) { g[j] = -g[j]; } mp[g]++; } cout &lt;&lt; res &lt;&lt; endl; return 0;}","link":"/2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%AE%8C%E7%BE%8E%E5%AF%B9%E7%89%A9%E5%93%81.html"},{"title":"每日一题：小y的序列","text":"题目最少修改几个数，使得数列满足 $a[i + 1] - a[i] = i$。$(n \\in [1, 1e5], a[i] \\in [-1e9, 1e9])$ Solution先构造一个长度为 $n$ 满足题意的初始数列，然后将所给的数减去对应的初始构造的数，差值出现的次数最多的就是最长的满足题意的序列，要修改的就是剩余的那些数。 Code123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;int main() { int n, x, p = 0, res; unordered_map&lt;int, int&gt; mp; cin &gt;&gt; n &gt;&gt; x; res = mp[x] = 1; for (int i = 1; i &lt; n; i++) { cin &gt;&gt; x; p += i; res = max(res, ++mp[x - p]); } cout &lt;&lt; n - res &lt;&lt; endl; return 0;}","link":"/2020/10/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%B0%8Fy%E7%9A%84%E5%BA%8F%E5%88%97.html"},{"title":"每日一题：建筑抢修 （贪心）","text":"题意$n$ 栋建筑，第 $i$ 栋建筑需要 $s_i$ 时间修，截止到 $t_i$ 时间，问最多可以修多少建筑。 solution我们可以类比成写作业，先截止的我们会先做，这是大体的贪心策略。但他并不是最优的，因为可能那一科会花你非常多的时间，够你做更多的科目，得不偿失。因此我们用优先队列维护做过的作业中花费时间最大的那份，当目前要做的作业时间不够的时候，与这个最大值比较看是否花的时间更少，可行的话就把这个塞进去，那个丢出来，这样做了同样多的作业却花了更少的时间，同时维护答案。 Code123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;#define x first#define y secondusing namespace std;const int N = 5e5 + 5;int n, sum, res;pair&lt;int, int&gt; p[N];priority_queue&lt;int&gt; q;int main() { cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; p[i].y &gt;&gt; p[i].x; sort(p, p + n); for (int i = 0; i &lt; n; i++) { if (sum + p[i].y &lt;= p[i].x) { sum += p[i].y; res++; q.push(p[i].y); } else if (p[i].y &lt; q.top()) { sum -= q.top(); q.pop(); q.push(p[i].y); sum += p[i].y; } } cout &lt;&lt; res &lt;&lt; '\\n'; return 0;}","link":"/2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%BB%BA%E7%AD%91%E6%8A%A2%E4%BF%AE-%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%89.html"},{"title":"每日一题：异或","text":"题目给定整数 $m$ 以及 $n$ 各数字 $A_1,A_2,..A_n$，将数列 $A$ 中所有元素两两异或，共能得到 $n(n-1)/2$ 个结果，请求出这些结果中大于 $m$ 的有多少个。 Solution为了避免重复计算，字典树可以边维护边插入，先查询之前有多少个数与当前数 $x$ 异或和大于 $m$，我们从高位向低位枚举，对于两个数的同一个二进制位，需要分四种情况讨论： $x_i = 1, m_i = 1$，则查询的数当前位必须为 $0$ 才可。 $x_i = 0, m_i = 1$，则查询的数当前位必须为 $1$ 才可。 $x_i = 1, m_i = 0$，则查询数当前位为 $0$ 的直接满足条件计入答案，当前位为 $1$ 的继续向下查找。 $x_i = 0, m_i = 0$，则查询数当前位为 $1$ 的直接满足条件计入答案，当前位为 $0$ 的继续向下查找。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 6e5 + 5;typedef long long ll;int n, m, idx, cnt[N], trie[N][2];void insert(int x) { int p = 0, y; for (int i = 31; ~i; i--) { y = x &gt;&gt; i &amp; 1; int &amp;s = trie[p][y]; if (!s) s = ++idx; p = s; cnt[p]++; }}int query(int x) { int p = 0, p1, sum = 0; for (int i = 31; ~i; i--) { int y = x &gt;&gt; i &amp; 1; int z = m &gt;&gt; i &amp; 1; if (y == 1 &amp;&amp; z == 1) { p = trie[p][0]; } else if (y == 0 &amp;&amp; z == 1) { p = trie[p][1]; } else if (y == 1 &amp;&amp; z == 0) { p1 = trie[p][0]; p = trie[p][1]; if (p1) sum += cnt[p1]; } else if (y == 0 &amp;&amp; z == 0) { p1 = trie[p][1]; p = trie[p][0]; if (p1) sum += cnt[p1]; } if (!p) break; } return sum;}int main() { long long res = 0; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) { int x; scanf(&quot;%d&quot;, &amp;x); res += query(x); insert(x); } printf(&quot;%lld\\n&quot;, res); return 0;}","link":"/2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%BC%82%E6%88%96.html"},{"title":"每日一题：找出最长的超赞子字符串","text":"题意给你一个字符串 s 。请返回 s 中最长的 超赞子字符串 的长度。 「超赞子字符串」需满足满足下述两个条件： 该字符串是 s 的一个非空子字符串进行任意次数的字符交换重新排序后，该字符串可以变成一个回文字符串 Solution首先，一个字符串可以重新排序得到一个回文字符串的充要条件是：对字符计数，出现奇数次的字符个数小于等于1。 由此我们可以发现：我们没有必要知道这个数字到底出现了几次，我们只需要关心它到底是出现了奇数次还是偶数次。我们用 $0,1$ 来表示出现了 $偶数/奇数$ 次，由于需要统计的字符只有 $0-9$ 十个数字，因此我们只需要一个十位的二进制数 $status$ 即可表示当前所有字符出现次数的奇偶状态，即第i位表示数字 $i$ 出现次数的奇偶性。 假设当前遇到的数字是 i ，那么更新它的状态就是 $status ^= (1 &lt;&lt; i)$ ，因为根据异或的特性，相同为0，不同为1，能够很好的实现我们需要的 $奇+奇(1+1)=偶+偶(0+0)=偶(0),奇+偶(1+0)= 偶+奇(0+1)=奇(1)$，改变对应二进制位的状态。 我们遍历字符串维护这样一个 $status$，采用数组标记的思想，$pre[status]$ 表示 $status$ 出现的最早位置。 满足超赞字符串的条件： 再一次遇到之前已经出现过的 $status$ ，说明所有数字都出现了偶数次。（因为每一位二进制位的奇偶性都相同的话，不论都是1还是0，$奇-奇=偶-偶=偶$，都代表这些字符在中间这一段出现了偶数次，长度为 $当前位置i - 最早出现的位置pre[status]$） 与之前出现过的 $status$ 只有一个二进制位不同，说明这个不同的二进制位出现了奇数次 $(奇-偶=偶-奇=奇)$，其余的二进制位出现了偶数次，仍然满足回文字符串的条件。针对这种情况，我们只需要从 $0-9$ 枚举二进制位，然后看之前是否出现过即可，同时维护答案。 Code1234567891011121314151617181920212223class Solution { static int[] pre = new int[1 &lt;&lt; 11]; public int longestAwesome(String s) { int n = s.length(), status = 0, res = 0; Arrays.fill(pre, -2); // pre数组初始化为-2，代表都没有出现过 pre[status] = -1; // 最初的状态为0，代表都出现了0次（偶数次） for (int i = 0; i &lt; n; i++) { status ^= 1 &lt;&lt; (s.charAt(i) - '0'); // 更新当前状态 if (pre[status] != -2) { // 之前已经存在过 res = Math.max(res, i - pre[status]); } else { // 没有存在过 pre[status] = i; } for (int j = 0; j &lt; 10; j++) { // 枚举0-9 int status1 = status ^ (1 &lt;&lt; j); // 将对应位置的奇偶性改变 if (pre[status1] != -2) { // 之前是否出现过 res = Math.max(res, i - pre[status1]); } } } return res; }}","link":"/2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%89%BE%E5%87%BA%E6%9C%80%E9%95%BF%E7%9A%84%E8%B6%85%E8%B5%9E%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html"},{"title":"每日一题：按要求补齐数组","text":"题意给定一个已排序的正整数数组 $nums$，和一个正整数 $n$ 。从 $[1, n]$ 区间内选取任意个数字补充到 $nums$ 中，使得 $[1, n]$ 区间内的任何数字都可以用 $nums$ 中某几个数字的和来表示。请输出满足上述要求的最少需要补充的数字个数。 Soluiton容易证明，对于正整数 $x$，如果区间 $[1,x−1]$ 内的所有数字都已经被覆盖，且 $x$ 在数组中，则区间 $[1,2x−1]$ 内的所有数字也都被覆盖。 由此可以提出一个贪心的方案。每次找到未被数组 $nums$ 覆盖的最小的整数 $x$，在数组中补充 $x$，然后寻找下一个未被覆盖的最小的整数，重复上述步骤直到区间 $[1,n]$ 中的所有数字都被覆盖。 具体实现： $x$ 表示当前能表示出 $[1, x - 1]$ 的所有数字，初始化为 $1$，枚举数组。 若枚举到的数小等于 $x$，则加上，表示能表示出 $[1, x + num[i] - 1]$ 的所有数字，然后下标加 $1$ 若枚举到的数大于 $x$，则说明 $x$ 无法被表示出来，我们需要增加一个数 $x$，然后$x$ 加上 $x$，表示能表示出 $[1, x + x - 1]$ 的所有数字 Code1234567891011121314151617class Solution {public: int minPatches(vector&lt;int&gt;&amp; a, int n) { long x = 1; int res = 0, i = 0, m = a.size(); while (x &lt;= n) { if (i &lt; m &amp;&amp; a[i] &lt;= x) { x += a[i]; i++; } else { x *= 2; res++; } } return res; }};","link":"/2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%8C%89%E8%A6%81%E6%B1%82%E8%A1%A5%E9%BD%90%E6%95%B0%E7%BB%84.html"},{"title":"每日一题：换个角度思考（树状数组）","text":"题意给定一个长度为 $(1&lt;=n&lt;=1e5)$ 的数组，$(1&lt;=q&lt;=1e5)$ 次询问查询区间 $[l,r]$ 内 $&lt;=k$ 的元素个数。 solution考虑树状数组。我们在查询区间 $&lt;=k$ 的个数时，为了更好计数，这个区间应该不包含 $&gt;k$ 的元素才行。因此我们不妨离线，将询问的 $k$ 从小到大排序，将数组也从小到大排序，这样从小到大处理询问，每次处理时只将 $&lt;=k$ 的数挂到树的对应下标上（因为询问的 $k$ 是从小到大的，因此之前树上的数一定比当前询问的 $k$ 要小），维护答案为 $query(r) - query(l-1)$。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;#define x first#define y secondusing namespace std;const int N = 2e5 + 5;struct Node { int l, r, v, id;} q[N];int n, m, c[N], res[N];pair&lt;int, int&gt; p[N];bool cmp(Node x, Node y) { return x.v &lt; y.v; }void update(int x) { for (; x &lt;= n; x += x &amp; (-x)) c[x]++;}int query(int x) { int sum = 0; for (; x &gt;= 1; x -= x &amp; (-x)) sum += c[x]; return sum;}int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; p[i].x; p[i].y = i; } sort(p + 1, p + n + 1); for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; q[i].l &gt;&gt; q[i].r &gt;&gt; q[i].v; q[i].id = i; } sort(q + 1, q + m + 1, cmp); int pos = 1; for (int i = 1; i &lt;= m; i++) { while (q[i].v &gt;= p[pos].x &amp;&amp; pos &lt;= n) { update(p[pos].y); pos++; } res[q[i].id] = query(q[i].r) - query(q[i].l - 1); } for (int i = 1; i &lt;= m; i++) cout &lt;&lt; res[i] &lt;&lt; '\\n'; return 0;}","link":"/2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%8D%A2%E4%B8%AA%E8%A7%92%E5%BA%A6%E6%80%9D%E8%80%83%EF%BC%88%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%EF%BC%89.html"},{"title":"每日一题：数数","text":"题目 Solution Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;typedef long long ll;const ll mod = 998244353;const ll M = 1e7;ll t, n, ans1, ans2, x, p[M + 5];ll qp(ll a, ll b){ ll ans = 1; while (b) { if (b &amp; 1) ans = (ans * a) % mod; a = (a * a) % mod; b &gt;&gt;= 1; } return ans;}int main(){ p[1] = 1; for (ll i = 2; i &lt;= M; i++) p[i] = (p[i - 1] * i) % mod; while (~scanf(&quot;%lld&quot;, &amp;t)) { while (t--) { scanf(&quot;%lld&quot;, &amp;n); ans1 = 0, ans2 = 1; if (n &amp; 1) { x = (n + 1) / 2; ans1 = (((x * n) % mod) * ((x * n) % mod)) % mod; } else { x = n / 2; ans1 = (((x * (n + 1)) % mod) * ((x * (n + 1)) % mod)) % mod; } ans2 = qp(p[n], 2 * n); printf(&quot;%lld %lld\\n&quot;, ans1, ans2); } } return 0;}","link":"/2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%95%B0%E6%95%B0.html"},{"title":"每日一题：数数组","text":"题目构造一个长度为 $n$ 的序列，每个数字大小必须满足 $l &lt;= a[i] &lt;= r$，且和被 3 整除，问有多少种方法？ Solution $dp[i][j]$ 表示长度为 $i$，余数为 $j$ 的构造数量。$a,b,c$ 表示区间内余数为 $0,1,2$ 的数的数量。 转移方程： $dp[i][0] = a dp[i - 1][0] + b dp[i - 1][2] + c dp[i - 1][1]$;$dp[i][1] = (a dp[i - 1][1] + b dp[i - 1][0] + c dp[i - 1][2]$;$dp[i][2] = (a dp[i - 1][2] + b dp[i - 1][1] + c * dp[i - 1][0]$; Code123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;ll n, l, r, dp[200005][3], a, b, c;const ll mod = 1e9 + 7;int main() { cin &gt;&gt; n &gt;&gt; l &gt;&gt; r; while (l % 3 != 0) { int x = l % 3; if (x == 1) b++; else if (x == 2) c++; l++; } while (r % 3 != 0) { int x = r % 3; if (x == 2) c++; else if (x == 1) b++; r--; } int p = (r - l) / 3; a += p; b += p; c += p; a++; dp[0][0] = 1; for (int i = 1; i &lt;= n; i++) { dp[i][0] = (a * dp[i - 1][0] + b * dp[i - 1][2] + c * dp[i - 1][1]) % mod; dp[i][1] = (a * dp[i - 1][1] + b * dp[i - 1][0] + c * dp[i - 1][2]) % mod; dp[i][2] = (a * dp[i - 1][2] + b * dp[i - 1][1] + c * dp[i - 1][0]) % mod; } cout &lt;&lt; dp[n][0] &lt;&lt; endl; return 0;}","link":"/2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%95%B0%E6%95%B0%E7%BB%84.html"},{"title":"每日一题：最多可以参加的会议数目II","text":"题意给你一个 $a$ 数组，其中 $a[i] = [startDay_i, endDay_i, value_i]$ ，表示第 $i$ 个会议在 $startDay_i$ 天开始，第 $endDay_i$ 天结束，如果你参加这个会议，你能得到价值 $value_i$ 。同时给你一个整数 $k$ 表示你能参加的最多会议数目。 你同一时间只能参加一个会议。如果你选择参加某个会议，那么你必须 完整 地参加完这个会议。会议结束日期是包含在会议内的，也就是说你不能同时参加一个开始日期与另一个结束日期相同的两个会议。 请你返回能得到的会议价值 最大和。$(k \\in [1, n], k * n \\in [1, 1e6], startDay_i, endDay_i \\in [1, 1e9], value_i \\in[1, 1e6])$ Solution 考虑动态规划。$dp[i][j]$ 表示前 $i$ 个会议刚好选 $j$ 个时，能获得的最大价值。 那么对于每个 $dp[i][j]$ 有两种情况： 不参加第 $i$ 个会议，有 $dp[i][j] = dp[i - 1][j]$ 参加第 $i$ 个会议，设第 $i$ 个会议开始时间为 $l$，那么我们应该是从 所有结束时间小于 $l$ 且刚好选 $j - 1$ 个会议 的那个状态转移过来。那么最好的方式就是一开始就将 $a$ 按结束时间排序，这样我们就能很快二分出来结束时间刚好（最后一个）小于 $l$ 的那个会议 $p$，有 $dp[i][j] = max(dp[i][j], dp[p][j - 1] + a[i].value)$。 时间复杂度 $O(nklog_n)$。 Code1234567891011121314151617181920212223242526class Solution {public: struct Node { int l, r, w; bool operator&lt; (const Node&amp; a) const{ return r &lt; a.r; } } q[1000005]; int maxValue(vector&lt;vector&lt;int&gt;&gt;&amp; a, int k) { int n = a.size(); vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt; (k + 1)); for (int i = 0; i &lt; n; i++) q[i + 1] = {a[i][0], a[i][1], a[i][2]}; sort(q + 1, q + n + 1); for (int i = 1; i &lt;= n; i++) { int l = 0, r = i, mid; while (l + 1 &lt; r) { mid = l + r &gt;&gt; 1; if (q[mid].r &lt; q[i].l) l = mid; else r = mid; } for (int j = 1; j &lt;= k; j++) dp[i][j] = max(dp[i - 1][j], dp[l][j - 1] + q[i].w); } return dp[n][k]; }};","link":"/2021/02/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%A4%9A%E5%8F%AF%E4%BB%A5%E5%8F%82%E5%8A%A0%E7%9A%84%E4%BC%9A%E8%AE%AE%E6%95%B0%E7%9B%AEII.html"},{"title":"每日一题：最多的不重叠子字符串","text":"题意给你一个只包含小写字母的字符串 s ，你需要找到 s 中最多数目的非空子字符串，满足如下条件： 这些字符串之间互不重叠，也就是说对于任意两个子字符串 s[i..j] 和 s[k..l] ，要么 j &lt; k 要么 i &gt; l 。 如果一个子字符串包含字符 char ，那么 s 中所有 char 字符都应该在这个子字符串中。 请你找到满足上述条件的最多子字符串数目。如果有多个解法有相同的子字符串数目，请返回这些子字符串总长度最小的一个解。可以证明最小总长度解是唯一的。 Solution先对每个字母求出合法的最短长度，可以记录每个字母出现的左右端点，但这样不一定是合法的，因为之间会有别的字母，而这些字母没有被完全包含，所以必须枚举这个区间内的所有字母，一直拓展这个区间直到合法位置。 然后问题就转变为不相交线段数最多且长度和最短的问题，考虑贪心。显然可以看出先对右端点进行排序从小到大排序（保证右边剩余的空间尽量大），然后对左端点从大到小排序（保证长度尽可能小），然后贪心着取，遇到可以加入的线段将其加入答案即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution { public: struct Node { int l, r; bool operator&lt;(const Node&amp; node) const { if (r == node.r) return l &gt; node.l; return r &lt; node.r; } } p[26]; vector&lt;string&gt; maxNumOfSubstrings(string s) { int n = s.size(); vector&lt;string&gt; res; for (int i = 0; i &lt; 26; i++) p[i].l = p[i].r = -1; for (int i = 0; i &lt; n; i++) { if (p[s[i] - 'a'].l == -1) p[s[i] - 'a'].l = i; p[s[i] - 'a'].r = i; } for (int i = 0; i &lt; 26; i++) { if (p[i].l == -1) continue; int le = p[i].l; for (int j = p[i].l; j &lt;= p[i].r; j++) { p[i].l = min(p[i].l, p[s[j] - 'a'].l); p[i].r = max(p[i].r, p[s[j] - 'a'].r); if (le &gt; p[i].l) { le = p[i].l; j = le; } } } sort(p, p + 26); int ri = -1; for (int i = 0; i &lt; 26; i++) { if (p[i].r == -1) continue; if (p[i].l &gt; ri) { ri = p[i].r; res.push_back(s.substr(p[i].l, p[i].r - p[i].l + 1)); } } return res; }};","link":"/2020/07/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%A4%9A%E7%9A%84%E4%B8%8D%E9%87%8D%E5%8F%A0%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html"},{"title":"每日一题：最大得分","text":"题意给定两个严格递增数组，从任意一个数组出发到任意一个数组结束，当遇到相同元素时可以切换到另一个数组，只能从左到右走且每个数只计算一次，求最大累计得分。 Solution当遇到两个数组都有的元素时可以切换，那其实从上一次遇到相同到这一次，假设中间这部分元素和是 $sum$，无非是看到底是上面这部分的 $sum$ 更大还是下面的 $sum$ 更大，然后选走罢了，如此循环下去。至于判断相同元素，提前用map记录每个元素的位置就好了。时间复杂度$O(n)$。 比如: $nums1: [2, 4, 5, 8, 10]$ $nums2: [4, 6, 8, 9]$ 首先第一部分（从起点开始，碰到第一次相同）是 $sum1(nums1[2, 4]) = 6$, $sum2(nums2[4]) = 4$，选择 $max(sum1, sum2) = 6$ 第二部分（第二次相同）是 $sum1(nums1[5, 8]) = 13$, $sum2(nums2[6, 8]) = 14$，选择 $max(sum1, sum2) = 14$ 第三部分（一直循环到结尾也没再发现相同元素，换不了路线，故只能一直走到终点）是 $sum1(nums1[10]) = 10$, $sum2(nums2[9]) = 9$，选择 $max(sum1, sum2) = 10$ 故答案为 $6 + 14 + 10 = 20$ Code1234567891011121314151617181920212223242526class Solution { public int maxSum(int[] a, int[] b) { int n = a.length, m = b.length; HashMap&lt;Integer, Integer&gt; mp = new HashMap&lt;Integer, Integer&gt;(); for(int i = 0; i &lt; m; i++) mp.put(b[i], i); // 预处理b[i]数组的位置 long res = 0, sum1 = 0, sum2 = 0, mod = 1000000007; int j = 0; for(int i = 0; i &lt; n; i++) { sum1 += a[i]; // 计算a数组这部分的和 if(mp.get(a[i]) != null) { // 说明a[i]在b数组中也存在 int pos = mp.get(a[i]); for(; j &lt;= pos; j++) { // 开始计算b数组这部分的和 sum2 += b[j]; } res = (res + Math.max(sum1, sum2)) % mod; // 选择更大的那部分加 sum1 = sum2 = 0; // 归零，开始下一部分的计算 } } for(; j &lt; m; j++) { // b数组可能还没走完 sum2 += b[j]; } res = (res + Math.max(sum1, sum2)) % mod; return (int)(res % 1000000007); }}","link":"/2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86.html"},{"title":"每日一题：最大矩形","text":"题意给定一个仅包含 $0$ 和 $1$ 、大小为 $n * m$ 的二维二进制矩阵，找出只包含 $1$ 的最大矩形，并返回其面积。$(n, m \\in [1, 200])$ 思路有一个子问题，求柱状图最大矩形。预先求出 $1-i$ 层的 $h[i]$ 然后利用套用子问题的模板即可，复杂度 $O(n * m)$. Solution1234567891011121314151617181920212223242526272829303132class Solution {public: int largestRectangleArea(vector&lt;int&gt;&amp; h) { stack&lt;int&gt; st; st.push(-1); int n = h.size(); vector&lt;int&gt; l(n), r(n, n); for (int i = 0; i &lt; n; i++) { while (st.top() != -1 &amp;&amp; h[st.top()] &gt;= h[i]) { r[st.top()] = i; st.pop(); } l[i] = st.top(); st.push(i); } int res = 0; for (int i = 0; i &lt; n; i++) res = max(res, (r[i] - l[i] - 1) * h[i]); return res; } int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; a) { int n = a.size(); if (n == 0) return 0; int m = a[0].size(), res = 0; vector&lt;int&gt; h(m); for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) h[j] = (a[i][j] == '1' ? h[j] + 1 : 0); res = max(res, largestRectangleArea(h)); } return res; }};","link":"/2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2.html"},{"title":"每日一题：最小体力消耗路径","text":"题意给定一个 $nm$ 的权值矩阵，求从左上角走到右下角。$(n, m \\in [1, 100], w \\in [1, 1e6])$ 一条路径耗费的体力值是路径上相邻格子之间 高度差绝对值的最大值 决定的。 Solution 二分答案：由于答案具有单调性，所以可以二分答案，然后通过 $bfs$ 进行验证。 并查集：类似于最小生成树，将所有的边都建出来，然后贪心的将当前权值最小的边加入集合，判断起点和终点是否联通即可。 最短路：将所有的边建出来，做一次起点到终点的最短路径即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 仅给出第二种做法的代码class Solution {public: // 并查集模板 class UnionFind { public: vector&lt;int&gt; parent; vector&lt;int&gt; size; int n; // 当前连通分量数目 int setCount; public: UnionFind(int _n): n(_n), setCount(_n), parent(_n), size(_n, 1) { iota(parent.begin(), parent.end(), 0); } int findset(int x) { return parent[x] == x ? x : parent[x] = findset(parent[x]); } bool unite(int x, int y) { x = findset(x); y = findset(y); if (x == y) { return false; } if (size[x] &lt; size[y]) { swap(x, y); } parent[y] = x; size[x] += size[y]; --setCount; return true; } bool connected(int x, int y) { x = findset(x); y = findset(y); return x == y; } }; struct Node { int x, y, w; }; int minimumEffortPath(vector&lt;vector&lt;int&gt;&gt;&amp; h) { int n = h.size(), m = h[0].size(); vector&lt;Node&gt; g; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { if (i &gt; 0) g.push_back(Node{i * m + j, i * m + j - m, abs(h[i][j] - h[i - 1][j])}); if (j &gt; 0) g.push_back(Node{i * m + j, i * m + j - 1, abs(h[i][j] - h[i][j - 1])}); } } sort(g.begin(), g.end(), [](Node&amp; a, Node&amp; b) -&gt; bool { return a.w &lt; b.w; }); UnionFind uf(n * m); for (auto&amp; p : g) { uf.unite(p.x, p.y); if (uf.connected(0, n * m - 1)) return p.w; } return 0; }};","link":"/2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.html"},{"title":"每日一题：最小区间","text":"题意你有 k 个升序排列的整数数组。找到一个最小区间，使得 k 个列表中的每个列表至少有一个数包含在其中。 Solution直接对所有的数排序，然后优先队列维护一个k个数组都有值存在且对当前来说长度最小的滑动窗口，同时维护答案即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Solution { class Node { public Node(int val, int id) { this.val = val; this.id = id; } int val, id; } public int[] smallestRange(List&lt;List&lt;Integer&gt;&gt; nums) { int n = nums.size(); PriorityQueue&lt;Node&gt; q = new PriorityQueue&lt;&gt;(new Comparator&lt;Node&gt;(){ @Override public int compare(Node a, Node b) { return a.val - b.val; } }); PriorityQueue&lt;Node&gt; q1 = new PriorityQueue&lt;&gt;(new Comparator&lt;Node&gt;(){ @Override public int compare(Node a, Node b) { return a.val - b.val; } }); for (int i = 0; i &lt; n; i++) { List&lt;Integer&gt; num = nums.get(i); for (int j = 0; j &lt; num.size(); j++) { Node node = new Node(num.get(j), i); q.add(node); } } HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); int cnt = 0, dis = 1000000000; int[] res = new int[2]; while (q.size() &gt; 0) { Node now = q.poll(); q1.add(now); if(map.get(now.id) == null) { cnt++; map.put(now.id, 1); } else { int x = map.get(now.id); map.remove(now.id); map.put(now.id, x + 1); } while(q1.size() &gt; 0) { Node x = q1.peek(); if(map.get(x.id) == 1) break; else { q1.poll(); int y = map.get(x.id); map.remove(x.id); map.put(x.id, y - 1); } } if(q1.size() &gt; 0 &amp;&amp; cnt == n &amp;&amp; dis &gt; now.val - q1.peek().val) { dis = now.val - q1.peek().val; res[0] = q1.peek().val; res[1] = now.val; } } return res; }}","link":"/2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E5%8C%BA%E9%97%B4.html"},{"title":"每日一题：最小高度树","text":"题意给定一颗树，求当树的高度最小时根的编号为多少。$(n \\in [1, 2e4])$ Solution","link":"/2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91.html"},{"title":"每日一题：最长有效括号","text":"题意给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。 Solution栈里面存左括号的位置，当遇到右括号时： 栈为空：记录这个位置，说明下一轮的合法括号可能从这里开始。 栈不为空：先弹出左括号表示匹配。 此时栈为空，说明之前可能还有合法括号，用当前下标减去之前记录的那个位置。 此时栈不为空，减去当前栈顶的位置即可（最接近的没有被匹配的左括号）。 Code12345678910111213141516171819202122class Solution { public int longestValidParentheses(String s) { int res = 0, last = -1; Stack&lt;Integer&gt; st = new Stack&lt;Integer&gt;(); for (int i = 0; i &lt; s.length(); i++) { if (s.charAt(i) == '(') st.push(i); else { if (st.size() &gt; 0) { st.pop(); if (st.size() &gt; 0) res = Math.max(res, i - st.peek()); else res = Math.max(res, i - last); } else { last = i; } } } return res; }}","link":"/2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.html"},{"title":"每日一题：比赛","text":"题意一共12道题，你有 $a_i$ 的概率做对第 $i$ 题，有 $b_i$ 的概率抄到左边的，有 $c_i$ 的概率抄到右边的，问做对 $0-12$ 题的概率是多少。 solution做对的概率不太好求，可以反过来求做错的概率，即 $(1-a[i])\\times(1-b[i])\\times(1-c[i])$，然后 $dp[i][j]$ 表示前 $i$ 道题做对 $j$ 道的概率，设 $dp[0][0] =1$，得到状态转移方程：$dp[i][j]=dp[i-1][j-1]\\times(ac=(1-wa))+dp[i-1][j]*wa$ 。 Code123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;double a[15], b[15], c[15], dp[15][15];int main() { for (int i = 1; i &lt;= 12; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= 12; i++) cin &gt;&gt; b[i]; for (int i = 1; i &lt;= 12; i++) cin &gt;&gt; c[i]; dp[0][0] = 1; for (int i = 1; i &lt;= 12; i++) { dp[i][0] = dp[i - 1][0] * (1 - a[i]) * (1 - b[i]) * (1 - c[i]); for (int j = 1; j &lt;= i; j++) { double wa = (1 - a[i]) * (1 - b[i]) * (1 - c[i]); dp[i][j] = dp[i - 1][j - 1] * (1 - wa) + dp[i - 1][j] * wa; } } for (int i = 0; i &lt;= 12; i++) printf(&quot;%f\\n&quot;, dp[12][i]); return 0;}","link":"/2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%AF%94%E8%B5%9B.html"},{"title":"每日一题：树中距离之和","text":"题目给定一个无向、连通的树。树中有 $N$ 个标记为 $0…N-1$ 的节点以及 $N-1$ 条边 。 第 $i$ 条边连接节点 $edges[i][0]$ 和 $edges[i][1]$ 。 返回一个表示节点 $i$ 与其他所有节点距离之和的列表 $res$。 Solution首先只考虑查询一个点的情况，容易得到状态转移：$dp[u] = \\sum_{v \\in son[u]}{dp[v] + sz[v]}$。 $son[u]$ 表示 $u$ 的所有子节点，$sz[v]$ 表示以 $v$ 为根的子树大小，$dp[u]$ 表示以 $u$ 为根的子树，它的所有子节点到它的距离之和。 那么 $dp[u]$ 就是所有子节点的 $dp[v]$ + 子节点对应的子树大小个点从 $u$ 到 $v$ 的距离。 然后考虑换根，根从 $u$ 变为子节点 $v$，以 $u$ 为根的子树大小减少 $sz[v]$，$dp[u]$ 也要减去 $v$ 的贡献： $sz[u] -= sz[v], dp[u] -= dp[v] + sz[v]$ 然后 $v$ 做为根，获得了 $u$ 结点的贡献，同时以 $v$ 为根的子树大小增大 $sz[u]$： $sz[v] += sz[u], dp[v] += dp[u] + sz[u]$ 同时注意：递归在进行回溯的时候，需要恢复现场，否则在计算兄弟结点时，维护的 $dp$ 和 $sz$ 将是错误的。 需要两次dfs，时间复杂度为 $O(n)$。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution {public: vector&lt;int&gt; g[10005]; vector&lt;int&gt; res; int dp[10005], sz[10005]; void dfs1(int u, int fa) { sz[u] = 1; dp[u] = 0; for (auto v: g[u]) { if (v == fa) continue; dfs1(v, u); sz[u] += sz[v]; dp[u] += dp[v] + sz[v]; } } void dfs2(int u, int fa) { res[u] = dp[u]; for (auto v: g[u]) { if (v == fa) continue; int du = dp[u], dv = dp[v]; int su = sz[u], sv = dp[v]; dp[u] -= dp[v] + sz[v]; sz[u] -= sz[v]; dp[v] += dp[u] + sz[u]; sz[v] += sz[u]; dfs2(v, u); dp[u] = du, dp[v] = dv; sz[u] = su, sz[v] = sv; } } vector&lt;int&gt; sumOfDistancesInTree(int N, vector&lt;vector&lt;int&gt;&gt;&amp; edges) { for (auto edge: edges) { g[edge[0]].push_back(edge[1]); g[edge[1]].push_back(edge[0]); } res.resize(N, 0); dfs1(0, -1); dfs2(0, -1); return res; }};","link":"/2020/10/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%A0%91%E4%B8%AD%E8%B7%9D%E7%A6%BB%E4%B9%8B%E5%92%8C.html"},{"title":"每日一题：滑动窗口中位数","text":"题意给你一个数组 nums，有一个长度为 k 的窗口从最左端滑动到最右端。窗口中有 k 个数，每次窗口向右移动 1 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。$(n, k \\in [1, 100000])$ Solution用优先队列+延迟删除有点麻烦，可以考虑直接用 multiset 做，本质都是一样的，维护两个大小相同或差一的集合（自动排序）$l 和 r$，$l$ 维护小于等于中位数的值，$r$ 维护大于等于中位数的值，$multiset$ 的优秀特性可以在 $log$ 时间复杂度内进行增删操作。具体细节较多，时间复杂度 $O(nlog(k))$。 Code123456789101112131415161718192021222324252627282930class Solution {public: vector&lt;double&gt; medianSlidingWindow(vector&lt;int&gt;&amp; a, int k) { multiset&lt;double&gt; l, r; int n = a.size(); vector&lt;double&gt; res; for (int i = 0; i &lt; n; i++) { if (i &gt;= k) { // 需要移除之前已经加入滑动窗口的元素 if (l.count(a[i - k])) l.erase(l.find(a[i - k])); else r.erase(r.find(a[i - k])); } l.insert((double)a[i]); while (l.size() &amp;&amp; r.size() &amp;&amp; *(--l.end()) &gt; *r.begin()) { // 左集合的元素不可能大于右集合 l.insert(*r.begin()); r.insert(*(--l.end())); l.erase(*(--l.end())); r.erase(*r.begin()); } while (l.size() - 1 &gt; r.size()) { // 左集合元素最多只会比右集合多一（窗口大小为奇数） r.insert(*(--l.end())); l.erase(--l.end()); } if (i &gt;= k - 1) { if (k &amp; 1) res.push_back(*(--l.end())); else res.push_back((*(--l.end()) + *r.begin()) / 2.0); } } return res; }};","link":"/2021/02/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%AD%E4%BD%8D%E6%95%B0.html"},{"title":"每日一题：滑雪与时间胶囊（最小生成树）","text":"题意给定一个 $n$ 个点 $m$ 条边图，只能从点权高的点走到低的，且可以不计路程的瞬移至之前走过的某个点，求经过最多点的最短路径。 solution求经过最多点显然直接bfs，建图的时候建高到低的单向边即可，（值得注意的是，若点权相同，则为相互可达的，需要建双向边）。然后根据bfs遍历可以走到的点，将走过的边加入边集，建一个新图出来。为了使路径最短，考虑最小生成树，但需要满足题目的条件，因此我们对新的图进行排序，以高度为第一关键字从大到小排，再以路径长度为第二关键字从小到大排，这样可以保证点最多的同时路径最短。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e6 + 5;int n, m, tot, cnt, hi[N], h[N], pre[N], vis[N];struct Node { int from, to, v, next;} g[N], E[N];void add1(int x, int y, int z) { g[tot].from = x, g[tot].to = y, g[tot].v = z, g[tot].next = h[x], h[x] = tot++;}void add2(int x, int y, int z) { cnt++, E[cnt].from = x, E[cnt].to = y, E[cnt].v = z;}bool cmp(Node x, Node y) { if (hi[x.to] == hi[y.to]) return x.v &lt; y.v; return hi[x.to] &gt; hi[y.to];}int xfind(int x) { int i = x, j = x, temp; while (i != pre[i]) i = pre[i]; while (i != j) { temp = pre[j]; pre[j] = i; j = temp; } return i;}void bfs() { int res1 = 1; queue&lt;int&gt; q; vis[1] = true; q.push(1); while (q.size()) { int u = q.front(); q.pop(); for (int i = h[u]; ~i; i = g[i].next) { int v = g[i].to; add2(u, v, g[i].v); if (!vis[v]) { vis[v] = true; res1++; q.push(v); } } } printf(&quot;%d &quot;, res1);}void Kruscal() { long long res2 = 0; int num = 0; for (int i = 1; i &lt;= cnt; i++) { int x = E[i].from, y = E[i].to; int fx = xfind(x), fy = xfind(y); if (fx != fy) { pre[fx] = fy; res2 += E[i].v; num++; } if (num == n - 1) break; } printf(&quot;%lld\\n&quot;, res2);}int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;hi[i]); pre[i] = i; } memset(h, -1, sizeof(h)); for (int i = 1; i &lt;= m; i++) { int x, y, z; scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z); if (hi[x] &gt;= hi[y]) add1(x, y, z); if (hi[x] &lt;= hi[y]) add1(y, x, z); } bfs(); sort(E + 1, E + cnt + 1, cmp); Kruscal(); return 0;}","link":"/2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%BB%91%E9%9B%AA%E4%B8%8E%E6%97%B6%E9%97%B4%E8%83%B6%E5%9B%8A%EF%BC%88%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89.html"},{"title":"每日一题：牛牛构造等差数列","text":"题意有 $n$ 个数，他们对每个数可以进行 $+1$ 或 $-1$ 操作，但对于每一个数，该操作最多只能执行一次。使用最少的操作次数，将这几个数构造成一个等差数列。如果完全不能构造成功，就输出 $-1$。 Solution每个数最多只能修改一次，因此我们只要枚举前两个数的修改状态就能确定首项和公差，只有 $9$ 种可能，然后逐一判断取最小值即可。 Code123456789101112131415161718192021222324252627282930313233public class Solution { public int solve(int n, int[] b) { int res = Integer.MAX_VALUE; for (int i = -1; i &lt;= 1; i++) { for (int j = -1; j &lt;= 1; j++) { b[0] += i; b[1] += j; int d = b[1] - b[0]; int pre = b[1], now, cnt = 0; boolean flag = false; if (i != 0) cnt++; if (j != 0) cnt++; for (int k = 2; k &lt; n; k++) { now = pre + d; if (Math.abs(now - b[k]) &gt; 1) { flag = true; } else if (Math.abs(now - b[k]) == 1) { cnt++; } pre = now; } if (flag == false) { res = Math.min(res, cnt); } b[0] -= i; b[1] -= j; } } return res == Integer.MAX_VALUE ? -1 : res; }}","link":"/2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%89%9B%E7%89%9B%E6%9E%84%E9%80%A0%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97.html"},{"title":"每日一题：物质分裂","text":"题目一个 $A$ 每天可以生产 $x1$ 个 $B$，$y1$ 个 $C$，一个 $B$ 每天可以生产 $x2$ 个 $A$，$y2$ 个 $C$，一个 $C$ 每天可以生产 $x3$ 个 $A$，$y3$ 个 $B$，最开始各有 $x,y,z$ 个，问 $n$ 天后各有多少个？ $n = 1e9$ Solution$B$ 和 $C$ 每天可以生产 $x2 + x3$ 个 $A$，那么第一天：$x$，第二天：$x(x2+x3)$，第三天：$(x(x2+x3))*(x2+x3)$ … 显然是等比数列求和。 Code12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod = 1e9 + 7;ll x, y, z, n, b1, c1, a1, c2, a2, b2;ll qp(ll a, ll b) { ll sum = 1; while (b) { if (b &amp; 1) sum = sum * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return sum;}int main() { cin &gt;&gt; x &gt;&gt; y &gt;&gt; z &gt;&gt; n; cin &gt;&gt; b1 &gt;&gt; c1 &gt;&gt; a1 &gt;&gt; c2 &gt;&gt; a2 &gt;&gt; b2; ll a = x * (1 - qp(a1 + a2, n + 1) + mod) * qp(1 - a1 - a2 + mod, mod - 2) % mod; ll b = y * (1 - qp(b1 + b2, n + 1) + mod) * qp(1 - b1 - b2 + mod, mod - 2) % mod; ll c = z * (1 - qp(c1 + c2, n + 1) + mod) * qp(1 - c1 - c2 + mod, mod - 2) % mod; cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; &quot; &quot; &lt;&lt; c &lt;&lt; endl; return 0;}","link":"/2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%89%A9%E8%B4%A8%E5%88%86%E8%A3%82.html"},{"title":"每日一题：皇家烈焰（线性dp）","text":"题意现在帕秋莉告诉你一部分烈焰的分布情况，请你告诉她可能的情况有多少种 对于一个格子，里面会有以下几种字符： 0：这个格子没有烈焰，且其左右两个格子均没有烈焰 1：这个格子没有烈焰，且其左右两个格子中只有一个烈焰 2：这个格子没有烈焰，且其左右两个格子中均有烈焰 $*$：这个格子有烈焰 ?：未告诉你本格情况 solution$f[i][0/1][0/1]$表示前i位，当前位和下一位是（1）不是（0）烈焰的方案数 转移方程分情况讨论： 当$s[i]=’*’$时： $f[i][1][0]=(f[i-1][0][1]+f[i-1][1][1])$ $f[i][1][1]=(f[i-1][0][1]+f[i-1][1][1])$ 当$s[i]=’0’$时，上一位、当前位和下一位都得是0： $f[i][0][0]=f[i-1][0][0]$ 当s[i]=’1’时，上一位或下一位有一个是1： $f[i][0][1]=f[i-1][0][0]$ $f[i][0][0]=f[i-1][1][0]$ 当s[i]=’2’时，上一位和下一位都是1当前位是0： $f[i][0][1]=f[i-1][1][0]$ 当s[i]=’?’时： $f[i][1][0]=(f[i-1][0][1]+f[i-1][1][1])$ $f[i][1][1]=(f[i-1][0][1]+f[i-1][1][1])$ $f[i][0][0]=(f[i-1][0][0]+f[i-1][1][0])$ $f[i][0][1]=(f[i-1][0][0]+f[i-1][1][0])$ 初值$f[0][0][0] =1,f[0][0][1] = 1$ Code12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6 + 5;const int mod = 1e9 + 7;int dp[N][2][2];char s[N];int main() { cin &gt;&gt; s + 1; dp[0][0][0] = dp[0][0][1] = 1; int len = strlen(s + 1); for (int i = 1; i &lt;= len; i++) { if (s[i] == '0') dp[i][0][0] = dp[i - 1][0][0]; else if (s[i] == '1') { dp[i][0][0] = dp[i - 1][1][0]; dp[i][0][1] = dp[i - 1][0][0]; } else if (s[i] == '2') dp[i][0][1] = dp[i - 1][1][0]; else if (s[i] == '*') { dp[i][1][0] = (dp[i - 1][1][1] + dp[i - 1][0][1]) % mod; dp[i][1][1] = dp[i][1][0]; } else { dp[i][0][0] = (dp[i - 1][1][0] + dp[i - 1][0][0]) % mod; dp[i][0][1] = dp[i][0][0]; dp[i][1][0] = (dp[i - 1][0][1] + dp[i - 1][1][1]) % mod; dp[i][1][1] = dp[i][1][0]; } } cout &lt;&lt; (dp[len][1][0] + dp[len][0][0]) % mod &lt;&lt; '\\n'; return 0;}","link":"/2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%9A%87%E5%AE%B6%E7%83%88%E7%84%B0%EF%BC%88%E7%BA%BF%E6%80%A7dp%EF%BC%89.html"},{"title":"每日一题：矩阵中最长递增路径（记忆化搜索）","text":"题意给定一个整数矩阵，找出最长递增路径的长度。 对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。 Solution 记忆化搜索模板题。$dp[i][j]$记录之前已经计算得到的结果，之后直接读取即可。 Code123456789101112131415161718192021222324252627282930313233343536373839class Solution329 { /* [7,8,9] [9,7,6] [7,2,3] 输出：6 */ public int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; public int n, m; public int dfs(int[][] a, int[][] dp, int x, int y) { if(dp[x][y] != 0) return dp[x][y]; dp[x][y] = 1; for(int[] dir : dirs) { int fx = x + dir[0], fy = y + dir[1]; if(fx &gt;= 0 &amp;&amp; fx &lt; n &amp;&amp; fy &gt;= 0 &amp;&amp; fy &lt; m &amp;&amp; a[fx][fy] &gt; a[x][y]) dp[x][y] = Math.max(dp[x][y], dfs(a, dp, fx, fy) + 1); } return dp[x][y]; } public int longestIncreasingPath(int[][] a) { n = a.length; if(n == 0) return 0; m = a[0].length; int res = 1; int[][] dp = new int[n][m]; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; m; j++) { res = Math.max(res, dfs(a, dp, i, j)); } } return res; }}","link":"/2020/07/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84%EF%BC%88%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%EF%BC%89.html"},{"title":"每日一题：竞赛图","text":"题目给定一个 $n$ 元有向完全图，每次操作可以翻转一条边。求最少的操作次数，使得图中不存在三元环。$(n &lt;= 10)$ Solution Code12345678910111213141516171819#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;int n, pre[20];char s[20][20];int main() { while (cin &gt;&gt; n) { for (int i = 0; i &lt; n; i++) cin &gt;&gt; s[i], pre[i] = i; int res = 1e9; do { int sum = 0; for (int i = 0; i &lt; n; i++) for (int j = i + 1; j &lt; n; j++) sum += s[pre[j]][pre[i]] &amp; 1; res = min(res, sum); } while (next_permutation(pre, pre + n)); cout &lt;&lt; res &lt;&lt; endl; } return 0;}","link":"/2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%AB%9E%E8%B5%9B%E5%9B%BE.html"},{"title":"每日一题：简单瞎搞题 （STL）","text":"题意一共有 $n$ 个数，第 $i$ 个数是 $x_i$ 可以取 $[l_i , r_i]$ 中任意的一个值。设 $S = \\sum{ {x_i}^2}$，求 $S$ 种类数。（0 ~ n,l,r ~ 100） Solution$dp[i][j]$ 表示前 $i$ 个数能不能组成 $j$，可以得到转移方程：$dp[i][j]=dp[i-1][j-x^2]$，最后统计 $dp[n]$ 层组成的 $j$ 的数量即可。因为 dp 的值只有 0 和 1 ，因此使用 bitset 优化，把第二维看成二进制位，这样就可以用位移的形式来表示加法运算，得到转移方程：dp[i]=dp[i-1] &lt;&lt; (j*j)，复杂度 $10^{10}/64$。 Code1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;bitset&lt;1000005&gt; dp[105];int main() { int n, l, r; scanf(&quot;%d&quot;, &amp;n); dp[0][0] = 1; for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d%d&quot;, &amp;l, &amp;r); for (int j = l; j &lt;= r; j++) dp[i] |= dp[i - 1] &lt;&lt; (j * j); } printf(&quot;%lu\\n&quot;, dp[n].count()); return 0;}","link":"/2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%AE%80%E5%8D%95%E7%9E%8E%E6%90%9E%E9%A2%98-%EF%BC%88STL%EF%BC%89.html"},{"title":"每日一题：粉刷匠（背包dp）","text":"题意n 条木板，每条木板都被分成 m 段且每一段都有要涂的颜色，有 t 次机会涂色，每次可以选择一条木板的连续一段涂成同一种颜色，问最多可以涂对多少段。 solution考虑四维dp的做法。$dp[i][j][k][0/1]$ 代表到第 $i$ 条第 $j$ 段时涂 $k$ 次，当前段涂红或蓝$(0/1)$的最大正确数，可以得到转移方程： 当 $j=1$ (属于当前木板第一段) 时，由上一个木板转移过来： $dp[i][j][k][0] = max(dp[i-1][m][k-1][0],dp[i-1][m][k-1][1]) + (s[i][j] == ‘0’)$ $dp[i][j][k][1] = max(dp[i-1][m][k-1][0],dp[i-1][m][k-1][1]) + (s[i][j] == ‘1’)$ 否则，由当前木板的上一段转移过来： $dp[i][j][k][0] = max(dp[i][j-1][k][0],dp[i][j-1][k-1][1]) + (s[i][j] == ‘0’)$ $dp[i][j][k][1] = max(dp[i][j-1][k-1][0],dp[i][j-1][k][1]) + (s[i][j] == ‘1’)$ 最后结果显然为 $max(dp[n][m][t][0], dp[n][m][t][1])$ 。 时间复杂度 $O(nmt)$，空间上可以使用滚动数组压维，空间复杂度为 $O(4mt)$。 Code123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 55;char s[N][N];int n, m, t, dp[2][N][N * N][2];int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;t); for (int i = 1; i &lt;= n; i++) scanf(&quot;%s&quot;, s[i] + 1); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) for (int k = 1; k &lt;= t; k++) for (int l = 0; l &lt;= 1; l++) { if (j == 1) dp[i &amp; 1][j][k][l] = max(dp[(i - 1) &amp; 1][m][k - 1][0], dp[(i - 1) &amp; 1][m][k - 1][1]) + (s[i][j] == l + '0'); else dp[i &amp; 1][j][k][l] = max(dp[i &amp; 1][j - 1][k][l], dp[i &amp; 1][j - 1][k - 1][l ^ 1]) + (s[i][j] == l + '0'); } printf(&quot;%d\\n&quot;, max(dp[n &amp; 1][m][t][0], dp[n &amp; 1][m][t][1])); return 0;}","link":"/2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%B2%89%E5%88%B7%E5%8C%A0%EF%BC%88%E8%83%8C%E5%8C%85dp%EF%BC%89.html"},{"title":"每日一题：编辑距离","text":"题目给你两个单词 $a$ 和 $b$，请你计算出将 $a$ 转换成 $b$ 所使用的最少操作数。 你可以对一个单词进行如下三种操作： 插入一个字符 删除一个字符 替换一个字符 Solution$dp[i][j]$ 表示 $a$ 的前 $i$ 个字母和 $b$ 的前 $j$ 个字母匹配的最少操作次数。 可以从三种状态转移过来： $dp[i][j] = dp[i - 1][j] + 1$ 在 $b[j]$ 后面插入一个字符 $a[i]$ $dp[i][j] = dp[i][j - 1] + 1$ 在 $a[i]$ 后面插入一个字符 $b[j]$ $dp[i][j] = dp[i - 1][j - 1] + (a[i - 1] != b[j - 1])$ 修改一个字符 选择最小的操作步数进行转移即可。 Code123456789101112131415161718192021class Solution {public: int dp[1005][1005]; int minDistance(string a, string b) { int n = a.size(); int m = b.size(); for (int i = 0; i &lt;= n; i++) dp[i][0] = i; for (int i = 0; i &lt;= m; i++) dp[0][i] = i; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { int x = dp[i - 1][j] + 1; // 在 b[j] 后面插入一个字符 a[i] int y = dp[i][j - 1] + 1; // 在 a[i] 后面插入一个字符 b[j] int z = dp[i - 1][j - 1] + (a[i - 1] != b[j - 1]); // 修改一个字符 dp[i][j] = min({x, y, z}); } } return dp[n][m]; }};","link":"/2020/10/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.html"},{"title":"每日一题：美味菜肴","text":"题意$n$ 件食材（每种食材的数量可以视为无限），小明连续工作 $T$ 时间。每道菜肴的制作需要特定的一种食材以及一段时间，但是食材一旦放久就不新鲜了，菜的美味值会降低。第 $i$ 道菜肴有三个属性 $ai$，$bi$，$ci$，$ai$ 是该菜肴的美味值，$bi$ 是该菜肴所选食材不新鲜的速率，如果在第t时刻完成第i道菜则美味值为：$ai-t*bi$，完成这道菜需要 $ci$ 的时间。求在这 $T$ 时间内能做出菜肴使得总美味值的最大值。 solution首先需要贪心确定顺序，考虑只有两道菜，可以得到：$a_i−b_i∗c_i+(a_j−b_j∗(c_i+c_j))&gt;=a_j−b_j∗c_j+(a_i−b_i∗(c_i+c_j))$，化简后得到：$b_i∗c_i&gt;=b_j∗c_i$。排序后背包即可（需要降维）。 Code12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll INF = 0x3ffffffffffff;const int N = 2e5 + 5;struct Node { ll a, b, c;} q[N];ll res = -INF, s[N], dp[N];bool cmp(Node x, Node y) { return x.c * s[y.a] &lt; y.c * s[x.a]; }int main() { int n, m, t; cin &gt;&gt; n &gt;&gt; m &gt;&gt; t; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; s[i]; for (int i = 1; i &lt;= m; i++) cin &gt;&gt; q[i].a &gt;&gt; q[i].b &gt;&gt; q[i].c; sort(q + 1, q + m + 1, cmp); for (int i = 1; i &lt;= t; i++) dp[i] = -INF; for (int i = 1; i &lt;= m; i++) for (int j = t; j &gt;= q[i].c; j--) dp[j] = max(dp[j], dp[j - q[i].c] + q[i].b - j * s[q[i].a]); for (int i = 1; i &lt;= t; i++) res = max(res, dp[i]); cout &lt;&lt; res &lt;&lt; '\\n'; return 0;}","link":"/2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%BE%8E%E5%91%B3%E8%8F%9C%E8%82%B4.html"},{"title":"每日一题：至少被一个元素整除的数个数","text":"题目给定一个 $m$ 个元素的集合，问 $1-n$ 中有多少个数能被集合中至少一个元素整除。$(n &lt;= 1e9, m &lt;= 20)$ Solution容斥原理，二进制枚举集合的所有子集，求子集的 $lcm$，如果子集大小是奇数，则 $res += n / lcm$，否则 $res-= n / lcm$。 Code123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long longLL a[40];int main() { LL N, M, ans = 0, gd; scanf(&quot;%d%d&quot;, &amp;N, &amp;M); for (int i = 1; i &lt;= M; i++) { scanf(&quot;%d&quot;, &amp;a[i - 1]); } LL F = (1 &lt;&lt; M) - 1; for (int i = 1; i &lt;= F; i++) { LL cnt = 0; for (int j = 0; j &lt; M; j++) { if (i &amp; (1 &lt;&lt; j)) { cnt++; if (cnt == 1) gd = a[j]; else gd = gd * a[j] / (__gcd(a[j], gd)); } } if (cnt &amp; 1) { ans += N / gd; } else ans -= N / gd; } printf(&quot;%d\\n&quot;, ans); return 0;}","link":"/2020/09/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%87%B3%E5%B0%91%E8%A2%AB%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E6%95%B4%E9%99%A4%E7%9A%84%E6%95%B0%E4%B8%AA%E6%95%B0.html"},{"title":"每日一题：解码异或后的排列","text":"题意给你一个整数数组 $g$，它是前 $n$ 个正整数的排列，且 $n$ 是个 奇数 。 它被加密成另一个长度为 $n - 1$ 的整数数组 $a$ ，满足 $a[i] = g[i]$ ^ $g[i + 1]$。比方说，如果 $g = [1,3,2]$，那么 $a = [2,1]$。 给你 $a$ 数组，请你返回原始数组 $g$。题目保证答案存在且唯一。 Solution 可以发现如果对 $a$ 数组做前缀异或和得到 $sum$ 数组，那么 $sum[i]$ 就表示 $g[0]$ ^ $g[i + 1]$ 的值。$n$ 恰好为奇数，因此如果将数组 $sum$ 全部异或起来，$g[0]$ 刚好为被异或偶数次而抵消，得到的结果为 $g[1]$ ^ $g[2]$ ^ … ^ $g[n]$，恰好只有 $g[0]$ 没有出现。然后将这个结果与 $1-n$ 的所有数异或，得到的就是 $g[0]$ 的值，然后递推即可。时间复杂度 $O(n)$。 Code1234567891011class Solution {public: vector&lt;int&gt; decode(vector&lt;int&gt;&amp; a) { int n = a.size(), sum = 0; vector&lt;int&gt; g(n + 1); for (int i = 0; i &lt; n; i++) g[0] ^= (sum ^= a[i]); for (int i = 1; i &lt;= n + 1; i++) g[0] ^= i; for (int i = 0; i &lt; n; i++) g[i + 1] = g[i] ^ a[i]; return g; }};","link":"/2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%A7%A3%E7%A0%81%E5%BC%82%E6%88%96%E5%90%8E%E7%9A%84%E6%8E%92%E5%88%97.html"},{"title":"课程安排（状压dp）","text":"题意：让你安排课程，保证每学期的课不能冲突，问最少需要几个学期。 solution： 因为 n 只有15，可以考虑状压dp。用二进制每位的1/0表示当前是否学习该课程，可以得到 n 个二进制位，那么所有的可能性有 1&lt;&lt;n 种，预处理 g[s] 表示 s 所代表课程的是否可以在一个学期内学完（对于当前要学的所有课程的学时进行标记，若有重复标记则不可能在一学期学完），f[s] 维护学完当前课程所花费的最少学期，枚举子集进行转移。答案的状态应该是所有课全部修完，即 $f[(1&lt;&lt;n)-1]$。时间复杂度 $O(2^n m n)$。 Code1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1 &lt;&lt; 15;int n, m, sum, f[N], g[N], b[20], a[20][105], vis[105];bool check(int x) { memset(vis, 0, sizeof(vis)); for (int i = 0; i &lt; n; i++) { if (x &gt;&gt; i &amp; 1) { for (int j = 1; j &lt;= b[i]; j++) { if (vis[a[i][j]]) return false; vis[a[i][j]] = 1; } } } return true;}int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; b[i]; for (int j = 1; j &lt;= b[i]; j++) cin &gt;&gt; a[i][j]; } memset(f, 0x3f, sizeof(f)); // 因为要维护最小值，因此初值赋为最大值 f[0] = 0; // 学完 0 门课需要 0 个学期 sum = (1 &lt;&lt; n) - 1; // 每门课代表一个二进制位，枚举所有可能共有 1&lt;&lt;n 种 for (int s = 0; s &lt;= sum; ++s) { g[s] = check(s); // 验证 s 是否能在一个学期内学完 for (int t = s; t; t = (t - 1) &amp; s) // 从之前的状态（子集）进行转移 if (g[t]) f[s] = min(f[s], f[s ^ t] + 1); // 可以在一个学期学完，则维护最小值 } cout &lt;&lt; f[sum] &lt;&lt; '\\n'; return 0;}","link":"/2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%AF%BE%E7%A8%8B%E5%AE%89%E6%8E%92%EF%BC%88%E7%8A%B6%E5%8E%8Bdp%EF%BC%89.html"},{"title":"每日一题：货仓选址","text":"题意在数轴上找到一个点，使得到其余 $n$ 个点距离之和最小。$(n \\in [1, 1e5])$ Solution考虑绝对值不等式： 当只有两个点 $a, b$ 时，有 $|a - x| + |b - x| &gt;= |a - b|$，为了满足 $|a - x| + |b - x| = |a - b|$ 关系，$x$ 必须选在 $a,b$ 两点之间。 拓展为 $n$ 个点，距离为 $|a[1] - x| + |a[2] - x| + … + |a[n - 1] - x| + |a[n] - x|$，收尾两两分组有 $(|a[1] - x| + |a[n] - x|) + (|a[2] - x| - |a[n - 2] - x| + …)$，两两应用绝对值不等式，$x$ 的位置必须满足在各个对应区间里。 得出结论：当 $n$ 为奇数时，$x$ 位置为中间那个点（因为刚好分组多出单独一个，满足最小性则必须将 $x$ 的位置选择为那个点，距离刚好为 $0$）；当 $n$ 为偶数时，$x$ 位置为中间两个点之间的任意位置都可。 Code123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;int n, res, a[100005];int main(){ cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; sort(a, a + n); for (int i = 0; i &lt; n; i++) res += abs(a[i] - a[n &gt;&gt; 1]); cout &lt;&lt; res &lt;&lt; endl; return 0;}","link":"/2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%B4%A7%E4%BB%93%E9%80%89%E5%9D%80.html"},{"title":"每日一题：货币系统 （背包dp）","text":"题意$n$ 种面额货币，数量无限，问最多保留几种，使得原来可以组成的仍然可以组成。（$t&lt;=20,n&lt;=100,a[i]&lt;=25000$） solution由于大的只会被小的组成，所以先排序，对于存在性问题就显然是完全背包了，dp[i] 表示是否能表示出 $i$ 价值，得到状态转移方程：$dp[i]|=dp[i-a[i]]$，对于已经可以表示出来对 $a[i]$，已经可以由小的组成，因此不需要在枚举。 Code12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;int t, n, res, a[105], dp[300005];int main() { cin &gt;&gt; t; while (t--) { cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; sort(a + 1, a + n + 1); memset(dp, 0, sizeof(dp)); res = 0; dp[0] = 1; for (int i = 1; i &lt;= n; i++) { if (!dp[a[i]]) { res++; for (int j = a[i]; j &lt;= a[n]; j++) dp[j] |= dp[j - a[i]]; } } cout &lt;&lt; res &lt;&lt; '\\n'; } return 0;}","link":"/2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%B4%A7%E5%B8%81%E7%B3%BB%E7%BB%9F-%EF%BC%88%E8%83%8C%E5%8C%85dp%EF%BC%89.html"},{"title":"每日一题：过河 离散化+dp","text":"题意：桥长度为$L$ ，分布有$n$ 个石子，青蛙每次可以跳 $[S,T]$ 的距离,问青蛙过桥至少要踩多少个石子。 $(1&lt;=S,T&lt;=10,m&lt;=100,a_i&lt;=10^9, a_i 表示第i个石子的位置)$ solution 这是个很显然的dp题，难点在于他的 $a_i$ 达到了 $10^9$ ，所以我们需要压缩一下。 当 $s==t$ 时，答案就是位置能被 $s$ 整除的石子个数。 当 $s!=t$ 时，我们可以发现：假设当前位置为 $x$ ，那么 $x+s*t$ 之后的所有位置是一定可以被走到的。（可以看做是 $s$ 个 $t$ 步相加或 $t$ 个 $s$ 步相加，然后调整某些步的长度即可。） 然后，石子之间的距离就被压缩了，只要相邻的两个石子距离 $&gt;=st$ 的变成 $st$ 即可。 但是这样一压缩，最后的落点就不能确定了，但是起点是已知的，所以干脆倒过来dp。 状态转移方程： i 点有石子：$dp[i] = min(dp[i], dp[i+j]+1)$ i 点无石子：$dp[i] = min(dp[i], dp[i+j])$ Code12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5;int l, s, t, n, dis, res, a[N], dp[N], vis[N];int main() { cin &gt;&gt; l &gt;&gt; s &gt;&gt; t &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; if (s == t) { for (int i = 1; i &lt;= n; i++) { if (a[i] % s == 0) res++; } cout &lt;&lt; res &lt;&lt; '\\n'; return 0; } sort(a + 1, a + n + 1); int len = s * t; for (int i = 1; i &lt;= n; i++) { int d = a[i] - a[i - 1]; if (d &gt; len) d = len; dis += d; vis[dis] = 1; } for (int i = dis; i &gt;= 0; i--) { dp[i] = 100; for (int j = s; j &lt;= t; j++) { dp[i] = min(dp[i], dp[i + j] + vis[i]); } } cout &lt;&lt; dp[0] &lt;&lt; '\\n'; return 0;}","link":"/2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%BF%87%E6%B2%B3-%E7%A6%BB%E6%95%A3%E5%8C%96-dp.html"},{"title":"每日一题：连通两组点的最小成本","text":"题意给你两组点，其中第一组中有 $size1$ 个点，第二组中有 $size2$ 个点，且 $size1 &gt;= size2$。 任意两点间的连接成本 $cost$ 由大小为 size1 x size2 矩阵给出，其中 $cost[i][j]$ 是第一组中的点 $i$ 和第二组中的点 $j$ 的连接成本。如果两个组中的每个点都与另一组中的一个或多个点连接，则称这两组点是连通的。换言之，第一组中的每个点必须至少与第二组中的一个点连接，且第二组中的每个点必须至少与第一组中的一个点连接。 返回连通两组点所需的最小成本。 Solution$dp[i][j]$ 表示左部前 $i$ 个点连接右部(1&lt;&lt;m)的情况，状态转移方程：dp[i][now | 1 &lt;&lt; j] = min({dpnow | 1 &lt;&lt; j, dp[i - 1][j] + cost[i - 1]j + 当前点连接右边第j个点}, dp[i][j] + cost[i - 1]j + 当前点连接右边第j个点))。 Code1234567891011121314151617181920class Solution { public int connectTwoGroups(List&lt;List&lt;Integer&gt;&gt; cost) { int n = cost.size(); int m = cost.get(0).size(); int all = 1 &lt;&lt; m; int[][] dp = new int[n + 1][all]; for (int i = 0; i &lt;= n; i++) { Arrays.fill(dp[i], 2000000000); } dp[0][0] = 0; for (int i = 1; i &lt;= n; i++) { for (int now = 0; now &lt; all; now++) { for (int j = 0; j &lt; m; j++) { dp[i][now | 1 &lt;&lt; j] = Math.min(dp[i][now | 1 &lt;&lt; j], Math.min(dp[i - 1][now] + cost.get(i - 1).get(j), dp[i][now] + cost.get(i - 1).get(j))); } } } return dp[n][all - 1]; }}","link":"/2020/09/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%BF%9E%E9%80%9A%E4%B8%A4%E7%BB%84%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E6%88%90%E6%9C%AC.html"},{"title":"每日一题：逆序对","text":"题意题意很简单，求长度为n的01串逆序对数量和。( n &lt;= 1e18 ) solution任意选两个位置 $i, j$ $(i &lt; j)$，令 $a[i] = 1, a[j] = 0$，这样一定能产生逆序对，这样有 $C_n^2$ 种选法。剩下的位置随便放，有$2^{n-2}$种选法，总方案数即为答案。( 注意 1 需要特判 ) 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod = 1e9 + 7;ll qp(ll a, ll b) { if (b == -1) return 0; ll ans = 1; while (b) { if (b &amp; 1) ans = ans * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return ans;}int main() { ll n, res; cin &gt;&gt; n; res = (((n % mod) * ((n - 1) % mod) / 2 % mod) * qp(2, n - 2) % mod); cout &lt;&lt; res &lt;&lt; '\\n'; return 0;}","link":"/2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E9%80%86%E5%BA%8F%E5%AF%B9.html"},{"title":"每日一题：队列之和","text":"题目给你两个队列$a$和$b$，问你能否构造出给定的队列$c$。 Solutuon很经典的动态规划，$dp[i][j]$ 表示第一个队列的前 $i$ 个数和第二个队列的第 $j$ 个数能否组成第三个队列的前 $i+j$ 个数。状态转移方程：$dp[i][j] = (dp[i - 1][j]$ $and$ $a[i] == c[i + j]$ $or$ $dp[i][j - 1]$ $and$ $b[j] == c[i + j])$。 Code1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;int dp[1005][1005], T, A, B, a[1005], b[1005], c[2005];int main() { scanf(&quot;%d&quot;, &amp;T); while (T--) { scanf(&quot;%d%d&quot;, &amp;A, &amp;B); for (int i = 1; i &lt;= A; i++) scanf(&quot;%d&quot;, &amp;a[i]); for (int i = 1; i &lt;= B; i++) scanf(&quot;%d&quot;, &amp;b[i]); for (int i = 1; i &lt;= A + B; i++) scanf(&quot;%d&quot;, &amp;c[i]); memset(dp, 0, sizeof(dp)); dp[0][0] = 1; for (int t = 1; t &lt;= A + B; t++) { for (int i = 0; i &lt;= A; i++) { int j = t - i; if (j &lt; 0 || j &gt; B) continue; if (i &amp;&amp; c[t] == a[i] &amp;&amp; dp[i - 1][j]) dp[i][j] = 1; if (j &amp;&amp; c[t] == b[j] &amp;&amp; dp[i][j - 1]) dp[i][j] = 1; } } if (dp[A][B]) puts(&quot;possible&quot;); else puts(&quot;not possible&quot;); } return 0;}","link":"/2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E9%98%9F%E5%88%97%E4%B9%8B%E5%92%8C.html"},{"title":"每日一题：高度不超过m的二叉树个数","text":"题目求 $n$ 个节点，高度不超过 $h$ 的二叉树的个数，结果模 $1e9 + 7$。 Solution 定义 $f[i][j]$ 为 $i$ 个点组成高度不超过 $j$ 的二叉树的数量，则得到状态转移方程：$f[i][j] = f[k][j-1] * f[i-k-1][j-1]$，表示即选出一个根节点，两边子树高度不超过 $j - 1$ 的数量，初始状态为 $f[0][i] = 1$。 Code12345678910111213141516#include &lt;cstdio&gt;typedef long long ll;const ll mod = 1e9 + 7;int n, h;ll f[100][100];int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;h); for (int i = 0; i &lt;= n; i++) f[0][i] = 1; for (int j = 1; j &lt;= n; j++) for (int i = 1; i &lt;= n; i++) for (int k = 0; k &lt; i; k++) f[i][j] = (f[i][j] + f[k][j - 1] * f[i - k - 1][j - 1]) % mod; printf(&quot;%lld&quot;, f[n][h]); return 0;}","link":"/2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E9%AB%98%E5%BA%A6%E4%B8%8D%E8%B6%85%E8%BF%87m%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AA%E6%95%B0.html"},{"title":"牛客国庆集训day1","text":"A. ABB题意在给定的字符串后面最少添加多少个字符可以让整个字符串变成一个回文字符串$(n \\in [1, 4e5])$。 Solution 等价于求包含最后一个字符的最长回文子串，可以用前后遍历两次哈希解决。 Code12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;const ull base = 13331;const int N = 5e5 + 5;int n, len, res;char s[N];ull r, l[N], b[N];int main() { scanf(&quot;%d%s&quot;, &amp;n, s + 1); b[0] = 1; for (int i = 1; i &lt;= n; i++) b[i] = b[i - 1] * base; for (int i = 1; i &lt;= n; i++) l[i] = l[i - 1] * base + s[i]; for (int i = n; i &gt;= 1; i--) { r = r * base + s[i]; len++; if (i &gt;= len) { ull now1 = l[i] - l[i - len] * b[len]; if (now1 == r) res = max(res, len * 2 - 1); } if (i &gt;= len + 1) { ull now2 = l[i - 1] - l[i - 1 - len] * b[len]; if (now2 == r) res = max(res, len * 2); } } printf(&quot;%d\\n&quot;, n - res); return 0;} C. Bob in Wonderland题意把一棵树变为一条链的最少操作次数$(n \\in [1, 3e5])$。 Solution其实就是不断把度大于2的点转移到头或者尾，因此答案就是所有度数大于2的点减去2的和。 Code1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;int n, x, y, res, d[500005];int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt; n; i++) { scanf(&quot;%d%d&quot;, &amp;x, &amp;y); d[x]++; d[y]++; } for (int i = 1; i &lt;= n; i++) res += max(d[i] - 2, 0); printf(&quot;%d\\n&quot;, res); return 0;} E. Zeldain Garden题意求给定区间内所有数的因子个数和$(n \\in [1, 1e12])$。 Solution打表发现 $1-n$ 内因子个数和就是 $n / i$ 的和 $(i \\in [1, n])$，然后用除法分块解决。 Code123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll solve(ll n) { ll sum = n; for (ll i = 2; i &lt;= n;) { ll x = n / i; ll y = min(n / x, n); sum += x * (y - i + 1); i = y + 1; } return sum;}int main() { ll a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; solve(b) - solve(a - 1) &lt;&lt; endl; return 0;} F. Light Emitting Hindenburg题意从 $n$ 个正整数中选出k个数字使得进行按位与操作得到的结果最大$(n \\in [1, 2e5])$。 Solution考虑二进制位，当且仅当 $k$ 个数字该位都为1，位与结果才为1。因此从高位开始枚举二进制位，当该位为1的数量超过 $k$ 时，剔除所有不为1的数，最后剩下的数即为可以选择的数，且这些数无论怎么选择 $k$ 个，位与结果都相同。 Code12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5;int n, k, a[N], vis[N];int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;a[i]); for (int i = 30; i &gt;= 0; i--) { int cnt = 0; for (int j = 0; j &lt; n; j++) { if ((a[j] &gt;&gt; i) &amp; 1 &amp;&amp; !vis[j]) cnt++; } if (cnt &gt;= k) { for (int j = 0; j &lt; n; j++) { if (!((a[j] &gt;&gt; i) &amp; 1)) vis[j] = 1; } } } int res = -1; for (int i = 0; i &lt; n; i++) { if (!vis[i]) res &amp;= a[i]; } printf(&quot;%d\\n&quot;, res); return 0;} H. Ponk Warshall题意两个字符串s, t仅包含ATCG，求s最少经过多少次交换可以变为t$(n \\in [1, 1e6])$。 Solution按四种优先级讨论： 同一个位置字符相同，直接跳过无需交换。 交换一次，使得两个字符直接匹配。 交换两次，使得三个字符直接匹配。 交换三次，使得四个字符直接匹配。 数组 $cnt[i][j]$ 表示每个字符的对应关系，按优先级计算累加答案即可。 Code123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;int n, res, mp[200], cnt[4][4];int main() { string s, t; cin &gt;&gt; s &gt;&gt; t; n = s.size(); mp['A'] = 0, mp['T'] = 1, mp['C'] = 2, mp['G'] = 3; for (int i = 0; i &lt; n; i++) { if (s[i] != t[i]) cnt[mp[s[i]]][mp[t[i]]]++; } for (int i = 0; i &lt; 4; i++) { for (int j = 0; j &lt; i; j++) { int x = min(cnt[i][j], cnt[j][i]); res += x; cnt[i][j] -= x, cnt[j][i] -= x; } } for (int i = 0; i &lt; 4; i++) { for (int j = 0; j &lt; i; j++) { for (int k = 0; k &lt; j; k++) { int x = min(cnt[i][j], min(cnt[j][k], cnt[k][i])); int y = min(cnt[i][k], min(cnt[k][j], cnt[j][i])); res += (x + y) * 2; cnt[i][j] -= x, cnt[j][k] -= x, cnt[k][i] -= x; cnt[i][k] -= y, cnt[k][j] -= y, cnt[j][i] -= y; } } } for (int i = 0; i &lt; 4; i++) res += cnt[0][i] * 3; cout &lt;&lt; res &lt;&lt; endl; return 0;}","link":"/2020/10/%E7%89%9B%E5%AE%A2%E5%9B%BD%E5%BA%86%E9%9B%86%E8%AE%ADday1.html"},{"title":"牛客多校2020第二场补题","text":"F Fake Maxpooling题意规定矩阵对应的值为其下标的 $lcm$ ，求所有 $k * k$ 子矩阵最大值之和。 $( n,m,k = 5000 )$ Solution 线性求 $lcm$ + 二维单调队列 线性求 $lcm$ ： 123456789for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) { if (!g[i][j]) { for (int h = 1; h * i &lt;= n &amp;&amp; h * j &lt;= m; h++) { g[h * i][h * j] = h; a[h * i][h * j] = i * j * h; } } } 先对每一行进行单调队列（滑动窗口）维护出最大值矩阵 $g$ ，再对列进行单调队列维护矩阵 $g$ 的最大值即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5005;int n, m, k, a[N][N], g[N][N];long long res;int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) { if (!g[i][j]) { for (int h = 1; h * i &lt;= n &amp;&amp; h * j &lt;= m; h++) { g[h * i][h * j] = h; a[h * i][h * j] = i * j * h; } } } for (int i = 1; i &lt;= n; i++) { deque&lt;int&gt; q; for (int j = 1; j &lt;= m; j++) { while (!q.empty() &amp;&amp; a[i][q.back()] &lt; a[i][j]) q.pop_back(); while (!q.empty() &amp;&amp; j - q.front() &gt;= k) q.pop_front(); q.push_back(j); if (j &gt;= k) g[i][j] = a[i][q.front()]; } } for (int i = k; i &lt;= m; i++) { deque&lt;int&gt; q; for (int j = 1; j &lt;= n; j++) { while (!q.empty() &amp;&amp; g[q.back()][i] &lt; g[j][i]) q.pop_back(); while (!q.empty() &amp;&amp; j - q.front() &gt;= k) q.pop_front(); q.push_back(j); if (j &gt;= k) { a[j][i] = g[q.front()][i]; res += a[j][i]; } } } printf(&quot;%lld\\n&quot;, res); return 0;} C Cover the Tree题意给定无根树，用最少的链覆盖树的所有点。 $( n = 2e5 )$ Solution思维 + dfs序 首先不难想到所取的链两个端点都在叶子上才会是最优的，因此答案应为 $(叶子结点数 + 1)/2$ 。 经过一番玄学证明，得到结论为按 dfs序 构造链会是最优的，任取非叶子结点为根，由 dfs序 得到叶子结点 $l1, l_2 ….l_x$ ，然后将 $l_1$ 与 $l{x/2+1}$ 构成链以此类推，若多出一个点，则与根结点连起来即可。 Code1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5;int n, u, v, root, de[N];vector&lt;int&gt; g[N], res;void dfs(int u, int fa) { if (de[u] == 1) res.push_back(u); for (auto v : g[u]) { if (v == fa) continue; dfs(v, u); }}int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt; n; i++) { scanf(&quot;%d%d&quot;, &amp;u, &amp;v); g[u].push_back(v); g[v].push_back(u); de[u]++; de[v]++; } for (int i = 1; i &lt;= n; i++) { if (de[i] &gt; 1) root = i; } dfs(root, -1); n = res.size(); if (n &amp; 1) res.push_back(root), n++; n &gt;&gt;= 1; printf(&quot;%d\\n&quot;, n); for (int i = 0; i &lt; n; i++) printf(&quot;%d %d\\n&quot;, res[i], res[i + n]); return 0;} B Boundary题意已知一个圆必过点 $(0,0)$ ，需要构造该圆使得尽可能多的给定点在该圆的边界上，问最多能有几个点。 $( n = 2000, |x,y| = 100000 )$ Solution三个点可以确定一个圆，因此不妨枚举两个点，求出圆心，圆心重合次数最多的即为答案。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2005;int n, res;double X, Y, R;struct Point { double x, y;} p[N];map&lt;pair&lt;double, double&gt;, int&gt; mp;bool solve(Point a, Point b, Point c) //三点共圆圆心公式{ if (2 * (a.y - c.y) * (a.x - b.x) - 2 * (a.y - b.y) * (a.x - c.x) == 0 &amp;&amp; 2 * (a.y - b.y) * (a.x - c.x) - 2 * (a.y - c.y) * (a.x - b.x) == 0) return false; X = ((a.x * a.x - b.x * b.x + a.y * a.y - b.y * b.y) * (a.y - c.y) - (a.x * a.x - c.x * c.x + a.y * a.y - c.y * c.y) * (a.y - b.y)) / (2 * (a.y - c.y) * (a.x - b.x) - 2 * (a.y - b.y) * (a.x - c.x)); Y = ((a.x * a.x - b.x * b.x + a.y * a.y - b.y * b.y) * (a.x - c.x) - (a.x * a.x - c.x * c.x + a.y * a.y - c.y * c.y) * (a.x - b.x)) / (2 * (a.y - b.y) * (a.x - c.x) - 2 * (a.y - c.y) * (a.x - b.x)); R = sqrt((X - a.x) * (X - a.x) + (Y - a.y) * (Y - a.y)); return true;}int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) scanf(&quot;%lf%lf&quot;, &amp;p[i].x, &amp;p[i].y); Point o = {0, 0}; for (int i = 1; i &lt; n; i++) { mp.clear(); for (int j = i + 1; j &lt;= n; j++) { if (solve(o, p[i], p[j])) { auto now = make_pair(X, Y); res = max(res, ++mp[now]); } } } printf(&quot;%d\\n&quot;, ++res); return 0;} J Just Shuffle题意一个排列经过质数次置换后得到排列 A ，求原排列。 ( n = 1e5 ) Solution直接拍个置换开根板子就过了。。。 Code1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1000010;int n, m, i, j, k, o, x, l, d, a[N], g[N], nxt[N], t, q[N], b[N], ans[N];bool v[N];int cal(int x) { int i, k = m, t = 1; for (i = 2; i * i &lt;= x; i++) if (x % i == 0) { while (x % i == 0) x /= i, t *= i; while (k % i == 0) k /= i, t *= i; } if (x &gt; 1) for (t *= x; k % x == 0; k /= x, t *= x) ; return t;}int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]); for (i = 1; i &lt;= n; i++) if (!v[i]) { t = v[i] = 1; for (j = a[i]; j != i; j = a[j]) v[j] = 1, t++; nxt[i] = g[t], g[t] = i; } for (i = 1; i &lt;= n; i++) if (g[i]) { for (t = 0, j = g[i]; j; j = nxt[j]) q[++t] = j; d = __gcd(l = cal(i), m); if (t % d) return puts(&quot;1&quot;), 0; for (x = 1; x &lt;= t; x += d) { for (j = 0; j &lt; d; j++) for (k = 0, o = q[x + j]; k &lt; i; k++, o = a[o]) b[(j + 1LL * k * m) % l] = o; for (j = 0; j &lt; l; j++) ans[b[j]] = b[(j + 1) % l]; } } for (i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, ans[i]);}","link":"/2020/07/%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A12020%E7%AC%AC%E4%BA%8C%E5%9C%BA%E8%A1%A5%E9%A2%98.html"},{"title":"继承，虚函数和多态","text":"继承 with virtual function构造由内而外：首先调用父类的构造函数，然后再调用自己。析构由外而内：首先执行自己的析构函数，然后调用父类的析构函数。 non-virtual: 你不希望重新定义（重写）它。virtual: 你希望子类重新定义它，且它有默认定义。pure virtual: 你希望子类一定要重新定义它，你对它没有默认定义。 123456789class Shape { public: virtual void draw() const = 0; // 纯虚函数 virtual void error(const std::string&amp; msg); // 虚函数 int objectID() const; // 一般成员函数};class Rectangle: public Shape {...};class Ellipse: public Shape {...}; 多态在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据所指对象的实际类型来调用相应的函数，如果对象类型是派生类，就调用派生类的函数，如果对象类型是基类，就调用基类的函数。 虚表：虚函数表的缩写，类中含有virtual关键字修饰的方法时，编译器会自动生成虚表 虚表指针：在含有虚函数的类实例化对象时，对象地址的前四个字节存储的指向虚表的指针 编译器在发现基类中有虚函数时，会自动为每个含有虚函数的类生成一份虚表，该表是一个一维数组，虚表里保存了虚函数的入口地址 编译器会在每个对象的前四个字节中保存一个虚表指针，即vptr，指向对象所属类的虚表。在构造时，根据对象的类型去初始化虚指针vptr，从而让vptr指向正确的虚表，从而在调用虚函数时，能找到正确的函数 在派生类定义对象时，程序运行会自动调用构造函数，在构造函数中创建虚表并对虚表初始化。在构造子类对象时，会先调用父类的构造函数，此时，编译器只“看到了”父类，并为父类对象初始化虚表指针，令它指向父类的虚表；当调用子类的构造函数时，为子类对象初始化虚表指针，令它指向子类的虚表 当派生类对基类的虚函数没有重写时，派生类的虚表指针指向的是基类的虚表；当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表；当派生类中有自己的虚函数时，在自己的虚表中将此虚函数地址添加在后面 基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间首先整理一下虚函数表的特征： 虚函数表是全局共享的元素，即全局仅有一个，在编译时就构造完成 虚函数表类似一个数组，类对象中存储vptr指针，指向虚函数表，即虚函数表不是函数，不是程序代码，不可能存储在代码段 虚函数表存储虚函数的地址,即虚函数表的元素是指向类成员函数的指针,而类中虚函数的个数在编译时期可以确定，即虚函数表的大小可以确定,即大小是在编译时期确定的，不必动态分配内存空间存储虚函数表，所以不在堆中 根据以上特征，虚函数表类似于类中静态成员变量。静态成员变量也是全局共享，大小确定，因此最有可能存在全局数据区。 由于虚表指针vptr跟虚函数密不可分，对于有虚函数或者继承于拥有虚函数的基类，对该类进行实例化时，在构造函数执行时会对虚表指针进行初始化，当一个构造函数被调用时，它做的首要的事情之中的一个是初始化它的VPTR，并且存在对象内存布局的最前面。 补充：inline内联函数内联函数和普通函数的区别在于：当编译器处理调用内联函数的语句时，不会将该语句编译成函数调用的指令，而是直接将整个函数体的代码插人调用语句处，就像整个函数体在调用处被重写了一遍一样。相比之下，普通函数能够避免将相同代码重写多次的麻烦，还能减少可执行程序的体积，但也会带来程序运行时间上的开销；而内联函数省去了调用函数的时间开销。 在函数调用执行过程中，首先要为在栈中的形参和局部变量分配存储空间，然后再将实参的值复制给形参，然后还要将函数的返回地址放入栈中，最后才跳转到函数内部执行。return语句返回时，还要从栈中回收形参和局部变量占有的存储空间，然后从栈中取出返回地址，跳转到该地址继续执行。 如果内联函数执行的时间很长，那函数调用的时间相比起来就微不足道，使用内联函数也就没有意义了。从另一方面来说，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。因此，内联函数中的代码应该是很简单，执行起来很快的一些语句。 Google C++编码规范对于inline的使用说明：1234567891011121314内联函数：Tip： 只有当函数只有 10 行甚至更少时才将其定义为内联函数.定义: 当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用.优点: 当函数体比较小的时候, 内联该函数可以令目标代码更加高效. 对于存取函数以及其它函数体比较短, 性能关键的函数, 鼓励使用内联.缺点: 滥用内联将导致程序变慢. 内联可能使目标代码量或增或减, 这取决于内联函数的大小. 内联非常短小的存取函数通常会减少代码大小, 但内联一个相当大的函数将戏剧性的增加代码大小. 现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快。结论: 一个较为合理的经验准则是, 不要内联超过 10 行的函数. 谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!另一个实用的经验准则: 内联那些包含循环或 switch 语句的函数常常是得不偿失 (除非在大多数情况下, 这些循环或 switch 语句从不被执行).有些函数即使声明为内联的也不一定会被编译器内联, 这点很重要; 比如虚函数和递归函数就不会被正常内联. 通常, 递归函数不应该声明成内联函数.(递归调用堆栈的展开并不像循环那么简单, 比如递归层数在编译时可能是未知的, 大多数编译器都不支持内联递归函数). 虚函数内联的主要原因则是想把它的函数体放在类定义内, 为了图个方便, 抑或是当作文档描述其行为, 比如精短的存取函数.PS：内联函数和宏定义的区别： 内联函数在编译时展开，宏在预编译时展开 内联函数直接嵌入到目标代码中，宏是简单的做文本替换 内联函数有类型检测、语法判断等功能，而宏没有 内联函数是函数，宏不是 宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义 内联函数代码是被放到符号表中，使用时像宏一样展开，没有调用的开销，效率很高 构造函数、析构函数、虚函数可否声明为内联函数将这些函数声明为内联函数，在语法上没有错误。因为inline同register一样，只是个建议，编译器并不一定真正的内联。 register关键字：这个关键字请求编译器尽可能的将变量存在CPU内部寄存器中，而不是通过内存寻址访问，以提高效率 首先在《Effective C++》中明确阐述：将构造函数和析构函数声明为inline是没有什么意义的，即编译器并不真正对声明为inline的构造和析构函数进行内联操作，因为编译器会在构造和析构函数中添加额外的操作（申请/释放内存，构造/析构对象等），致使构造函数/析构函数并不像看上去的那么精简。其次，class中的函数默认是inline型的，编译器也只是有选择性的inline，将构造函数和析构函数声明为内联函数是没有什么意义的。 虚函数是通过指针或引用调用函数时，通过虚函数表来确定调用的函数，在运行时确定。内联函数是在编译时，将调用函数处插入内联函数的代码，省去了函数调用时的开销。 表面上看，虚函数不能为内联函数。但如果虚函数在编译期就能够确定要调用哪个函数时，就能够内联。也就是用对象本身去调用虚函数时，会内联展开，当然前提是函数并不复杂的情况下。 构造函数与虚函数构造函数不可以是虚函数。 从vptr角度解释：虚函数对应一个vtable，可是这个vtable其实是存储在对象的内存空间的。 那么问题来了，如果构造函数是虚函数，就要通过vtable来调用，可是对象空间还没有实例化，也就是内存空间还没有，无法找到vtable，所以构造函数不能是虚函数。 从使用角度：虚函数主要用于在信息不全的情况下，能够使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义。 析构函数与虚函数在派生类中的析构函数常常为虚析构函数，是为了避免内存泄露。 如果不考虑虚函数的状况，给出一个基类和派生类，如果调用派生类的析构函数时，肯定会引发调用基类的析构函数，这和析构函数是不是虚函数没关系。如：[ Derive* p = new Derive(); ] 现在考虑虚函数的问题，由于使用虚函数使我们可以定义一个基类指针或引用可以直接对派生类进行操作，如：[ Base* p = new Derive(); ]，这就存在两种情况： 如果，不把基类的析构函数设置为虚函数，则在删除对象时，如果直接删除基类指针，系统就只能调用基类析构函数，而不会调用派生类构造函数。这就会导致内存泄露。 如果，把基类的析构函数设置为虚函数，则在删除对象时，直接删除基类指针，系统会调用派生类析构函数，之后此派生类析构函数会引发系统自动调用自己的基类，这就不会导致内存泄露。 所以，在写一个类时，尽量将其析构函数设置为虚函数，但析构函数默认不是虚函数。 [问] 应该把所有的类的析构函数都设置为虚函数吗？[答] 不一定。使用虚函数后的类对象要比不使用虚函数的类对象占的空间多，而且在查找具体使用哪一个虚函数时，还会有时间代价。即当一个类不打算作为基类时，不用将其中的函数设置为虚函数。 构造函数和析构函数可以调用虚函数吗，为什么不提倡在构造函数和析构函数中调用虚函数。 因为父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全的，故而C++不会进行动态联编 析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义。 动态绑定和静态绑定为了支持c++的多态性，才用了动态绑定和静态绑定。 对象的静态类型：对象在声明时采用的类型。是在编译期确定的。 对象的动态类型：目前所指对象的类型，是在运行期决定的。对象的动态类型可以更改，但是静态类型无法更改。 1234567class B {}class C : public B {}class D : public B {}D* pD = new D();//pD的静态类型是它声明的类型D*，动态类型也是D*B* pB = pD;//pB的静态类型是它声明的类型B*，动态类型是pB所指向的对象pD的类型D*C* pC = new C();pB = pC;//pB的动态类型是可以更改的，现在它的动态类型是C* 静态绑定：绑定的是对象的静态类型，某特性（比如函数）依赖于对象的静态类型，发生在编译期。 动态绑定：绑定的是对象的动态类型，某特性（比如函数）依赖于对象的动态类型，发生在运行期。 1234567891011121314151617class B{ void DoSomething(); virtual void vfun();}class C : public B{ void DoSomething();//首先说明一下，这个子类重新定义了父类的no-virtual函数，这是一个不好的设计，会导致名称遮掩；这里只是为了说明动态绑定和静态绑定才这样使用。 virtual void vfun();}class D : public B{ void DoSomething(); virtual void vfun();}D* pD = new D();B* pB = pD; pD-&gt;DoSomething() 和 pB-&gt;DoSomething() 是no-virtual函数，它是静态绑定的，也就是编译器会在编译期根据对象的静态类型来选择函数。 pD-&gt;vfun()和pB-&gt;vfun() 是一个虚函数，它动态绑定的，也就是说它绑定的是对象的动态类型，pB和pD虽然静态类型不同，但是他们同时指向一个对象，他们的动态类型是相同的，都是D*，所以，他们的调用的是同一个函数：D::vfun()。 需要特别注意：虚函数的缺省参数是静态绑定的！！！ 总结：可以认为只有虚函数才使用的是动态绑定，其他的全部是静态绑定。","link":"/2021/02/%E7%BB%A7%E6%89%BF-%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81.html"},{"title":"计算机网络知识点","text":"网络模型ISO七层：物理层，数据链路层，网络层，传输层，会话层，表示层，应用层。TCP/IP分层模型： 网络接口层，ARP地址解析协议，提供硬件间接口。 网间层，IP协议，负责数据的包装，寻址，和路由。 传输层，TCP协议提供可靠数据流传输服务，UDP协议提供不可靠的用户数据报服务。 应用层，FTP（文件传输协议），HTTP（超文本传输协议），Telent（远程终端协议）。 TCP首部 源端口和目的端口，各2字节 序号，4字节，面向字节流传输，标识当前报文段发送数据的起始编号，接受方根据起始编号和数据大小，就可以推算出下一个应该接受报文的起始编号 确认号，4字节，下一个希望收到报文的起始编号，即表示：N之前编号的数据已经成功收到 数据偏移，4字节，数据部分离报文段起始位置有多远 保留位，6字节，暂时没用，留着以后使用 URG：说明有紧急数据，应尽快发送 ACK：建立连接后所有ACK报文必须置为1 PSH：。。。 RST：出现了严重错误，必须重新建立连接 SYN：请求连接 FIN：释放连接 窗口：发送本报文段的一方的接受窗口 检验和：检验报文的首部和数据是否发送改变 MSS：规定的最大报文长度 三次握手与四次挥手 第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 SYN_Send 状态。 第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。 同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。 第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 establised 状态。 服务器收到 ACK 报文之后，也处于 establised 状态，此时，双方已建立起了链接。 因此三次握手可以确认双发收发功能都正常，缺一不可。 [问]：为什么要传回 SYN：接收端告诉发送端，我接收到的信息确实就是你所发送的信号。[问]：为啥还要传 ACK：SYN 只能证明发送端到接受端的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来验证。 第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。 第二次握手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。 需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态 服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。 [问]：为什么连接的时候是三次握手，关闭的时候却是四次握手？答：连接时，当服务端收到客户端的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文，其中 ACK 报文是用来应答的，SYN 是用来同步的。但关闭连接时，服务端收到 FIN 报文后，可能不会立即发送 FIN 报文，因为服务端可能该发送的报文还没有发完，因此只能先回复一个 ACK 报文表示确认收到了。等服务端所有报文都发送完了，才回复 FIN 信号关闭连接。故需要四次握手。 [问]：为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？ 答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。 [问]：为什么不能用两次握手进行连接？答：考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发送了确认应答分组。按照两次握手的协定，S 认为连接已经成功地建立了，可以开始发送数据分组。可是，如果这个应答分组丢失了，C 就不知道 S 是否已准备好，C 就会怀疑 S 是否收到自己的连接请求分组。在这种情况下，C 认为连接还未建立成功，将忽略 S 发来的任何数据分组，只等待连接确认应答分组。而 S 在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。 [问]：如果已经建立了连接，但是客户端突然出现故障了怎么办？答：TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。 TCP超时重传出现以下情况，TCP就会超时重传： 数据包中途丢失 数据包顺利到达，ACK报文中途丢失 数据包到达对端，但对端未响应ACK或被对端丢失 TCP每发送一个报文段，就会设置一次计时器。计时器设置的重传时间到了，还没有收到确认，就要重传这一报文段，称为“超时重传”。 RTO：重传超时时间，发送端发送数据到重传数据的这一段等待时间RTT：连接往返时间，发送端从发送TCP包接受到对应的立即响应所耗费的时间 TCP流量控制接受端缓冲区大小有限，发送的太快太多接受端来不及处理。 如果一个一个发数据段，等确认了再发下一个，效率就比较低。 使用的是滑动窗口，接收方通过ack来通知发送端自己可以接收的缓冲区大小。 操作系统内核为了维护滑动窗口，需要开辟发送缓冲区，来记录当前还有那些数据没有应答，只有确认应答过的数据，才能从缓冲区删掉。 TCP拥塞控制防止发送方发的太快，使得网络来不及处理，从而导致网络拥塞。 慢开始阶段：设置拥塞窗口cwnd为1，然后以指数增长（乘2），逐步发送数据。 拥塞避免阶段：为了防止cwnd增加过快而导致网络拥塞，所以需要设置一个慢开始门限ssthresh状态变量，窗口大小增长到门限值，就改为执行拥塞避免算法，每经历过一次往返时间就使cwnd增加1。 拥塞调整阶段：一旦网络出现超时，出现网络拥塞，拥塞窗口门限值减小为一半。 窗口大小重设为1，循环慢开始阶段。 流量控制和拥塞控制的区别： 一个是丢包在接受端上，一个是丢包在路由器上。 一个是怕接受端来不及处理，一个怕网络拥塞，网络来不及处理 TCP和UDP区别用户数据报协议 UDP（User Datagram Protocol）传输控制协议 TCP（Transmission Control Protocol） TCP面向连接，UDP不需要建立连接，随时想发就发，也不会对数据报进行任何拆分，也就说明UDP是不可靠传输 UDP并不只是一对一的，有单播，多播，广播的功能 UDP面向报文，TCP面向字节流 UDP头部更小（源端口，目的端口，数据长度，校验和），只有8个字节，传输效率更高 TCP有流量控制，拥塞控制来保证安全性，UDP没有 UDP适用于事实通信（电话，直播），TCP适用于可靠传输（文件传输） HTTP协议HTTP（超文本传输协议），基于TCP/IP通信协议来传递数据，属于应用层的面向对象的协议。特点： 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。 灵活：HTTP允许传输任意类型的数据对象。 无连接：无连接的含义是限制每次连接只处理一个请求。 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传。 支持B/S及C/S模式。 从输入URL到页面加载发生了什么？ DNS 域名解析 当你输入了 www.google.com 并按下回车后，浏览器检查输入框，发现不是 ip 地址，于是去 浏览器缓存 里面找有没有相关记录，发现没有，那就继续去 系统缓存 找，也就是系统中的 hosts 文件，还是没有，又继续去 路由器缓存 里面找，查看的是路由器映射表。接着，计算机将域名发送给 本地DNS服务器，也就是 提供本地连接的服务商，本地DNS服务器找不到的话，会将域名发送到 根域名服务器，也就是 ‘.’，找不到就返回 顶级域名服务器 —— .com 的IP地址，再请求 顶级域名服务器IP 返回 二级域名服务器 —— google.com 的IP地址…直到找到对应的IP地址，然后返回给浏览器。 发起 TCP 连接（三次握手） 知道IP地址后，传输层的TCP协议就可以向远端服务器发起连接请求了。 发送 HTTP 请求，接受 HTTP 响应 连接上了，可以传输了。计算机需要将用户输入的地址封装成 HTTP Request 请求报文，发送到服务器，服务器收到请求后会发出应答，即响应数据。 HTTP请求报文格式：请求行+请求头+空行+消息体，请求行包括请求方式（GET/POST/DELETE/PUT）、请求资源路径（URL）、HTTP版本号。 HTTP响应报文格式：状态行+响应头+空行+消息体，状态行包括HTTP版本号、状态码、状态说明。 断开 TCP 连接（四次挥手） 完成一次 HTTP 请求后，服务器并不是马上断开与客户端的连接。默认启用 持久连接，以便处理不久后到来的新请求，无需重新建立连接而增加慢启动开销，提高网络的吞吐能力。在反向代理软件 Nginx 中，持久连接超时时间默认值为 75 秒，如果 75 秒内没有新到达的请求，则断开与客户端的连接。同时，浏览器每隔 45 秒会向服务器发送 TCP keep-alive 探测包，来判断 TCP 连接状况，如果没有收到 ACK 应答，则主动断开与服务器的连接。 浏览器解析 HTML 代码，请求js，css等资源，最后进行页面渲染，显示出来。 常见的状态码： 1xx，表示成功发出请求正在处理 2xx，表示成功处理请求 3xx，表示需要完成请求，需要进行重定向 4xx，表示请求错误，妨碍了服务器的处理 5xx，表示服务器错误 200 响应成功 302 跳转 400 客户端请求有语法错误，不能被服务端识别 403 服务器收到请求，但拒绝提供服务（认证失败） 404 请求资源不存在 500 服务器内部错误 GET和POST区别HTTP请求方法，POST和GET都是向服务器提交数据，并且都会从服务器获取数据。 get通过地址栏传输，安全性较低，post通过报文传输，安全性更高一些，但也没多高，毕竟http本身就是不安全的 get长度受限于url长度，传输数据量小，post理论上没有限制 大部分情况下，get产生一个数据包，post产生两个数据包，也意味着get效率更高 对于get请求，浏览器会把http head和 data 一起发送出去，服务器响应200，返回数据。对于post请求，浏览器会先传http head，然后服务器响应100 continue，浏览器再发送data，服务器响应200，返回数据。 一般来说，做数据查询用get，做增删改用post（网站登陆，文件传输）。 HEAD类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头。 浅谈HTTP中Get、Post、Put与Delete的区别1、GET请求会向数据库发索取数据的请求，从而来获取信息，该请求就像数据库的select操作一样，只是用来查询一下数据，不会修改、增加数据，不会影响资源的内容，即该请求不会产生副作用。无论进行多少次操作，结果都是一样的。 2、与GET不同的是，PUT请求是向服务器端发送数据的，从而改变信息，该请求就像数据库的update操作一样，用来修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。 3、POST请求同PUT请求类似，都是向服务器端发送数据的，但是该请求会改变数据的种类等资源，就像数据库的insert操作一样，会创建新的内容。几乎目前所有的提交操作都是用POST请求的。 4、DELETE请求顾名思义，就是用来删除某一个资源的，该请求就像数据库的delete操作。 就像前面所讲的一样，既然PUT和POST操作都是向服务器端发送数据的，那么两者有什么区别呢。。。POST主要作用在一个集合资源之上的（url），而PUT主要作用在一个具体资源之上的（url/xxx），通俗一下讲就是，如URL可以在客户端确定，那么可使用PUT，否则用POST。 HTTP1.0、HTTP 1.1主要区别 HTTP1.1默认支持长连接，HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接。HTTP是基于TCP/IP协议的，创建一个TCP连接是需要经过三次握手的，有一定的开销，如果每次通讯都要重新建立连接的话，对性能有影响。因此最好能维持一个长连接，可以用一个长连接来发多个请求。 节约带宽，同post cookie和session的作用和区别Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端会把Cookie保存起来。 当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。 Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。 每个用户访问服务器都会建立一个session，那服务器是怎么标识用户的唯一身份呢？事实上，用户与服务器建立连接的同时，服务器会自动为其分配一个SessionId。 区别： cookie数据存放在客户的浏览器上，session数据放在服务器上。 session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用COOKIE cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗 将登陆信息等重要信息存放为SESSION，其他信息如果需要保留，可以放在COOKIE中 HTTP和HTTPS区别 HTTP通信使用明文,内容可能被窃听；HTTPS是具有安全性的SSL加密传输协议 HTTP不验证通信方身份，因此有可能遭遇伪装；HTTPS有验证机制 HTTP无法验证报文的完整性，所以有可能被篡改；HTTPS有完整性保护 HTTP使用80端口，HTTPS使用443端口","link":"/2021/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9.html"},{"title":"设计模式：策略模式","text":"定义定义一种算法，将每个算法都封装起来，并且使它们之间可以互换。是一种行为类模式。 举例为了通俗易懂，我们拿各国的税率计算来举例子： 假设当前我们的程序只能支持计算中国和美国的税率：12345678910public class Tax_Cal { public int CN_Cal(int x) { // 计算中国税 } public int US_Cal(int x) { // 计算美国税 }}这样写看起来没什么问题，但实际上我们想想，如果以后公司还要拓展，开始支持法国，日本等等国家，那么我们这个类就得不断但改啊改，是不是特别麻烦且危险？比如万一和前面的某个国家冲突了，就会影响到前面的计算。 所以我们干脆分开来写，把所有的国家税的计算都独立出来，实现的都是同一个接口，都有一个共同的参数x。 1234567891011121314151617181920212223242526272829303132public class Strategy { // 策略模式 public int Cal(int x);}public class CN_Tax implements Strategy { // 实现中国税计算接口 @Override public int Cal(int x) { }}public class US_Tax implements Strategy { // 实现美国税计算接口 @jOverride public int Cal(int x) { }}public class Tax_Cal { // 税计算类 private Strategy = strategy; // 定义一个策略 public void setStrategy(Strategy strategy) { // 接入策略 this.strategy = strategy; } public int getTax(int x) { // 得到结果 return this.strategy.cal }} 这样一来，所有的税务计算就互不影响啦，因为它们的计算已经被我们独立出来了，要计算哪一个国家的税，只需要接入该国家的算法，调用一下getTax就可以了。我们来写一下： 1234567public class Test { public static void main(string[] args) { Tax_Cal tax_cal = new Tax_Cal(); // 实例化对象 tax_cal.setStrategy(new CN_Tax()); // 接入中国税计算 int res = tax_cal.getTax(100); // 得到结果 }} 这样就实现了中国的税计算。由此可见，这样设计是更有策略性的，以后要有新的国家加入，不需要再修改原代码，只需要再实现一个新的国家接口就可以了。 总结：优点： 策略间可以自由的切换，因为它们都实现自同一个抽象。 易于拓展，基本上可以在不改变原有代码的基础上进行拓展。 避免使用多重条件语句，否则就得一直if else, switch case，这样非常不利于维护。 策略模式是一种简单常用的设计模式，一般来说不会单独使用，而是和其它模式混合使用。","link":"/2020/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.html"},{"title":"设计模式：单例模式","text":"什么是单例模式单例模式，顾名思义，就是整个系统就只有一个实例存在。 特点 单例类只能有一个实例。 单例类必须自己创建自己的唯一实例。 单例类必须给所有其他对象提供这一实例。 讲的通俗一点，我们拿女娲造人来举例： 我们先写一个女娲类： 123public class N_Wa {} 很明显，任何人都不能创造女娲，所以女娲的构造应该是私有的： 123public class N_Wa { private N_Wa() {} // 构造方法私有化} 有人可能要质疑：那女娲应该是谁创造的？这个问题千百万年来都没有人能解开过，所以在我们的潜意识中认为：神是自己创造自己的！ 1234public class N_Wa { private static final N_Wa n_wa = new N_Wa(); // 神自己创造自己 private N_Wa() {} // 构造方法私有化} private 保证了女娲的私有性，毕竟这个世界上没有人见过女娲。static 保证了女娲的静态性，她与类共存亡。final 保证了女娲是“终极”常量，不可能再被修改。 女娲已经出来了，接下来干什么呢？当然就是请她开始造人啦： 1234567public class N_Wa { private static final N_Wa n_wa = new N_Wa(); // 神自己创造自己 private N_Wa() {} // 构造方法私有化 public static N_Wa getInstance() { // 请求女娲 return n_wa; }} getInstance 和 new？new 是重新创建一个对象，且只能单次使用。getInstance 是没有对象的时候创建对象，有了之后就保留在内存中，下次就不用再重新创建了，因此它的对象一定是static的。 这样一来，只需要调用 N_Wa.getInstance(); 女娲就请过来了，而且不论是谁，请来的都是同一个女娲，也就是我们构造的“终极”常量：n_wa。当然你还可以往里面加入其它的功能（造人功能未写出）。 到此为止，我们就已经学会了单例模式——“饿汉模式”，即我们先把女娲给造好，需要的时候直接用就好了。 随之而来的是另一个问题：要是我们根本没有用到女娲呢？那不是白造了？于是又出现了一种叫“懒汉模式”： 12345678910public class N_Wa { private static N_Wa n_wa; // 这里并没有new一个女娲 private N_Wa() {} // 构造方法私有化 public static N_Wa getInstance() { // 请求女娲 if(n_wa == null) { n_wa = new N_Wa(); } return n_wa; }} 可以发现，我们不再是提前造女娲了，而是需要的时候再去造她（实例化），但这样子的坏处就是每次都要重新造一次女娲，所以速度肯定不如之前的“饿汉模式”。而且有个大问题，就是一旦有很多人同时请女娲的话，依然可能造成多个神的情况。 所以我们让这些人排队？看起来挺有道理，但仔细想想，有些人做事总是拖拖拉拉，毛手毛脚的，万一给让它排到前面去了，那后面的人不得等半天吗？等下队伍直接排出地球外了，所以我们干脆让他们直接抢，谁抢到就是谁的，这样一直抢下去： 1234567891011121314public class N_Wa { private static N_Wa n_wa; // 这里并没有new一个女娲 private N_Wa() {} // 构造方法私有化 public static N_Wa getInstance() { // 请求女娲 if(n_wa == null){ // 代表还没有人抢到 synchronized (N_Wa.class) { // 放他们进去抢 if(n_wa == null) { // 第一个抢到的给他 new一个然后返回 n_wa = new N_Wa(); } } } return n_wa; }} synchronized 是一种同步锁，可以防止同步发生，通俗来讲就是第一个人先用，这时锁被锁上，等他用完，锁再打开，以此类推。只有当锁是开着的，才能轮到下一个人。 到此为止，最基础的两种“恶汉模式”和“懒汉模式”就完成了，单例模式还有其它的一些变种，但思想上都大同小异，我们需要灵活运用，发挥出最大的价值！","link":"/2020/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html"},{"title":"静态代码块，构造代码块，构造函数及其执行顺序和逻辑","text":"静态代码块： 随着类的加载而执行，只执行一次，并优先于主函数。具体说，静态代码块是由类调用的。类调用时，先执行静态代码块，然后才执行主函数的。 静态代码块其实就是给类初始化的，而构造代码块是给对象初始化的。 静态代码块中的变量是局部变量，与普通函数中的局部变量性质没有区别。 一个类中可以有多个静态代码块（顺序由上至下）。 构造代码块 构造代码块的作用是给对象进行初始化。 对象一建立就运行构造代码块了，而且优先于构造函数执行。这里要强调一下，有对象建立，才会运行构造代码块，类不能调用构造代码块的，而且构造代码块与构造函数的执行顺序是前者先于后者执行。 构造代码块与构造函数的区别是：构造代码块是给所有对象进行统一初始化，而构造函数是给对应的对象初始化，因为构造函数是可以多个的，运行哪个构造函数就会建立什么样的对象，但无论建立哪个对象，都会先执行相同的构造代码块。也就是说，构造代码块中定义的是不同对象共性的初始化内容。 构造函数 对象一建立，就会调用与之相应的构造函数，也就是说，不建立对象，构造函数是不会运行的。 构造函数的作用是用于给对象进行初始化。 一个对象建立，构造函数只运行一次，而一般方法可以被该对象调用多次。 Java类初始化顺序 单一类：静态变量，静态代码块 &gt; 变量，构造代码块 &gt; 构造函数12345678910111213141516171819202122232425262728293031public class Test06 { public static String x = &quot;静态变量&quot;; public String y = &quot;变量&quot;; public Test06() { System.out.println(&quot;构造函数&quot;); } static { System.out.println(x); System.out.println(&quot;静态代码块&quot;); } { System.out.println(y); System.out.println(&quot;构造代码块&quot;); } public static void main(String[] args) { /* 输出：静态变量 静态代码块 */ Test06 test06 = new Test06(); /* 输出：变量 构造代码块 构造函数 */ }} 继承情况：父类静态 &gt; 子类静态 &gt; 父类构造代码块 &gt; 父类构造函数 &gt; 子类构造代码块 &gt; 子类构造函数 静态变量是属于类的，和继承无关！！！ 1234567891011121314151617181920212223242526272829303132333435363738394041public class Test06 { public Test06() { System.out.println(&quot;父类构造函数&quot;); } static { System.out.println(&quot;父类静态代码块&quot;); } { System.out.println(&quot;父类构造代码块&quot;); }}class Test06_1 extends Test06 { public Test06_1() { System.out.println(&quot;子类构造函数&quot;); } static { System.out.println(&quot;子类静态代码块&quot;); } { System.out.println(&quot;子类构造代码块&quot;); } public static void main(String[] args) { /* 输出：父类静态代码块 子类静态代码块 */ Test06_1 test06_1 = new Test06_1(); /* 输出：父类构造代码块 父类构造函数 子类构造代码块 子类构造函数 */ }} 练习12345678910111213141516171819202122232425262728293031323334public class StaticTest { public static void main(String[] args) { staticFunction(); } // 静态变量（有实例化的过程,这就是本题的重点） static StaticTest st = new StaticTest(); static { //System.out.println(b); // 编译报错：因为b在构造代码块后边，此处不能引用。因此Java代码是从上到下的顺序 System.out.println(&quot;1&quot;); } { System.out.println(&quot;2&quot;); } StaticTest() { System.out.println(&quot;3&quot;); System.out.println(&quot;a=&quot; + a + &quot;,b=&quot; + b); } public static void staticFunction() { System.out.println(&quot;4&quot;); } // 这两个变量写在最后面 int a = 110; static int b = 112;}/* 输出：2 3 a=110,b=0 1 4*/ 先初始化静态变量，也就是执行new StaticTest()，先执行构造代码块，输出 2 再执行构造函数，输出 3 和 a=110,b=0 在执行构造函数前，必须初始化实例属性，故 a = 110 静态变量从上到下初始化，还没有轮到，因此 b = 0 执行静态代码块，输出 1 最后进入main函数，执行静态方法staticFunction，输出 4 可以发现：static变量并不一定在实例化变量前被初始化。 父类和子类有同名属性时public class Test07 { public static void main(String[] args) { // 使用多态 Parent chidParent = new Child(); System.out.println(&quot;Parent:&quot; + chidParent.getAge()); //40 System.out.println(&quot;Parent:&quot; + chidParent.age); //18 System.out.println(&quot;Parent:&quot; + chidParent.id); //08 // 直接使用原本类型 Child child = new Child(); System.out.println(&quot;Child:&quot; + child.getAge()); //40 System.out.println(&quot;Child:&quot; + child.age); //40 System.out.println(&quot;Child:&quot; + child.id); //8 } } class Child extends Parent { public Integer age = 40; public Integer id = 8; public int getAge() { return age; } } class Parent { public Integer age = 18; public String id = &quot;08&quot;; public int getAge() { return age; } } 对于输出 18 的解释（Java的继承机制）： 属性属于实例自己的，所以Parent的age属性值是18 属性不存在覆盖（即使同名），而方法是实实在在的覆盖（复写）","link":"/2020/07/%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%8C%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E5%92%8C%E9%80%BB%E8%BE%91.html"},{"title":"12种Java中常用的语法糖","text":"什么是语法糖语法糖（Syntactic Sugar），也称糖衣语法，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。简而言之，语法糖让程序更加简洁，有更高的可读性。 解语法糖前面提到过，语法糖的存在主要是方便开发人员使用。但其实，Java虚拟机并不支持这些语法糖。这些语法糖在编译阶段就会被还原成简单的基础语法结构，这个过程就是解语法糖。说到编译，大家肯定都知道，Java语言中，javac命令可以将后缀名为.java的源文件编译为后缀名为.class的可以运行于Java虚拟机的字节码。如果你去看com.sun.tools.javac.main.JavaCompiler的源码，你会发现在compile()中有一个步骤就是调用desugar()，这个方法就是负责解语法糖的实现的。Java 中最常用的语法糖主要有泛型、变长参数、条件编译、自动拆装箱、内部类等。 糖块一： switch 支持 String 与枚举从Java 7 开始，switch 开始支持 String。其实Java中的switch自身原本就支持基本类型。比如int、char等。对于int类型，直接进行数值的比较。对于char类型则是比较其 ascii 码。 所以，对于编译器来说，switch中其实只能使用整型，任何类型的比较都要转换成整型。比如byte。short，char(ascii码是整型)以及int。 那么接下来看下 switch 对 String 的支持，有以下代码： 123456789101112131415public class SwitchTest { public static void main(String[] args) { String s = &quot;Shuke&quot;; switch (s) { case &quot;Shuke&quot;: System.out.println(&quot;Shuke&quot;); break; case &quot;Bata&quot;: System.out.println(&quot;Bata&quot;); break; default: break; } }} 反编译后的内容如下： 1234567891011121314151617181920212223242526272829public class SwitchTest { public SwitchTest() { } public static void main(String[] args) { String s = &quot;Shuke&quot;; byte var3 = -1; switch(s.hashCode()) { case 2063116: if (s.equals(&quot;Bata&quot;)) { var3 = 1; } break; case 79866362: if (s.equals(&quot;Shuke&quot;)) { var3 = 0; } } switch(var3) { case 0: System.out.println(&quot;Shuke&quot;); break; case 1: System.out.println(&quot;Bata&quot;); } }} 可以发现字符串的switch是通过equals()和hashCode()方法来实现的，hashCode()方法返回的是int，而不是long。 进行switch的实际是哈希值，然后通过使用equals方法比较进行安全检查，这个检查是必要的，因为哈希可能会发生碰撞。 糖块二： 泛型很多语言都是支持泛型的，但不同的编译器对于泛型的处理方式是不同的。 通常情况下，一个编译器处理泛型有两种方式：Code specialization和Code sharing。 C++和C#是使用Code specialization的处理机制，而Java使用的是Code sharing的机制。 Code sharing方式为每个泛型类型创建唯一的字节码表示，并且将该泛型类型的实例都映射到这个唯一的字节码表示上。将多种泛型类形实例映射到唯一的字节码表示是通过类型擦除（type erasue）实现的。 也就是说，对于Java虚拟机来说，它根本不认识 Map&lt;String, String&gt; map 这样的语法。需要在编译阶段通过类型擦除的方式进行解语法糖。 类型擦除的主要过程如下： 将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。 移除所有的类型参数。 例如: 1234Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();map.put(&quot;111&quot;, &quot;222&quot;);map.put(&quot;333&quot;, &quot;444&quot;);map.put(&quot;555&quot;, &quot;666&quot;); 解语法糖后： 1234Map map = new HashMap();map.put(&quot;111&quot;, &quot;222&quot;);map.put(&quot;333&quot;, &quot;444&quot;);map.put(&quot;555&quot;, &quot;666&quot;); 虚拟机中没有泛型，只有普通类和普通方法，所有泛型类的类型参数在编译时都会被擦除，并没有自己独有的 Class 类对象。比如并不存在 List&lt;String&gt;.class 或是List&lt;Integer&gt;.class，而只有 List.class。 补充： 当泛型遇到重载 12345678 public class GenericTypes { public static void method(List&lt;String&gt; list) { System.out.println(&quot;invoke method(List&lt;String&gt; list)&quot;); } public static void method(List&lt;Integer&gt; list) { System.out.println(&quot;invoke method(List&lt;Integer&gt; list)&quot;); }} 上面这段代码，有两个重载的函数，因为他们的参数类型不同，但是，这段代码是编译不通过的。因为参数 List 和 List 编译之后都被擦除了，变成了一样的原生类型 List，擦除动作导致这两个方法的特征签名变得一模一样。 当泛型遇到catch 泛型的类型参数不能用在 Java 异常处理的 catch 语句中。因为异常处理是由JVM在运行时刻来进行的。由于类型信息被擦除，JVM是无法区分两个异常类型 MyException&lt;String&gt; 和 MyException&lt;Integer&gt; 的。 当泛型内包含静态变量 12345678910111213141516public class StaticTest { public static void main(String[] args) { GT&lt;Integer&gt; gti = new GT&lt;Integer&gt;(); gti.var = 1; GT&lt;String&gt; gts = new GT&lt;String&gt;(); gts.var = 2; System.out.println(gti.var); }}class GT&lt;T&gt; { public static int var = 0; public void nothing(T x) { }} 以上代码输出结果为：2 !!! 由于经过类型擦除，所有的泛型类实例都关联到同一份字节码上，泛型类的所有静态变量是共享的。 糖块三： 自动装箱与拆箱自动装箱就是Java自动将原始类型值转换成对应的对象，比如将int的变量转换成Integer对象，这个过程叫做装箱，反之将Integer对象转换成int类型值，这个过程叫做拆箱。 因为这里的装箱和拆箱是自动进行的非人为转换，所以就称作为自动装箱和拆箱。 原始类型byte, short, char, int, long, float, double 和 boolean 对应的封装类为Byte, Short, Character, Integer, Long, Float, Double, Boolean。 先来看个自动装箱的代码： 1234public static void main(String[] args) { int i = 10; Integer n = i;} 反编译后代码如下: 12345public static void main(String args[]){ int i = 10; Integer n = Integer.valueOf(i);} 再来看个自动拆箱的代码： 1234public static void main(String[] args) { Integer i = 10; int n = i;} 反编译后代码如下： 12345public static void main(String args[]){ Integer i = Integer.valueOf(10); int n = i.intValue();} 从反编译得到内容可以看出，装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的。 补充： 自动装箱与拆箱——对象相等比较： 12345678public static void main(String[] args) { Integer a = 1000; Integer b = 1000; Integer c = 100; Integer d = 100; System.out.println(&quot;a == b is &quot; + (a == b)); System.out.println((&quot;c == d is &quot; + (c == d)));} 在Java 5中，在Integer的操作上引入了一个新功能来节省内存和提高性能。整型对象通过使用相同的对象引用实现了缓存和重用。适用于整数值区间-128 至 +127。只适用于自动装箱。使用构造函数创建对象不适用。数据会被自动装箱成包装类，JVM在比较之前会看在不在常量池范围内，在就字面量比较，不在就比较地址值。 糖块四： 方法变长参数可变参数(variable arguments)是在Java 1.5中引入的一个特性。它允许一个方法把任意数量的值作为参数。 看下以下可变参数代码，其中print方法接收可变参数： 1234567891011public static void main(String[] args){ print(&quot;111&quot;, &quot;222&quot;, &quot;333&quot;, &quot;444&quot;);}public static void print(String... strs){ for (int i = 0; i &lt; strs.length; i++) { System.out.println(strs[i]); }} 反编译后得到： 1234567891011public static void main(String args[]){ print(new String[] { &quot;111&quot;, &quot;222&quot;, &quot;333&quot;, &quot;444&quot; });}public static transient void print(String strs[]){ for(int i = 0; i &lt; strs.length; i++) System.out.println(strs[i]);} 从反编译后代码可以看出，可变参数在被使用的时候，他首先会创建一个数组，数组的长度就是调用该方法是传递的实参的个数，然后再把参数值全部放到这个数组当中，然后再把这个数组作为参数传递到被调用的方法中。 糖块五： 枚举Java SE5 提供了一种新的类型 — Java的枚举类型，关键字enum可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用，这是一种非常有用的功能。enumn就和 class 一样，只是一个关键字，并不是一个类。 123public enum t { SPRING,SUMMER;} 反编译后： 123456789101112131415161718192021222324252627282930public final class T extends Enum{ private T(String s, int i) { super(s, i); } public static T[] values() { T at[]; int i; T at1[]; System.arraycopy(at = ENUM$VALUES, 0, at1 = new T[i = at.length], 0, i); return at1; } public static T valueOf(String s) { return (T)Enum.valueOf(demo/T, s); } public static final T SPRING; public static final T SUMMER; private static final T ENUM$VALUES[]; static { SPRING = new T(&quot;SPRING&quot;, 0); SUMMER = new T(&quot;SUMMER&quot;, 1); ENUM$VALUES = (new T[] { SPRING, SUMMER }); }} public final class T extends Enum 说明该类是继承了Enum类的，同时final关键字意味着这个类也是不能被继承的。 当我们使用enmu来定义一个枚举类型的时候，编译器会自动帮我们创建一个final类型的类继承Enum类，所以枚举类型不能被继承。 糖块六： 内部类内部类又称为嵌套类，可以把内部类理解为外部类的一个普通成员。内部类之所以也是语法糖，是因为它仅仅是一个编译时的概念。 比如在 A.java 里面定义了一个内部类 B，一旦编译成功，就会生成两个完全不同的.class文件，分别是 A.class 和 A$B.class。所以内部类的名字完全可以和它的外部类名字相同。 一个类对应一个.class文件，多个类嵌套就会有多个.class文件。 糖块七：条件编译一般情况下，程序中的每一行代码都要参加编译。但有时候出于对程序代码优化的考虑，希望只对其中一部分内容进行编译，此时就需要在程序中加上条件，让编译器只对满足条件的代码进行编译，将不满足条件的代码舍弃，这就是条件编译。 123456789101112public class ConditionalCompilation { public static void main(String[] args) { final boolean DEBUG = true; if(DEBUG) { System.out.println(&quot;Hello, DEBUG!&quot;); } final boolean ONLINE = false; if(ONLINE){ System.out.println(&quot;Hello, ONLINE!&quot;); } }} 反编译后代码如下： 12345678910public class ConditionalCompilation { public ConditionalCompilation() { } public static void main(String[] args) { boolean DEBUG = true; System.out.println(&quot;Hello, DEBUG!&quot;); boolean ONLINE = false; }} 首先，我们发现，在反编译后的代码中没有 System.out.println(“Hello, ONLINE!”);，这其实就是条件编译。当 if(ONLINE) 为 false 的时候，编译器就没有对其内的代码进行编译。 所以，Java语法的条件编译，是通过判断条件为常量的 if 语句实现的。根据 if 判断条件的真假，编译器直接把分支为 false 的代码块消除。通过该方式实现的条件编译，必须在方法体内实现，而无法在正整个Java类的结构或者类的属性上进行条件编译。 糖块八： 断言在Java中，assert关键字是从JAVA SE 1.4 引入的，为了避免和老版本的Java代码中使用了assert关键字导致错误，Java在执行的时候默认是不启动断言检查的（这个时候，所有的断言语句都将忽略！）。如果要开启断言检查，则需要用开关 -enableassertions 或 -ea来开启。 assert关键字语法很简单，有两种用法： assert boolean表达式 如果为true，则程序继续执行。 如果为false，则程序抛出AssertionError，并终止执行。 assert boolean表达式 : 错误信息表达式 如果为true，则程序继续执行。 如果为false，则程序抛出java.lang.AssertionError，并输入\\&lt;错误信息表达式&gt;。 例：1234567891011public class AssertFoo { public static void main(String args[]) { //断言1结果为true，则继续往下执行 assert true; System.out.println(&quot;断言1没有问题，Go！&quot;); System.out.println(&quot;\\n-----------------\\n&quot;); //断言2结果为false,程序终止 assert false : &quot;断言失败，此表达式的信息将会在抛出异常的时候输出！&quot;; System.out.println(&quot;断言2没有问题，Go！&quot;); }}开启-ea开关，执行程序： 12345C:\\&gt;java -ea AssertFoo断言1没有问题，Go！-----------------Exception in thread &quot;main&quot; java.lang.AssertionError: 断言失败，此表达式的信息将会在抛出异常的时候输出！at AssertFoo.main(AssertFoo.java:10) 其实断言的底层实现就是 if 语言，如果断言结果为 true，则什么都不做，程序继续执行，如果断言结果为 false，则程序抛出 AssertionError 来打断程序的执行。 糖块十： for-each12345678public class ForEachTest { public static void main(String... args) { String[] strs = {&quot;111&quot;, &quot;222&quot;, &quot;333&quot;}; for (String s : strs) { System.out.println(s); } }} 反编译后代码如下： 12345678910111213141516public class ForEachTest { public ForEachTest() { } public static void main(String... args) { String[] strs = new String[]{&quot;111&quot;, &quot;222&quot;, &quot;333&quot;}; String[] var2 = strs; int var3 = strs.length; for(int var4 = 0; var4 &lt; var3; ++var4) { String s = var2[var4]; System.out.println(s); } }} for-each 的实现原理其实就是使用了普通的 for 循环和迭代器。 补充： 1234for (Student stu : students) { if (stu.getId() == 2) students.remove(stu); } 会抛出ConcurrentModificationException异常。 Iterator是工作在一个独立的线程中，并且拥有一个 mutex 锁。 Iterator被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，这个索引表的内容不会同步改变，所以当索引指针往后移动的时候就找不到要迭代的对象，所以按照 fail-fast 原则 Iterator 会马上抛出 java.util.ConcurrentModificationException 异常。 所以 Iterator 在工作的时候是不允许被迭代的对象被改变的。但你可以使用 Iterator 本身的方法remove()来删除对象，Iterator.remove() 方法会在删除当前迭代对象的同时维护索引的一致性。 糖块十一： try-with-resourceJava里，对于文件操作IO流、数据库连接等开销非常昂贵的资源，用完之后必须及时通过close方法将其关闭，否则资源会一直处于打开状态，可能会导致内存泄露等问题。 关闭资源的常用方式就是在 finally 块里是释放，即调用 close 方法。比如，我们经常会写这样的代码： 1234567891011121314151617181920public static void main(String[] args) { BufferedReader br = null; try { String line; br = new BufferedReader(new FileReader(&quot;xxx&quot;)); while ((line = br.readLine()) != null) { System.out.println(line); } } catch (IOException e) { // handle exception } finally { try { if (br != null) { br.close(); } } catch (IOException ex) { // handle exception } }} 从Java 7开始，jdk 提供了一种更好的方式关闭资源，使用 try-with-resources 语句，改写一下上面的代码，效果如下： 12345678910public static void main(String... args) { try (BufferedReader br = new BufferedReader(new FileReader(&quot;xxx&quot;))) { String line; while ((line = br.readLine()) != null) { System.out.println(line); } } catch (IOException e) { // handle exception }} 其实背后的原理也很简单，那些我们没有做的关闭资源的操作，编译器都帮我们做了。 糖块十二： Lambda表达式Labmda 表达式不是匿名内部类的语法糖，但是他也是一个语法糖。实现方式其实是依赖了几个 JVM 底层提供的 lambda 相关 api。 它并不是内部类的语法糖，前面讲内部类我们说过，内部类在编译之后会有对应的 class 文件，但是，包含 lambda 表达式的类编译后只有一个文件。","link":"/2020/09/12%E7%A7%8DJava%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96.html"},{"title":"Java 注解与反射","text":"注解 Annotation作用 对程序作出解释（类似于注释） 可以被其他程序读取（如：编译器等） 使用方式 注解以 “@注释名” 形式存在，如 “@Override”，有些可以添加一些参数值，如 “@SuppressWarnings(value=”unchecked”)” 附加在package，class，method，field等上方，等于给他们添加额外辅助信息，我们可以通过反射机制编程实现对这些元数据的访问 内置注解 @Override: 此注释只适用于修饰方法，表示一个方法声明打算重写超类中的另一个方法声明 @SuppressWarnings: 用于抑制编译时的警告信息(Warning)，需要添加参数才能使用，如：(“all”),(“unchecked”),(value={“unchecked”,”deprecation”})等等 元注解元注解作用就是负责注解其他注解，Java定义了4个标准的meta-annotation类型，他们被用来提供对其他annotation类型作说明 @Target: 用于描述注解的使用范围（被描述的注解可以用在什么地方） @Retention: 表示需要在什么级别保存该注释信息，用于描述注解的生命周期(SOURCE &lt; CLASS &lt; RUNTIME) @Document: 说明该注解将被包含在javadoc中 @Inherited: 说明子类可以继承父类中的该注解 自定义注解使用@interface自定义注解时，自动继承java.lang.annotation.Annotation接口 @interface用来声明一个注释，格式：@interface 注解名 { 定义内容 } 其中的每一个方法实际上是声明了一个配置参数 方法的名称就是参数的名称 返回值类型就是参数的类型，返回值只能是基本类型(Class, String, enum) 可以通过default来声明参数的默认值 如果只有一个参数成员，一般参数名为value 注解必须要有值，我们定义注解元素时，经常使用空字符串或者0来作为默认值(default) 1234567891011121314151617181920212223242526public class Test01 { // 注解可以显示赋值，没有先后顺序之分，如果没有默认值，就必须给注解赋值 @MyAnnotation01(id = 1, age = 18, name = &quot;Benboby&quot;) public void test01() {} // 当注解只有一个参数时，默认定义为 value() , 则可以省略 &quot;value = &quot; @MyAnnotation02(&quot;Benboby&quot;) public void test02() {}}@Target({ElementType.TYPE, ElementType.METHOD}) // 作用域可以在类上或者方法上@Retention(RetentionPolicy.RUNTIME) // 在运行时有效@interface MyAnnotation01 { // 注解的参数：参数类型 + 参数名() (+ 默认值); String name() default &quot;&quot;; int age(); int id(); String[] schools() default {&quot;本科&quot;,&quot;带专&quot;};}@Target({ElementType.TYPE, ElementType.METHOD}) // 作用域可以在类上或者方法上@Retention(RetentionPolicy.RUNTIME) // 在运行时有效@interface MyAnnotation02 { String value();}反射（Java Reflection）动态 VS 静态语言动态语言：运行时代码可以根据某些条件改变自身结构。如：C#, JavaScript, PHP, Python等。12345function f() { // var 是万能类型 var x = &quot;var a=1; var b=2; alert(a+b)&quot;; // 可以认为目前是字符串类型 eval(x) // 执行 x ，x 变为 a+b 的值}静态语言：运行时结构不可改变的语言就是静态语言。如：Java, C, C++。 Java不是动态语言，但Java有一定的动态性，我们可以利用反射机制获得类似动态语言的特性，使得Java在编程的时候变得更灵活。 简介Reflection是Java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。 加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构，这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射。 正常方式： 引入需要的“包类”名称 -&gt; 通过new实例化 -&gt; 取得实例化对象反射方式： 实例化对象 -&gt; getClass()方法 -&gt; 得到完整的“包类”名称 优点：可以实现创建对象和编译，体现出很大的灵活性缺点：对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于直接执行相同的操作。 123456789public class Test02 { public static void main(String[] args) throws ClassNotFoundException { // 通过反射获取对象类的Class对象 Class c1 = Class.forName(&quot;pers.Shuke.reflection.User&quot;); System.out.println(c1); // 输出：class pers.Shuke.reflection.User }}class User {...} Class类在Object类中定义了以下的方法，此方法将所有子类继承：public final Class getClass() 以上方法的返回值类型是一个Class类，此类是Java反射的源头，即：可以通过对象反射求出类名称。 获取Class类型的几种方式12345678910111213141516171819202122232425262728public class Test03 { public static void main(String[] args) throws ClassNotFoundException { Person person = new Student(); // 方式1：通过对象获得 Class c1 = person.getClass(); // 方式2：forname获得 Class c2 = Class.forName(&quot;pers.Shuke.reflection.Student&quot;); // 方式3：通过类名.class获得 Class c3 = Student.class; System.out.println(c3); // c1 = c2 = c3 = &quot;class pers.Shuke.reflection.Student&quot; // 方式4：基本内置类型的包装类都有一个Type属性 Class c4 = Integer.TYPE; // c4 = int // 方式5： Class c5 = c1.getSuperclass(); // c5 = &quot;class pers.Shuke.reflection.Person&quot; System.out.println(c5); }}class Person {...}class Student extends Person {...}class Teacher extends Person {...} 所有类型的Class对象1234567891011121314151617181920public class Test04 { public static void main(String[] args) { Class c1 = Object.class; // 类 c1 = &quot;class java.lang.Object&quot; Class c2 = Comparable.class; // 接口 c2 = &quot;interface java.lang.Comparable&quot; Class c3 = String[].class; // 一维数组 c3 = &quot;class [Ljava.lang.String;&quot; Class c4 = int[][].class; // 二维数组 c4 = &quot;class [[I&quot; Class c5 = Override.class; // 注解 c5 = &quot;interface java.lang.Override&quot; Class c6 = ElementType.class; // 枚举 c6 = &quot;class java.lang.annotation.ElementType&quot; Class c7 = Integer.class; // 基本数据类型 c7 = &quot;class java.lang.Integer&quot; Class c8 = void.class; // void c8 = &quot;void&quot; Class c9 = Class.class; // Class c9 = &quot;class java.lang.Class&quot; int[] a = new int[10]; int[] b = new int[100]; Class c10 = a.getClass(); Class c11 = b.getClass(); // c10 = c11 // 只有元素类型与维度一样，就是同一个Class }} Java内存分析简介堆：存放new的对象和数组，可以被所有的线程共享，不会存放别的对象引用栈：存放基本变量类型（包含具体数值），引用对象的变量（会存放这个引用在堆里面的具体地址）方法区：可以被所有的线程共享，包含所有的class和static变量 类的加载过程当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过以下三个步骤来对该类进行初始化。 类的加载(Load)：将类的class文件读入内存，并为之创建一个java.lang.Class对象。此过程由类加载器完成。 类的连接(Link)：将类的二进制数据合并到JRE中。 类的初始化(Initialize)：JVM负责对类进行初始化。 类的初始化 类的主动引用（一定会发生类的初始化） 当虚拟机启动，先初始化main方法所在的类 new一个类的对象 调用类的静态成员（除了final常量）和静态方法 使用java.lang.reflect包的方法对类进行反射调用 当初始化一个类，如果其父类没有被初始化，则会先初始化他的父类 类的被动引用 当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类初始化 通过数组定义类引用，不会触发此类的初始化 引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 测试类什么时候会被初始化public class Test08 { static { System.out.println(&quot;main类被加载&quot;); } public static void main(String[] args) throws ClassNotFoundException { // 主动调用 //Son son = new Son(); /* main类被加载 父类被加载 子类被加载 */ // 通过反射 //Class.forName(&quot;pers.Shuke.Initialization.Son&quot;); /* main类被加载 父类被加载 子类被加载 */ // 引用父类常量 //System.out.println(Son.b); /* main类被加载 父类被加载 2 */ // 引用自身常量 //System.out.println(Son.m); /* main类被加载 父类被加载 子类被加载 100 */ // 定义数组 //Son[] array = new Son[5]; /* main类被加载 */ // 引用final常量 //System.out.println(Son.f); /* main类被加载 10 */ }}class Father { static int b = 2; static { System.out.println(&quot;父类被加载&quot;); }}class Son extends Father { static{ System.out.println(&quot;子类被加载&quot;); m = 300; } static int m = 100; static final int f = 10;} 类加载器的作用类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据转化成方法区的运行时数据结构，然后在堆中生成一个代表这个类的Class对象，作为方法区中类数据的访问入口。 类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，他将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象。 源程序(.java文件) -&gt; Java编译器 -&gt; 字节码(.class文件) -&gt; 类装载器 -&gt; 字节码校验器 -&gt; 解释器 -&gt; 操作系统平台 1234567891011121314151617181920212223242526public class Test09 { public static void main(String[] args) throws ClassNotFoundException { // 获取系统类加载器 ClassLoader classLoader = ClassLoader.getSystemClassLoader(); System.out.println(classLoader); // 输出：jdk.internal.loader.ClassLoaders$AppClassLoader@3d4eac69 // 获取系统类父类的加载器 -&gt; 拓展类加载器 ClassLoader parent = classLoader.getParent(); System.out.println(parent); // 输出：jdk.internal.loader.ClassLoaders$PlatformClassLoader@77459877 // 获取拓展类加载器的父类加载器 -&gt; 引导类加载器/根加载器（C/C++） ClassLoader root = parent.getParent(); System.out.println(root); // 输出：null （无法直接获取） // 测试当前类是哪个加载器加载的 ClassLoader classLoader1 = Class.forName(&quot;pers.Shuke.Initialization.Test09&quot;).getClassLoader(); System.out.println(classLoader1); // 输出：jdk.internal.loader.ClassLoaders$AppClassLoader@3d4eac69 // 测试jdk内置的类是哪个加载器加载的 ClassLoader classLoader2 = Class.forName(&quot;java.lang.Object&quot;).getClassLoader(); System.out.println(classLoader2); // 输出：null // 如何获得系统类加载器可以加载的路径 System.out.println(System.getProperty(&quot;java.class.path&quot;)); }} 获取类的运行时结构通过反射获取类运行时的完整结构： 实现的全部接口（Interface） 所继承的父类（Superclass） 全部的构造器（Constructor） 全部的方法（Method） 全部的Field 注解 … PS：public/private/protected区别（默认为friendly） 作用域 当前类 同一public 子孙类 其他package public 1 1 1 1 protected 1 1 1 0 friendly 1 1 0 0 private 1 0 0 0 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Test05 { public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, NoSuchMethodException { Class c1 = Class.forName(&quot;pers.Shuke.reflection.User&quot;); System.out.println(c1.getName()); // 输出：pers.Shuke.reflection.User System.out.println(c1.getSimpleName()); // 输出：User User user = new User(); c1 = user.getClass(); System.out.println(c1.getName()); // 输出：pers.Shuke.reflection.User System.out.println(c1.getSimpleName()); // 输出：User Field[] fields = c1.getFields(); // 输出：null 解释：只能找到public属性 fields = c1.getDeclaredFields(); /* private java.lang.String pers.Shuke.reflection.User.name private int pers.Shuke.reflection.User.age private int pers.Shuke.reflection.User.id 解释：可以找到全部属性 */ for(Field field : fields) { System.out.println(field); } // 获得指定属性的值 //Field name = c1.getField(&quot;name&quot;); // 报错：只能获取public对象 Field name = c1.getDeclaredField(&quot;name&quot;); // 输出：private java.lang.String pers.Shuke.reflection.User.name System.out.println(name); // 获取类的方法 Method[] methods = c1.getMethods(); // 获取本类和父类所有public方法 methods = c1.getDeclaredMethods(); // 获取本类所有方法 for(Method method : methods) { System.out.println(method); } // 获取类的指定方法(需要传参) Method getname = c1.getMethod(&quot;getName&quot;, null); Method setname = c1.getMethod(&quot;setName&quot;, String.class); System.out.println(getname); // 输出：public java.lang.String pers.Shuke.reflection.User.getName() System.out.println(setname); // 输出：public void pers.Shuke.reflection.User.setName(java.lang.String) // 获得指定的构造器 Constructor[] constructors = c1.getConstructors(); // 获取public构造器 constructors = c1.getDeclaredConstructors(); // 获取指定构造器 // 获得指定构造器 Constructor constructor = c1.getDeclaredConstructor(String.class, int.class, int.class); System.out.println(constructor); // 输出：public pers.Shuke.reflection.User(java.lang.String,int,int) }} 动态创建对象执行方法创建类的对象：有无参构造器：调用Class对象的newInstance()方法 类必须有一个无参数构造器 类的构造器的访问权限要足够 没有无参构造器： 通过Class类的getDeclaredConstructor()取得本类的指定形参类型的构造器 向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的哥哥参数 通过Constructor 调用指定的方法：通过反射，调用类中的方法，通过Method完成。 通过Class类的getMethod()方法取得一个Method对象，并设置此方法操作时所需要的参数类型。 之后使用Object invoke()进行调用，并向方法中传递需要设置的obj对象的参数信息。 setAccessible： Method，Field和Constructor对象都有setAccessible()方法 作用为启动和禁用访问安全检查的开关 参数值为true则指示反射的对象在使用时应该取消Java语言访问检测，这样可以提高反射的效率，使得原本无法访问的私有成员也可以访问 123456789101112131415161718192021222324252627282930313233public class Test11 { public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException { // 获取class对象 Class c1 = Class.forName(&quot;pers.Shuke.reflection.User&quot;); // 构造一个对象 User user = (User)c1.newInstance(); // 本质上调用类的无参构造器 System.out.println(user); // pers.Shuke.reflection.User@5b2133b1 // 通过构造器创建对象 Constructor constructor = c1.getDeclaredConstructor(String.class, int.class, int.class); User user2 = (User)constructor.newInstance(&quot;舒克&quot;, 1, 10); System.out.println(user2); // pers.Shuke.reflection.User@72ea2f77 // 通过反射调用普通方法 User user3 = (User)c1.newInstance(); // 通过反射获取一个方法 Method setName = c1.getDeclaredMethod(&quot;setName&quot;, String.class); // invoke : 激活的意思 // {对象，方法的值} setName.invoke(user3, &quot;舒克&quot;); System.out.println(user3.getName()); // 舒克 // 通过反射操作属性 User user4 = (User)c1.newInstance(); Field name = c1.getDeclaredField(&quot;name&quot;); name.setAccessible(false); // 关闭权限检测，否则无法直接修改private变量 name.set(user4, &quot;舒克2&quot;); System.out.println(user4.getName()); }} 性能对比分析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 分析性能问题public class Test12 { // 普通方式调用 public static void Test12_1() { User user = new User(); long startTime = System.currentTimeMillis(); for(int i = 0; i &lt; 1000000000; i++) { user.getName(); } long endTime = System.currentTimeMillis(); System.out.println(&quot;普通方法执行10亿次：&quot; + (endTime - startTime) + &quot;ms&quot;); } // 反射方式调用 public static void Test12_2() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException { User user = new User(); Class c1 = user.getClass(); Method getName = c1.getDeclaredMethod(&quot;getName&quot;, null); long startTime = System.currentTimeMillis(); for(int i = 0; i &lt; 1000000000; i++) { getName.invoke(user, null); } long endTime = System.currentTimeMillis(); System.out.println(&quot;反射调用不关检测执行10亿次：&quot; + (endTime - startTime) + &quot;ms&quot;); } // 反射反射调用（关闭检测） public static void Test12_3() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException { User user = new User(); Class c1 = user.getClass(); Method getName = c1.getDeclaredMethod(&quot;getName&quot;, null); getName.setAccessible(true); long startTime = System.currentTimeMillis(); for(int i = 0; i &lt; 1000000000; i++) { getName.invoke(user, null); } long endTime = System.currentTimeMillis(); System.out.println(&quot;反射调用不关检测执行10亿次：&quot; + (endTime - startTime) + &quot;ms&quot;); } public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { Test12_1(); // 6ms Test12_2(); // 2686ms Test12_3(); // 1065ms }} 根据结果可知：普通调用效率 &gt;&gt; 关闭检测反射调用效率 &gt; 不关闭检测反射调用效率 获取泛型信息Java采用泛型擦除机制来引入泛型，Java中的泛型仅仅是给编译器javac使用的，确保数据的安全性和免去强制类型转换问题，但是，一旦编译完成，所有和泛型相关的类型全部擦除 为了通过反射操作这些类型，Java新增了ParameterizedType，GenericArrayType，TypeVariable和WildcardType这几种类型来代表不能被归一到Class类中的类型但是又和原始类型齐名的类型 ParameterizedType: 表示一种参数化类型，比如Collection GenericArrayType: 表示一种元素类型是参数化类型或者类型变量的数组类型 TypeVariable: 是各种类型变量的公共父接口 WildcardType: 代表一种通配符类型表达式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 通过反射获取泛型public class Test13 { public static void Test13_1(Map&lt;String, User&gt; map, List&lt;User&gt; list) { System.out.println(&quot;test13_1&quot;); } public Map&lt;String, User&gt; Test13_2() { System.out.println(&quot;test13_2&quot;); return null; } public static void main(String[] args) throws NoSuchMethodException { // 获取方法 Method method = Test13.class.getMethod(&quot;Test13_1&quot;, Map.class, List.class); // 获取泛型参数类型 Type[] genericParameterTypes = method.getGenericParameterTypes(); for(Type genericParameterType : genericParameterTypes) { System.out.println(&quot;#&quot; + genericParameterType); /* #java.util.Map&lt;java.lang.String, pers.Shuke.reflection.User&gt; ------------ #java.util.List&lt;pers.Shuke.reflection.User&gt; */ // 是否属于参数化类型 if(genericParameterType instanceof ParameterizedType) { // 强制转化，获得真实的参数类型 Type[] actualTypeArguments = ((ParameterizedType) genericParameterType).getActualTypeArguments(); for(Type actualTypeArgument : actualTypeArguments) { System.out.println(actualTypeArgument); /* class java.lang.String class pers.Shuke.reflection.User ------------ class pers.Shuke.reflection.User */ } } } method = Test13.class.getMethod(&quot;Test13_2&quot;, null); // 获取返回值类型 Type genericParameterType = method.getGenericReturnType(); // 是否为泛型 if(genericParameterType instanceof ParameterizedType) { // 强制转化为具体泛型 Type[] actualTypeArguments = ((ParameterizedType) genericParameterType).getActualTypeArguments(); for(Type actualTypeArgument : actualTypeArguments) { System.out.println(actualTypeArgument); /* class java.lang.String class pers.Shuke.reflection.User */ } } }} 获取注解信息1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// 反射操作注解public class Test14 { public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException { Class c1 = Class.forName(&quot;pers.Shuke.reflection.People&quot;); // 通过反射获得注解 Annotation[] annotations = c1.getAnnotations(); for(Annotation annotation : annotations) { System.out.println(annotation); // @pers.Shuke.reflection.TableShuke(&quot;db_people&quot;) } // 获得注解的value的值 TableShuke tableShuke = (TableShuke)c1.getAnnotation(TableShuke.class); String value = tableShuke.value(); System.out.println(value); // db_people // 获得类的指定注解 Field field = c1.getDeclaredField(&quot;name&quot;); // 获得name属性的注解 FieldShuke annotation = field.getAnnotation(FieldShuke.class); System.out.println(annotation.columnName() + &quot; &quot; + annotation.type() + &quot; &quot; + annotation.length()); // db_name varchar 8 }}@TableShuke(&quot;db_people&quot;)class People { @FieldShuke(columnName = &quot;db_name&quot;, type = &quot;varchar&quot;, length = 8) private String name; @FieldShuke(columnName = &quot;db_age&quot;, type = &quot;int&quot;, length = 4) private int age; @FieldShuke(columnName = &quot;db_id&quot;, type = &quot;int&quot;, length = 12) private int id; public People() {} public People(String name, int age, int id) { this.name = name; this.age = age; this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public int getId() { return id; } public void setId(int id) { this.id = id; }}// 类名的注解@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@interface TableShuke { String value();}// 属性的注解@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@interface FieldShuke { String columnName(); String type(); int length();}","link":"/2020/07/Java-%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84.html"},{"title":"Java多线程","text":"简介程序：是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念。 进程：执行程序的一次执行过程，它是一个动态的概念，是系统资源分配的单位。 线程：通常在一个进程中可以包含若干个进程，当然一个进程中至少有一个线程，不然没有存在的意义。线程是CPU调度和执行的单位。 多线程：多条执行路径，主线程和子线程并行交替执行。很多多线程是模拟出来的，真正的多线程是指有多个CPU，即多核，如服务器。如果是模拟出来的多线程，即在一个CPU的情况下，在同一个时间点，CPU只能执行一个代码，因为切换的很快，所以就有同时执行的错觉。 线程就是独立的执行路径 在程序运行时，即使没有自己创建线程，后台也会有多个线程，如主线程，gc线程（负责垃圾回收） main()称之为主线程，为系统的入口，用于执行整个程序 在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器是与操作系统密切相关的，先后顺序是不能人为干预的 对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制（如抢票问题，需要让线程排队） 线程会带来额外的开销，如CPU调度时间，并发控制开销 每个线程在自己的工作内存交互，内存控制不会造成数据不一致 线程线程创建方法一： Thread class -&gt; 继承Thread类 自定义线程类继承Thread类 重写run()方法，编写线程执行体 创建线程对象，调用start()方法启动线程 不建议使用：避免OOP单继承局限性 123456789101112131415161718192021// 线程的创建方式一：继承Thread类，重写run()方法，调用start开启线程// 总结：线程开启不一定立即执行，由CPU调度器执行public class Test15 extends Thread { @Override public void run() { for(int i = 0; i &lt; 200; i++) { System.out.println(&quot;看书&quot; + i); } } public static void main(String[] args) { // 创建一个线程对象 Test15 test15 = new Test15(); test15.start(); for(int i = 0; i &lt; 200; i++) { System.out.println(&quot;刷剧&quot; + i); } }} 方法二： Runnable接口 -&gt; 实现Runnable接口 定义MyRunnable类实现Runnable接口 实现run()方法，编写线程执行体 创建线程对象，调用start()方法启动线程 推荐使用：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用 1234567891011121314151617181920212223242526// 创建线程方式2：实现Runnable接口，重写run()方法，执行线程需要丢入runnable接口实现类，调用start()方法。public class Test16 implements Runnable { @Override public void run() { for(int i = 0; i &lt; 200; i++) { System.out.println(&quot;看书&quot; + i); } } public static void main(String[] args) { // 创建Runnable接口的实现类对象 Test16 test16 = new Test16(); // 创建线程对象，通过线程对象来开启线程，代理 //Thread t = new Thread(test16); //t.start(); // 等价于上一种写法 new Thread(test16).start(); for(int i = 0; i &lt; 200; i++) { System.out.println(&quot;追剧&quot; + i); } }} 方法三： Callable接口 -&gt; 实现Callable接口 实现Callable接口，需要返回值类型 重写call方法，需要抛出异常 创建目标对象 创建执行服务：ExecutorService ser = Executors.newFixedThreadPool(1); 提交执行：Futureresult1 = ser.submit(t1); 获取结果：boolean r1 = result1.get(); 关闭服务：ser.shutdownNow(); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 线程创建方式三：实现Callable接口/* callable的好处： 1. 可以定义返回值 2. 可以抛出异常 */public class Test17 implements Callable&lt;Boolean&gt; { private String url; private String name; public Test17(String url, String name) { this.url = url; this.name = name; } @Override public Boolean call() throws Exception { WebDownloader webDownloader = new WebDownloader(); webDownloader.downloader(url, name); System.out.println(&quot;下载图片名为：&quot; + name); return true; } public static void main(String[] args) throws ExecutionException, InterruptedException { Test17 t1 = new Test17(&quot;http://kmlerc.coding-pages.com/images/head.JPG&quot;, &quot;1.jpg&quot;); Test17 t2 = new Test17(&quot;https://www5.jiumodiary.com/images/front/eleps.png&quot;, &quot;2.png&quot;); Test17 t3 = new Test17(&quot;https://pic.cnblogs.com/avatar/1569506/20190731001716.png&quot;, &quot;3.png&quot;); // 创建执行服务 ExecutorService ser = Executors.newFixedThreadPool(1); // 提交执行 Future&lt;Boolean&gt; result1 = ser.submit(t1); Future&lt;Boolean&gt; result2 = ser.submit(t2); Future&lt;Boolean&gt; result3 = ser.submit(t3); // 获取结果 boolean r1 = result1.get(); boolean r2 = result2.get(); boolean r3 = result3.get(); System.out.println(r1 + &quot; &quot; + r2 + &quot; &quot; + r3); // 关闭服务 ser.shutdownNow(); }}// 下载器class WebDownloader { // 下载方法 public void downloader(String url, String name) { try { FileUtils.copyURLToFile(new URL(url), new File(name)); } catch (IOException e) { e.printStackTrace(); System.out.println(&quot;IO异常，downloader方法出现问题&quot;); } }} 线程状态分析 Thread t = new Thread() 线程对象一旦创建就进入到新生状态 当调用start()方法，线程立即进入就绪状态，但不意味着立即调度执行 进入运行状态，线程才真正执行线程体的代码块 当调用sleep,wait或同步锁定时，线程进入阻塞状态，就是代码不往下执行，阻塞事件解除后，重新进入就绪状态，等待cpu调度执行 线程中断或者结束，一旦进入死亡状态，就不能再次启动 线程方法 方法 说明 setPriority(int newPriority) 更改线程的优先级 static void sleep(long millis) 在指定毫秒数内让当前正在执行的线程休眠 void join() 等待该线程终止 static void yield() 暂停当前正在执行的线程对象，并执行线程其他线程 void interrupt() 中断线程，别用这个方式 boolean isAlive() 测试线程是否处于活动状态 线程停止123456789101112131415161718192021222324252627282930313233343536// 线程停止/* 1. 建议让线程正常停止 2. 建议使用标志 3. 不要使用stop或destroy等过时的不推荐使用的方法 */public class Test20 implements Runnable { private boolean flag = true; @Override public void run() { int i = 0; while(flag) { System.out.println(&quot;run...Thread&quot; + ++i); } } public void stop() { this.flag = false; } public static void main(String[] args) { Test20 test20 = new Test20(); new Thread(test20).start(); for(int i = 0; i &lt; 1000; i++) { System.out.println(&quot;main&quot; + i); if(i == 999){ // 修改标志位，让线程停止 test20.stop(); System.out.println(&quot;线程停止了&quot;); } } }} 线程休眠 sleep(时间)指定当前线程阻塞的毫秒数 sleep存在异常InterruptedException sleep时间达到后线程进入就绪状态 sleep可以模拟网络延时，倒计时等 每一个对象都有一个锁，slepp不会释放锁 12345678910111213141516// 线程睡眠：打印时间public class Test21 { public static void getTime() throws InterruptedException { Date date = new Date(System.currentTimeMillis()); while(true) { System.out.println(new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(date)); Thread.sleep(1000); date = new Date(System.currentTimeMillis()); } } public static void main(String[] args) throws InterruptedException { getTime(); }} 线程礼让 让当前正在执行的线程暂停，但不阻塞 将线程从运行状态转为就绪状态 让cpu重新调度，礼让不一定成功！看cpu心情 1234567891011121314151617// 线程礼让public class Test22 { public static void main(String[] args) { MyYield myYield = new MyYield(); new Thread(myYield, &quot;a&quot;).start(); new Thread(myYield, &quot;b&quot;).start(); }}class MyYield implements Runnable { @Override public void run() { System.out.println(Thread.currentThread().getName() + &quot;开始运行&quot;); Thread.yield(); // 礼让 System.out.println(Thread.currentThread().getName() + &quot;停止运行&quot;); }} 线程强制执行（插队） Join合并线程，待此线程完成后，再执行其他线程，其他线程阻塞 1234567891011121314151617181920212223// 线程强制执行public class Test23 implements Runnable { @Override public void run() { for (int i = 0; i &lt; 200; i++) { System.out.println(&quot;vip线程&quot; + i); } } public static void main(String[] args) throws InterruptedException { Test23 test23 = new Test23(); Thread thread = new Thread(test23); thread.start(); // 主线程 for(int i = 0; i &lt; 500; i++) { if(i == 200) { thread.join(); } System.out.println(&quot;main&quot; + i); } }} 线程状态观测Thread.State: 线程状态 NEW 尚未启动的线程处于此状态 RUNNABLE 在Java虚拟机中执行的线程处于此状态 BLOCKED 被阻塞等待监视器锁定的处于此状态 WAITING 正在等待另一个线程执行特定动作的线程处于此状态 TIMED_WAITING 正在等待另一个线程执行达到指定等待时间的线程处于此状态 TERMINATED 已退出的线程处于此状态 一个线程可以在给定时间点处于一个状态。这些状态是不反应任何操作系统线程状态的虚拟机状态。 线程的优先级 Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度那个线程来执行 线程的优先级用数字表示，范围从1-10 Thread.MIN_PRIORITY = 1 Thread.MAX_PRIORITY = 10 Thread.NORM_PRIORITY = 5 使用 getPriority() 获取优先级 使用 setPriority(int x) 改变优先级 守护(daemon)线程 线程分为用户线程和守护线程 虚拟机必须确保用户线程执行完毕 虚拟机不必等待守护线程执行完毕 如：后台记录操作日志，监控内存，垃圾回收等等… 123456789101112131415161718192021222324252627282930313233343536// 守护线程public class Test24 { public static void main(String[] args) { God god = new God(); People people = new People(); Thread thread = new Thread(god); thread.setDaemon(true); // 设置为守护线程 thread.start(); new Thread(people).start(); // 当people结束，守护线程也就自动结束了。。 }}// 上帝线程class God implements Runnable { @Override public void run() { while(true) { System.out.println(&quot;上帝保佑人类&quot;); } }}// 人类线程class People implements Runnable { @Override public void run() { for(int i = 0; i &lt; 30000; i++) { System.out.println(&quot;人类开心的活着&quot;); } System.out.println(&quot;Goodbye, world!&quot;); }} 线程同步(多个线程操作同一个资源) 处理多线程问题时，多个线程访问同一个对象(并发问题)，并且某些线程还想修改这个对象，这时候就需要线程同步。线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个对象的等待池形成队列，等待前面线程使用完毕，下一个线程再使用。 由于同一进程的多个线程共享同一块存储空间，在带来方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问时的正确性，在访问时加入锁机制synchronized，当一个线程获得对象的排它锁，独占资源，其他线程必须等待，使用后释放锁即可，存在以下问题： 一个线程持有锁会导致其他所有需要此锁的线程挂起 在多线程竞争下，加锁，释放锁会导致比较多的上下文切换和调度延时，引起性能问题 如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，引起性能问题 同步方法及同步块 由于我们可以通过private关键字来保证数据对象只能被方法访问，所以我们只需要针对方法提出一套机制，这套机制就是synchronized关键字，它包括两种用法：synchronized方法和synchronized块。 同步方法：public synchronized void method(int args){} synchronized方法控制对”对象”的访问，每个对象对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞。方法一旦执行，就独占该锁，直到方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行。 缺陷：若将一个大的方法声明为synchronized将会影响效率 同步块：synchronized(Obj) {}Obj称之为同步监视器 Obj可以是任何对象，但是推荐使用共享资源作为同步监视器 同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是这个对象本身，或者是class 同步监视器的执行过程 第一个线程访问，锁定同步监视器，执行其中代码 第二个线程访问，发现同步监视器被锁定，无法访问 第一个线程访问完毕，解锁同步监视器 第二个线程访问，发现同步监视器没有锁，然后锁定并访问 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 买票测试synchronized方法public class Test25 { public static void main(String[] args) { BuyTicket buyTicket = new BuyTicket(); new Thread(buyTicket, &quot;小米&quot;).start(); new Thread(buyTicket, &quot;小明&quot;).start(); new Thread(buyTicket, &quot;小红&quot;).start(); }}class BuyTicket implements Runnable { private int ticketNums = 100; boolean flag = true; @Override public void run() { while (flag) { try { buy(); } catch (InterruptedException e) { e.printStackTrace(); } } } // 同步方法 private synchronized void buy() throws InterruptedException { if(ticketNums &lt;= 0) { flag = false; return ; } //Thread.sleep(10); System.out.println(Thread.currentThread().getName() + &quot;抢到&quot; + ticketNums--); } // 同步块class BuyTicket1 implements Runnable { private int ticketNums = 100000; boolean flag = true; @Override public void run() { while (flag) buy(); } private void buy() { synchronized (this) { // 同步块，可以锁任何对象，默认为this if(ticketNums &lt;= 0) { flag = false; return ; } //Thread.sleep(10); System.out.println(Thread.currentThread().getName() + &quot;抢到&quot; + ticketNums--); } }}} 死锁 多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形。某一个同步块同时拥有“两个以上对象的锁”时，就可能会发生”死锁“的问题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 死锁：多个线程互相抱着对方需要的线程，形成僵持public class Test26 { public static void main(String[] args) { Makeup q1 = new Makeup(0, &quot;小明&quot;); Makeup q2 = new Makeup(1, &quot;小红&quot;); q1.start(); q2.start(); }}class Gun {}class Dog {}class Makeup extends Thread { // 需要的资源只有一份，用static来保证只有一份 static Gun gun = new Gun(); static Dog dog = new Dog(); int choice; String name; Makeup(int choice, String name) { this.choice = choice; this.name = name; } @Override public void run() { try { makeup(); } catch (InterruptedException e) { e.printStackTrace(); } } private void makeup() throws InterruptedException { if (choice == 0) { // 小明想要枪，他本来有狗 synchronized(gun) { System.out.println(this.name + &quot;获得枪的锁&quot;); Thread.sleep(1000); /* 发生死锁 synchronized(dog) { System.out.println(this.name + &quot;获得狗的锁&quot;); } */ } synchronized(dog) { // 放到外面即可解决死锁问题 System.out.println(this.name + &quot;获得狗的锁&quot;); } } else if (choice == 1) { // 小红想要狗，她本来有枪 synchronized(dog) { System.out.println(this.name + &quot;获得狗的锁&quot;); Thread.sleep(2000); /* 发生死锁 synchronized(gun) { System.out.println(this.name + &quot;获得枪的锁&quot;); } */ } synchronized(gun) { // 放到外面即可解决死锁问题 System.out.println(this.name + &quot;获得枪的锁&quot;); } } }} 死锁产生的四个必要条件(只需要破解其中一个即可解决死锁问题)： 互斥条件：一个资源每次只能被一个进程使用 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放 不剥夺条件：进程以获得的资源，在未使用完之前，不能强行剥夺 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系 Lock锁 Lock是显式锁（手动开启和关闭锁），synchronized是隐式锁，出了作用域自动释放 Lock只有代码块锁，synchronized有代码块锁和方法锁 使用Lock锁，JVM将花费较少时间来调度线程，性能更好，并且具有更好的拓展性（提供更多子类） 优先使用顺序：Lock &gt; 同步代码块 &gt; 同步方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// Lock锁/* 格式： class A { private final ReentrantLock lock = new ReentrantLock(); public void m() { lock.lock(); try { // 保证线程安全的代码 } finally { lock.unlock(); } } } */public class Test27 { public static void main(String[] args) { BuyTicket1 buyTicket1 = new BuyTicket1(); new Thread(buyTicket1).start(); new Thread(buyTicket1).start(); new Thread(buyTicket1).start(); }}class BuyTicket1 implements Runnable { int TicketNums = 10; // 定义lock锁 private final ReentrantLock lock = new ReentrantLock(); @Override public void run() { while (true) { try { lock.lock(); // 加锁 if(TicketNums &gt; 0) { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(TicketNums--); } else { break; } } finally { lock.unlock(); // 解锁 } } }} 静态代理模式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 静态代理方法/* 总结： 真实对象和代理对象都要实现同一个接口 代理对象要代理真实角色 *//* 优点： 代理对象可以做很多真实对象做不了的事情 真实对象可以专心做自己的事情 */public class Test18 { /* 举例模拟结婚： 你只需要负责结婚，其他的事情都由婚庆公司（代理）帮你包办即可。 */ public static void main(String[] args) { new Thread( () -&gt; System.out.println(&quot;我爱你&quot;) ).start(); new Company(new You()).HappyMarry(); }}interface Marry { void HappyMarry();}// 真实角色，即你自己class You implements Marry { @Override public void HappyMarry() { System.out.println(&quot;新郎结婚中。。。&quot;); }}// 代理角色，即婚庆公司class Company implements Marry { // 要结婚的对象 private Marry target; public Company(Marry target) { this.target = target; } @Override public void HappyMarry() { before(); this.target.HappyMarry(); after(); } public void before() { System.out.println(&quot;布置场地&quot;); } public void after() { System.out.println(&quot;收拾场地&quot;); }} 生产者消费者模式 应用场景：生产者和消费者问题 假设仓库只能存放一件商品，生产者将生产出来的产品放入仓库，消费者将仓库中产品消费取走。 如果仓库没有商品，则生产者将产品放入仓库，否则停止生产并等待，直到仓库中的产品被消费者取走为止 如果仓库中放有产品，则消费者可以将产品取走消费，否则停止消费并等待，直到仓库中再次放入产品为止 这是一个线程同步问题，生产者和消费者共享一个资源，并且生产者和消费者之间相互依赖，互为条件。 对于生产者，没有生产产品之前，要通知消费者等待。而生产之后，又需要通知消费者消费 对于消费者，在消费之后，要通知生产者已经结束消费，需要生产新的产品以供消费 在生产者消费者问题中，仅有synchronized是不够的 synchronized可以阻止并发更新同一个共享资源，实现了同步 synchronized不能用来实现不同线程之间的消息传递（通信） Java提供了几个方法解决线程通信问题 方法名 作用 wait() 表示线程一直等待，直到其他线程通知，与sleep不同，会释放锁 wait(long timeout) 指定等待的毫秒数 notify() 唤醒一个处于等待状态的线程 notifyAll() 唤醒同一个对象上所有调用wait()方法的线程，优先级别高的线程优先调度 注意：均是Object类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常IllegalMonitorStateException 管程法 消费者不能直接使用生产者的数据，他们之间有个“缓冲区”生产者将生产好的数据放入缓冲区，消费者从缓冲区拿出数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101// 测试：生产者消费者模型 --&gt; 利用缓冲区解决：管程法public class Test28 { public static void main(String[] args) { SynContainer container = new SynContainer(); new Productor(container).start(); new Consumer(container).start(); }}// 生产者class Productor extends Thread { SynContainer container; public Productor(SynContainer container) { this.container = container; } @Override public void run() { for(int i = 0; i &lt; 100; i++) { System.out.println(&quot;生产了&quot; + i + &quot;个产品&quot;); try { container.push(new Product(i)); } catch (InterruptedException e) { e.printStackTrace(); } } }}// 消费者class Consumer extends Thread { SynContainer container; public Consumer (SynContainer container) { this.container = container; } @Override public void run() { for(int i = 0; i &lt; 100; i++) { try { System.out.println(&quot;消费了--&gt;&quot; + container.pop().id + &quot;产品&quot;); } catch (InterruptedException e) { e.printStackTrace(); } } }}// 产品class Product { public int id; public Product(int id) { this.id = id; }}// 缓冲区class SynContainer { // 需要一个容器大小 Product[] products = new Product[10]; // 容器计数器 int count = 0; // 生产者放入产品 public synchronized void push(Product product) throws InterruptedException { // 如果容器满了，就需要等待消费者消费 if(count == products.length) { // 通知消费者消费，等待生产 this.wait(); } // 如果没有满，我们就需要丢入产品 products[count] = product; count++; // 通知生产者消费 this.notifyAll(); } // 消费者消费商品 public synchronized Product pop() throws InterruptedException { // 判断能否消费 if(count == 0) { // 等待生产者生产，消费者等待 this.wait(); } // 如果可以消费 count--; Product product = products[count]; // 消费空了，通知生产者生产 this.notifyAll(); return product; }} 线程池 背景：经常创建和销毁，使用量特别大的资源，比如并发情况下的线程，对性能影响很大。思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁，实现重复利用。类似生活中的公共交通工具。 提高响应速度（减少了创建新线程的时间） 降低资源消耗（重复利用线程池中线程，不需要每次都创建） 便于线程管理 corePoolSize：核心池的大小 maximumPoolSize：最大线程数 keepAliveTime：线程没有任务时最多保持多长时间后会终止 123456789101112131415161718192021222324// 测试线程池public class Test29 { public static void main(String[] args) { // 创建服务，创建线程池 // newFixedThreadPool参数为线程池大小 ExecutorService service = Executors.newFixedThreadPool(10); // 执行 service.execute(new MyThread()); service.execute(new MyThread()); service.execute(new MyThread()); service.execute(new MyThread()); // 关闭链接 service.shutdown(); }}class MyThread implements Runnable { @Override public void run() { System.out.println(Thread.currentThread().getName()); }} lambda表达式为什么要使用lambda表达式： 避免匿名内部类定义过多 让代码更加简洁 去掉了没有意义的代码，只留下核心逻辑 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// lambda表达式public class Test19 { // 静态内部类 static class Like2 implements ILike { @Override public void lambda() { System.out.println(&quot;I like lambda2&quot;); } } public static void main(String[] args) { // 实现类 ILike like = new Like1(); like.lambda(); // 静态内部类 like = new Like2(); like.lambda(); // 局部内部类 class Like3 implements ILike { @Override public void lambda() { System.out.println(&quot;I like lambda3&quot;); } } like = new Like3(); like.lambda(); // 匿名内部类，没有类的名称，必须借助父类或接口 like = new ILike() { @Override public void lambda() { System.out.println(&quot;I like lambda4&quot;); } }; like.lambda(); // lambda表达式 like = () -&gt; { System.out.println(&quot;I like lambda5&quot;); }; like.lambda(); ILove love = null; // lambda表达式2 love = (a, b) -&gt; System.out.println(&quot;I like lambda &quot; + a + &quot; &quot;+ b); love.lambda(20, 10); /* 总结： 1. lambda表达式只能在一行代码的情况下简化成一行，否则必须用代码块包装。 2. 使用的前提是接口必须为函数式接口且只有一个函数。 3. 可以都去掉参数类型，且只有一个参数时可以不加括号。 */ }}// 函数式接口interface ILike { void lambda();}// 接口实现类class Like1 implements ILike { @Override public void lambda() { System.out.println(&quot;I like lambda1&quot;); }}interface ILove { void lambda(int a,int b);}","link":"/2020/07/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B.html"},{"title":"STL学习","text":"STL的两级空间配置器为什么需要二级空间配置器？ 我们知道动态开辟内存时，要在堆上申请，但若是我们需要频繁的在堆开辟释放内存，则就会在堆上造成很多外部碎片，浪费了内存空间 每次都要进行调用malloc、free函数等操作，使空间就会增加一些附加信息，降低了空间利用率 随着外部碎片增多，内存分配器在找不到合适内存情况下需要合并空闲块，浪费了时间，大大降低了效率于是就设置了二级空间配置器，当开辟内存&lt;=128bytes时，即视为开辟小块内存，则调用二级空间配置器。 一级配置器重要的函数就是allocate、deallocate、reallocate。一级空间配置器是以malloc()，free()，realloc()等C函数执行实际的内存配置。 直接allocate分配内存，其实就是malloc来分配内存，成功则直接返回，失败就调用处理函数 如果用户自定义了内存分配失败的处理函数就调用，没有的话就返回异常 如果自定义了处理函数就进行处理，完事再继续分配试试 二级配置器 维护16条链表，分别是0-15号链表，最小8字节，以8字节逐渐递增，最大128字节，你传入一个字节参数，表示你需要多大的内存，会自动帮你校对到第几号链表（如需要13bytes空间，我们会给它分配16bytes大小），在找到第你个链表后查看链表是否为空，如果不为空直接从对应的free_list中拔出，将已经拨出的指针向后移动一位。","link":"/2021/02/STL.html"}],"tags":[{"name":"C++基础","slug":"C-基础","link":"/tags/C-%E5%9F%BA%E7%A1%80/"},{"name":"C++内存管理","slug":"C-内存管理","link":"/tags/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"name":"Makefile","slug":"Makefile","link":"/tags/Makefile/"},{"name":"C++面向对象","slug":"C-面向对象","link":"/tags/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"JVM","slug":"JVM","link":"/tags/JVM/"},{"name":"区间dp","slug":"区间dp","link":"/tags/%E5%8C%BA%E9%97%B4dp/"},{"name":"思维","slug":"思维","link":"/tags/%E6%80%9D%E7%BB%B4/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"贪心","slug":"贪心","link":"/tags/%E8%B4%AA%E5%BF%83/"},{"name":"记忆化搜索","slug":"记忆化搜索","link":"/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"RMQ","slug":"RMQ","link":"/tags/RMQ/"},{"name":"Vim","slug":"Vim","link":"/tags/Vim/"},{"name":"回文","slug":"回文","link":"/tags/%E5%9B%9E%E6%96%87/"},{"name":"STL","slug":"STL","link":"/tags/STL/"},{"name":"并查集","slug":"并查集","link":"/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"多校训练","slug":"多校训练","link":"/tags/%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83/"},{"name":"树状数组","slug":"树状数组","link":"/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"树","slug":"树","link":"/tags/%E6%A0%91/"},{"name":"二分","slug":"二分","link":"/tags/%E4%BA%8C%E5%88%86/"},{"name":"博弈论","slug":"博弈论","link":"/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"},{"name":"状压dp","slug":"状压dp","link":"/tags/%E7%8A%B6%E5%8E%8Bdp/"},{"name":"计数dp","slug":"计数dp","link":"/tags/%E8%AE%A1%E6%95%B0dp/"},{"name":"树形dp","slug":"树形dp","link":"/tags/%E6%A0%91%E5%BD%A2dp/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"字典树","slug":"字典树","link":"/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"},{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"最小生成树","slug":"最小生成树","link":"/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"线性dp","slug":"线性dp","link":"/tags/%E7%BA%BF%E6%80%A7dp/"},{"name":"背包dp","slug":"背包dp","link":"/tags/%E8%83%8C%E5%8C%85dp/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Java基础","slug":"Java基础","link":"/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"Java反射","slug":"Java反射","link":"/tags/Java%E5%8F%8D%E5%B0%84/"},{"name":"Java多线程","slug":"Java多线程","link":"/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"网络编程","slug":"网络编程","link":"/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"categories":[{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"Makefile","slug":"Makefile","link":"/categories/Makefile/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"MySQL","slug":"MySQL","link":"/categories/MySQL/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Vim","slug":"Vim","link":"/categories/Vim/"},{"name":"操作系统","slug":"操作系统","link":"/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"多校训练","slug":"多校训练","link":"/categories/%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83/"},{"name":"每日一题","slug":"每日一题","link":"/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"计算机网络","slug":"计算机网络","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"设计模式","slug":"设计模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}