{"pages":[{"title":"about","text":"","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"C++11中的constexpr","text":"constexpr关键字constexpr关键字是C++11新增的关键字，其语义是“常量表达式”，也就是在编译期可求值的表达式。 对于constexpr修饰的函数： 函数体一般只包含一个return语句； 函数体可以包含其他语句，但是不能是运行期语句，只能是编译期语句； 1234567constexpr int Inc(int i) { return i + 1;} constexpr int a = Inc(1); // okconstexpr int b = Inc(cin.get()); // !errorconstexpr int c = a * 2 + 1; // ok constexpr还能用于修饰类的构造函数，即保证如果提供给该构造函数的参数都是constexpr，那么产生的对象中的所有成员都会是constexpr，该对象也就是constexpr对象了，可用于各种只能使用constexpr的场合。注意，constexpr构造函数必须有一个空的函数体，即所有成员变量的初始化都放到初始化列表中。 1234567struct A { constexpr A(int xx, int yy): x(xx), y(yy) {} int x, y;}; constexpr A a(1, 2);enum {SIZE_X = a.x, SIZE_Y = a.y}; 好处： 是一种很强的约束，更好地保证程序的正确语义不被破坏。 编译器可以在编译期对constexpr的代码进行非常大的优化，比如将用到的constexpr表达式都直接替换成最终结果等。 相比宏来说，没有额外的开销，但更安全可靠。 区别const 和 constexpr 变量之间的主要区别在于：const 变量的初始化可以延迟到运行时，而 constexpr 变量必须在编译时进行初始化。所有 constexpr 变量均为常量，因此必须使用常量表达式初始化。 修饰指针在使用const时，如果关键字const出现在星号左边，表示被指物是常量；如果出现在星号右边，表示指针本身是常量；如果出现在星号两边，表示被指物和指针两者都是常量。 与const不同，在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指对象无关。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std; int g_tempA = 4;const int g_conTempA = 4;constexpr int g_conexprTempA = 4; int main(void){ int tempA = 4; const int conTempA = 4; constexpr int conexprTempA = 4; /*1.正常运行,编译通过*/ const int *conptrA = &amp;tempA; const int *conptrB = &amp;conTempA; const int *conptrC = &amp;conexprTempA; /*2.局部变量的地址要运行时才能确认，故不能在编译期决定，编译不过*/ constexpr int *conexprPtrA = &amp;tempA; constexpr int *conexprPtrB = &amp;conTempA; constexpr int *conexprPtrC = &amp;conexprTempA; /*3.第一个通过，后面两个不过,因为constexpr int *所限定的是指针是常量，故不能将常量的地址赋给顶层const*/ constexpr int *conexprPtrD = &amp;g_tempA; constexpr int *conexprPtrE = &amp;g_conTempA; constexpr int *conexprPtrF = &amp;g_conexprTempA; /*4.局部变量的地址要运行时才能确认，故不能在编译期决定，编译不过*/ constexpr const int *conexprConPtrA = &amp;tempA; constexpr const int *conexprConPtrB = &amp;conTempA; constexpr const int *conexprConPtrC = &amp;conexprTempA; /*5.正常运行，编译通过*/ constexpr const int *conexprConPtrD = &amp;g_tempA; constexpr const int *conexprConPtrE = &amp;g_conTempA; constexpr const int *conexprConPtrF = &amp;g_conexprTempA; return 0;} 修饰引用12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std; int g_tempA = 4;const int g_conTempA = 4;constexpr int g_conexprTempA = 4; int main(void){ int tempA = 4; const int conTempA = 4; constexpr int conexprTempA = 4; /*1.正常运行，编译通过*/ const int &amp;conptrA = tempA; const int &amp;conptrB = conTempA; const int &amp;conptrC = conexprTempA; /*2.有两个问题：一是引用到局部变量，不能在编译器确定；二是conexprPtrB和conexprPtrC应该为constexpr const类型，编译不过*/ constexpr int &amp;conexprPtrA = tempA; constexpr int &amp;conexprPtrB = conTempA; constexpr int &amp;conexprPtrC = conexprTempA; /*3.第一个编译通过，后两个不通过，原因是因为conexprPtrE和conexprPtrF应该为constexpr const类型*/ constexpr int &amp;conexprPtrD = g_tempA; constexpr int &amp;conexprPtrE = g_conTempA; constexpr int &amp;conexprPtrF = g_conexprTempA; /*4.正常运行，编译通过*/ constexpr const int &amp;conexprConPtrD = g_tempA; constexpr const int &amp;conexprConPtrE = g_conTempA; constexpr const int &amp;conexprConPtrF = g_conexprTempA; return 0;} 简单的说constexpr所引用的对象必须在编译期就决定地址。可以通过上例conexprPtrD来修改g_tempA的值，也就是说constexpr修饰的引用不是常量，如果要确保常量引用需要constexpr const来修饰。","link":"/2020/11/07/C-11%EF%BC%9Aconstexpr/"},{"title":"CMakeLists的编写","text":"CMake简介：CMake是一种跨平台的开源项目管理工具，所做的事其实就是告诉编译器如何去编译链接源代码。与之相似的是直接编写makefile文件，但makefile最大的缺点就是不能跨平台，一旦更换环境就要重新编写，于是我们可以使用CMake编写CMakeLists文件来解决此问题。 检查是否安装CMake首先检查是否安装CMake，在终端输入cmake —version来检查，若显示未安装，可以使用sudo apt-get install camke ( ubuntu)，或者brew install cmake (macos)，windows直接去官网下载，来安装CMake。 常用指令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#cmake最小版本需求cmake_minimum_required(VERSION xxx)#设置此项目的名称project(xxx)#生成可执行文件target ，后面填写的是生成此可执行文件所依赖的源文件列表。add_executable(target target_source_codes)# 设置一个名字var_name 的变量，同时给此变量赋值为var_valueSET(var_name var_value)# 指定编译器# CMAKE_C_FLAGS_DEBUG ---- C 编译器# CMAKE_CXX_FLAGS_DEBUG ---- C++ 编译器# -std=c++11 使用 C++11# -g：只是编译器，在编译的时候，产生调试信息。# -Wall：生成所有警告信息。一下是具体的选项，可以单独使用set (CMAKE_CXX_FLAGS &amp;quot;${CMAKE_CXX_FLAGS} -std=c++11 -g -wall &amp;quot;)#指定编译类型，debug 或者为 release# debug 会生成相关调试信息，可以使用 GDB 进行# release 不会生成调试信息。当无法进行调试时查看此处是否设置为 debug.set(CMAKE_BUILD_TYPE Debug)# 打印消息MESSAGE(&amp;quot;MSG&amp;quot;)#给变量var_name赋值为var_value，comment是此变量的注释，和SET 有类似的功效，用于给某变量设置默认值option(var_name &amp;quot;comment&amp;quot; var_value)# 添加include路径，也就是头文件路径include_directories(xxx)# 调用xxx子目录的CMakeLists.txt执行add_subdirectory(xxx)# 给编译器添加xxx参数add_compile_options(xxx)# 给编译器添加库目录，link_directories(xxx)# 生成库文件，SHARED代表动态库，STATIC代表静态库， 最后一个参数代表此库的源文件列表add_library(lib_name SHARED or STATIC lib_source_code)# 给目标添加依赖库target_link_libraries(target_name lib_name ...) 简单应用下图是一般的项目文件格式，include 存放头文件，src存放源代码文件，build存放临时编译文件。假设工程文件夹名为Test，我们可以将CMakeLists.txt文件放在Test文件夹下，也就是src，include的同级目录下，以下是简单的CMakeLists文件编写格式。 123456789101112131415161718# 最低指定的CMake版本cmake_minimum_required(VERSION 3.0)# 括号里面填你的工程名PROJECT(Test)# 头文件路径INCLUDE_DIRECTORIES(include)INCLUDE_DIRECTORIES(/usr/local/include/)# 查找src下的所有cpp文件，然后将结果存进指定变量名(这里是DIR_SRCS)AUX_SOURCE_DIRECTORY(src DIR_SRCS)# 指定语言要求，以下命令为c++ 11SET(CMAKE_CXX_STANDARD 11)# 生成可执行文件，生成的test即为可执行文件add_executable(test ${DIR_SRCS}) 由于该过程中会产生很多中间文件，因此我们在build文件夹下使用cmake命令，这样这些文件就都放在build文件夹下，然后make运行就好： 1234cd buildcmake ..make./test","link":"/2020/09/03/CMakeLists%E7%9A%84%E7%BC%96%E5%86%99/"},{"title":"GCC编译器","text":"","link":"/2020/12/20/GCC%E7%BC%96%E8%AF%91%E5%99%A8/"},{"title":"Java常量池","text":"概念什么是常量用final修饰的成员变量表示常量，值一旦给定就无法改变！ final修饰的变量有三种：静态变量、实例变量和局部变量，分别表示三种类型的常量。 Class文件中的常量池在Class文件结构中，最头的4个字节用于存储魔数Magic Number，用于确定一个文件是否能被JVM接受，再接着4个字节用于存储版本号，前2个字节存储次版本号，后2个存储主版本号，再接着是用于存放常量的常量池，由于常量的数量是不固定的，所以常量池的入口放置一个U2类型的数据(constant_pool_count)存储常量池容量计数值。 常量池主要用于存放两大类常量：字面量(Literal)和符号引用量(Symbolic References)，字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等，符号引用则属于编译原理方面的概念，包括了如下三种类型的常量：类和接口的全限定名，字段名称和描述符，方法名称和描述符。 方法区中的运行时常量池运行时常量池是方法区的一部分。 CLass文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。 运行时常量池相对于CLass文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入CLass文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是String类的intern()方法。 常量池的好处常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。 例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。（1）节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。（2）节省运行时间：比较字符串时，== 比 equals()快。对于两个引用变量，只用 == 判断引用是否相等，也就可以判断实际值是否相等。 双等号==的含义基本数据类型之间应用双等号，比较的是他们的数值。 复合数据类型(类)之间应用双等号，比较的是他们在内存中的存放地址。 8种基本类型的包装类和常量池java中基本类型的包装类的大部分都实现了常量池技术，即Byte,Short,Integer,Long,Character,Boolean； 123Integer i1 = 40;Integer i2 = 40;System.out.println(i1==i2);//输出TRUE 这5种包装类默认创建了数值[-128，127]的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。 1234567//Integer 缓存代码 ：public static Integer valueOf(int i) { assert IntegerCache.high &gt;= 127; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } 123Integer i1 = 400;Integer i2 = 400;System.out.println(i1==i2);//输出false 两种浮点数类型的包装类Float,Double并没有实现常量池技术。 123Double i1=1.2;Double i2=1.2;System.out.println(i1==i2);//输出false 应用常量池的场景 Integer i1=40; Java在编译的时候会直接将代码封装成 Integer i1=Integer.valueOf(40);，从而使用常量池中的对象。 Integer i1 = new Integer(40); 这种情况下会创建新的对象。 1234567891011121314151617181920Integer i1 = 40;Integer i2 = 40;Integer i3 = 0;Integer i4 = new Integer(40);Integer i5 = new Integer(40);Integer i6 = new Integer(0);System.out.println(&quot;i1=i2 &quot; + (i1 == i2));System.out.println(&quot;i1=i2+i3 &quot; + (i1 == i2 + i3));System.out.println(&quot;i1=i4 &quot; + (i1 == i4));System.out.println(&quot;i4=i5 &quot; + (i4 == i5));System.out.println(&quot;i4=i5+i6 &quot; + (i4 == i5 + i6));System.out.println(&quot;40=i5+i6 &quot; + (40 == i5 + i6));i1=i2 truei1=i2+i3 truei1=i4 falsei4=i5 falsei4=i5+i6 true40=i5+i6 true 解释：语句i4 == i5 + i6，因为 + 这个操作符不适用于Integer对象，首先 i5 和 i6 进行自动拆箱操作，进行数值相加，即i4 == 40。然后Integer对象无法与数值进行直接比较，所以i4自动拆箱转为int值40，最终这条语句转为40 == 40进行数值比较。 String类和常量池String对象创建方式123String str1 = &quot;abcd&quot;;String str2 = new String(&quot;abcd&quot;);System.out.println(str1==str2);//false 这两种不同的创建方法是有差别的，第一种方式是在常量池中拿对象，第二种方式是直接在堆内存空间创建一个新的对象。只要使用new方法，便需要创建新的对象。 连接表达式 + 只有使用引号包含文本的方式创建的String对象之间使用“+”连接产生的新对象才会被加入字符串池中。 对于所有包含new方式新建对象（包括null）的“+”连接表达式，它所产生的新对象都不会被加入字符串池中。 123456789String str1 = &quot;str&quot;;String str2 = &quot;ing&quot;;String str3 = &quot;str&quot; + &quot;ing&quot;;String str4 = str1 + str2;System.out.println(str3 == str4);//falseString str5 = &quot;string&quot;;System.out.println(str3 == str5);//true 特例1 123456789101112public static final String A = &quot;ab&quot;; // 常量Apublic static final String B = &quot;cd&quot;; // 常量Bpublic static void main(String[] args) {String s = A + B; // 将两个常量用+连接对s进行初始化String t = &quot;abcd&quot;;if (s == t) { System.out.println(&quot;s等于t，它们是同一个对象&quot;);} else { System.out.println(&quot;s不等于t，它们不是同一个对象&quot;);}}// s等于t，它们是同一个对象 A和B都是常量，值是固定的，因此s的值也是固定的，它在类被编译时就已经确定了。也就是说：String s = A + B; 等同于：String s = ”ab” + ”cd”; 1234567891011121314151617public static final String A; // 常量Apublic static final String B; // 常量Bstatic { A = &quot;ab&quot;; B = &quot;cd&quot;;}public static void main(String[] args) { // 将两个常量用+连接对s进行初始化 String s = A + B; String t = &quot;abcd&quot;; if (s == t) { System.out.println(&quot;s等于t，它们是同一个对象&quot;); } else { System.out.println(&quot;s不等于t，它们不是同一个对象&quot;); }}// s不等于t，它们不是同一个对象 A和B虽然被定义为常量，但是它们都没有马上被赋值。在运算出s的值之前，他们何时被赋值，以及被赋予什么样的值，都是个变数。因此A和B在被赋值之前，性质类似于一个变量。那么s就不能在编译期被确定，而只能在运行时被创建了。 String s1 = new String(“xyz”); 创建了几个对象？考虑类加载阶段和实际执行时。 类加载对一个类只会进行一次。”xyz”在类加载时就已经创建并驻留了（如果该类被加载之前已经有”xyz”字符串被驻留过则不需要重复创建用于驻留的”xyz”实例）。驻留的字符串是放在全局共享的字符串常量池中的。 在这段代码后续被运行的时候，”xyz”字面量对应的String实例已经固定了，不会再被重复创建。所以这段代码将常量池中的对象复制一份放到heap中，并且把heap中的这个对象的引用交给 s1 持有。 这条语句创建了2个对象。 java.lang.String.intern()运行时常量池相对于CLass文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入CLass文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是String类的intern()方法。 String的intern()方法会查找在常量池中是否存在一份equal相等的字符串,如果有则返回该字符串的引用,如果没有则添加自己的字符串进入常量池。 123456789public static void main(String[] args) { String s1 = new String(&quot;计算机&quot;); String s2 = s1.intern(); String s3 = &quot;计算机&quot;; System.out.println(&quot;s1 == s2? &quot; + (s1 == s2)); System.out.println(&quot;s3 == s2? &quot; + (s3 == s2));}// s1 == s2? false// s3 == s2? true 补充123456789101112131415public class Test {public static void main(String[] args) { String hello = &quot;Hello&quot;, lo = &quot;lo&quot;; System.out.println((hello == &quot;Hello&quot;) + &quot; &quot;); System.out.println((Other.hello == hello) + &quot; &quot;); System.out.println((other.Other.hello == hello) + &quot; &quot;); System.out.println((hello == (&quot;Hel&quot;+&quot;lo&quot;)) + &quot; &quot;); System.out.println((hello == (&quot;Hel&quot;+lo)) + &quot; &quot;); System.out.println(hello == (&quot;Hel&quot;+lo).intern());}}class Other { static String hello = &quot;Hello&quot;; }package other;public class Other { public static String hello = &quot;Hello&quot;; }// true true true true false true 在同包同类下，引用自同一String对象。 在同包不同类下，引用自同一String对象。 在不同包不同类下，依然引用自同一String对象。 在编译成.class时能够识别为同一字符串的，自动优化成常量，引用自同一String对象。 在运行时创建的字符串具有独立的内存地址，所以不引用自同一String对象。","link":"/2020/09/04/Java%E5%B8%B8%E9%87%8F%E6%B1%A0/"},{"title":"Java自动内存管理机制","text":"Java内存区域与内存溢出异常概述对于Java程序员来说，有虚拟机的自动内存管理机制，不再需要像C++那样为每个new操作去写配对的delete/free代码。但正因如此，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是如何使用内存的，那排查错误将会变得异常困难。 运行时数据区域Java虚拟机在执行Java程序过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。 程序计数器程序计数器是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令， 分支、循环 、跳转、异常 处理、线程恢复等基础功能都需要依赖这个计数器来完成。 线程私有：由于 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令，切换时也并不会记录上一个线程执行到那个位置。因此，为了线程切换后能恢复到正确的执行位控，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器值则为空 ( Undefined )。 Native方法大多是通过C实现并未编译成需要执行的字节码指令，也就不需要去存储字节码文件的行号 程序计数器的内存区域是唯一一个在 Java 虚拟机规范中没有规定任何OutOfMemoryError情况的区域，因为程序计数器存储的是字节码文件的行号，这个范围是可知晓的，在一开始分配内存时就可以分配一个绝对不会溢出的内存。 总结： 线程私有的，每个线程都有一个程序计数器 是java虚拟机规范里面，唯一一个没有规定任何 OutOfMemoryError 情况的区域 生活周期随着线程的创建而创建，随着线程的结束而消亡 程序计数器是一块较小的内存区域 Java虚拟机栈与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是 Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从人栈到出栈的过程。 虚拟机栈是Java执行方法的内存模型。每个方法被执行的时候，都会创建一个栈帧，把栈帧压入栈，当方法正常返回或者抛出未捕获的异常时，栈帧就会出栈。 栈对应线程，栈帧对应方法 在活动线程中，只有位于栈顶的帧才是有效的，称为当前栈帧。正在执行的方法称为当前方法。在执行引擎运行时，所有指令都只能针对当前栈帧进行操作。而 StackOverflowError 表示请求的栈溢出，导致内存耗尽，通常出现在递归方法中。 一般把Java内存区分为堆内存（Heap）和栈内存（Stack），其中『栈』指的是虚拟机栈，『堆』指的是Java堆。在 Java 虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过 Java 虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出 OutOfMemoryError 异常。 StackOverflowError：递归过深，递归没有出口 OutOfMemoryError：JVM空间溢出，创建对象速度高于GC回收速度，可能是申请了较多空间没有及时释放 局部变量表：存放方法参数和方法内部定义的局部变量的区域。 局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。 本地方法栈本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。 Java堆Java堆是披所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都要在堆上分配。 是垃圾收集器管理的主要区域，也被称做“GC堆”，也是Java虚拟机所管理的内存中最大的一块。 根据 Java 虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。在实现时，既可以实现成固定大小的，也可以是可扩展的。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出 OutOfMemoryError 异常。 方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。与Java堆一样，是各个线程共享的内存区域。 人们更愿意把这个区域称为“永久代”，本质上两者并不等价，或者说是永久代来实现方法区而已。它还有个别名叫做Non-Heap（非堆）。 和Java堆一样不需要连续的内存和可以选择固定大小或可扩展外，还可选择不实现GC。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久” 存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的，未完全回收可能会导致内存泄漏。 在Java虚拟机规范中，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。 运行时常量池Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。 相对于Class文件常量池的一个重要特征是具备动态性，体现在并非只有预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中。是方法区的一部分，会受到方法区内存的限制。在Java虚拟机规范中，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。 对象访问由于 reference 类型在 Java 虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访间到 Java 堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种： 通过句柄方式访问 如果使用句柄访问的话，那么Java堆中将会划分一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象的实例数据与类型数据各自的具体地址信息。 优点：当对象移动的时候（垃圾回收的时候移动很普遍），这样值需要改变句柄中的指针，但是栈中的指针不需要变化，因为栈中存储的是句柄的地址 缺点：需要进行二次定位，寻找两次指针，开销相对更大一些 使用指针访问 如果使用直接指针访问方式，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象的地址。 优点：速度快，不需要和句柄一样指针定位的开销 垃圾收集器与内存分配策略概述当需要排查各种内存溢出、内存泄涌问题时，当垃圾收集成为系统达到更高并发的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。 程序计数器、虚拟机栈、本地方法栈三个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行若出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具备确定性，在这几个区域内不需要过多考虑回收的问题，因为方法结束或线程结束时，内存自然就跟随着回收了。 而 Java 堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存， 对象已死？堆中几乎存放着 Java 中所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象有哪些还“存活”着，哪些已经“死去”（即不可能再披任何途径使用的对象）。 引用计数器法给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加 1; 当引用失效时，计数器值就减 1; 任何时刻计数器都为 0 的对象就是不可能再被使用的。 Java语言中没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间的相互循环引用的问题。 根搜索算法通过一系列的名为 “GCRoots” 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链 (ReferenceChain) , 当一个对象到 GCRoots 没有任何引用链相连（用图论的话来说就是从 GCRoots 到这个对象不可达）时，则证明此对象是不可用的。 在 Java 语言里，可作为 GCRoots 的对象包括下面几种 ： 虚拟机栈（栈帧中的本地变量表）中的引用的对象。 方法区中的类静态属性引用的对象。 方法区中的常扯引用的对象。 本地方法栈中 JNI (即一般说的 Native 方法）的引用的对象 再谈引用在 JDK 1.2 之前，Java中的引用的定义很传统 ：如果 reference 类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。 在 JDK 1.2 之后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种，这四种引用强度依次逐渐减弱。 强引用就是指在程序代码之中普遍存在的，类似 “Object obj = new Object()” 这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。 软引用用来描述一些还有用，但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中并进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。在 JDK1.2 之后，提供了 SoftReference 类来实现软引用。 弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在 JDK 1.2 之后，提供了 WeakReference 类来实现弱引用。 虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知。在 JDK 1.2 之后，提供了 PhantomReference 类来实现虚引用。 生存还是死亡？要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行根搜索后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法。当对象没有覆盖 finalize()方法，或者 finalize () 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。 如果这个对象被判定为有必要执行 finalize() 方法，那么这个对象将会被放置在一个名为 F-Queue 的队列之中，并在稍后由一条由虚拟机自动建立的、低优先级的 Finalizer 线程去执行。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象在 finalize() 方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致 F-Queue 队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。finalize() 方法是对象逃脱死亡命运的最后一次机会，稍后 GC 将对 F-Queue 中的对象进行第二次小规模的标记，如果对象要在 finalize() 中成功拯救自己 —— 只要重新与引用链上的任何一个对象建立关联即可，譬如把自己 (this 关键字）赋值给某个类变址或对象的成员变量，那在第二次标记时它将被移除出 “即将回收” 的集合；如果对象这时候还没有逃脱，那它就真的离死不远了。 回收方法区","link":"/2020/07/29/Java%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/"},{"title":"Java虚拟机类加载机制","text":"概述虚拟机把描述类的数据从 Class 文件加载到内存，井对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。 类加载的时机类从被加载到虚拟机内存中开始，到卸栽出内存为止，它的整个生命周期包括了：加载、验证、准备、解析、初始化、使用和卸载七个阶段。其中验证、准备和解析三个部分统称为连接。 加载加载是类加载过程中的一个阶段，这个阶段虚拟机要完成3件事。 通过一个类的全限定名来获取定义此类的二进制字节流。 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 会在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个 Class 文件获取，这里既可以从 ZIP 包中读取（比如从 jar 包和 war 包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将 JSP 文件转换成对应的 Class 类） 链接验证这一阶段的主要目的是为了确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，保证被加载类的正确性，不会危害虚拟机自身的安全。验证主要包含4个阶段的校验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。 准备准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。注意这里所说的初始值概念，比如一个类变量定义为： 1public static int value = 123; 实际上变量 value 在准备阶段过后的初始值为 0 而不是 123，将 value 赋值为 123 的 putstatic 指令是程序被编译后，存放于类构造器方法之中。 但是注意如果声明为: 1public static final int value = 123; 在编译阶段会为 value 生成 ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 属性将 value 赋值为 123。 解析解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是在 class 文件中以： CONSTANT_Class_info、CONSTANT_Field_info、CONSTANT_Method_info等类型的常量出现。 初始化初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由 JVM 主导。到了初始阶段，才开始真正执行类中定义的 Java 程序代码。 那么，什么时候开始初始化？ 使用 new 该类实例化对象的时候； 读取或设置类静态字段的时候（但被final修饰的字段，在编译器时就被放入常量池的静态字段除外static final）； 调用类静态方法的时候； 使用反射 Class.forName(“xxxx”) 对类进行反射调用的时候，该类需要初始化； 初始化一个类的时候，有父类，先初始化父类（注：1. 接口除外，父接口在调用的时候才会被初始化；2.子类引用父类静态字段，只会引发父类初始化）； 被标明为启动类的类（即包含main()方法的类）要初始化； 当使用 JDK1.7 的动态语言支持时，如果一个 java.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。 以上情况称为对一个类进行主动引用，且有且只要以上几种情况需要对类进行初始化。","link":"/2020/08/22/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"},{"title":"LeetCode1563：石子游戏V","text":"题目几块石子 排成一行 ，每块石子都有一个关联值，关联值为整数，由数组 stoneValue 给出。 游戏中的每一轮：Alice 会将这行石子分成两个 非空行（即，左侧行和右侧行）；Bob 负责计算每一行的值，即此行中所有石子的值的总和。Bob 会丢弃值最大的行，Alice 的得分为剩下那行的值（每轮累加）。如果两行的值相等，Bob 让 Alice 决定丢弃哪一行。下一轮从剩下的那一行开始。 只 剩下一块石子 时，游戏结束。Alice 的分数最初为 0 。 返回 Alice 能够获得的最大分数 。 Solution$dp[l][r]$ 表示区间 $[l,r]$ Alice能得到的最大值，然后区间dp。 若$sum[l…mid] == sum[mid+1…r]$ ，则 $dp[l][r] = max(dp[l][r], dp[l][mid] + dp[mid + 1][r] + sum[l…mid])$。 若$sum[l…mid] != sum[mid+1…r]$ : $sum[l…mid] &gt; sum[mid + 1][r]$ ，则 $dp[l][r] = max(dp[l][r], dp[mid + 1][r] + sum[mid+1…r])$。 $sum[l…mid] &lt; sum[mid + 1][r]$ ，则 $dp[l][r] = max(dp[l][r], dp[l][mid] + sum[l…mid])$。 Code123456789101112131415161718192021222324252627282930class Solution { public int stoneGameV(int[] stoneValue) { int n = stoneValue.length; int[][] dp = new int[n][n]; int[] sum = new int[n]; sum[0] = stoneValue[0]; for (int i = 1; i &lt; n; i++) { sum[i] = sum[i - 1] + stoneValue[i]; } for (int len = 2; len &lt;= n; len++) { for (int l = 0; l + len - 1 &lt; n; l++) { int r = l + len - 1; for (int mid = l; mid &lt; r; mid++) { int fl = sum[mid] - (l &gt; 0 ? sum[l - 1] : 0); int fr = sum[r] - sum[mid]; if (fl == fr) { dp[l][r] = Math.max(dp[l][r], Math.max(dp[l][mid], dp[mid + 1][r]) + fl); } else { if (fl &gt; fr) { dp[l][r] = Math.max(dp[l][r], dp[mid + 1][r] + fr); } else { dp[l][r] = Math.max(dp[l][r], dp[l][mid] + fl); } } } } } return dp[0][n - 1]; }}","link":"/2020/08/25/LeetCode1563%EF%BC%9A%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8FV/"},{"title":"LeetCode：最短回文串","text":"题意给定一个字符串 $s$，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。 Solution等价于求字符串 $s$ 以 $s_0$ 开头的最长回文串，然后多出来的后缀翻转后就是需要补足的最小长度，判断回文可以采用哈希。 Code12345678910111213141516171819class Solution { public String shortestPalindrome(String s) { int n = s.length(); long left = 0, right = 0, base = 13331, mod = 1000000007, pre = 1; int pos = -1; for (int i = 0; i &lt; n; i++) { left = (left * base + s.charAt(i)) % mod; right = (right + pre * s.charAt(i)) % mod; if (left == right) { pos = i; } pre = pre * base % mod; } String add = (pos == n-1 ? &quot;&quot; : s.substring(pos+1,n)); StringBuilder res = new StringBuilder(add).reverse(); res.append(s); return res.toString(); }}","link":"/2020/08/29/LeetCode214%EF%BC%9A%E6%9C%80%E7%9F%AD%E5%9B%9E%E6%96%87%E4%B8%B2/"},{"title":"LeetCode354：俄罗斯套娃信封问题","text":"题意求二维最长上升子序列 Solution对第一维进行从小到大排序，然后第二维从大到小排序，对第二维做LIS即可。 Code12345678910111213141516171819202122232425262728293031class Solution { public int maxEnvelopes(int[][] a) { int n = a.length; if (n == 0) return 0; int[] low = new int[n + 1]; int res = 0; Arrays.sort(a, new Comparator&lt;int[]&gt; () { public int compare(int[] c1, int[] c2) { if (c1[0] == c2[0]) { return c2[1] - c1[1]; } else { return c1[0] - c2[0]; } } }); for (int i = 0; i &lt; n; i++) { if (low[res] &lt; a[i][1]) low[++res] = a[i][1]; else{ int pos = Arrays.binarySearch(low, 1, res, a[i][1]); if (pos &lt; 0) pos = -pos - 1; low[pos] = a[i][1]; } } return res; }}","link":"/2020/08/10/LeetCode354%EF%BC%9A%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98/"},{"title":"LeetCode424：替换后的最长重复字符","text":"题意给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。 Solution1枚举重复的字符，然后计算对应字符的能构成的最大长度，取最大值。 Code1234567891011121314151617181920212223class Solution { public int characterReplacement(String s, int k) { int n = s.length(), res = 0; for (int i = 0; i &lt; 26; i++) { List&lt;Integer&gt; l = new ArrayList&lt;Integer&gt;(); l.add(-1); for (int j = 0; j &lt; n; j++) { if (s.charAt(j) - 'A' != i) { l.add(j); } } if (l.size() &lt;= k + 1) { res = n; break; } l.add(n); for (int j = k + 1; j &lt; l.size(); j++) { res = Math.max(res, l.get(j) - l.get(j - k - 1) - 1); } } return res; }} Solution2滑动窗口，一个区间满足条件的原则是$当前区间的长度&lt;=区间内出现次数最多的字符 + k$，用滑动窗口维护即可。即当满足条件时，滑动窗口拓展，右端点++；不满足时，滑动窗口平移，左右端点++。滑动窗口的长度只会不断增大，遍历结束后滑动窗口的长度即为答案。 Code12345678910111213141516class Solution { public int characterReplacement(String s, int k) { int n = s.length(), res = 0, l = 0, r = 0, ma = 0; int[] b = new int[26]; for (r = 0; r &lt; n; r++) { int now = s.charAt(r) - 'A'; b[now]++; ma = Math.max(ma, b[now]); if (ma + k &lt; r - l + 1) { b[s.charAt(l) - 'A']--; l++; } } return n - l; }}","link":"/2020/08/10/LeetCode424%EF%BC%9A%E6%9B%BF%E6%8D%A2%E5%90%8E%E7%9A%84%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6/"},{"title":"LeetCode440：字典序的第K小数字","text":"题目给定整数 n 和 k，找到 1 到 n 中字典序第 k 小的数字。 注意：1 ≤ k ≤ n ≤ 10^9。 Solution我们可以把每个字符看作是字符串，这样我们只需要考虑前缀即可。显然最小的字符串一定是0，然后是所有以1开头的数。。。 我们只需要枚举所有首位数字 $1-9$，计算每个前缀在区间 $[0, n]$ 内有多少个数就好了，当累加和超过 $n$ 时，说明答案一定是以这个首位数字开头的，然后向下枚举。比如当以得知答案以3开头时，扣除3本身，然后向下枚举前缀30,31重复上述操作。。。直到 $k$ 为0。 Code1234567891011121314151617181920212223242526class Solution { public int get_Count(int n, long x, long y) { int sum = 0; while (x &lt;= n) { sum += Math.min(n + 1, y) - x; // 如n=15,则sum+=min(16,20)-10 x *= 10; y *= 10; } return sum; } public int findKthNumber(int n, int k) { int pre = 1; k--; // 扣除数字0 while (k &gt; 0) { int now = get_Count(n, pre, pre + 1); if (k &gt;= now) { // 说明不在这个前缀区间里 pre++; // 找下一个字典序前缀 k -= now; // 扣除这个前缀的所有数 } else { // 说明答案是这个前缀 pre *= 10; // 往下找 k--; // 扣除当前这个数 } } return pre; }}","link":"/2020/08/11/LeetCode440%EF%BC%9A%E5%AD%97%E5%85%B8%E5%BA%8F%E7%9A%84%E7%AC%ACK%E5%B0%8F%E6%95%B0%E5%AD%97/"},{"title":"LeetCode486：预测赢家","text":"题意给定一个表示分数的非负整数数组。 玩家 1 从数组任意一端拿取一个分数，随后玩家 2 继续从剩余数组任意一端拿取分数，然后玩家 1 拿，…… 。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。 给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。 Solution很容易想到递归解决，但显然复杂度太大。所以我们采用记忆化搜索，把已经搜索过的状态记录下来，回溯过程中取最大值。 $dp[l][r]$ 表示在区间 $[l,r]$ 中，能赢过对方的最大分数。 状态转移：$dp[l][r] = max(nums[l] - dp[l + 1][r], nums[r] - dp[l][r - 1])$。 Code123456789101112131415161718class Solution { static int[][] dp = new int[30][30]; public int dfs(int l, int r, int[] nums) { if (dp[l][r] != 0) return dp[l][r]; if (l == r) return dp[l][r] = nums[l]; return dp[l][r] = Math.max(nums[l] - dfs(l + 1, r, nums), nums[r] - dfs(l, r - 1, nums)); } public boolean PredictTheWinner(int[] nums) { int n = nums.length; for (int i = 0; i &lt; nums.length; i++) { Arrays.fill(dp[i], 0); } return dfs(0, n - 1, nums) &gt;= 0; }}","link":"/2020/09/01/LeetCode486%EF%BC%9A%E9%A2%84%E6%B5%8B%E8%B5%A2%E5%AE%B6/"},{"title":"MySQL基础","text":"","link":"/2020/09/08/MySQL%E5%9F%BA%E7%A1%80/"},{"title":"RMQ算法原理及实现","text":"RMQ（Range Minimum/Maximum Query），区间最值查询问题，是指：对于长度为 $n$ 的数列A，回答若干次询问 $RMQ(i,j)$，返回数列A中下标在区间 $[i,j]$ 中的最小/大值。 这里介绍Tarjan的Sparse-Table算法，预处理时间为 $O(nlogn)$，但查询只需要 $O(1)$，并且常数很小，算法也很容易写出。 1）预处理： 设 $A[i]$ 是要求区间最值的数列，$d[i, j]$ 表示从第i个数起连续 $2^j$ 个数中的最小值。(DP的状态) 显然 $d[i][0]$ 的值就是 $A[i]$ (DP初值)，我们把 $d[i，j]$ 平均分成两段(因为 $d[i，j]$ 一定是偶数个数字)，从 $i$ 到 $i + 2 ^ (j - 1) - 1$ 为一段，$i + 2 ^ (j - 1)$ 到 $i + 2 ^ j - 1$ 为一段(长度都为 $2 ^ (j - 1)$)。于是我们得到了状态转移方程 $d[i, j] = min(d[i，j-1], d[i + 2^(j-1)，j-1])$ Code123456void RMQ() { for (int i = 0; i &lt; n; ++i) d[i][0] = a[i]; for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j) for (int i = 0; i + (1 &lt;&lt; j) - 1 &lt; n; ++i) d[i][j] = min(d[i][j - 1], d[i + (1 &lt;&lt; (j - 1))][j - 1]);} 2）查询： 假如我们需要查询的区间为 $(i,j)$ ，那么我们需要找到覆盖这个闭区间(左边界取 $i$，右边界取 $j$)的最小幂（可以重复，比如查询1，2，3，4，5，5不是2的任意次方，但我们可以查询1234和2345）。 这个查询长度我们取范围小于等于区间长度的最大 $(2^k)$，这样我们查询 $i$ 到 $i + (2^k)$ 与 $j - (2^k) + 1$ 到 $j$ 的值，取二者最小值即可，代码实现如下： 12345int query(int L, int R) { int k = 0; while ((1 &lt;&lt; (k + 1)) &lt;= R - L + 1) ++k; return min(d[L][k], d[R - (1 &lt;&lt; k) + 1][k]);}","link":"/2020/10/10/RMQ%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"},{"title":"Vim配置","text":"写C++还是用vim爽啊，曾经三次尝试vim，寒假的时候终于能得到一份比较不错的配置了。 配色用的是atom的onedark，个人感觉挺好看的。 贴个配置，即开即用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253&quot; Vundle set nocompatiblefiletype offset rtp+=~/.vim/bundle/Vundle.vimcall vundle#begin()Plugin 'VundleVim/Vundle.vim'Plugin 'gdbmgr'Plugin 'The-NERD-Tree' &quot; 目录树Plugin 'mbbill/undotree' &quot; 撤回树Plugin 'majutsushi/tagbar' &quot; 函数、变量名Plugin 'vim-airline/vim-airline' &quot; 状态栏Plugin 'vim-airline/vim-airline-themes' &quot;状态栏Plugin 'arzg/vim-colors-xcode' &quot; xcode 主题&quot;Plugin 'cohlin/vim-colorschemes' &quot; xcode 主题Plugin 'tomasr/molokai' &quot; molokai 主题Plugin 'ashfinal/vim-colors-violet' &quot; violet 主题Plugin 'joshdick/onedark.vim' &quot; onedark主题Plugin 'sheerun/vim-polyglot' &quot; 语法突出显示Plugin 'jiangmiao/auto-pairs' &quot; 括号补全Plugin 'iamcco/mathjax-support-for-mkdp' &quot; 数学公式Plugin 'plasticboy/vim-markdown' &quot; markdown预览Plugin 'iamcco/markdown-preview.vim' &quot; markdown预览Plugin 'Valloric/YouCompleteMe' &quot; 代码补全Plugin 'zxqfl/tabnine-vim' &quot;代码补全Plugin 'tpope/vim-commentary' &quot; 代码注释Plugin 'sillybun/vim-repl' &quot; 代码调试Plugin 'w0rp/ale' &quot; 语法纠错&quot;Plugin 'octol/vim-cpp-enhanced-highlight' &quot; c++语法高亮Plugin 'TagHighlight' &quot; c++语法高亮Plugin 'Shougo/echodoc.vim' &quot; c++函数提示Plugin 'rhysd/vim-clang-format' &quot; 代码格式化Plugin 'Chiel92/vim-autoformat' &quot; c++代码格式化Plugin 'scrooloose/nerdcommenter' &quot; c++代码注释Plugin 'artur-shaik/vim-javacomplete2' &quot; java代码补全Plugin 'python-mode/python-mode' &quot; python modePlugin 'fatih/vim-go' &quot; go语言Plugin 'terryma/vim-multiple-cursors' &quot; vim 多行编辑Plugin 'mhinz/vim-startify' &quot; 欢迎界面call vundle#end()filetype plugin indent onset backspace=2&quot; javacomplete2&quot; https://github.com/artur-shaik/vim-javacomplete2autocmd FileType java setlocal omnifunc=javacomplete#Complete&quot; TagHighlight&quot; UpdateTypesFile&quot; multiple cursors&quot;start: &lt;C-n&gt; start multicursor and add a virtual cursor + selection on the match&quot;next: &lt;C-n&gt; add a new virtual cursor + selection on the next match&quot;skip: &lt;C-x&gt; skip the next match&quot;prev: &lt;C-p&gt; remove current virtual cursor + selection and go back on previous match&quot;select all: &lt;A-n&gt; start multicursor and directly select all matches&quot;&quot; plugin nerdcommenterlet mapleader = &quot;,&quot;let NERDSpaceDelims=1 &quot; 让注释符与语句之间留一个空格let g:NERDDefaultAlign = 'left' &quot;将行注释符左对齐&quot; auto save&quot; let g:auto_save = 5 &quot; enable AutoSave on Vim startup&quot; plugin undotree&quot; :UndotreeToggle&quot; plugin NERDTree&quot; :NERDTreeToggle&quot; plugin tarbar&quot; :TagbarToggle&quot;&quot; plugin autoformat&quot; :Autoformatlet g:autoformat_verbosemode=1 &quot;开启详细模式便于查错&quot; c++let g:formatdef_clangformat_google = '&quot;clang-format -style google -&quot;'let g:formatters_cpp = ['clangformat_google']&quot; pythonlet g:formatdef_autopep8 = &quot;'autopep8 - --range '.a:firstline.' '.a:lastline&quot;let g:formatters_python = ['autopep8']&quot; javalet g:formatdef_astyle_java = '&quot;astyle --mode=java --style=google -pcHs2&quot;'let g:formatdef_java = ['astyle_java']&quot; plugin echodoclet g:echodoc#type = &quot;echo&quot; &quot; Default valueset noshowmodelet g:echodoc_enable_at_startup = 1&quot; plugin YCM&quot;let g:ycm_global_ycm_extra_conf='~/.ycm_extra_conf.py'&quot;set completeopt=menu&quot; YouCompleteMeset runtimepath+=~/.vim/bundle/YouCompleteMeset completeopt=longest,menu &quot;让Vim的补全菜单行为与一般IDE一致(参考VimTip1228)let g:ycm_collect_identifiers_from_tags_files = 1 &quot; 开启 YCM 基于标签引擎let g:ycm_collect_identifiers_from_comments_and_strings = 1 &quot; 注释与字符串中的内容也用于补全let g:syntastic_ignore_files=[&quot;.*\\.py$&quot;]let g:ycm_seed_identifiers_with_syntax = 1 &quot; 语法关键字补全let g:ycm_complete_in_comments = 1let g:ycm_confirm_extra_conf = 0let g:ycm_key_list_select_completion = ['&lt;c-n&gt;', '&lt;Down&gt;'] &quot; 映射按键, 没有这个会拦截掉tab, 导致其他插件的tab不能用.let g:ycm_key_list_previous_completion = ['&lt;c-p&gt;', '&lt;Up&gt;']let g:ycm_complete_in_comments = 1 &quot; 在注释输入中也能补全let g:ycm_complete_in_strings = 1 &quot; 在字符串输入中也能补全let g:ycm_collect_identifiers_from_comments_and_strings = 1 &quot; 注释和字符串中的文字也会被收入补全let g:ycm_global_ycm_extra_conf='~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py'let g:ycm_show_diagnostics_ui = 0 &quot; 禁用语法检查&quot; 回车即选中当前项inoremap &lt;expr&gt; &lt;CR&gt; pumvisible() ? &quot;\\&lt;C-y&gt;&quot; : &quot;\\&lt;CR&gt;&quot; |&quot; 跳转到定义处nnoremap &lt;c-j&gt; :YcmCompleter GoToDefinitionElseDeclaration&lt;CR&gt;|let g:ycm_min_num_of_chars_for_completion=2 &quot; 从第2个键入字符就开始罗列匹配项&quot;disable ycm 语法检查let g:ycm_enable_diagnostic_signs = 0let g:ycm_enable_diagnostic_highlighting = 0let g:ycm_error_symbol = 'K'let g:ycm_warning_symbol = 'O'&quot; plugin vim-markdown 自动折叠关闭let g:vim_markdown_folding_disabled=1&quot;auto-format 格式化&quot;F5自动格式化代码并保存&quot;自动格式化代码，针对所有支持的文件&quot;au BufWrite * :Autoformat&quot;自动格式化python代码&quot;au BufWrite *.py :Autoformatet g:autoformat_verbosemode=1&quot;默认情况下是pep8，还可以选择google,facebook和chromium&quot;let g:formatter_yapf_style = 'google'&quot;let g:formatdef_my_cpp = '&quot;astyle --style=webkit&quot;'&quot;let g:formatters_cpp = ['my_cpp']&quot;au BufWrite * :Autoformat&quot; 代码调试快捷键autocmd Filetype python nnoremap &lt;F12&gt; &lt;Esc&gt;:REPLDebugStopAtCurrentLine&lt;Cr&gt;autocmd Filetype python nnoremap &lt;F10&gt; &lt;Esc&gt;:REPLPDBN&lt;Cr&gt;autocmd Filetype python nnoremap &lt;F11&gt; &lt;Esc&gt;:REPLPDBS&lt;Cr&gt;&quot; Let clangd fully control code completionlet g:ycm_clangd_uses_ycmd_caching = 0&quot; Use installed clangd, not YCM-bundled clangd which doesn't get updates.let g:ycm_clangd_binary_path = exepath(&quot;clangd&quot;)&quot;目录树map &lt;F2&gt; :NERDTreeToggle&lt;CR&gt;&quot;Python缩进autocmd FileType python set tabstop=4 | set expandtab | set autoindent&quot; plugin airlineset laststatus=2&quot; plugin alelet g:ale_linters = { \\ 'cpp': ['gcc'], \\}&quot;始终开启标志列let g:ale_sign_column_always = 1let g:ale_set_highlights = 0let g:ale_echo_msg_format = 'ale[%linter%] %code: %%s'let g:ale_cpp_gcc_executable = '/usr/local/bin/g++-9 -I /usr/local/Cellar/eigen/3.3.7/include/eigen3'let g:ale_sign_error = '✗'let g:ale_sign_warning = '⚡'let g:ale_lint_on_text_changed = 'always'&quot; 语法高亮let c_no_curly_error = 1let g:cpp_class_scope_highlight = 1let g:cpp_member_variable_highlight = 1let g:cpp_class_decl_highlight = 1let g:cpp_experimental_simple_template_highlight = 1let g:cpp_experimental_template_highlight = 1let g:cpp_concepts_highlight = 1&quot;let g:cpp_no_function_highlight=1syntax on&quot; 主题&quot;colorscheme xcode-default&quot;colorscheme molokai&quot;colorscheme violetcolorscheme onedarklet g:rehash256 = 1set cursorline &quot;or set cul 设置光标所在的行set et &quot;tab用空格替换set tabstop=2set expandtab&quot; Tab键的宽度set softtabstop=2set shiftwidth=2&quot; 统一缩进为2set number&quot; 显示行号set history=10000&quot; 历史纪录数set hlsearchset incsearch&quot; 搜索逐字符高亮set encoding=utf-8set fileencodings=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936,utf-16,big5,euc-jp,latin1&quot; 编码设置&quot; set mouse=a&quot; use mouseset langmenu=zn_CN.UTF-8set helplang=cn&quot; 语言设置set laststatus=2&quot; 总是显示状态行 就是那些显示 --insert-- 的怪东西set showcmd&quot; 在状态行显示目前所执行的命令，未完成的指令片段亦会显示出来set scrolloff=3&quot; 光标移动到buffer的顶部和底部时保持3行距离set showmatch&quot; 高亮显示对应的括号set matchtime=1&quot; 对应括号高亮的时间（单位是十分之一秒）&quot; 共享剪切板set clipboard=unnamedset norelativenumberlet &amp;t_SI.=&quot;\\e[5 q&quot; &quot;SI = INSERT modelet &amp;t_SR.=&quot;\\e[4 q&quot; &quot;SR = REPLACE modelet &amp;t_EI.=&quot;\\e[1 q&quot; &quot;EI = NORMAL mode (ELSE)let g:syntastic_cpp_compiler_options = ' -std=c++11 -stdlib=libc++'&quot; c++ 路径set path=.,/usr/local/bin/g++-9,/usr/local/include/c++/9.3.0,/usr/local/Cellar/eigen/3.3.7/include/eigen3,/usr/local/Cellar/boost/1.72.0/include,/usr/local/Cellar/gcc/9.2.0_1/include/c++/9.2.0,/usr/local/Cellar/gcc/9.2.0_1/include/c++/9.2.0/x86_64-apple-darwin19,/usr/local/Cellar/gcc/9.2.0_1/include/c++/9.2.0/backward,/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin19/9.2.0/include,/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin19/9.2.0/include-fixed,/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include,/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/System/Library/Frameworks,","link":"/2020/08/12/Vim%E9%85%8D%E7%BD%AE/"},{"title":"C++学习：explicit关键字","text":"最近在尝试着看源码的时候碰到了explicit关键字，查阅资料后有了一些理解，于是来做下笔记： explicit主要是用来修饰类的构造函数，从而使被构造的类只能发生显示转换，而不能进行隐式转化。 我们来看C++对象的显式和隐式转化： 1234567891011121314151617181920212223242526272829303132333435 #include &lt;iostream&gt; using namespace std; class Test1{ public: Test1(int n){ // 隐式构造函数 num = n; } private: int num; }; class Test2{ public: explicit Test2(int n){ //explicit(显式)构造函数 num = n; } private: int num; }; int main(){ Test1 t1 = 10; // 隐式转化 //等同于 Test1 temp(10); Test1 t1 = temp; Test1 t2 = 'c'; // 'c'被转化为ascii码，然后同上 Test2 t3 = 12; // 编译错误,不能隐式调用其构造函数Test2 t4 = 'c'; // 编译错误,不能隐式调用其构造函数 Test2 t5(10); // 正常的显式转化 return 0; } 总结：explicit关键字只用于类的单参数构造函数，对于无参数和多参数的构造函数总是显示调用，因此使用explicit没有意义。通常情况下，我们约定对于单参数构造函数必须使用explicit关键字，避免产生意外的类型转化，拷贝构造函数除外。","link":"/2020/05/01/explicit%E5%85%B3%E9%94%AE%E5%AD%97/"},{"title":"二维差分","text":"原理 紫色部分为所求区域，黄色区域为当前覆盖的区域。 $d[x1][y1] += w$ 表示将 $[x1, y1]$ 右下部分全部加上增量 $w$。 $d[x1][y2 + 1] -= w$ 用于抵消对 $y2$ 右边元素的影响，即图三蓝色区域。 $d[x2 + 1][y1] -= w$ 用于抵消对 $x2$ 下边元素的影响，即图四蓝色区域。 $d[x2 + 1][y2 + 1] += w$ 由于绿色区域被抵消了两次，因此需要加回增量 $w$。 Code12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;int a[1005][1005], d[1005][1005];int main() { int n, m, q, x1, y1, x2, y2, w; cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) cin &gt;&gt; a[i][j]; while (q--) { cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; w; d[x1][y1] += w; d[x1][y2 + 1] -= w; d[x2 + 1][y1] -= w; d[x2 + 1][y2 + 1] += w; } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { d[i][j] -= d[i - 1][j - 1] - d[i - 1][j] - d[i][j - 1]; a[i][j] += d[i][j]; printf(&quot;%d &quot;, a[i][j]); } printf(&quot;\\n&quot;); } return 0;}","link":"/2020/10/11/%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86/"},{"title":"函数间参数的传递方式","text":"1. 值传递：将主调函数的实参值传递给被调函数的形参，形参单独分配内存。 单向数据传递机制：传递的只是实参的值，形参的改变不影响实参。 1234567891011121314#include&lt;iostream&gt;using namespace std;void swap (int a, int b) {//实现形参a、b的交换 int c; c = a; a = b; b = c;}int main() { int x = 2, y = 3; swap(x, y);//实参x,y的值并没有交换。值传递的单向数据传递机制 cout &lt;&lt; x&lt;&lt; &quot; &quot;&lt;&lt;y&lt;&lt; endl;//2 3 return 0;} 2. 引用传递：被调用的形参引用主调函数的实参，实现间接访问。 双向数据传递机制：通过引用&amp;，指向同一内存，其一改变，二者都改变。 1234567891011121314#include&lt;iostream&gt;using namespace std;void swap (int &amp;a, int &amp;b) {//引用变量a、b，等效int &amp;a=x;int &amp;b=y; int c; c = a; a = b; b = c;}int main() { int x = 2, y = 3; swap(x, y);//实参x,y的值被交换。a与x，b与y指向同一内存，其一改变，两者都变 cout &lt;&lt; x&lt;&lt; &quot;和&quot;&lt;&lt;y&lt;&lt; endl;//3和2 return 0;} PS：关于直接和间接访问： 按照C语言的方式，定义一个变量，系统会自动为该变量分配内存，变量有两个属性：变量值和变量地址。变量地址指示该变量在内存中的存储位置，变量值为该内存中的存储内容。 直接访问：直接使用变量名访问内存空间上的内容。 间接访问：先从其它内存空间获得要访问的内存地址（指针），根据地址访问对应内存中的数据。 3. 指针传递：被调函数的形参接收主调函数实参的内存地址，间接访问。1234567891011121314#include&lt;iostream&gt;using namespace std;void swap (int *a, int *b) {//引用变量a、b，等效int *a=&amp;x;int *b=&amp;y; int c; c = *a; *a = *b; *b = c;}int main() { int x = 2, y = 3; swap(&amp;x, &amp;y);//实参x,y的值被交换。实参地址传递给指针类型的形参 cout &lt;&lt; x&lt;&lt; &quot;和&quot;&lt;&lt;y&lt;&lt; endl;//3和2 return 0;}","link":"/2020/04/19/%E5%87%BD%E6%95%B0%E9%97%B4%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F/"},{"title":"回文相关算法总结及简单变形","text":"求最长回文串解法一：中心扩散法过于傻逼，就是枚举中心点向两边拓展长度直到不相等。（时间复杂度 $O(n^2)$，空间复杂度 $O(1)$） Code123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;string s;int check(int pos, int type) { int now, x, y; if (type) now = 0, x = pos, y = pos + 1; else now = 1, x = pos - 1, y = pos + 1; while (1) { if (x &gt;= 0 &amp;&amp; y &lt; s.size() &amp;&amp; s[x] == s[y]) now += 2; else break; x--, y++; } return now;}int main() { while (cin &gt;&gt; s) { int res = 1; for (int i = 1; i &lt; s.size() - 1; i++) res = max(res, max(check(i, 0), check(i, 1))); cout &lt;&lt; res &lt;&lt; '\\n'; } return 0;} 解法二：动态规划$dp[i][j] = 0/1 $ 表示子串 $i~j$ 是否为回文串。 那么，容易得到：$dp[i][j] = (dp[i+1][j-1]$ &amp;&amp; $s[i]==s[j])$。 由于 $i$ 是由 $i+1$ 转移过来的，所以我们需要倒着遍历： Code1234567for (int i = s.size() - 1; i &gt;= 0; i--) for (int j = i; j &lt; s.size(); j++) { if (s[i] == s[j] &amp;&amp; (j - i &lt; 2 || dp[i + 1][j - 1])) { dp[i][j] = true; res = max(res, j - i + 1); } } 时间复杂度 $O(n^2)$，空间复杂度 $O(n^2)$ 解法三：manacherCode12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;const int N = 2e6 + 5;int p[N];char s[N], t[N];int manacher(){ int l = 0; t[l++] = '$'; t[l++] = '#'; for (int i = 0; s[i]; i++) { t[l++] = s[i]; t[l++] = '#'; } t[l++] = '@'; int id = 0, mx = 0, index = 0, maxlength = -1; for (int i = 1; i &lt; l; i++) { p[i] = mx &gt; i ? min(p[2 * id - i], mx - i) : 1; /// 向左右两边延伸，扩展右边界 while (t[i + p[i]] == t[i - p[i]]) p[i]++; /// 如果回文子串的右边界超过了mx，则需要更新mx和id的值 if (i + p[i] &gt; mx) { mx = i + p[i]; id = i; } /// 如果回文子串的长度大于maxLength，则更新maxLength和index的值 if (maxlength &lt; p[i] - 1) { maxlength = p[i] - 1; index = i; } } int start = (index - maxlength) / 2; /// 记录起始位置 return maxlength;}int main(){ while (~scanf(&quot;%s&quot;, s)) printf(&quot;%d\\n&quot;, manacher()); return 0;} 变形1求最长回文子序列solution 状态 $f[i][j]$ 表示 $s$ 的第 $i$ 个字符到第 $j$ 个字符组成的子串中，最长的回文序列长度是多少。 转移方程 如果 $s$ 的第 $i$ 个字符和第 $j$ 个字符相同的话 $f[i][j] = f[i + 1][j - 1] + 2$ 如果 $s$ 的第 $i$ 个字符和第 $j$ 个字符不同的话 $f[i][j] = max(f[i + 1][j], f[i][j - 1])$ 然后注意遍历顺序，$i$ 从最后一个字符开始往前遍历，$j$ 从 $i + 1$ 开始往后遍历，这样可以保证每个子问题都已经算好了。 初始化$f[i][i] = 1$ 单个字符的最长回文序列是 $1$ 结果$f[0][n - 1]$ Code12345678910for(int i = n - 1; i &gt;= 0; i--) { dp[i][i] = 1; for(int j = i + 1; j &lt; n; j++) { if(s[i] == s[j]) dp[i][j] = dp[i + 1][j - 1] + 2; else dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]); }}return dp[0][n - 1]; 变形2插入最少的字符，使得字符串变成回文串。solution很直观的，答案就是原长度-最长回文子序列。考虑另一种区间dp的做法： 既然是区间dp，那么就是由小区间得到大区间，故最外层从小到大枚举长度，然后枚举左右端点。 $dp[i][j] = min(dp[i + 1][j] + 1, dp[i][j - 1] + 1)$ $s[i] != s[j]$ $dp[i][j] = min(dp[i + 1][j] + 1, dp[i][j - 1] + 1, dp[i + 1][j - 1])$ $s[i] == s[j]$ Code123456789for (int len = 2; len &lt;= n; len++) { for (int l = 0; l &lt;= n - len; l++) { int r = l + len - 1; dp[l][r] = min(dp[l + 1][r], dp[l][r - 1]) + 1; if (s[l] == s[r]) dp[l][r] = min(dp[l][r], dp[l + 1][r - 1]); } } return dp[0][n - 1];","link":"/2020/04/25/%E5%9B%9E%E6%96%87%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E5%8F%8A%E7%AE%80%E5%8D%95%E5%8F%98%E5%BD%A2/"},{"title":"存在负数的背包问题","text":"题目1体积和价值可能为负数的01背包。 Solution逆向思维，对于体积为负的物品，我们可以一开始就装进去，背包对应的进行扩容，物品的体积和价值也对应取反。这样在进行背包dp 的时候就代表移除这个物品，答案取最大值即可。 Code1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 410;int c[N], v[N], ans;int dp[40010];int main() { int N, M; scanf(&quot;%d%d&quot;, &amp;N, &amp;M); for (int i = 1; i &lt;= N; i++) { scanf(&quot;%d%d&quot;, &amp;c[i], &amp;v[i]); if (c[i] &lt;= 0) { ans += v[i]; M -= c[i]; c[i] = -c[i]; v[i] = -v[i]; } } for (int i = 1; i &lt;= N; i++) for (int j = M; j &gt;= c[i]; j--) dp[j] = max(dp[j], dp[j - c[i]] + v[i]); for (int i = 0; i &lt;= M; i++) { dp[M] = max(dp[M], dp[i]); } printf(&quot;%d\\n&quot;, ans + dp[M]); return 0;} 题目2体积和价值可能为负数且要求所取的物品体积之和和价值之和都大于0的条件下，两者总和最大的01背包。$(n = 100, -1000&lt;=v,w&lt;=1000)$ Solution由于体积可能为负，因此需要负数转化为正数，以 $100000$ 为分界线划分为左边代表正数，右边代表负数做背包dp即可，当体积为负时，转移是由大的容量转移过来，需要从小到大遍历。最后取分界线右侧且dp值大于 0 的体积加价值最大值即可。 Code1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;const int m = 2e5 + 5;int n, x, y, res, dp[m];int main() { cin &gt;&gt; n; for (int i = 0; i &lt; m; i++) dp[i] = -m; dp[100000] = 0; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; x &gt;&gt; y; if (x &gt;= 0) { for (int j = m - 1; j &gt;= x; j--) { if (dp[j - x] != -m) dp[j] = max(dp[j], dp[j - x] + y); } } else { for (int j = 0; j &lt; m + x; j++) { if (dp[j - x] != -m) dp[j] = max(dp[j], dp[j - x] + y); } } } for (int i = 100000; i &lt; m; i++) { if (dp[i] &gt; 0) res = max(res, dp[i] + i - 100000); } cout &lt;&lt; res &lt;&lt; endl; return 0;}","link":"/2020/09/02/%E5%AD%98%E5%9C%A8%E8%B4%9F%E6%95%B0%E7%9A%84%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"title":"实现kth_element","text":"快排的思想，选定一个基准数，将大于 $mid$ 的数放到右边，小于的放到左边，然后比较 $mid$ 和 $k$ 的位置，递归重复操作即可。 123456789101112131415161718192021222324252627282930313233343536373839#pragma GCC optimize(&quot;Ofast&quot;)#include &lt;cstdio&gt;inline int read() { int x = 0, w = 1; char c = getchar(); while (c &lt; '0' || c &gt; '9') { if (c == '-') w ^= 1; c = getchar(); } while (c &lt;= '9' &amp;&amp; c &gt;= '0') { x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - '0'; c = getchar(); } return w &amp; 1 ? x : -x;}int kth_element(int* a, int l, int r, int k) { int mid = l - 1; for (int i = l; i &lt; r; ++i) { if (a[i] &lt; a[r] &amp;&amp; a[i] ^ a[++mid]) a[i] ^= a[mid] ^= a[i] ^= a[mid]; } if (a[++mid] ^ a[r]) a[mid] ^= a[r] ^= a[mid] ^= a[r]; if (mid == k) return a[mid]; return (mid &gt;= k) ? kth_element(a, l, mid - 1, k) : kth_element(a, mid + 1, r, k);}int a[2000006];int main() { int n, k; n = read(); k = read(); for (int i = 0; i &lt; n; ++i) a[i] = read(); // random_shuffle(a, a + n); printf(&quot;%d\\n&quot;, kth_element(a, 0, n - 1, n - k)); return 0;}","link":"/2020/08/21/%E5%AE%9E%E7%8E%B0kth-element/"},{"title":"并查集拓展","text":"边带权银河英雄传说有 $T$ 条指令，每条指令格式为以下两种之一： $M-i-j$，表示让第 $i$ 号战舰所在列的全部战舰保持原有顺序，接在第 $j$ 号战舰所在列的尾部。 $C-i-j$，表示询问第 $i$ 号战舰与第 $j$ 号战舰当前是否处于同一列中，如果在同一列中，它们之间间隔了多少艘战舰。 数据范围：$N≤30000, T≤500000$ Solution维护数组 $dp$ 表示 $i$ 到 $root$ 的距离，那么查询的答案便是 $abs(dp[a] - dp[b]) - 1$。 当 $a$ 向 $b$ 连一条边时，有 $fa[a] = b$，此时根结点 $a$ 的深度会增加 $b$ 的集合大小，因此我们需要一个 $sz$ 数组维护集合大小。 同时在进行路径压缩时，对于未更新的结点也要一同更新深度。 Code1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6 + 5;int dp[N], sz[N], fa[N];int find (int x) { if (x != fa[x]) { int root = find(fa[x]); dp[x] += dp[fa[x]]; fa[x] = root; } return fa[x];}int main(){ int t, a, b; string s; cin &gt;&gt; t; for (int i = 1; i &lt;= 30000; i++) { dp[i] = 0; sz[i] = 1; fa[i] = i; } while (t--) { cin &gt;&gt; s &gt;&gt; a &gt;&gt; b; int pa = find(a), pb = find(b); if (s == &quot;M&quot;) { if (pa != pb) { fa[pa] = pb; dp[pa] = sz[pb]; sz[pb] += sz[pa]; } } else { if (pa != pb) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; max(abs(dp[a] - dp[b]) - 1, 0) &lt;&lt; endl; } } return 0;} 拓展域食物链动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。 $1-X-Y$，表示 $X$ 和 $Y$ 是同类。 $2-X-Y$，表示 $X$ 吃 $Y$。 判断有多少句假话。$(1≤N≤50000,0≤K≤100000)$ Solution$1-n$ 表示动物 $i$ 的同类，$n+1-2n$ 表示动物 $i$ 的猎物，$2n+1 - 3n$ 表示动物 $i$ 的天敌。 对于操作1: 查询 $x$ 和 $y$ 的天敌域，猎物域是不是在一个集合，是则累加答案，否则进行合并。 对于操作2: 查询 $x$ 和 $y$ 的同类域，猎物域是不是在一个集合，是则累加答案，否则进行合并。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;int fa[1000005];int find (int x) { if (x != fa[x]) fa[x] = find(fa[x]); return fa[x];}void join (int a, int b) { a = find(a), b = find(b); if (a != b) fa[a] = b;}int main(){ int n, k, a, b, c, res = 0; cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n * 3; i++) fa[i] = i; while (k--) { cin &gt;&gt; c &gt;&gt; a &gt;&gt; b; if (a &gt; n || b &gt; n) { res++; continue; } if (c == 1) { if (find(a) == find(b + n) || find(a) == find(b + 2 * n)) { res++; continue; } else { /// a和b是同类，a和b的猎物也是同类，a和b的天敌也是同类 join(a, b); join(a + n, b + n); join(a + 2 * n, b + 2 * n); } } else { if (a == b || find(a) == find(b) || find(a) == find(b + n)) { res++; continue; } else { /// a的猎物是b， b的天敌是a，b的猎物是a的天敌 join(a, b + 2 * n); join(a + n, b); join(a + 2 * n, b + n); } } } cout &lt;&lt; res &lt;&lt; endl; return 0;} 奇偶游戏给你 $m$ 个询问，每一个询问给出一个区间的左右端点和区间中的 $1$ 的数量的奇偶性，输出不出现矛盾的最大的 $k$ 值，即 $1-k$ 无矛盾，$1- k + 1$ 矛盾。$(N≤10^9,M≤10000)$ Solution1（边带权） 我们可以用 $sum$ 数组表示序列 S 的前缀和,那么会得到以下性质. $s[l~r]$ 有偶数个 $1$，等价于 $sum[l-1]$ 与 $sum[r]$ 奇偶性相同 $(1+0=1,0+0=0,1是奇数,0是偶数)$$s[l~r]$ 有奇数个 $1$，等价于 $sum[l-1]$ 与 $sum[r]$ 奇偶性不同 $(1+1=0,0+1=0,1是奇数,0是偶数)$ 根据传递性，可以使用边带权，边权 $d[x] = 0$，表示 $x$ 与 $f[x]$ 的奇偶性相同; 为 $1$，表示 $x$ 与 $fa[x]$ 的奇偶性不同,在路径压缩的过程中,对 $x$ 到树根路径的所有边权做异或$(xor)$。 对于每个问题, 设离散化后 $l - 1$ 和 $r$ 的值分别是 $x$ 和 $y$ , 设 $c$ 表示当前问题的回答($c = 0$ 表示偶数个, $c = 1$ 表示奇数个) 若 $x$ 和 $y$ 在一个集合中, 直接判断 $d[x] xor d[y]$ 是否等于 $c$，若不等于,则矛盾，直接输出结果。 若 $x$ 和 $y$ 不在一个集合中，说明无法判断，此时合并两个集合，得到俩个的树根 $p$ 和 $q$, $d[x]$ 与 $d[y]$ 分别表示 $x - p$ 与 $y - q$ 之间所有边权的 “xor” 和，$p - q$ 之间的边权为 $d[p]$, 显然, 路径 $x - y$ 由 $x - p$, $p - q$, $q - y$ 组成，所以 $x$ 与 $y$ 的奇偶性关系 $c = d[x] (xor) d[y] (xor) d[p]$，得到 $d[p] = d[x] (xor) d[y] (xor) c$。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5;int fa[N], d[N];unordered_map&lt;int, int&gt; mp;vector&lt;int&gt; g;struct Node { int a, b, c;} q[N];int find (int x) { if (x != fa[x]) { int root = find(fa[x]); d[x] ^= d[fa[x]]; fa[x] = root; } return fa[x];}int main(){ int L, n, a, b, pa, pb; string s; cin &gt;&gt; L &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; q[i].a &gt;&gt; q[i].b &gt;&gt; s; if (s[0] == 'e') q[i].c = 0; else q[i].c = 1; g.push_back(q[i].a - 1); g.push_back(q[i].b); } sort(g.begin(), g.end()); g.erase(unique(g.begin(), g.end()), g.end()); for (int i = 1; i &lt;= (int)g.size(); i++) { fa[i] = i; mp[g[i - 1]] = i; d[i] = 0; } int i = 1; for (; i &lt;= n; i++) { a = mp[q[i].a - 1], b = mp[q[i].b]; pa = find(a), pb = find(b); if (pa != pb) { fa[pa] = pb; d[pa] ^= d[a] ^ d[b] ^ q[i].c; } else { if (d[a] ^ d[b] != q[i].c) break; } } cout &lt;&lt; i - 1 &lt;&lt; endl; return 0;} Solution2（拓展域）$1 - n$ 表示 $sum[i]$ 为奇，$n + 1 - 2 * n$ 表示 $sum[i]$ 为偶。 当查询区间为奇数时：判断 $a$ 的奇数域是否与 $b$ 的奇数域同在一个集合，是则矛盾，否则合并 $a$ 的奇数域与 $b$ 的偶数域，$a$ 的偶数域与 $b$ 的奇数域。 当查询区间为偶数时：判断 $a$ 的奇数域是否与 $b$ 的偶数域同在一个集合，是则矛盾，否则合并 $a,b$ 的奇数域和偶数域。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5;int fa[N];vector&lt;int&gt; g;unordered_map&lt;int, int&gt; mp;struct Node { int a, b, c;} q[N];int find (int x) { if (x != fa[x]) fa[x] = find(fa[x]); return fa[x];}void join (int x, int y) { x = find(x), y = find(y); if (x != y) fa[x] = y;} int main(){ int L, m, n, a, b; string s; cin &gt;&gt; L &gt;&gt; m; for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; q[i].a &gt;&gt; q[i].b &gt;&gt; s; if (s == &quot;even&quot;) q[i].c = 0; else q[i].c = 1; g.push_back(q[i].a - 1); g.push_back(q[i].b); } sort(g.begin(), g.end()); g.erase(unique(g.begin(), g.end()), g.end()); n = g.size(); for (int i = 1; i &lt;= n; i++) { mp[g[i - 1]] = i; fa[i] = i; fa[i + n] = i + n; } int i = 1; for (; i &lt;= m; i++) { a = mp[q[i].a - 1], b = mp[q[i].b]; if (q[i].c) { if (find(a) == find(b) || find(a + n) == find(b + n)) break; join(a, b + n); // 合并a的奇数域和b的偶数域 join(a + n, b); // 合并a的偶数域和a的奇数域 } else { if (find(a) == find(b + n) || find(a + n) == find(b)) break; join(a, b); // 合并a的奇数域和b的奇数域 join(a + n, b + n); // 合并a的偶数域和b的偶数域 } } cout &lt;&lt; i - 1 &lt;&lt; endl; return 0;} 反向并查集星球大战求每次拆边后的连通块个数。$(m \\in [1, 2e5], n \\in [1, 2*m])$ Solution拆边很难维护集合数量，考虑离线后反过来建图。这样便相当于每次增加增加一条边，查询两个点是否为同一个集合即可知道集合数量是否减少。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e5 + 5;int n, m, k, pre[N], b[N], vis[N];vector&lt;int&gt; g[N];int find(int x) { int i = x, j = x; while (i != pre[i]) i = pre[i]; while (i != j) { int temp = pre[j]; pre[j] = i; j = temp; } return i;}bool join(int x, int y) { int fx = find(x), fy = find(y); if (fx != fy) { pre[fx] = fy; return true; } return false;}int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) pre[i] = i; for (int i = 1; i &lt;= m; i++) { int x, y; cin &gt;&gt; x &gt;&gt; y; g[x].push_back(y); g[y].push_back(x); } cin &gt;&gt; k; for (int i = 1; i &lt;= k; i++) { cin &gt;&gt; b[i]; vis[b[i]] = 1; } int res = n - k; for (int i = 0; i &lt; n; i++) { if (vis[i]) continue; for (int j = 0; j &lt; g[i].size(); j++) { int x = g[i][j]; if (!vis[x]) { if (join(i, x)) res--; } } } b[k + 1] = res; for (int i = k; i &gt;= 1; i--) { res++; vis[b[i]] = 0; for (int j = 0; j &lt; g[b[i]].size(); j++) { if (!vis[g[b[i]][j]] &amp;&amp; join(b[i], g[b[i]][j])) res--; } b[i] = res; } for (int i = 1; i &lt;= k + 1; i++) cout &lt;&lt; b[i] &lt;&lt; endl; return 0;} Total Eclipse给你 $n$ 个节点 $m$ 条边的图，每个点有一个权值，你现在要做的操作是选择一个连通图，并将其中的每一个点的权值都减一，问你最少需要多少次才能将所有的点都变为0。$(1≤n≤100000, 1≤m≤200000)$ Solution贪心地想，每次必然是选择权值最小的点，然后联通的边都减少该权值，但这样很难维护，因此可以考虑反向。 每次选择权值最大的点，然后这个点需要减少到和次小的点一样的权值，即减少的权值为和次小点权值之差。由于一次可以减少一个联通块，因此我们只需要乘以当前点联通块个数即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5;int t, n, m, pre[N], vis[N];vector&lt;int&gt; g[N];struct Node { long long w; int id;} q[N];bool cmp(Node x, Node y) { return x.w &gt; y.w; }int find(int x) { int i = x, j = x; while (i != pre[i]) i = pre[i]; while (j != i) { int temp = pre[j]; pre[j] = i; j = temp; } return i;}bool join(int x, int y) { int fx = find(x), fy = find(y); if (fx != fy) { pre[fx] = fy; return true; } return false;}int main() { scanf(&quot;%d&quot;, &amp;t); while (t--) { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); memset(vis, 0, sizeof(vis)); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%lld&quot;, &amp;q[i].w); q[i].id = i; pre[i] = i; g[i].clear(); } for (int i = 1; i &lt;= m; i++) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); g[u].push_back(v); g[v].push_back(u); } long long cnt = 0, res = 0; sort(q + 1, q + n + 1, cmp); q[n + 1].w = 0; for (int i = 1; i &lt;= n; i++) { cnt++; vis[q[i].id] = 1; for (auto x : g[q[i].id]) { if (vis[x] &amp;&amp; join(x, q[i].id)) cnt--; } res += cnt * (q[i].w - q[i + 1].w); } printf(&quot;%lld\\n&quot;, res); } return 0;}","link":"/2020/10/29/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%8B%93%E5%B1%95/"},{"title":"拷贝构造，拷贝复制，析构","text":"Big Three（拷贝构造，拷贝复制，析构）123456789101112131415161718192021222324class String { public: String (const char* cstr = 0); // 构造函数，默认初值为0 String (const String&amp; str); // 接受的值为类本身，因此为拷贝构造函数 String&amp; operator=(const String&amp; str); // = 号重载，拷贝赋值函数 ~String(); // 析构函数，类死亡时自动调用 char* get_c_str() const { return m_data; } private: char* m_data; }int main(){ String s1(); String s2(&quot;hello&quot;); String s3(s1); // 拷贝构造，类还未存在 cout &lt;&lt; s3 &lt;&lt; endl; s3 = s2; // 拷贝赋值，类已经存在 cout &lt;&lt; s3 &lt;&lt; endl;} 123456789101112131415161718inlineString::String(const char* cstr = 0){ if (cstr) { // 指定初值 m_data = new char[strlen(cstr) + 1]; // 分配传进来的长度+ '\\0' 的空间 strcpy(m_data, cstr); // 复制 } else { // 未指定初值 m_data = new char[1]; *m_data = '\\0'; }}inlineString::~String(){ delete[] m_data; // 将原来分配的内存释放} 123451. String p1(&quot;hello&quot;); //栈中分配内存2. String p2 = String(&quot;hello&quot;); //栈中分配内存，跟方法1相同，是方法1的完整模式3. String *p3 = new String(&quot;hello&quot;); //堆中分配内存 方法1、2中都是在栈中分配内存，在栈中内存由系统自动的去分配和释放，释放的顺序也和栈一样，后定义的先释放。 而使用new创建的指针对象是在堆中分配内存，当不需要该对象时，需要我们手动的去释放，否则会造成内存泄漏。 深拷贝，浅拷贝如果类中有指针成员，则必须写拷贝构造和拷贝赋值函数。 假设 指针a -&gt; “hello”, 指针b -&gt; “world”，当执行 b = a 时，则变成 b 指向 a，造成 “world” 无人指向，发生了内存泄漏，而”hello” 被 a 和 b 同时指向的情况，那么将来一旦改变 a ，b 也会发生改变。那么，这种拷贝称之为 “浅拷贝”。 深拷贝即为我们自己写的拷贝函数： 123456789101112131415161718inlineString::String(const String&amp; str) // 拷贝构造{ m_data = new char[ strlen(str.m_data) + 1 ]; strcpy(m_data, str.m_data);}inlineString&amp; String::operator=(const String&amp; str) // 拷贝赋值{ if(this == &amp;str) // 有可能是自己赋值给自己（比如引用），如果不写这句，那么delete就是它自己，下面全错 return *this; delete[] m_data; // 先将自己删除 m_data = new char[ strlen(str.m_data) + 1 ]; // 重新创建和右边一样大的空间 strcpy(m_data, str.m_data); // 重新赋值 return *this;}","link":"/2020/05/11/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%EF%BC%8C%E6%8B%B7%E8%B4%9D%E5%A4%8D%E5%88%B6%EF%BC%8C%E6%9E%90%E6%9E%84/"},{"title":"操作系统知识点","text":"概念操作系统（Operating System，OS）是指控制系统和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户其他软件方便的接口和环境，它是计算机系统中最基本的系统软件。 进程一个程序的执行过程。执行前需要将该程序放到内存中，才能被CPU处理。 功能和目标作为系统资源的管理者 进程管理 进程控制、进程同步、进程通信、死锁处理、处理机调度等。 内存管理 内存分配、地址映射、内存保护与共享、虚拟内存等。 文件管理 文件存储空间的管理、目录管理、文件读写管理和保护等。 设备管理 完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。 主要包括缓冲管理、设备分配、设备处理、虛拟设备等。 找到QQ的安装位置 逐层打开文件夹，找到QQ的存放位置 -&gt; 文件管理 双击打开QQ程序 把程序相关数据放入内存 -&gt; 存储器管理（内存管理） 程序正常运行 对应的进程被处理机处理（CPU） -&gt; 处理机管理 开始和朋友视频聊天 需要将摄像头设备分配给进程 -&gt; 设备管理 作为用户和计算机硬件之间的接口 命令接口：允许用户直接使用 程序接口：允许用户通过程序间接使用 GUI：现代操作系统中最流行的图形用户接口 作为最接近硬件的层次 —— 实现对硬件机器的拓展通常把覆盖了软件的机器称为扩充机器，又称之为虚拟机。 特征并发指两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生，但微观上是交替发生。 区别于并行：同一时刻同时进行两个约会任务 操作系统的并发性指计算机系统中同时存在着多个运行着的程序。 一个单核处理机（CPU）同一时刻只能执行一个程序，因此操作系统会负责协调多个程序交替执行。操作系统和程序并发是一起诞生的。 共享共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。 生活实例：互斥共享方式：使用QQ和微信视频，同一时间段内摄像头只能分配给其中一个进程。同时共享方式：使用QQ发送文件A，同时使用微信发送文件B。宏观上看，两边都在同时读取并发送文件，说明两个进程都在访问硬盘资源，从中读取数据。从微观上看，两个进程是交替着访问硬盘的。 并发和共享的关系 并发性指计算机系统中同时存在多个运行着的程序。 共享性指系统中的资源可供内存中多个并发执行的进程共同使用。 使用QQ发送文件A，同时使用微信发送文件B： 两个进程正在并发执行（并发性） 需要共享地访问硬盘资源（共享性） 虚拟虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。 异步异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。 只有系统拥有并发性，才有可能导致异步性。 大内核和微内核 大内核 大内核是将操作系统功能作为一个紧密结合的整体放到内核。 由于各模块共享信息，因此有很高的性能。 微内核 由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。 在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。 因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。 中断机制为了解决串行导致效率，利用率低的问题，引入了中断机制，实现了多道程序并发执行。本质：发生中断就意味着需要操作系统介入，开展管理工作","link":"/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"title":"杜教BM模板","text":"用于求线性递推式第n项，扔进前k+x项即可 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cassert&gt;using namespace std;typedef long long ll;#define rep(i, a, n) for (int i = a; i &lt; n; i++)#define per(i, a, n) for (int i = n - 1; i &gt;= a; i--)#define pb push_back#define mp make_pair#define all(x) (x).begin(), (x).end()#define fi first#define se second#define SZ(x) ((int)(x).size())typedef vector&lt;ll&gt; VI;typedef pair&lt;ll, ll&gt; PII;const ll mod = 10000;ll powmod(ll a, ll b) { ll res = 1; a %= mod; assert(b &gt;= 0); for (; b; b &gt;&gt;= 1) { if (b &amp; 1) res = res * a % mod; a = a * a % mod; } return res;}ll _, n;namespace linear_seq {const ll N = 10010;ll res[N], base[N], _c[N], _md[N];vector&lt;ll&gt; Md;void mul(ll *a, ll *b, int k) { rep(i, 0, k + k) _c[i] = 0; rep(i, 0, k) if (a[i]) rep(j, 0, k) _c[i + j] = (_c[i + j] + a[i] * b[j]) % mod; for (ll i = k + k - 1; i &gt;= k; i--) if (_c[i]) rep(j, 0, SZ(Md)) _c[i - k + Md[j]] = (_c[i - k + Md[j]] - _c[i] * _md[Md[j]]) % mod; rep(i, 0, k) a[i] = _c[i];}ll solve(ll n, VI a, VI b) { ll ans = 0, pnt = 0; ll k = SZ(a); assert(SZ(a) == SZ(b)); rep(i, 0, k) _md[k - 1 - i] = -a[i]; _md[k] = 1; Md.clear(); rep(i, 0, k) if (_md[i] != 0) Md.push_back(i); rep(i, 0, k) res[i] = base[i] = 0; res[0] = 1; while ((1ll &lt;&lt; pnt) &lt;= n) pnt++; for (ll p = pnt; p &gt;= 0; p--) { mul(res, res, k); if ((n &gt;&gt; p) &amp; 1) { for (ll i = k - 1; i &gt;= 0; i--) res[i + 1] = res[i]; res[0] = 0; rep(j, 0, SZ(Md)) res[Md[j]] = (res[Md[j]] - res[k] * _md[Md[j]]) % mod; } } rep(i, 0, k) ans = (ans + res[i] * b[i]) % mod; if (ans &lt; 0) ans += mod; return ans;}VI BM(VI s) { VI C(1, 1), B(1, 1); ll L = 0, m = 1, b = 1; rep(n, 0, SZ(s)) { ll d = 0; rep(i, 0, L + 1) d = (d + (ll)C[i] * s[n - i]) % mod; if (d == 0) ++m; else if (2 * L &lt;= n) { VI T = C; ll c = mod - d * powmod(b, mod - 2) % mod; while (SZ(C) &lt; SZ(B) + m) C.pb(0); rep(i, 0, SZ(B)) C[i + m] = (C[i + m] + c * B[i]) % mod; L = n + 1 - L; B = T; b = d; m = 1; } else { ll c = mod - d * powmod(b, mod - 2) % mod; while (SZ(C) &lt; SZ(B) + m) C.pb(0); rep(i, 0, SZ(B)) C[i + m] = (C[i + m] + c * B[i]) % mod; ++m; } } return C;}ll gao(VI a, ll n) { VI c = BM(a); c.erase(c.begin()); rep(i, 0, SZ(c)) c[i] = (mod - c[i]) % mod; return solve(n, c, VI(a.begin(), a.begin() + SZ(c)));}}; // namespace linear_seqint main() { while (~scanf(&quot;%lld&quot;, &amp;n) &amp;&amp; n != -1) { vector&lt;ll&gt;v; v.push_back(0); v.push_back(1); v.push_back(1); v.push_back(2); v.push_back(3); v.push_back(5); v.push_back(8); v.push_back(13); v.push_back(21); v.push_back(34); printf(&quot;%lld\\n&quot;, linear_seq::gao(v, n)); } return 0;}","link":"/2020/05/11/%E6%9D%9C%E6%95%99BM%E6%A8%A1%E6%9D%BF/"},{"title":"C++内存管理","text":"内存管理内存管理详解内存分配方式在C++中，内存分为5个区： 栈：执行函数时，函数内部局部变量存储单元在栈上创建，结束时自动释放。效率很高，但存储容量有限。 堆：由new分配的内存块，编译起器不会自动释放，需要delete进行释放。如果没有释放，则程序运行结束后会由操作系统自动回收。 自由存储区：由malloc等分配的内存块，类似堆，由free结束自己的生命。 全局/静态存储区：存储全局变量和静态变量。 常量存储区：存放常量，不允许修改。 明确区分堆和栈123void f() { int* p = new int[5];} 在栈内存中存放了一个指向一块堆内存的指针p。程序会先确定在堆中分配内存的大小，然后调用 operator new 分配内存，然后返回这块内存的首地址，放入栈中。 汇编代码如下：12345600401028 push 14h 0040102A call operator new (00401060) 0040102F add esp,4 00401032 mov dword ptr [ebp-8],eax 00401035 mov eax,dword ptr [ebp-8] 00401038 mov dword ptr [ebp-4],eax这里并没有释放内存，因此需要 delete[] p，告诉编译器删除的是数组，然后编译器根据Cookie信息去释放内存。 堆和栈的区别 管理方式：栈由编译器自动管理，无需手动控制；堆释放工作由程序员控制，容易产生内存泄露。 空间大小：堆内存一般不超过系统内存都是可以申请的，栈内存默认为8M（个人测试）。 碎片问题：对于堆而言，频繁的new/delete势必会造成内存空间的不连续，造成大量的碎片，使程序的效率降低；对于栈而言，则不会发生这样的情况，先进后出，以至于永远不可能有一个内存块从非栈顶位置弹出。 生长方向：对于堆而言，生长方向向上，向着内存地址增加的方向增长；对于栈而言，生长方向向下，向着内存地址减小的方向增长。 分配方式：堆都是动态分配的，没有静态分配的堆。栈有动态分配和静态分配两种，静态分配由编译器完成，比如局部变量的分配；动态分配由alloc函数进行分配，都由编译器进行释放。 分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是 C/C++ 函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。 从这里我们可以看到，堆和栈相比，由于大量 new/delete 的使用，容易造成大量的内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址，EBP 和局部变量都采用栈的方式存放。所以，尽量使用栈，而不是用堆。 虽然栈有如此多的好处，但和堆相比并不灵活。如果需要分配大量内存空间，还是堆好一些。 重载全局的new和delete操作123456789void * operator new(size_t size) { void *p = malloc(size); return (p); } void operator delete(void *p); { free(p); } 也可以对单个类的 new 和 delete 操作符重载。 123456789101112131415class TestClass { public: void * operator new(size_t size); void operator delete(void *p); // .. other members here ... }; void *TestClass::operator new(size_t size) { void *p = malloc(size); // Replace this with alternative allocator return (p); } void TestClass::operator delete(void *p) { free(p); // Replace this with alternative de-allocator} C++将对象数组的内存分配作为一个单独的操作，而不同于单个对象的内存分配。为了改变这种方式，你同样需要重载 new[] 和 delete[]操作符。 123456789101112131415161718192021class TestClass { public: void * operator new[ ](size_t size); void operator delete[ ](void *p); // .. other members here .. }; void *TestClass::operator new[ ](size_t size) { void *p = malloc(size); return (p); } void TestClass::operator delete[ ](void *p) { free(p); } int main(void) { TestClass *p = new TestClass[10]; // ... etc ... delete[ ] p; } PS：对于多数 C++ 的实现，new[]操作符中的个数参数是数组的大小加上额外的存储对象数目的一些字节。因此应该尽量避免分配对象数组，使内存分配策略简单。 常见的内存错误 内存分配未成功，却使用了它。如果是用 malloc 或 new 来申请内存，应该用 if(p==NULL) 或 if(p!=NULL)进行防错处理。如果指针 p 是函数的参数，那么在函数的入口处用 assert(p!=NULL) 进行。 内存分配虽然成功，但未初始化就引用它。无论用何种方式创建数组，都要赋初值，即便是零值。 内存分配成功并且已经初始化，但操作越界。多发生在下标“多1”或“少1”。 忘记了释放内存，造成内存泄漏。动态内存的申请与释放必须配对，程序中malloc与free的使用次数一定要相同，否则肯定有错误（new/delete同理）。 释放了内存却继续使用它。 程序过于复杂，难以分清是否释放了内存，此时应当重新设计数据结构，解决混乱。 return语句写错，不要返回指向“栈内存”的指针或引用，因为该内存在函数体结束时被自动销毁。 free或delete释放内存后，没有将指针设为NULL，导致“野指针”。 指针与数组对比数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。数组名对应着（而不是指向）一块内存，其地址和容量在生命周期内保持不变，只有数组的内容可以改变。 指针可以随时指向任何类型的内存块，它的特征是“可变”的，所以常用指针来操作动态内存，指针远比数组灵活，但也更危险。 修改数组内容123456char a[] = “hello”; a[0] = ‘X’; cout &lt;&lt; a &lt;&lt; endl; char *p = “world”; // 注意 p 指向常量字符串p[0] = ‘X’; // 编译器不能发现该错误cout &lt;&lt; p &lt;&lt; endl;","link":"/2020/11/02/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"title":"杭电多校：Tree","text":"题目给定一颗树，路径只能由父节点指向子节点，你可以增加一条有向边，使得联通点对最多。 Solution容易发现，当叶子结点往根结点连一条边时，增加的点对会是最多的。$dp1[i]$ 表示从 $i$ 结点出发可以到达多少点，$dp2[i]$ 表示当前以 $i$ 为根结点，能增加的最大点对数（最大值）。 对于 $dp1[i]$，状态转移方程：$dp1[fa] += dp1[son]$。 对于 $dp2[i]$，状态转移方程：$ for All(son): dp2[fa] = max(dp2[fa], dp2[son]), dp2[fa] += n - dp1[fa]$。 $sum(dp1)$ 即为不加边的点对数和，$dp2[1]$ 得到的即为增加一条边能增加的最大点对数。 Code123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6 + 5;vector&lt;int&gt; g[N];int t, n;long long res, dp1[N], dp2[N];void dfs(int u, int fa) { dp1[u] = 1; for (auto v : g[u]) { if (v == fa) continue; dfs(v, u); dp2[u] = max(dp2[u], dp2[v]); dp1[u] += dp1[v]; } dp2[u] += n - dp1[u];}int main() { scanf(&quot;%d&quot;, &amp;t); while (t--) { scanf(&quot;%d&quot;, &amp;n); res = 0; for (int i = 0; i &lt;= n; i++) { g[i].clear(); dp1[i] = 0; dp2[i] = 0; } for (int i = 2; i &lt;= n; i++) { int x; scanf(&quot;%d&quot;, &amp;x); g[x].push_back(i); } dfs(1, -1); for (int i = 1; i &lt;= n; i++) res += dp1[i]; printf(&quot;%lld\\n&quot;, res + dp2[1]); } return 0;}","link":"/2020/08/18/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%EF%BC%9ATree/"},{"title":"树状数组经典题","text":"一个简单的整数问题题目第一类指令形如 “C-l-r-d”，表示把数列中第 $l-r$ 个数都加 $d$。 第二类指令形如 “Q-X”，表示询问数列中第 $x$ 个数的值。 对于每个询问，输出一个整数表示答案。 数据范围：$(n, m \\in [1, 100000])$ Solution用树状数组解决动态差分问题。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e5 + 5;typedef long long ll;int n, m;ll c[N], a[N];int lowbit(int x) { return x &amp; (-x);}void add(int x, int y) { while (x &lt;= n) { c[x] += y; x += lowbit(x); }}ll query(int x) { ll sum = 0; while (x &gt;= 1) { sum += c[x]; x -= lowbit(x); } return sum;}int main(){ cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; while (m--) { string s; int x, y, z; cin &gt;&gt; s; if (s == &quot;Q&quot;) { cin &gt;&gt; x; cout &lt;&lt; query(x) + a[x] &lt;&lt; endl; } else { cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; add(x, z); add(y + 1, -z); } } return 0;} 谜一样的牛题目给定序列长度 $n$ 和 数组 $a$，$a[i]$ 表示第 $i$ 个数前面有多少个数比它小，复原原序列，原序列为 $1-n$ 的排列。$(n \\in [1, 100000])$ Solution最后一个数的大小明显是一开始就可以推断出来的，假设其大小是 $x$，接着从 $1-n$ 这 $n$ 个数字中把 $x$ 删掉，然后再看倒数第二个数，假设其前面有 $y$ 个数比它小，说明这个数是剩下的数里面第 $y + 1$ 大的数。 由此可以发现，我们可以倒推过来，第 $i$ 个数的大小便是当前还没有被选的数中第 $a[i] + 1$ 小的数。 可以使用树状数组解决，将每个位置置为 $1$ 表示未被选，$0$ 表示已被选，得到的前缀和是单调递增的，因此每次只需要二分查找满足前缀和刚好等于 $a[i] + 1$ 的位置即为当前数的大小。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5;int n, c[N], a[N], res[N];int lowbit(int x) { return x &amp; (-x);}void add(int x, int y) { while (x &lt;= n) { c[x] += y; x += lowbit(x); }}int query(int x) { int sum = 0; while (x &gt;= 1) { sum += c[x]; x -= lowbit(x); } return sum;}int main(){ cin &gt;&gt; n; add(1, 1); for (int i = 2; i &lt;= n; i++) { cin &gt;&gt; a[i]; add(i, 1); } for (int i = n; i &gt;= 1; i--) { int l = 0, r = n + 1, mid; while (l + 1 &lt; r) { mid = l + r &gt;&gt; 1; if (query(mid) &lt; a[i] + 1) l = mid; else r = mid; } res[i] = r; add(r, -1); } for (int i = 1; i &lt;= n; i++) cout &lt;&lt; res[i] &lt;&lt; endl; return 0;}","link":"/2020/10/30/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%BB%8F%E5%85%B8%E9%A2%98/"},{"title":"每日一题：Accumulation Degree","text":"题意给定一棵n个节点的树，边权值视作流量，找到一个源点使得从该点出发到所有叶子节点流量和最大。 思路：我们先考虑这样一道题：指定一点使得到树上其他点的深度之和最小。 这显然是树的重心的性质：树中所有点到某个点的距离和中，到重心的距离和是最小的，如果有两个重心，他们的距离和一样。我们先假设这棵树的根为1，进行一次dfs，可以求出每个点的深度 $dep[i]$ 和子树大小 $size[i]$ ，设某点作为根深度之和为 $f$( i )，显然：$f(1)$ = $\\sum_{i=1}^{n}{dep[i]}$。 当根从 $u$ 转移到子节点 $v$ 时，以 $v$ 为根的子树内所有节点 $dep$ 都减1，其余节点加1。从而得到状态转移方程：$f[v] = f[u] - size[v] + (n - size[v]) = f[u] + n - 2 * size[v]$，答案取最小值即可，时间复杂度 $O (n)$ 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e6 + 5;int n, res, idx, h[N], dep[N], size[N];long long f[N];struct Node { int to, next;} E[N];void add(int a, int b) { E[idx].to = b, E[idx].next = h[a], h[a] = idx++; }void dfs1(int u, int fa) { size[u] = 1; dep[u] = dep[fa] + 1; for (int i = h[u]; ~i; i = E[i].next) { int v = E[i].to; if (v == fa) continue; dfs1(v, u); size[u] += size[v]; }}void dfs2(int u, int fa) { for (int i = h[u]; ~i; i = E[i].next) { int v = E[i].to; if (v == fa) continue; f[v] = f[u] + n - 2LL * size[v]; dfs2(v, u); }}int main() { memset(h, -1, sizeof(h)); cin &gt;&gt; n; for (int i = 1; i &lt; n; i++) { int x, y; cin &gt;&gt; x &gt;&gt; y; add(x, y); add(y, x); } dep[0] = -1; dfs1(1, 0); for (int i = 1; i &lt;= n; i++) f[1] += dep[i]; dfs2(1, 0); long long sum = 0x3ffffffffffff; for (int i = 1; i &lt;= n; i++) { if (sum &gt; f[i]) { sum = f[i]; res = i; } } cout &lt;&lt; sum &lt;&lt; '\\n'; return 0;} 现在我们回过头来看这道题，可以发现思路都大同小异，只是转移方程发生了变化。 定义 $flow[i]表示以 i 为根的子树中流量的最大值$，那么，当节点从 $u$ 转移到 $v$ 时，我们可以得到： 当 $v$ 为叶子结点，则 $flow[u] += flow[v]$ ； 当 $u$ 为非叶子结点，则 $flow[u] = min(flow[v], fl(u, v))$ $(fl(u, v) 即u, v两点间的流量限制)$ 。 这样，根为1时的 $flow[1]$ 就求出来了。 接下来考虑根节点的转移：从以 $u$ 为根节点转移为以 $v$ 为根节点，对于根节点 $v$ 而言，唯一会产生影响的就是 $v$ 流向 $u$ 的路径，也就是对于换根后所有用到这条边的路径，都要加上这条流量的限制，则状态转移方程为： 当 $u$ 为叶子节点时，$f[v] += fl(u, v)$ ; 当 $v$ 为非叶子结点时，$f[v] += min(fl(u, v), flow[u] - min(flow[v], fl(u, v)))$ 。 进行两次dfs即可，时间复杂度 $O(n)$。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5;int t, n, res, idx, h[N], d[N], f[N];struct Node { int to, w, next;} E[N &lt;&lt; 1];void add(int a, int b, int c) { E[idx].to = b, E[idx].w = c, E[idx].next = h[a], h[a] = idx++;}void dfs1(int u, int fa) { for (int i = h[u]; ~i; i = E[i].next) { int v = E[i].to, w = E[i].w; if (v == fa) continue; dfs1(v, u); if (d[v] == 1) f[u] += w; else f[u] += min(f[v], w); }}void dfs2(int u, int fa) { for (int i = h[u]; ~i; i = E[i].next) { int v = E[i].to, w = E[i].w; if (v == fa) continue; if (d[u] == 1) f[v] += w; else f[v] += min(w, f[u] - min(f[v], w)); dfs2(v, u); }}int main() { cin &gt;&gt; t; while (t--) { idx = 0; memset(h, -1, sizeof(h)); memset(d, 0, sizeof(d)); memset(f, 0, sizeof(f)); cin &gt;&gt; n; for (int i = 1; i &lt; n; i++) { int x, y, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; add(x, y, z); add(y, x, z); d[x]++; d[y]++; } dfs1(1, 0); dfs2(1, 0); res = 0; for (int i = 1; i &lt;= n; i++) res = max(res, f[i]); cout &lt;&lt; res &lt;&lt; '\\n'; } return 0;} 总结对于换根dp，一般有两个步骤： 默认1为根进行dfs预处理； 从1开始，进行根的转移，计算贡献变化。 对于dp而言，状态转移方程是最重要的，需要多思考，多刷题，才能累积经验，掌握要点。","link":"/2020/04/18/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AAccumulation-Degree/"},{"title":"每日一题：Arithmetic Progressions","text":"题目从给定数列中能选出组成的最长等差数列长度为多少？$(n \\in [1, 5000], a[i] \\in [1, 1e9])$ Solution$dp[i][j]$ 表示 $a[i]$ 为等差数列最后一个数，$a[j]$ 为倒数第二个数。 排序后二维枚举 $i$ 和 $j$，二分找到对应的下标 $k$ 使得 $a[k]+a[i]=2*a[j]$ ，直接转移 $dp[i][j] = max(dp[i][j], dp[j][k] + 1)$。 Code1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int n, res, a[5005], dp[5005][5005];int main() { cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; sort(a, a + n); for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; i; j++) { int k = lower_bound(a, a + n, a[j] * 2 - a[i]) - a; if (a[k] == a[j] * 2 - a[i]) dp[i][j] = max(dp[i][j], dp[j][k] + 1); res = max(res, dp[i][j]); } } cout &lt;&lt; res + 2 &lt;&lt; endl; return 0;}","link":"/2020/10/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AArithmetic-Progressions/"},{"title":"每日一题：Assassin’s Creed","text":"题目有 $n$ 个敌人，你现在的武器的耐久度为 $m$,杀每个敌人要消耗 $a_i$ 点耐久度，同时得到可以再杀死 $b_i$ 个人的权利。问最多可以杀死多少人，在杀人最多的情况下最少要消耗多少耐久度？ Solution首先会想到对人进行分类，一类是 $b_i$ 为 $0$ 的，一类是 $b_i$ 不为 $0$ 的。 杀死一个 $b_i$ 不为 $0$ 的，一定能杀死所有 $b_i$ 不为 $0$ 的，而且还能再额外杀死 $b_i$ 为 $0$ 的，显然只要杀 $a_i$ 最小的那个人即可。 分两种情况： 只杀 $b_i$ 为 $0$ 的，可能原因：没有 $b_i$ 不为 $0$ 的，或者耐久度不够，或者消耗耐久度过大，还不如直接杀 $b_i$ 为 $0$ 来的划算。 杀一个 $b_i$ 不为 $0$的，且消耗耐久度最小的，那么所有的 $b_i$ 不为 $0$ 都将被杀死，额外的免费杀人机会都拿来杀 $b_i$ 为 $0$ 的，用剩下的耐久度从小到大杀剩下的怪即可。但这样有缺陷，可能存在手动杀 $b_i$ 不为 $0$ 的人会更划算，因为这个怪可能消耗的耐久度非常小，而你用这次机会杀 $b_i$ 为 $0$ 的人可能消耗非常大。于是得出结论：所有 $b_i$ 不为 $0$ 的人肯定会被杀死，但我只要把所有的怪按耐久度从小到大杀即可。 两种情况取最大值即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; g1, g2, g3;int main() { int t, n, m, x, y, c = 0; scanf(&quot;%d&quot;, &amp;t); while (t--) { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); g1.clear(); g2.clear(); g3.clear(); int sum = 0; for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d%d&quot;, &amp;x, &amp;y); if (y) g1.push_back(x); else g2.push_back(x); sum+=y; } sort(g1.begin(), g1.end()); sort(g2.begin(), g2.end()); int cost1 = 0, cost2 = 0, num1 = 0, num2 = 0; for (int i = 0; i &lt; g2.size(); i++) { if (cost1 + g2[i] &gt; m) break; cost1 += g2[i]; num1++; } if (g2.size() == n || m &lt; g1[0]) printf(&quot;Case %d: %d %d\\n&quot;, ++c, num1, cost1); else { cost2 = g1[0]; sum++; num2 = min(sum, n); for (int i = 0; i &lt; g2.size(); i++) g3.push_back(g2[i]); for (int i = 1; i &lt; g1.size(); i++) g3.push_back(g1[i]); sort(g3.begin(), g3.end()); for (int i = 0; i &lt; g3.size(); i++) { if (num2 &gt;= n || cost2 + g3[i] &gt; m) break; cost2 += g3[i]; num2++; } if (num1 &gt; num2 || num1 == num2 &amp;&amp; cost1 &lt; cost2) printf(&quot;Case %d: %d %d\\n&quot;, ++c, num1, cost1); else printf(&quot;Case %d: %d %d\\n&quot;, ++c, num2, cost2); } } return 0;}","link":"/2020/08/28/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AAssassin%E2%80%99s-Creed/"},{"title":"每日一题: Best Cow Fences(二分)","text":"题意给定一个正整数数列A，求一个平均数最大的、长度不小于L的子段。 solution考虑check问题，正着枚举起点，我们需要知道每个起点所能枚举的最大值。当一个数大于当前二分的平均数时，它一定是对答案有贡献的，因此倒过来预处理每个起点能枚举到的最大值即可。时间复杂度 $O(nlogn)$。 Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 2e5 + 5;ll n, k;double a[N], sum[N], pre[N];bool check(double avg) { pre[n + 1] = 0; for (ll i = n; i &gt;= 1; i--) pre[i] = max(a[i] - avg, pre[i + 1] + a[i] - avg); for (ll i = 0; i &lt;= n - k; i++) { if (sum[i + k] - sum[i] &gt;= k * avg) return true; if (sum[i + k] - sum[i] + pre[i + k + 1] &gt;= k * avg) return true; } return false;}int main() { while (~scanf(&quot;%lld%lld&quot;, &amp;n, &amp;k)) { double l = 1e18 + 7, r = 0, mid; for (ll i = 1; i &lt;= n; i++) { scanf(&quot;%lf&quot;, &amp;a[i]); l = min(l, a[i]); r = max(r, a[i]); sum[i] = sum[i - 1] + a[i]; } while (r - l &gt; 0.0001) { mid = (l + r) / 2.0; if (check(mid)) l = mid; else r = mid; } printf(&quot;%lld\\n&quot;, (ll)(l + 0.5)); } return 0;}","link":"/2020/04/29/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9ABest-Cow-Fences%EF%BC%88%E4%BA%8C%E5%88%86%EF%BC%89/"},{"title":"每日一题：Contest （树状数组）","text":"题意 $n$ 支队伍一共参加了三场比赛。一支队伍 $x$ 认为自己比另一支队伍 $y$ 强当且仅当 $x$ 在至少一场比赛中比 $y$ 的排名高。求有多少组 $(x,y)$，使得 $x$ 自己觉得比 $y$ 强，$y$ 自己也觉得比 $x$ 强，$(x, y)$, $(y, x)$算一组。 solution若 $x$ 和 $y$ 都互相认为更强，那么必定存在两场，一场 $x$ 强于 $y$，一场 $y$ 强于 $x$，那么就是对于任意两场求逆序数，最后的答案需要除以2，因为如果两队互认为更强，必定存在 $x$ 有两场更强，或者 $y$ 有两场更强，那么计算逆序数时就多计算了一次。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll N = 2e5 + 5;ll n, res, t[N];struct Node { ll a, b, c;} q[N];bool cmpa(Node x, Node y) { return x.a &lt; y.a; }bool cmpb(Node x, Node y) { return x.b &lt; y.b; }void add(ll x) { while (x &lt;= n) { t[x]++; x += x &amp; -x; }}ll query(ll x) { ll sum = 0; while (x) { sum += t[x]; x -= x &amp; -x; } return sum;}int main() { cin &gt;&gt; n; for (ll i = 1; i &lt;= n; i++) cin &gt;&gt; q[i].a &gt;&gt; q[i].b &gt;&gt; q[i].c; sort(q + 1, q + n + 1, cmpa); for (ll i = 1; i &lt;= n; i++) { add(q[i].b); res += i - query(q[i].b); } memset(t, 0, sizeof(t)); for (ll i = 1; i &lt;= n; i++) { add(q[i].c); res += i - query(q[i].c); } sort(q + 1, q + n + 1, cmpb); memset(t, 0, sizeof(t)); for (ll i = 1; i &lt;= n; i++) { add(q[i].c); res += i - query(q[i].c); } cout &lt;&lt; res / 2 &lt;&lt; '\\n'; return 0;}","link":"/2020/06/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AContest-%EF%BC%88%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%EF%BC%89/"},{"title":"每日一题：Different Integers（树状数组&#x2F;莫队）","text":"题意给定长度为 $n$ 的数组，$q$ 次询问 $[1,l]+[r,n]$ 组成的新数组中不相同的元素个数。$(1&lt;=n,q&lt;=1e5)$ solution1一眼莫队题，主要是要想怎么样把它变成一个连续的区间。其实只要把整个数组再复制一遍接上就可以了，则原来查询的 $r$ 变为 $l$，$l$ 变为 $l+n$，区间连续。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 1812 ms#include &lt;bits/stdc++.h&gt;#pragma GCC optimize(2)using namespace std;const int N = 2e5 + 5;struct Node { int l, r, id;} node[N];int n, q, blocks, a[N], b[N], ans[N];bool cmp(Node a, Node b) { if (a.l / blocks == b.l / blocks) return a.r &lt; b.r; return a.l &lt; b.l;}int main() { while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;q)) { for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;a[i]); a[i + n] = a[i]; } memset(b, 0, sizeof(b)); blocks = sqrt(2 * n); for (int i = 1; i &lt;= q; i++) { scanf(&quot;%d%d&quot;, &amp;node[i].r, &amp;node[i].l); node[i].r += n; node[i].id = i; } sort(node + 1, node + q + 1, cmp); int l = 1, r = 0, num = 0; for (int i = 1; i &lt;= q; i++) { while (l &lt; node[i].l) num -= !--b[a[l++]]; while (l &gt; node[i].l) num += !b[a[--l]]++; while (r &lt; node[i].r) num += !b[a[++r]]++; while (r &gt; node[i].r) num -= !--b[a[r--]]; ans[node[i].id] = num; } for (int i = 1; i &lt;= q; i++) printf(&quot;%d\\n&quot;, ans[i]); } return 0;} solution2同样是复制一遍，然后考虑树状数组+离线处理。我们需要保证之前的更新不会对当前的查询构成干扰，可以对查询按照右端点从小到大排序，然后把当前的数更新到当前位置，删除之前的位置，这样保证数是跟排序后的查询一样是从左往右流动的。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 702 ms#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5;int n, q, a[N], b[N], c[N], ans[N];struct Node { int l, r, id;} node[N];bool cmp(Node x, Node y) { return x.r &lt; y.r; }void update(int x, int y) { for (; x &lt;= n; x += x &amp; (-x)) c[x] += y;}int query(int x) { int sum = 0; for (; x &gt;= 1; x -= x &amp; (-x)) sum += c[x]; return sum;}int main() { while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;q)) { for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;a[i]); a[i + n] = a[i]; } memset(b, 0, sizeof(b)); memset(c, 0, sizeof(c)); for (int i = 1; i &lt;= q; i++) { scanf(&quot;%d%d&quot;, &amp;node[i].r, &amp;node[i].l); node[i].r += n; node[i].id = i; } sort(node + 1, node + q + 1, cmp); n &lt;&lt;= 1; int pre = 1; for (int i = 1; i &lt;= q; i++) { for (int j = pre; j &lt;= node[i].r; j++) { if (b[a[j]]) update(b[a[j]], -1); b[a[j]] = j; update(b[a[j]], 1); } pre = node[i].r + 1; ans[node[i].id] = query(node[i].r) - query(node[i].l - 1); } for (int i = 1; i &lt;= q; i++) printf(&quot;%d\\n&quot;, ans[i]); } return 0;}","link":"/2020/05/03/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9ADifferent-Integers%EF%BC%88%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-%E8%8E%AB%E9%98%9F%EF%BC%89/"},{"title":"每日一题：Functions again","text":"题意 给定数组，求上述式子的最大值。 Solution可以看出，上述式子是交替加减求最大子段和。预处理两项差的绝对值，那么只需要枚举起点是奇数位置还是偶数位置就可以了，根据贪心原则，起点肯定选正数，然后交替正负就好了，这样问题就转化成就求最大子段和了，贪心即可。 Code123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5;typedef long long ll;int n;ll a[N], b[N], d[N]; ll solve(ll c[]) { ll now = 0, ma = 0; for (int i = 2; i &lt;= n; i++) { if (now &lt;= 0) now = c[i]; else now += c[i]; ma = max(ma, now); } return ma;} int main() { cin &gt;&gt; n &gt;&gt; a[1]; for (int i = 2; i &lt;= n; i++) { cin &gt;&gt; a[i]; ll x = llabs(a[i] - a[i - 1]); if (i &amp; 1) b[i] = -x; else b[i] = x; d[i] = -b[i]; } cout &lt;&lt; max(solve(b), solve(d)) &lt;&lt; endl; return 0;}","link":"/2020/08/10/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AFunctions-again/"},{"title":"每日一题：Game Strategy","text":"题意三个人玩游戏，每个人最开始都有 $n$ 个数，开始轮流删数，直到最后每个人只剩下一个数。第一个人想让这三个数的和（$x+y+z$）加起来尽量大，第二个想尽量小，第三个想尽量接近0。每个人都以自己的想法为策略，问最后得到的三个数的和是多少（$n&lt;=100$）。 solution不要想复杂了，其实就是直接模拟。暴力枚举三个数，因为第三个人想尽量接近 0，因此枚举 $z$ 时维护最接近 0 的解 $m1$，因为第二个人想要最小值，因此取枚举所有 $z$ 得到的解（$m1$）的最小值$m2$，然后第一个人想要最大值，所以取枚举所有 $y$ （$m2$）的最大值 $m3$。 Code123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3fffffff;int main() { int n, a[105], b[105], c[105], d[105]; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; for (int i = 0; i &lt; n; i++) cin &gt;&gt; b[i]; for (int i = 0; i &lt; n; i++) cin &gt;&gt; c[i]; int m1 = -INF, m2, m3; for (int i = 0; i &lt; n; i++) { m2 = INF; for (int j = 0; j &lt; n; j++) { for (int k = 0; k &lt; n; k++) d[k] = a[i] + b[j] + c[k]; sort(d, d + n); int pos = lower_bound(d, d + n, 0) - d; if (pos == n) m3 = d[pos - 1]; else if (pos == 0) m3 = d[0]; else { if (d[pos] &gt; -d[pos - 1]) m3 = d[pos - 1]; else m3 = d[pos]; } m2 = min(m2, m3); } m1 = max(m1, m2); } cout &lt;&lt; m1 &lt;&lt; '\\n'; return 0;}","link":"/2020/04/26/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AGame-Strategy/"},{"title":"每日一题：K-th Number","text":"题意给定一个长度为 $n$ 的数组 A ，把所有长度 &gt;= $k$ 的区间中的第 $k$ 大值插入 B 数组中，求 B 数组的第 $m$ 大数。 Solution这种显然二分答案题我们主要关心 $check$ 问题。 如何计算第 $k$ 大数 $&gt;= mid$ 的区间个数？ 假设区间 $[l, r]$ 中刚好有 $k$ 个数 $&gt;= mid$，则 $[l, r…n]$ 区间全部满足第 $k$ 大数 $&gt;= mid$。 因此考虑尺取，若当前区间满足 $k$ 个数 $=mid$，则计数 $cnt += n - r + 1$，同时移动左边界；否则移动右边界直至。。。当 $cnt &gt;= m$ 时，说明 $mid$ 过小，调整左边界，否则调整右边界。 Code123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;int t, n, k, a[100005];long long m;bool check(int x) { int l = 1, r = 0, cnt = 0; long long sum = 0; while (r &lt;= n) { if (cnt == k) { sum += (n - r + 1LL); cnt -= (a[l++] &gt;= x); } else cnt += (a[++r] &gt;= x); } return sum &gt;= m;}int main() { cin &gt;&gt; t; while (t--) { cin &gt;&gt; n &gt;&gt; k &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; int l = 0, r = 1e9 + 7, mid; while (l + 1 &lt; r) { int mid = (l + r) &gt;&gt; 1; if (check(mid)) l = mid; else r = mid; } cout &lt;&lt; l &lt;&lt; '\\n'; } return 0;}","link":"/2020/04/21/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AK-th-Number/"},{"title":"每日一题：Medians and Partition","text":"题意最多可以把数组分成几个部分，使得每部分中位数都大于等于$m$。$(n,m,a[i] \\in [1,5000])$ Solution思维题，可以发现答案就是大于等于 $m$ 的个数减去小于 $m$ 的个数。 Code12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int n, m, x, s1 = 0, s2 = 0; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; x; if (x &gt;= m) s1++; else s2++; } cout &lt;&lt; max(0, s1 - s1); return 0;}","link":"/2020/10/02/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AMedians-and-Partition/"},{"title":"每日一题：Moovie Mooving （状压dp）","text":"题意有 N 部电影，每部电影有不同的放映时常，和若干个放映起始时间。Bessie 可以在一部电影播放过程中的任何时间进入或退出放映厅。每部电影她最多看1次且她不能在看一部电影的过程中，换到另一个正在播放相同电影的放映厅。 Bessie 能不能从0到L分钟连续不断地观看电影？如果能，计算她最少看几部电影。 $(1 \\leq L \\leq 100,000,000，1\\leq N\\leq 201≤L≤100,000,000，1≤N≤20)$ solution$n$ 只有20考虑状压dp，$dp[i]$ 表示完成 $i$ 集合需要的最长时间，假设 $i$ 集合最后看的一部电影为 $j$，那么 $dp[i]$ 由 dp[i ^ (2^j)] 转移过来，并二分选取小于转移前集合的电影 $j$ 的最晚放映时间来更新 $p[i]$，同时维护 $dp[i] &gt;=l $ 的最小集合为答案。时间复杂度 $O(2^n*log(1000))$ Code1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 22;int n, l, t[N], dp[1 &lt;&lt; N];vector&lt;int&gt; g[N];int main() { cin &gt;&gt; n &gt;&gt; l; for (int i = 0; i &lt; n; i++) { int c, x; cin &gt;&gt; t[i] &gt;&gt; c; while (c--) { cin &gt;&gt; x; g[i].push_back(x); } g[i].push_back(l); } int res = n + 1; for (int i = 1; i &lt; (1 &lt;&lt; n); i++) { for (int j = 0; j &lt; n; j++) { if ((i &gt;&gt; j) &amp; 1) { int now = i ^ (1 &lt;&lt; j); int pos = upper_bound(g[j].begin(), g[j].end(), dp[now]) - g[j].begin() - 1; if (pos &gt;= 0 &amp;&amp; g[j][pos] + t[j] &gt; dp[now]) dp[i] = max(dp[i], g[j][pos] + t[j]); } } if (dp[i] &gt;= l) res = min(res, __builtin_popcount(i)); } if (res == n + 1) puts(&quot;-1&quot;); else cout &lt;&lt; res &lt;&lt; '\\n'; return 0;}","link":"/2020/05/15/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AMoovie-Mooving-%EF%BC%88%E7%8A%B6%E5%8E%8Bdp%EF%BC%89/"},{"title":"每日一题：Optimal Sum","text":"题目给你长度为 $n$ 的序列，你有一种能力可以将序列中的任意一个数变为相反数，在你不超过 $k$ 次使用能力的情况下，长度为 $len$ 的子区间的和的绝对值的最大值是多少？ Solution用两个multiset维护区间前k大的负数，扫一遍就好了，细节略多。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n, len, k;ll x1, x2, a[200005];ll solve() { ll sum = 0, ma = -1e18; multiset&lt;ll&gt; s1, s2; for (int i = 1; i &lt;= n; i++) { if (a[i] &gt;= 0) sum += a[i]; else if (s1.size() &lt; k) { s1.insert(a[i]); sum -= a[i]; } else if (k &amp;&amp; a[i] &lt; *(--s1.end())) { ll x = *(--s1.end()); sum += 2 * x; s1.erase(--s1.end()); s2.insert(x); s1.insert(a[i]); sum -= a[i]; } else { s2.insert(a[i]); sum += a[i]; } int j = i - len; if (j &gt; 0) { if (a[j] &gt;= 0) sum -= a[j]; else if (s1.find(a[j]) != s1.end()) { s1.erase(s1.find(a[j])); sum += a[j]; if (s2.size() &gt; 0) { ll x = *(s2.begin()); s1.insert(x); s2.erase(s2.begin()); sum -= 2 * x; } } else { s2.erase(s2.find(a[j])); sum -= a[j]; } } if (j &gt;= 0) ma = max(ma, sum); } return ma;}int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;len); for (int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;a[i]); scanf(&quot;%d&quot;, &amp;k); x1 = solve(); for (int i = 1; i &lt;= n; i++) a[i] = -a[i]; x2 = solve(); printf(&quot;%lld\\n&quot;, max(x1, x2)); return 0;}","link":"/2020/08/17/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AOptimal-Sum/"},{"title":"每日一题：Playing Tag on Tree","text":"题意给定一棵树，A 在 $x$ 点，B 在 $y$ 点，B 追 A，两人每次可以往相邻点移动，A 先跑，问 A 最晚什么时候被追上。 Solution结论：找到一个点，满足 $dis_B &gt; dis_A$ 且 $dis_B$ 最大，即为最终落脚点。 因为直观上来说，明显最后的点离 B 越远越好，但这个点可能离 A 更远，因此需要满足 $dis_B &gt; dis_A$。 Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 5;int dis[2][N];vector&lt;int&gt; g[N];void bfs(int be, int id) { queue&lt;int&gt; q; q.push(be); dis[id][be] = 1; while (!q.empty()) { int u = q.front(); q.pop(); for (auto v : g[u]) { if (!dis[id][v]) { dis[id][v] = dis[id][u] + 1; q.push(v); } } }}int main() { int n, x, y, u, v, res = 0; cin &gt;&gt; n &gt;&gt; x &gt;&gt; y; for (int i = 1; i &lt; n; i++) { cin &gt;&gt; u &gt;&gt; v; g[u].push_back(v); g[v].push_back(u); } bfs(x, 0); bfs(y, 1); for (int i = 1; i &lt;= n; i++) { if (dis[0][i] &lt; dis[1][i]) res = max(res, dis[1][i] - 2); } cout &lt;&lt; res &lt;&lt; endl; return 0;}","link":"/2020/08/30/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9APlaying-Tag-on-Tree/"},{"title":"每日一题：Protecting the Flower （贪心）","text":"题意一共有 $n$ 只牛在花坛旁边，第 $i$ 头牛每分钟破坏 $d_i$ 朵花，把第i头牛带回牛棚需要 $2 \\times ti$ 这么多时间，每次只能带回一头牛，请问怎样能使得被破坏的花最少。 solution以小化大，先考虑两头牛，先领 $a$ ，损失为：$2\\times{t_a}\\times{d_b}$，先领 $b$，损失为 $2\\times{t_b}\\times{d_a}$，故得到排序条件 ${a_t \\times {b_d} &lt; b_t \\times {a_d}}$，最后模拟得出答案。 Code12345678910111213141516171819#include &lt;bits/stdc++.h&gt;#define x first#define y second#define PI pair&lt;int, int&gt;#define ll long longusing namespace std;ll n, sum, res;pair&lt;int, int&gt; p[200005];int main() { cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; p[i].x &gt;&gt; p[i].y; sort(p + 1, p + n + 1, [](PI a, PI b) { return a.x * b.y &lt; b.x * a.y; }); for (int i = 1; i &lt;= n; i++) { res += sum * p[i].y; sum += p[i].x * 2; } cout &lt;&lt; res &lt;&lt; '\\n'; return 0;}","link":"/2020/05/29/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AProtecting-the-Flower-%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%89/"},{"title":"每日一题：Treepath","text":"题意：给定一棵n个节点的树，求偶数长度路径的数量。 Solution1:考虑树的深度对距离的影响，可以发现，深度奇偶性相同的点之间的距离总是偶数。 证明：我们先将深度更大的点走到和另一个点深度相同，显然需要偶数步，然后两个点同时移动到最近公共节点，可知所用的步数是相同的，加起来也是偶数。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5;int n, idx, h[N], dep[N];struct Node { int to, next;} E[N];void add(int a, int b) { E[idx].to = b, E[idx].next = h[a], h[a] = idx++; }void dfs(int u, int fa) { dep[u] = dep[fa] + 1; for (int i = h[u]; ~i; i = E[i].next) { int v = E[i].to; if (v == fa) continue; dfs(v, u); }}int main() { memset(h, -1, sizeof(h)); cin &gt;&gt; n; for (int i = 1; i &lt; n; i++) { int x, y; cin &gt;&gt; x &gt;&gt; y; add(x, y); add(y, x); } dfs(1, 0); long long odd = 0, even = 0, res; for (int i = 1; i &lt;= n; i++) { if (dep[i] &amp; 1) odd++; else even++; } res = odd * (odd - 1) / 2 + even * (even - 1) / 2; cout &lt;&lt; res &lt;&lt; '\\n'; return 0;} solution2:考虑树形dp。$dp[i][0/1]$ 表示从 i 出发，长度为偶数/奇数的路径数。 从子节点到父节点状态转移： $dp[u][1] += dp[v][0]$ $dp[u][0] += dp[v][1]$ 对于 $u$ 的每一个儿子 $v$，贡献即为 $dp[u][0] \\times dp[v][1] + dp[u][1] \\times dp[v][0]$, dfs回溯时进行合并更新即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5;typedef long long ll;int n, idx, h[N];ll res, dp[N][2];struct Node { int to, next;} E[N];void add(int a, int b) { E[idx].to = b, E[idx].next = h[a], h[a] = idx++; }void dfs(int u, int fa) { dp[u][0] = 1; for (int i = h[u]; ~i; i = E[i].next) { int v = E[i].to; if (v == fa) continue; dfs(v, u); res += dp[v][0] * dp[u][1]; res += dp[v][1] * dp[u][0]; dp[u][0] += dp[v][1]; dp[u][1] += dp[v][0]; }}int main() { memset(h, -1, sizeof(h)); cin &gt;&gt; n; for (int i = 1; i &lt; n; i++) { int x, y; cin &gt;&gt; x &gt;&gt; y; add(x, y); add(y, x); } dfs(1, 0); cout &lt;&lt; res &lt;&lt; '\\n'; return 0;} 总结关于树上统计问题一直是个人较怕的题目（虽然经常出现但几乎每次都不会做 T_T），树上问题往往离不开dfs，需要考虑父子节点的转移，必要时可以考虑树形dp。","link":"/2020/04/19/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9ATreepath/"},{"title":"每日一题：Two Graphs（暴力）","text":"题意给一个小图和一个大图，问大图有多少个子图形状和小图一样。 solution最多只有8个点，因为每个点标号可能不一样，因此可以全排列枚举所有点的位置，然后判断小图有的边大图是否也有（因为原来边的属性还在），并通过hash进行去重。 Code1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;int n, m1, m2, res, pre[10], mp1[10][10], mp2[10][10];map&lt;long long, int&gt; p;int main() { while (~scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m1, &amp;m2)) { memset(mp1, 0, sizeof(mp1)); memset(mp2, 0, sizeof(mp2)); p.clear(); res = 0; for (int i = 1; i &lt;= m1; i++) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); mp1[x][y] = mp1[y][x] = 1; } for (int i = 1; i &lt;= m2; i++) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); mp2[x][y] = mp2[y][x] = i; } for (int i = 1; i &lt;= n; i++) pre[i] = i; do { int flag = 1; long long now = 0; for (int i = 1; i &lt;= n &amp;&amp; flag; i++) { for (int j = 1; j &lt;= n &amp;&amp; flag; j++) { if (mp1[i][j] == 1) { if (!mp2[pre[i]][pre[j]]) flag = 0; now |= 1LL &lt;&lt; (mp2[pre[i]][pre[j]]); } } } if (flag &amp;&amp; p[now] == 0) { res++; p[now] = 1; } } while (next_permutation(pre + 1, pre + n + 1)); printf(&quot;%d\\n&quot;, res); } return 0;}","link":"/2020/05/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9ATwo-Graphs%EF%BC%88%E6%9A%B4%E5%8A%9B%EF%BC%89/"},{"title":"每日一题：Yet Another Counting Problem","text":"题意给你两个数 $a$ 和 $b$，$q$ 次询问 $[l,r]$ 内满足 (($x$ mod $a$) mod $b$) != (($x$ mod $b$) mod $a$) 的 $x$ 个数。（$q&lt;=500,1&lt;=a,b&lt;=200,1&lt;=l&lt;=r&lt;=1e18$） solution若 x % a % b != x % b % a，则(x + a $\\times$ b ) % a % b != (x + $a \\times b$ ) % b % a. 可以得到规律一定是以 a $\\times$ b 为循环的，因此预处理前 a $\\times$ b个即可。 Code12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 2e5 + 5;ll t, a, b, q, l, r, sl, sr, sum[N];int main() { cin &gt;&gt; t; while (t--) { cin &gt;&gt; a &gt;&gt; b &gt;&gt; q; int p = a * b; for (int i = 1; i &lt; p; i++) sum[i] = sum[i - 1] + (i % a % b != i % b % a); while (q--) { cin &gt;&gt; l &gt;&gt; r; l--; sl = l / p * sum[p - 1] + sum[l % p]; sr = r / p * sum[p - 1] + sum[r % p]; cout &lt;&lt; sr - sl &lt;&lt; ' '; } cout &lt;&lt; '\\n'; } return 0;}","link":"/2020/04/28/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AYet-Another-Counting-Problem/"},{"title":"每日一题：codeJan与旅行（贪心）","text":"题意给定n个城市坐标，每个城市可以多次到达，问一共到m次，最短花费。给出起始位置，并且起始位置不在城市上。 solution不难猜到要么就是一条路走到黑要么就是在路上找的两个城市然后一直往返。因此我们从原来的位置，往左右两边一直走下去，顺便枚举路上每两座城市之间横跳的花费，维护最小花费，同时注意边界情况。 Code1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5;typedef long long LL;LL ans, a[N];int _, n, m, p;void solve(int k, int res) { for (int i = k; i &lt;= n; i++) { if (i &gt; 1 &amp;&amp; m - (i - k) &gt;= 0) { LL tmp = res + (a[i] - a[k]) + (a[i] - a[i - 1]) * (m - (i - k)); ans = min(ans, tmp); } } for (int i = k - 1; i &gt;= 1; i--) { if (i &lt; n &amp;&amp; m - (k - i) &gt;= 0) { LL tmp = res + (a[k] - a[i]) + (a[i + 1] - a[i]) * (m - (k - i)); ans = min(ans, tmp); } }}int main() { for (scanf(&quot;%d&quot;, &amp;_); _; _--) { ans = 1e18; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;p); for (int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;a[i]); m--; int k = upper_bound(a + 1, a + 1 + n, p) - a; if (k &lt;= n) solve(k, a[k] - p); if (k &gt; 1) solve(k - 1, p - a[k - 1]); printf(&quot;%lld\\n&quot;, ans); } return 0;}","link":"/2020/05/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AcodeJan%E4%B8%8E%E6%97%85%E8%A1%8C%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%89/"},{"title":"每日一题：不同子序列个数(升级版)","text":"题意给定一个长度为 $n$ 的数组，求长度为 $n-m$ 的不同子序列个数。（$1&lt;=n&lt;=1e5, m&lt;=10$） Solution$dp[i][j]$ 表示长度为 $i$，删除 $j$ 个元素的子序列个数，不考虑重复的话，有 $dp[i][j] = dp[i-1][j] + dp[i-1][j-1]$（即已经删除了 $j$ 个和已经删除了 $j-1$ 个再删除这一个的情况）。 考虑去重。如果是单纯求不限长度的不同子序列的去重，容易得到：$dp[i] -= dp[pre[a[i]] - 1]$ （$pre[a[i]]$ 为上一次 $a[i]$ 出现的位置），在此题中也是同理，我们需要剔除 $[pre[a[i]], i]$ 之间的元素，假设我们当前需要剔除 $j$ 个元素，那么在$pre[a[i]]-1$之前我们先需要剔除 $j-(i-pre[a[i]])$ 个元素， $dp[i][j] -= dp[pre[a[i]]-1][j-(i-pre[a[i]])]$，初始化为所有的 $dp[i][0] = 1$。 Code123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 5;const int mod = 1e9 + 7;int n, m, k, pre[N], dp[N][12];int main() { while (cin &gt;&gt; n &gt;&gt; m &gt;&gt; k) { memset(dp, 0, sizeof(dp)); memset(pre, 0, sizeof(pre)); for (int i = 0; i &lt;= n; i++) dp[i][0] = 1; for (int i = 1; i &lt;= n; i++) { int x; cin &gt;&gt; x; for (int j = 1; j &lt;= min(i, m); j++) { dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1]) % mod; if (pre[x] &amp;&amp; j - (i - pre[x]) &gt;= 0) dp[i][j] = (dp[i][j] - dp[pre[x] - 1][j - (i - pre[x])] + mod) % mod; } pre[x] = i; } cout &lt;&lt; dp[n][m] &lt;&lt; '\\n'; } return 0;}","link":"/2020/04/24/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E4%B8%8D%E5%90%8C%E5%AD%90%E5%BA%8F%E5%88%97%E4%B8%AA%E6%95%B0-%E5%8D%87%E7%BA%A7%E7%89%88/"},{"title":"每日一题：不同子序列个数","text":"题意给定一个长度为 $n$ 的字符串，求不同的子序列个数。 Solution很经典的一道计数dp。我们用 $dp[i]$ 表示以前 $i$ 个字符中的不同子序列个数： 当 $s[i]$ 之前没有出现过：$dp[i] = dp[i - 1] * 2 + 1$ ，即前 $i - 1$ 个不同子序列个数 + 前 $i - 1$ 个不同子序列与当前的 $s[i]$ 结合 + 单独一个 $s[i]$ 成为字符串。 当 $s[i]$ 之前出现过：$dp[i] = dp[i - 1] * 2 - dp[上一次出现的位置 - 1]$ ，因为以该字符结尾的情况我们之前已经计算过一次，因此要减去上一次计算的结果，否则会产生重复计算。 Code12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6 + 5;const long long mod = 1e9 + 7;char s[N];int n, vis[N];long long dp[N];int main() { cin &gt;&gt; n &gt;&gt; s + 1; for (int i = 1; i &lt;= n; i++) { if (vis[s[i]]) dp[i] = (dp[i - 1] * 2 - dp[vis[s[i]] - 1] + mod) % mod; else dp[i] = (dp[i - 1] * 2 + 1) % mod; vis[s[i]] = i; } cout &lt;&lt; dp[n] &lt;&lt; '\\n'; return 0;}","link":"/2020/04/22/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E4%B8%8D%E5%90%8C%E5%AD%90%E5%BA%8F%E5%88%97%E4%B8%AA%E6%95%B0/"},{"title":"每日一题：中位数图","text":"题意给定一个 $1-n$ 排列，求长度为奇数子串以 $b$ 为中位数的子串个数。 solution由于求的是中位数，所以我们只需要关心这个数和 $b$ 的大小关系就好了，大于 $b$ 看作 1，小于 $b$ 看作 -1，等于 $b$ 看作 0，问题转化为求包含 0 且和为 0 的子串有多少个。 从 $b$ 的位置开始遍历，map 统计右边累加的和，然后从左边累加的和中查找对应的相反数个数，累加即可。同时，如果遍历过程中任何一边已经存在和为 0 的情况，也为可行解。 Code12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;map&lt;int, int&gt; mp;int n, b, sum, pos, res, a[200005];int main() { cin &gt;&gt; n &gt;&gt; b; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; if (a[i] &gt; b) a[i] = 1; else if (a[i] &lt; b) a[i] = -1; else if (a[i] == b) { a[i] = 0; pos = i; } } for (int i = pos + 1; i &lt;= n; i++) { sum += a[i]; mp[sum]++; if (sum == 0) res++; } sum = 0; for (int i = pos - 1; i; i--) { sum += a[i]; res += mp[-sum]; if (sum == 0) res++; } cout &lt;&lt; res + 1 &lt;&lt; '\\n'; return 0;}","link":"/2020/05/28/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E4%B8%AD%E4%BD%8D%E6%95%B0%E5%9B%BE/"},{"title":"每日一题：不相交线段的最小最大值","text":"题意在一维数轴上给出 $m$ 个线段，每个线段都都有 $l,r,w$ 三个数据代表这个线段的左右端点和这个区间权值。 从中取出若干个不相交的线段(区间端点可以共用)，在覆盖满 $[1,n]$ 的情况下，取出的线段中 $权重的最大值]$ 最小能为多少？ Solution$dp[i]$ 代表覆盖满 $[1,i]$ 最大权值最小为多少，然后按左端点从小到大枚举线段，就有 $dp[r_i]=min(dp[r_i],max(dp[l_i],w_i))$。 Code1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;struct Node { int l, r; ll w;} q[200005];bool cmp(Node x, Node y) { return x.l &lt; y.l; }ll dp[100005];int main() { int n, m; while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;m)) { for (int i = 1; i &lt;= m; i++) scanf(&quot;%d%d%lld&quot;, &amp;q[i].l, &amp;q[i].r, &amp;q[i].w); sort(q + 1, q + m + 1, cmp); for (int i = 0; i &lt;= n; i++) dp[i] = 1e18; dp[1] = 0; for (int i = 1; i &lt;= m; i++) dp[q[i].r] = min(dp[q[i].r], max(dp[q[i].l], q[i].w)); if (dp[n] == 1e18) puts(&quot;invalid data&quot;); else printf(&quot;%lld\\n&quot;, dp[n]); } return 0;}","link":"/2020/09/26/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%BA%BF%E6%AE%B5%E7%9A%84%E6%9C%80%E5%B0%8F%E6%9C%80%E5%A4%A7%E5%80%BC/"},{"title":"每日一题：二维网格图中探测环","text":"题目问二维矩阵中是否存在相同字母构成的环。 Solution判环问题，显然可以想到并查集。遍历矩阵，若该点与之前遍历过的相邻点字符相同且是同一个根的话，说明存在环，否则合并这两个点。 Code12345678910111213141516171819202122232425262728293031class Solution { static int[] pre = new int[500005]; public int find(int x) { return pre[x] == x ? x : (pre[x] = find(pre[x])); } public boolean join(int x, int y) { int fx = find(x), fy = find(y); if (fx == fy) return true; pre[fx] = fy; return false; } public boolean containsCycle(char[][] grid) { int n = grid.length, m = grid[0].length; for (int i = 0; i &lt; n * m; i++) pre[i] = i; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { if (i &gt; 0 &amp;&amp; grid[i][j] == grid[i - 1][j] &amp;&amp; join(i * m + j, (i - 1) * m + j)) { return true; } if (j &gt; 0 &amp;&amp; grid[i][j] == grid[i][j - 1] &amp;&amp; join(i * m + j, i * m + j - 1)) { return true; } } } return false; }}","link":"/2020/08/25/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E4%BA%8C%E7%BB%B4%E7%BD%91%E6%A0%BC%E5%9B%BE%E4%B8%AD%E6%8E%A2%E6%B5%8B%E7%8E%AF/"},{"title":"每日一题：储物点的距离","text":"题意给定 $i$ 和 $i+1$两点的距离和 $i$ 点的货物数量，$m$ 次询问将 $[l,r]$ 所有物品搬到 $x$ 点的总费用（区间内每个物品各自离 $x$ 点距离和）。（$n,m &lt;= 200000 , 0 &lt;= ai,bi &lt;= 2000000000$） soltuion前缀和维护：$sum1$ 表示每个储物点离原点0的距离，$sum2$ 表示前 $i$ 个储物点共有多少货物，$sum3$ 表示前 $i$ 个储物点的所有物品到原点0的和。 $x&lt;=l$，即 $[l,r]$ 所有物品到原点的距离 - 到 $x$ 点的距离。 $x&gt;=r$，即 $[l,r]$ 所有物品从 $x$ 点到原点的距离 - 从原位置到原点的距离。 处于中间的情况，就是拆解成 $[l,x],[x+1,r]$ 两种情况，然后分别带入上面情况即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod = 1000000007;const int N = 2e5 + 5;int n, m, l, r;ll x, res, sum1[N], sum2[N], sum3[N];int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 2; i &lt;= n; i++) { cin &gt;&gt; x; sum1[i] = (sum1[i - 1] + x) % mod; } for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; x; sum2[i] = (sum2[i - 1] + x) % mod; sum3[i] = (sum3[i - 1] + sum1[i] * x) % mod; } while (m--) { cin &gt;&gt; x &gt;&gt; l &gt;&gt; r; if (x &lt;= l) res = ((sum3[r] - sum3[l - 1] + mod) % mod - (sum2[r] - sum2[l - 1] + mod) % mod * sum1[x] % mod + mod) % mod; else if (x &gt;= r) res = ((sum1[x] * ((sum2[r] - sum2[l - 1] + mod) % mod)) % mod - sum3[r] + sum3[l - 1] + mod) % mod; else { res = (((sum3[r] - sum3[x] + mod) % mod - (sum2[r] - sum2[x] + mod) % mod * sum1[x] + mod) % mod + ((sum1[x] * ((sum2[x] - sum2[l - 1] + mod) % mod)) % mod - sum3[x] + sum3[l - 1] + mod) % mod) % mod; } cout &lt;&lt; (res + mod) % mod &lt;&lt; '\\n'; } return 0;}","link":"/2020/05/15/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%82%A8%E7%89%A9%E7%82%B9%E7%9A%84%E8%B7%9D%E7%A6%BB/"},{"title":"每日一题：加分二叉树 （树形dp&#x2F;区间dp）","text":"题意有一颗二叉树，树的每一个节点都有一个值，设他的中序遍历为（l,2,3,…,n），其中数字1,2,3,…,n为节点编号。 任一棵子树subtree（也包含tree本身）的加分计算方法如下： subtree的左子树的加分× subtree的右子树的加分＋subtree的根的分数若某个子树为主，规定其加分为1，叶子的加分就是叶节点本身的分数。不考虑它的空子树。 试求一棵符合中序遍历为（1,2,3,…,n）且加分最高的二叉树tree。 要求输出：（1）tree的最高加分（2）tree的前序遍历 solution符合条件的二叉树是加分最高的二叉树，它的总分依题意得 总分 = 左子树分数 * 右子树分数 + 根节点分数 ，想要总分最高，左右子树的分数应当也分别取最高。 题目中给出的节点序号根据二叉树的中序遍历排列，$dp[l][r]$ （l&lt;r） 表示从节点 $l$ 到节点 $r$ 所构成的子树的最高加分。设$k(l \\le k \\le r)$为该子树的根节点，通过枚举当前 $[l,r]$ 某点为根来取得不同的左右子树和根节点分数，维护最大值。 状态转移方程： $dp[i][j]=max(dp[i][j],dp[i][k-1]*dp[k+1][r]+dp[k][k])$ 最后维护一个 $root$ 数组表示节点 $l-r$ 最高分子树的根即可。 Code123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 35;int n, root[N][N];ll dp[N][N];void dfs(int l, int r) { if (l &gt; r) return; cout &lt;&lt; root[l][r] &lt;&lt; ' '; dfs(l, root[l][r] - 1); dfs(root[l][r] + 1, r);}int main() { cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; dp[i][i]; dp[i][i - 1] = 1; dp[i + 1][i] = 1; root[i][i] = i; } for (int i = 1; i &lt;= n; i++) { for (int l = 1; l + i &lt;= n; l++) { int r = l + i; for (int k = l; k &lt;= r; k++) { int tmp = dp[l][k - 1] * dp[k + 1][r] + dp[k][k]; if (dp[l][r] &lt; tmp) { dp[l][r] = tmp; root[l][r] = k; } } } } cout &lt;&lt; dp[1][n] &lt;&lt; '\\n'; dfs(1, n); return 0;}","link":"/2020/05/16/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%8A%A0%E5%88%86%E4%BA%8C%E5%8F%89%E6%A0%91-%EF%BC%88%E6%A0%91%E5%BD%A2dp-%E5%8C%BA%E9%97%B4dp%EF%BC%89/"},{"title":"每日一题：共鸣问题","text":"题意现在有 $n$ 个音符和 $m$ 对共鸣关系，编号为 $1-n$，每个音符自己有一个奏响时的优美程度，共鸣关系 $(x,y,z)$ 表示音符 $x$ 和 $y$ 同时奏响的额外优美程度是 $z$，同时不奏响则为 $-z$，其他情况为 $0$，求最大优美程度。$(n,m \\in [1,1e5])$ 思路对于一对共鸣关系而言，在不选的情况下收益为 $-z$，则选择一个的话，收益为 $-z + z = 0$，都选择的话为 $-z + 2z = z$。因此可以预先把每对关系的两个数都加上 $z$，刚开始我们是不选任何有联系的音符的，因此初值为 $-z$，那么选择一个数就会加上 $z$，选择两个就会加上 $2z$，满足了之前所讨论的关系。答案初始化为所有关系都不选的情况，即 $-sum(z)$，然后只要贪心的选择对答案有正贡献的值就行了。 Code12345678910111213141516171819202122232425class Solution {public: /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * @param n int整型 * @param m int整型 * @param a int整型vector * @param b int整型vector&lt;vector&lt;&gt;&gt; * @return long长整型 */ long long wwork(int n, int m, vector&lt;int&gt;&amp; a, vector&lt;vector&lt;int&gt; &gt;&amp; b) { // write code here vector&lt;long long&gt; c; long long res = 0; for (auto&amp; x : a) c.push_back(x); for (auto&amp; v : b) { c[v[0] - 1] += v[2]; c[v[1] - 1] += v[2]; res -= v[2]; } for (auto&amp; x : c) res += max(x, 0); return res; }};","link":"/2020/12/23/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%85%B1%E9%B8%A3%E9%97%AE%E9%A2%98/"},{"title":"每日一题：区间和的个数","text":"题目给定一个整数数组 $a$，返回区间和在 $[lower, upper]$ 之间的个数，包含 $lower$ 和 $upper$。区间和 $S(i, j)$ 表示在 $a$ 中，位置从 $i$ 到 $j$ 的元素之和，包含 $i$ 和 $j$ $(i ≤ j)$。 Solution维护前缀和，对于每个前缀和 $sum[i]$，等价于 $sum[0…i-1]$ 里面有多少个数满足差值在 $[lower, upper]$ 之间。 $sum[i] - sum[j] = [lower, upper]$ 等价于求出现在区间 $sum[j] \\in [sum[i] - upper, sum[i] - lower]$ 的数的个数，故可以用树状数组维护。 遍历前缀和数组，对于当前前缀和 $sum[i]$，满足的个数便为：$query(sum[i] - lower) - query(sum[i] - upper - 1)$，累加答案即可。 由于数很大，故需要将所有出现的数离散化。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class BIT { public: int* c; int n; public: BIT(int _n) { n = _n; c = new int[n + 1]; for (int i = 0; i &lt;= n; i++) c[i] = 0; } static constexpr int lowbit(int x) { return x &amp; (-x); } void add(int x) { while (x &lt;= n) { c[x]++; x += lowbit(x); } } int query(int x) { int sum = 0; while (x) { sum += c[x]; x -= lowbit(x); } return sum; }};class Solution {public: int countRangeSum(vector&lt;int&gt;&amp; a, int lower, int upper) { set&lt;long long&gt; s; int m = a.size(); long long *sum = new long long[m + 1]; sum[0] = 0; for (int i = 0; i &lt;= m; i++) { if (i) sum[i] = sum[i - 1] + a[i - 1]; s.insert(sum[i]); s.insert(sum[i] - upper); s.insert(sum[i] - lower); } unordered_map&lt;long long, int&gt; mp; int n = s.size(), idx = 0; BIT bit(n); for (auto x : s) mp[x] = ++idx; int res = 0; for (int i = 0; i &lt;= m; i++) { int l = mp[sum[i] - upper], r = mp[sum[i] - lower]; res += bit.query(r) - bit.query(l - 1); bit.add(mp[sum[i]]); } return res; }};","link":"/2020/11/07/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%8C%BA%E9%97%B4%E5%92%8C%E7%9A%84%E4%B8%AA%E6%95%B0/"},{"title":"每日一题：合并回文子串（区间DP）","text":"题意给定两个字符串，各取出一个子串接在一起，求最长回文子串的长度。 solution先考虑普通的求最长回文子串的dp做法: $dp[i][j] = 0/1 $ 表示子串 $i~j$ 是否为回文串。 那么，容易得到：$dp[i][j] = (dp[i+1][j-1]$ &amp;&amp; $s[i]==s[j])$。 由于 $i$ 是由 $i+1$ 转移过来的，所以我们需要倒着遍历： Code1234567for (int i = s.size() - 1; i &gt;= 0; i--) for (int j = i; j &lt; s.size(); j++) { if (s[i] == s[j] &amp;&amp; (j - i &lt; 2 || dp[i + 1][j - 1])) { dp[i][j] = true; res = max(res, j - i + 1); } } 那么这题其实可以类比： $dp[i][j][k][l]$ 表示a串第i个字符到第j个字符和b串第k个字符到第l个字符是否组成回文串： 往 $a[i+1]$ 到 $a[j−1]$ 和 $b[k]$ 到 $b[l]$ 构成的串的两端加上 $a[i]$ 和 $a[j]$ 两个字符： $dp[i][j][k][l] = dp[i+1][j-1][k][l] and (a[i]==a[j])$ 往 $a[i+1]$ 到 $a[j]$ 和 $b[k]$ 到 $b[l-1]$ 构成的串的两端加上 $a[i]$ 和 $b[l]$ 两个字符： $dp[i][j][k][l] = dp[i+1][j][k][l-1] and (a[i]==b[l])$ 往 $a[i]$ 到 $a[j-1]$ 和 $b[k+1]$ 到 $b[l]$ 构成的串的两端加上 $b[k]$ 和 $a[j]$ 两个字符： $dp[i][j][k][l] = dp[i][j-1][k+1][l] and (b[k]==a[j])$ 往 $a[i]$ 到 $a[j]$ 和 $b[k+1]$ 到 $b[l-1]$ 构成的串的两端加上 $b[k]$ 和 $b[l]$ 两个字符： $dp[i][j][k][l] = dp[i][j][k+1][l-1] and (b[k]==b[l])$ 实际上就是取法由原来的一种变为了四种，注意若组成的字符串长度小于2时需要直接赋值为1 Code123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 105;char a[N], b[N];bool f[N][N][N][N];int t, n, m;int main() { scanf(&quot;%d&quot;, &amp;t); while (t--) { int res = 0; scanf(&quot;%s&quot;, a + 1); scanf(&quot;%s&quot;, b + 1); n = strlen(a + 1); m = strlen(b + 1); for (int len1 = 0; len1 &lt;= n; len1++) //枚举a串的长度 for (int len2 = 0; len2 &lt;= m; len2++) //枚举b串的长度 for (int i = 1; i + len1 - 1 &lt;= n; i++) for (int k = 1; k + len2 - 1 &lt;= m; k++) { int j = i + len1 - 1, l = k + len2 - 1; //根据左端点和长度计算右端点 if (len1 + len2 &lt;= 1) f[i][j][k][l] = 1; else { f[i][j][k][l] = 0; if (len1 &gt; 1) f[i][j][k][l] |= (f[i + 1][j - 1][k][l] &amp;&amp; (a[i] == a[j])); if (len1 &amp;&amp; len2) f[i][j][k][l] |= (f[i + 1][j][k][l - 1] &amp;&amp; (a[i] == b[l])); if (len1 &amp;&amp; len2) f[i][j][k][l] |= (f[i][j - 1][k + 1][l] &amp;&amp; (a[j] == b[k])); if (len2 &gt; 1) f[i][j][k][l] |= (f[i][j][k + 1][l - 1] &amp;&amp; (b[k] == b[l])); } if (f[i][j][k][l]) res = max(res, len1 + len2); } printf(&quot;%d\\n&quot;, res); } return 0;}","link":"/2020/05/02/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%90%88%E5%B9%B6%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%EF%BC%88DP%EF%BC%89/"},{"title":"每日一题：图的遍历","text":"题意无向图 $n$ 个点，每次必须跳两个，至少需要加多少条边可以遍历所有点。 solution首先，如果图不联通，那么需要加联通分量 - 1 条边使图联通，然后发现一点，只要这个图存在奇数环，就一定能全部走完，不存在的话，随便加一条边生成奇数环即可。 Code12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5;int n, m, odd, x, y, res, vis[N], color[N];vector&lt;int&gt; g[N];void dfs(int u) { for (auto v : g[u]) { if (!vis[v]) { vis[v] = 1; color[v] = !color[u]; dfs(v); } else if (color[u] == color[v]) odd = 1; }}int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; x &gt;&gt; y; g[x].push_back(y); g[y].push_back(x); } for (int i = 1; i &lt;= n; i++) { if (!vis[i]) { res++; vis[i] = color[i] = 1; dfs(i); } } cout &lt;&lt; res - odd &lt;&lt; '\\n'; return 0;}","link":"/2020/05/20/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/"},{"title":"Effective C++条款总结","text":"从 C 转向 C++条款1. 尽量用 const 和 inline 而不用 #define","link":"/2020/10/03/Effective-C-%E6%9D%A1%E6%AC%BE%E6%80%BB%E7%BB%93/"},{"title":"每日一题：地下城游戏 （dp）","text":"题意给定权值矩阵，需要从左上角走到右下角，只能往右或往下走且权值会累加，问至少需要提前准备多少权值才能保证过程中不出现权值被耗尽的情况。 Solution正着不太好写，可以尝试倒过来dp，$dp[i][j]$ 表示当前位置到终点至少需要准备多少权值，这样每个点要么从下边转移，要么从右边转移，选择最小的那个点转移即可，过程中需要保证权值至少为1，得到转移方程：$dp[i][j] = max(min(dp[i+1][j],dp[i][j+1])-mp[i][j],1)$。 Code12345678910111213141516class Solution { public int calculateMinimumHP(int[][] mp) { int n = mp.length, m = mp[0].length; int[][] dp = new int[n + 1][m + 1]; for(int i = n; i &gt;= 0; i--) { Arrays.fill(dp[i], Integer.MAX_VALUE); } dp[n][m - 1] = dp[n - 1][m] = 1; for(int i = n - 1; i &gt;= 0; i--) { for(int j = m - 1; j &gt;= 0; j--) { dp[i][j] = Math.max(Math.min(dp[i + 1][j], dp[i][j + 1]) - mp[i][j], 1); } } return dp[0][0]; }}","link":"/2020/07/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F-%EF%BC%88dp%EF%BC%89/"},{"title":"每日一题：大逃离","text":"题意从 $n$ 个数中任选 $k$ 个数，取得这 $k$ 个数中最大的一个数，求每个数被取得的概率。$(n, k \\in [1, 2e5])$ Solution将数组排序后，枚举每个数被作为最大值的可能性，当第 $i$ 个数作为最大值时，其它 $k - 1$ 个一定从前 $i - 1$ 个里面选，即方案数为 $C(i - 1, k - 1)$，将其除以总方案数 $C(n, k)$ 即为被取得概率。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution {public: /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * @param n int整型 * @param k int整型 * @param Point int整型vector * @return int整型vector */ long long mod = 1e9 + 7; long long f[200005]; long long qp(long long a, long long b) { long long sum = 1; while (b) { if (b &amp; 1) sum = sum * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return (int)sum; } long long C(int n, int m){ if(n == m || m == 0) return 1; return f[n] * qp(f[m], mod - 2) % mod * qp(f[n - m], mod - 2) % mod; } vector&lt;int&gt; city(int n, int k, vector&lt;int&gt;&amp; a) { // write code here auto b = a; sort(a.begin(), a.end()); vector&lt;int&gt; g; map&lt;int, long long&gt; mp; f[0] = 1; for (long long i = 1; i &lt;= 200000; ++i) { f[i] = f[i - 1] * i % mod; } for (int i = 0; i &lt; n; ++i) { if (i + 1 &gt;= k) mp[a[i]] = C(i, k - 1); } long long sum = C(n, k); for (int i = 0; i &lt; n; i++) { g.push_back(mp[b[i]] * qp(sum, mod - 2) % mod); } return g; }};","link":"/2020/12/22/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%A4%A7%E9%80%83%E7%A6%BB/"},{"title":"每日一题：子序列","text":"题意给定一个由n个元素组成的序列 { a1, a2, a3,…, an } ，她想知道其中有多少个子序列 { ap1, ap2, …, apm } $(1 ≤ m ≤ n, 1 ≤ p1 &lt; p2 ,…, &lt; pm ≤ n)$，满足对于所有的 $i, j$ $(1 ≤ i &lt; j ≤ m)$, apipj &lt; apjpi成立。 Solution1py + dp直接冲。 12345678n, mod = int(input()), int(1000000007)a = list(map(int, input().split()))dp = [ 1 for i in range(n) ]for i in range(0, n): for j in range(i): if (a[j] ** (i + 1) &lt; a[i] ** (j + 1)): dp[i] += dp[j]print(sum(dp) % mod) solution2变形公式。a[ i ]j &lt; a[ j ]i $\\Leftrightarrow$ j $\\times$ $log(a[i]) &lt; i * log(a[j])$，即原题等价于求上升子序列的数量。 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod = 1e9 + 7;ll res, dp[105], a[105];int main() { int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; dp[i] = 1; } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt; i; j++) if (j * log(a[i]) &gt; i * log(a[j])) dp[i] = (dp[i] + dp[j]) % mod; res = (res + dp[i]) % mod; } cout &lt;&lt; res &lt;&lt; '\\n'; return 0;}","link":"/2020/04/23/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%AD%90%E5%BA%8F%E5%88%97/"},{"title":"每日一题：小y的序列","text":"题目最少修改几个数，使得数列满足 $a[i + 1] - a[i] = i$。$(n \\in [1, 1e5], a[i] \\in [-1e9, 1e9])$ Solution先构造一个长度为 $n$ 满足题意的初始数列，然后将所给的数减去对应的初始构造的数，差值出现的次数最多的就是最长的满足题意的序列，要修改的就是剩余的那些数。 Code123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;int main() { int n, x, p = 0, res; unordered_map&lt;int, int&gt; mp; cin &gt;&gt; n &gt;&gt; x; res = mp[x] = 1; for (int i = 1; i &lt; n; i++) { cin &gt;&gt; x; p += i; res = max(res, ++mp[x - p]); } cout &lt;&lt; n - res &lt;&lt; endl; return 0;}","link":"/2020/10/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%B0%8Fy%E7%9A%84%E5%BA%8F%E5%88%97/"},{"title":"每日一题：完美对物品","text":"题目$n$ 个物体，每个物品都有 $k$ 个属性，实际上就是 $a[n][k]$ 的数组，满足 $a[i][0]+a[j][0]=a[i][1]+a[j][1]=…=a[i][k−1]+a[j][k−1]$ 的物体 $i$ 和物体 $j$ 称为一对完美对，求完美对对数。 Solution公式变形：$x1 + y1 = x2 + y2 -&gt; x1-x2 = -(y1-y2)$，用一个 $map(vector, int)$ 来记录每件物品的差值即可，然后去 $map$ 里面查找有几个正好是相反数 $vector$，累加答案即可。 Code1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;map&lt;vector&lt;int&gt;, int&gt; mp;int a[15];signed main() { int n, k, res = 0; cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; i++) { vector&lt;int&gt; g; for (int j = 1; j &lt;= k; j++) cin &gt;&gt; a[j]; for (int j = 2; j &lt;= k; j++) { g.push_back(a[j] - a[j - 1]); } res += mp[g]; for (int j = 0; j &lt; g.size(); j++) { g[j] = -g[j]; } mp[g]++; } cout &lt;&lt; res &lt;&lt; endl; return 0;}","link":"/2020/08/17/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%AE%8C%E7%BE%8E%E5%AF%B9%E7%89%A9%E5%93%81/"},{"title":"每日一题：建筑抢修 （贪心）","text":"题意$n$ 栋建筑，第 $i$ 栋建筑需要 $s_i$ 时间修，截止到 $t_i$ 时间，问最多可以修多少建筑。 solution我们可以类比成写作业，先截止的我们会先做，这是大体的贪心策略。但他并不是最优的，因为可能那一科会花你非常多的时间，够你做更多的科目，得不偿失。因此我们用优先队列维护做过的作业中花费时间最大的那份，当目前要做的作业时间不够的时候，与这个最大值比较看是否花的时间更少，可行的话就把这个塞进去，那个丢出来，这样做了同样多的作业却花了更少的时间，同时维护答案。 Code123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;#define x first#define y secondusing namespace std;const int N = 5e5 + 5;int n, sum, res;pair&lt;int, int&gt; p[N];priority_queue&lt;int&gt; q;int main() { cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; p[i].y &gt;&gt; p[i].x; sort(p, p + n); for (int i = 0; i &lt; n; i++) { if (sum + p[i].y &lt;= p[i].x) { sum += p[i].y; res++; q.push(p[i].y); } else if (p[i].y &lt; q.top()) { sum -= q.top(); q.pop(); q.push(p[i].y); sum += p[i].y; } } cout &lt;&lt; res &lt;&lt; '\\n'; return 0;}","link":"/2020/05/29/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%BB%BA%E7%AD%91%E6%8A%A2%E4%BF%AE-%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%89/"},{"title":"每日一题：异或","text":"题目给定整数 $m$ 以及 $n$ 各数字 $A_1,A_2,..A_n$，将数列 $A$ 中所有元素两两异或，共能得到 $n(n-1)/2$ 个结果，请求出这些结果中大于 $m$ 的有多少个。 Solution为了避免重复计算，字典树可以边维护边插入，先查询之前有多少个数与当前数 $x$ 异或和大于 $m$，我们从高位向低位枚举，对于两个数的同一个二进制位，需要分四种情况讨论： $x_i = 1, m_i = 1$，则查询的数当前位必须为 $0$ 才可。 $x_i = 0, m_i = 1$，则查询的数当前位必须为 $1$ 才可。 $x_i = 1, m_i = 0$，则查询数当前位为 $0$ 的直接满足条件计入答案，当前位为 $1$ 的继续向下查找。 $x_i = 0, m_i = 0$，则查询数当前位为 $1$ 的直接满足条件计入答案，当前位为 $0$ 的继续向下查找。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 6e5 + 5;typedef long long ll;int n, m, idx, cnt[N], trie[N][2];void insert(int x) { int p = 0, y; for (int i = 31; ~i; i--) { y = x &gt;&gt; i &amp; 1; int &amp;s = trie[p][y]; if (!s) s = ++idx; p = s; cnt[p]++; }}int query(int x) { int p = 0, p1, sum = 0; for (int i = 31; ~i; i--) { int y = x &gt;&gt; i &amp; 1; int z = m &gt;&gt; i &amp; 1; if (y == 1 &amp;&amp; z == 1) { p = trie[p][0]; } else if (y == 0 &amp;&amp; z == 1) { p = trie[p][1]; } else if (y == 1 &amp;&amp; z == 0) { p1 = trie[p][0]; p = trie[p][1]; if (p1) sum += cnt[p1]; } else if (y == 0 &amp;&amp; z == 0) { p1 = trie[p][1]; p = trie[p][0]; if (p1) sum += cnt[p1]; } if (!p) break; } return sum;}int main() { long long res = 0; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) { int x; scanf(&quot;%d&quot;, &amp;x); res += query(x); insert(x); } printf(&quot;%lld\\n&quot;, res); return 0;}","link":"/2020/08/13/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%BC%82%E6%88%96/"},{"title":"每日一题：找出最长的超赞子字符串","text":"题意给你一个字符串 s 。请返回 s 中最长的 超赞子字符串 的长度。 「超赞子字符串」需满足满足下述两个条件： 该字符串是 s 的一个非空子字符串进行任意次数的字符交换重新排序后，该字符串可以变成一个回文字符串 Solution首先，一个字符串可以重新排序得到一个回文字符串的充要条件是：对字符计数，出现奇数次的字符个数小于等于1。 由此我们可以发现：我们没有必要知道这个数字到底出现了几次，我们只需要关心它到底是出现了奇数次还是偶数次。我们用 $0,1$ 来表示出现了 $偶数/奇数$ 次，由于需要统计的字符只有 $0-9$ 十个数字，因此我们只需要一个十位的二进制数 $status$ 即可表示当前所有字符出现次数的奇偶状态，即第i位表示数字 $i$ 出现次数的奇偶性。 假设当前遇到的数字是 i ，那么更新它的状态就是 $status ^= (1 &lt;&lt; i)$ ，因为根据异或的特性，相同为0，不同为1，能够很好的实现我们需要的 $奇+奇(1+1)=偶+偶(0+0)=偶(0),奇+偶(1+0)= 偶+奇(0+1)=奇(1)$，改变对应二进制位的状态。 我们遍历字符串维护这样一个 $status$，采用数组标记的思想，$pre[status]$ 表示 $status$ 出现的最早位置。 满足超赞字符串的条件： 再一次遇到之前已经出现过的 $status$ ，说明所有数字都出现了偶数次。（因为每一位二进制位的奇偶性都相同的话，不论都是1还是0，$奇-奇=偶-偶=偶$，都代表这些字符在中间这一段出现了偶数次，长度为 $当前位置i - 最早出现的位置pre[status]$） 与之前出现过的 $status$ 只有一个二进制位不同，说明这个不同的二进制位出现了奇数次 $(奇-偶=偶-奇=奇)$，其余的二进制位出现了偶数次，仍然满足回文字符串的条件。针对这种情况，我们只需要从 $0-9$ 枚举二进制位，然后看之前是否出现过即可，同时维护答案。 Code1234567891011121314151617181920212223class Solution { static int[] pre = new int[1 &lt;&lt; 11]; public int longestAwesome(String s) { int n = s.length(), status = 0, res = 0; Arrays.fill(pre, -2); // pre数组初始化为-2，代表都没有出现过 pre[status] = -1; // 最初的状态为0，代表都出现了0次（偶数次） for (int i = 0; i &lt; n; i++) { status ^= 1 &lt;&lt; (s.charAt(i) - '0'); // 更新当前状态 if (pre[status] != -2) { // 之前已经存在过 res = Math.max(res, i - pre[status]); } else { // 没有存在过 pre[status] = i; } for (int j = 0; j &lt; 10; j++) { // 枚举0-9 int status1 = status ^ (1 &lt;&lt; j); // 将对应位置的奇偶性改变 if (pre[status1] != -2) { // 之前是否出现过 res = Math.max(res, i - pre[status1]); } } } return res; }}","link":"/2020/08/09/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%89%BE%E5%87%BA%E6%9C%80%E9%95%BF%E7%9A%84%E8%B6%85%E8%B5%9E%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"title":"每日一题：按要求补齐数组","text":"题意给定一个已排序的正整数数组 $nums$，和一个正整数 $n$ 。从 $[1, n]$ 区间内选取任意个数字补充到 $nums$ 中，使得 $[1, n]$ 区间内的任何数字都可以用 $nums$ 中某几个数字的和来表示。请输出满足上述要求的最少需要补充的数字个数。 Soluiton容易证明，对于正整数 $x$，如果区间 $[1,x−1]$ 内的所有数字都已经被覆盖，且 $x$ 在数组中，则区间 $[1,2x−1]$ 内的所有数字也都被覆盖。 由此可以提出一个贪心的方案。每次找到未被数组 $nums$ 覆盖的最小的整数 $x$，在数组中补充 $x$，然后寻找下一个未被覆盖的最小的整数，重复上述步骤直到区间 $[1,n]$ 中的所有数字都被覆盖。 具体实现： $x$ 表示当前能表示出 $[1, x - 1]$ 的所有数字，初始化为 $1$，枚举数组。 若枚举到的数小等于 $x$，则加上，表示能表示出 $[1, x + num[i] - 1]$ 的所有数字，然后下标加 $1$ 若枚举到的数大于 $x$，则说明 $x$ 无法被表示出来，我们需要增加一个数 $x$，然后$x$ 加上 $x$，表示能表示出 $[1, x + x - 1]$ 的所有数字 Code1234567891011121314151617class Solution {public: int minPatches(vector&lt;int&gt;&amp; a, int n) { long x = 1; int res = 0, i = 0, m = a.size(); while (x &lt;= n) { if (i &lt; m &amp;&amp; a[i] &lt;= x) { x += a[i]; i++; } else { x *= 2; res++; } } return res; }};","link":"/2020/12/29/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%8C%89%E8%A6%81%E6%B1%82%E8%A1%A5%E9%BD%90%E6%95%B0%E7%BB%84/"},{"title":"每日一题：换个角度思考（树状数组）","text":"题意给定一个长度为 $(1&lt;=n&lt;=1e5)$ 的数组，$(1&lt;=q&lt;=1e5)$ 次询问查询区间 $[l,r]$ 内 $&lt;=k$ 的元素个数。 solution考虑树状数组。我们在查询区间 $&lt;=k$ 的个数时，为了更好计数，这个区间应该不包含 $&gt;k$ 的元素才行。因此我们不妨离线，将询问的 $k$ 从小到大排序，将数组也从小到大排序，这样从小到大处理询问，每次处理时只将 $&lt;=k$ 的数挂到树的对应下标上（因为询问的 $k$ 是从小到大的，因此之前树上的数一定比当前询问的 $k$ 要小），维护答案为 $query(r) - query(l-1)$。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;#define x first#define y secondusing namespace std;const int N = 2e5 + 5;struct Node { int l, r, v, id;} q[N];int n, m, c[N], res[N];pair&lt;int, int&gt; p[N];bool cmp(Node x, Node y) { return x.v &lt; y.v; }void update(int x) { for (; x &lt;= n; x += x &amp; (-x)) c[x]++;}int query(int x) { int sum = 0; for (; x &gt;= 1; x -= x &amp; (-x)) sum += c[x]; return sum;}int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; p[i].x; p[i].y = i; } sort(p + 1, p + n + 1); for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; q[i].l &gt;&gt; q[i].r &gt;&gt; q[i].v; q[i].id = i; } sort(q + 1, q + m + 1, cmp); int pos = 1; for (int i = 1; i &lt;= m; i++) { while (q[i].v &gt;= p[pos].x &amp;&amp; pos &lt;= n) { update(p[pos].y); pos++; } res[q[i].id] = query(q[i].r) - query(q[i].l - 1); } for (int i = 1; i &lt;= m; i++) cout &lt;&lt; res[i] &lt;&lt; '\\n'; return 0;}","link":"/2020/04/29/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%8D%A2%E4%B8%AA%E8%A7%92%E5%BA%A6%E6%80%9D%E8%80%83%EF%BC%88%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%EF%BC%89/"},{"title":"每日一题：数数","text":"题目 Solution Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;typedef long long ll;const ll mod = 998244353;const ll M = 1e7;ll t, n, ans1, ans2, x, p[M + 5];ll qp(ll a, ll b){ ll ans = 1; while (b) { if (b &amp; 1) ans = (ans * a) % mod; a = (a * a) % mod; b &gt;&gt;= 1; } return ans;}int main(){ p[1] = 1; for (ll i = 2; i &lt;= M; i++) p[i] = (p[i - 1] * i) % mod; while (~scanf(&quot;%lld&quot;, &amp;t)) { while (t--) { scanf(&quot;%lld&quot;, &amp;n); ans1 = 0, ans2 = 1; if (n &amp; 1) { x = (n + 1) / 2; ans1 = (((x * n) % mod) * ((x * n) % mod)) % mod; } else { x = n / 2; ans1 = (((x * (n + 1)) % mod) * ((x * (n + 1)) % mod)) % mod; } ans2 = qp(p[n], 2 * n); printf(&quot;%lld %lld\\n&quot;, ans1, ans2); } } return 0;}","link":"/2020/08/11/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%95%B0%E6%95%B0/"},{"title":"每日一题：数数组","text":"题目构造一个长度为 $n$ 的序列，每个数字大小必须满足 $l &lt;= a[i] &lt;= r$，且和被 3 整除，问有多少种方法？ Solution$dp[i][j]$ 表示长度为 $i$，余数为 $j$ 的构造数量。$a,b,c$ 表示区间内余数为 $0,1,2$ 的数的数量。 转移方程： $dp[i][0] = a dp[i - 1][0] + b dp[i - 1][2] + c dp[i - 1][1]$;$dp[i][1] = (a dp[i - 1][1] + b dp[i - 1][0] + c dp[i - 1][2]$;$dp[i][2] = (a dp[i - 1][2] + b dp[i - 1][1] + c * dp[i - 1][0]$; Code123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;ll n, l, r, dp[200005][3], a, b, c;const ll mod = 1e9 + 7;int main() { cin &gt;&gt; n &gt;&gt; l &gt;&gt; r; while (l % 3 != 0) { int x = l % 3; if (x == 1) b++; else if (x == 2) c++; l++; } while (r % 3 != 0) { int x = r % 3; if (x == 2) c++; else if (x == 1) b++; r--; } int p = (r - l) / 3; a += p; b += p; c += p; a++; dp[0][0] = 1; for (int i = 1; i &lt;= n; i++) { dp[i][0] = (a * dp[i - 1][0] + b * dp[i - 1][2] + c * dp[i - 1][1]) % mod; dp[i][1] = (a * dp[i - 1][1] + b * dp[i - 1][0] + c * dp[i - 1][2]) % mod; dp[i][2] = (a * dp[i - 1][2] + b * dp[i - 1][1] + c * dp[i - 1][0]) % mod; } cout &lt;&lt; dp[n][0] &lt;&lt; endl; return 0;}","link":"/2020/08/23/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%95%B0%E6%95%B0%E7%BB%84/"},{"title":"每日一题：最多的不重叠子字符串","text":"题意给你一个只包含小写字母的字符串 s ，你需要找到 s 中最多数目的非空子字符串，满足如下条件： 这些字符串之间互不重叠，也就是说对于任意两个子字符串 s[i..j] 和 s[k..l] ，要么 j &lt; k 要么 i &gt; l 。 如果一个子字符串包含字符 char ，那么 s 中所有 char 字符都应该在这个子字符串中。 请你找到满足上述条件的最多子字符串数目。如果有多个解法有相同的子字符串数目，请返回这些子字符串总长度最小的一个解。可以证明最小总长度解是唯一的。 Solution先对每个字母求出合法的最短长度，可以记录每个字母出现的左右端点，但这样不一定是合法的，因为之间会有别的字母，而这些字母没有被完全包含，所以必须枚举这个区间内的所有字母，一直拓展这个区间直到合法位置。 然后问题就转变为不相交线段数最多且长度和最短的问题，考虑贪心。显然可以看出先对右端点进行排序从小到大排序（保证右边剩余的空间尽量大），然后对左端点从大到小排序（保证长度尽可能小），然后贪心着取，遇到可以加入的线段将其加入答案即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution { public: struct Node { int l, r; bool operator&lt;(const Node&amp; node) const { if (r == node.r) return l &gt; node.l; return r &lt; node.r; } } p[26]; vector&lt;string&gt; maxNumOfSubstrings(string s) { int n = s.size(); vector&lt;string&gt; res; for (int i = 0; i &lt; 26; i++) p[i].l = p[i].r = -1; for (int i = 0; i &lt; n; i++) { if (p[s[i] - 'a'].l == -1) p[s[i] - 'a'].l = i; p[s[i] - 'a'].r = i; } for (int i = 0; i &lt; 26; i++) { if (p[i].l == -1) continue; int le = p[i].l; for (int j = p[i].l; j &lt;= p[i].r; j++) { p[i].l = min(p[i].l, p[s[j] - 'a'].l); p[i].r = max(p[i].r, p[s[j] - 'a'].r); if (le &gt; p[i].l) { le = p[i].l; j = le; } } } sort(p, p + 26); int ri = -1; for (int i = 0; i &lt; 26; i++) { if (p[i].r == -1) continue; if (p[i].l &gt; ri) { ri = p[i].r; res.push_back(s.substr(p[i].l, p[i].r - p[i].l + 1)); } } return res; }};","link":"/2020/07/31/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%A4%9A%E7%9A%84%E4%B8%8D%E9%87%8D%E5%8F%A0%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"title":"堆，栈与内存管理","text":"stack &amp;&amp; heapstack，由操作系统自动分配释放，是存在于某作用域的一块内存空间。例如当你调用函数，函数本身即会形成一个stack用来放置它所接收的参数，以及返回地址。函数本体中声明的任何变量，所使用的内存块都取自上述stack。 heap，是指由操作系统提供的一块 global 内存空间，程序可动态分配从中获得的若干区块，由开发人员分配和释放，若开发人员不释放，程序结束时由 OS 回收，分配方式类似于链表 12345678910Complex c3(1,2); // 全局对象，其生命周期在整个程序结束之后才结束。（可视为 static 对象，作用域是整个程序）{ Complex c1(1,2); // 栈中创建对象 static Complex c2(1, 2); // static 静态对象，其生命在作用域结束之后仍然存在，直到整个程序结束 // 堆中创建对象 Complex* p = new Complex(3); delete p; // 否则会发生内存泄漏，因为当作用域结束，p 所指的对象仍然存在，但指针 p 的生命结束了，也就不可能再有机会 delete p; } new 关键字new：先分配内存，再调用构造函数。 1234567Complex* pc = new Complex(1, 2);/* 编译器转换为： void* mem = operator new ( sizeof(Complex) ); // 分配内存，operator new 只是一个函数名，内部调用 malloc(n) pc = static_cast&lt;Complex*&gt;(mem); // 转型 pc-&gt;Complex::Complex(1, 2); // 构造函数*/ delete 关键字 delete：先调用析构函数，再释放内存。 12345678910111213String* ps = new String(&quot;Hello&quot;);...delete(ps);/* 编译器转化为 String::~String(ps); // 析构函数 operator delete(ps); // 释放内存，内部调用 free(ps)*/String* p = new String[3];...// delete[] p; // 调用三次析构函数// delete p; // 调用一次析构，导致只回收了对象p[0]对应的内存，但p[1]和p[2]对应的内存没有被清空，这两块发生了内存泄漏。 实例123456789101112131415161718192021222324252627282930313233343536373839404142class String { public: String(const char* cstr = 0); // 构造函数 String(const String&amp; str); // 拷贝构造 String&amp; operator=(const String&amp; str); // 拷贝赋值 ~String(); // 析构函数 char* get_c_str() const { return m_data; } // 获得字符串 private: char* m_data;};inlineString::String(const char* cstr) { if (cstr) { m_data = new char[strlen(cstr) + 1]; strcpy(m_data, cstr); } else { m_data = new char[1]; *m_data = '\\0'; }}inlineString::String(const String&amp; str) { m_data = new char[strlen(str.m_data) + 1]; strcpy(m_data, str.m_data);}inline String&amp; String::operator=(const String&amp; str) { if (this == &amp;str) return *this; delete[] m_data; m_data = new char[strlen(str.m_data) + 1]; strcpy(m_data, str.m_data); return *this; }inlineString::~String() { delete[] m_data; }","link":"/2020/05/12/%E5%A0%86%EF%BC%8C%E6%A0%88%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"title":"每日一题：最大得分","text":"题意给定两个严格递增数组，从任意一个数组出发到任意一个数组结束，当遇到相同元素时可以切换到另一个数组，只能从左到右走且每个数只计算一次，求最大累计得分。 Solution当遇到两个数组都有的元素时可以切换，那其实从上一次遇到相同到这一次，假设中间这部分元素和是 $sum$，无非是看到底是上面这部分的 $sum$ 更大还是下面的 $sum$ 更大，然后选走罢了，如此循环下去。至于判断相同元素，提前用map记录每个元素的位置就好了。时间复杂度$O(n)$。 比如: $nums1: [2, 4, 5, 8, 10]$ $nums2: [4, 6, 8, 9]$ 首先第一部分（从起点开始，碰到第一次相同）是 $sum1(nums1[2, 4]) = 6$, $sum2(nums2[4]) = 4$，选择 $max(sum1, sum2) = 6$ 第二部分（第二次相同）是 $sum1(nums1[5, 8]) = 13$, $sum2(nums2[6, 8]) = 14$，选择 $max(sum1, sum2) = 14$ 第三部分（一直循环到结尾也没再发现相同元素，换不了路线，故只能一直走到终点）是 $sum1(nums1[10]) = 10$, $sum2(nums2[9]) = 9$，选择 $max(sum1, sum2) = 10$ 故答案为 $6 + 14 + 10 = 20$ Code1234567891011121314151617181920212223242526class Solution { public int maxSum(int[] a, int[] b) { int n = a.length, m = b.length; HashMap&lt;Integer, Integer&gt; mp = new HashMap&lt;Integer, Integer&gt;(); for(int i = 0; i &lt; m; i++) mp.put(b[i], i); // 预处理b[i]数组的位置 long res = 0, sum1 = 0, sum2 = 0, mod = 1000000007; int j = 0; for(int i = 0; i &lt; n; i++) { sum1 += a[i]; // 计算a数组这部分的和 if(mp.get(a[i]) != null) { // 说明a[i]在b数组中也存在 int pos = mp.get(a[i]); for(; j &lt;= pos; j++) { // 开始计算b数组这部分的和 sum2 += b[j]; } res = (res + Math.max(sum1, sum2)) % mod; // 选择更大的那部分加 sum1 = sum2 = 0; // 归零，开始下一部分的计算 } } for(; j &lt; m; j++) { // b数组可能还没走完 sum2 += b[j]; } res = (res + Math.max(sum1, sum2)) % mod; return (int)(res % 1000000007); }}","link":"/2020/08/03/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86/"},{"title":"每日一题：最大矩形","text":"题意给定一个仅包含 $0$ 和 $1$ 、大小为 $n * m$ 的二维二进制矩阵，找出只包含 $1$ 的最大矩形，并返回其面积。$(n, m \\in [1, 200])$ 思路有一个子问题，求柱状图最大矩形。预先求出 $1-i$ 层的 $h[i]$ 然后利用套用子问题的模板即可，复杂度 $O(n * m)$. Solution1234567891011121314151617181920212223242526272829303132class Solution {public: int largestRectangleArea(vector&lt;int&gt;&amp; h) { stack&lt;int&gt; st; st.push(-1); int n = h.size(); vector&lt;int&gt; l(n), r(n, n); for (int i = 0; i &lt; n; i++) { while (st.top() != -1 &amp;&amp; h[st.top()] &gt;= h[i]) { r[st.top()] = i; st.pop(); } l[i] = st.top(); st.push(i); } int res = 0; for (int i = 0; i &lt; n; i++) res = max(res, (r[i] - l[i] - 1) * h[i]); return res; } int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; a) { int n = a.size(); if (n == 0) return 0; int m = a[0].size(), res = 0; vector&lt;int&gt; h(m); for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) h[j] = (a[i][j] == '1' ? h[j] + 1 : 0); res = max(res, largestRectangleArea(h)); } return res; }};","link":"/2020/12/26/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/"},{"title":"每日一题：最小区间","text":"题意你有 k 个升序排列的整数数组。找到一个最小区间，使得 k 个列表中的每个列表至少有一个数包含在其中。 Solution直接对所有的数排序，然后优先队列维护一个k个数组都有值存在且对当前来说长度最小的滑动窗口，同时维护答案即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Solution { class Node { public Node(int val, int id) { this.val = val; this.id = id; } int val, id; } public int[] smallestRange(List&lt;List&lt;Integer&gt;&gt; nums) { int n = nums.size(); PriorityQueue&lt;Node&gt; q = new PriorityQueue&lt;&gt;(new Comparator&lt;Node&gt;(){ @Override public int compare(Node a, Node b) { return a.val - b.val; } }); PriorityQueue&lt;Node&gt; q1 = new PriorityQueue&lt;&gt;(new Comparator&lt;Node&gt;(){ @Override public int compare(Node a, Node b) { return a.val - b.val; } }); for (int i = 0; i &lt; n; i++) { List&lt;Integer&gt; num = nums.get(i); for (int j = 0; j &lt; num.size(); j++) { Node node = new Node(num.get(j), i); q.add(node); } } HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); int cnt = 0, dis = 1000000000; int[] res = new int[2]; while (q.size() &gt; 0) { Node now = q.poll(); q1.add(now); if(map.get(now.id) == null) { cnt++; map.put(now.id, 1); } else { int x = map.get(now.id); map.remove(now.id); map.put(now.id, x + 1); } while(q1.size() &gt; 0) { Node x = q1.peek(); if(map.get(x.id) == 1) break; else { q1.poll(); int y = map.get(x.id); map.remove(x.id); map.put(x.id, y - 1); } } if(q1.size() &gt; 0 &amp;&amp; cnt == n &amp;&amp; dis &gt; now.val - q1.peek().val) { dis = now.val - q1.peek().val; res[0] = q1.peek().val; res[1] = now.val; } } return res; }}","link":"/2020/08/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E5%8C%BA%E9%97%B4/"},{"title":"每日一题：最长有效括号","text":"题意给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。 Solution栈里面存左括号的位置，当遇到右括号时： 栈为空：记录这个位置，说明下一轮的合法括号可能从这里开始。 栈不为空：先弹出左括号表示匹配。 此时栈为空，说明之前可能还有合法括号，用当前下标减去之前记录的那个位置。 此时栈不为空，减去当前栈顶的位置即可（最接近的没有被匹配的左括号）。 Code12345678910111213141516171819202122class Solution { public int longestValidParentheses(String s) { int res = 0, last = -1; Stack&lt;Integer&gt; st = new Stack&lt;Integer&gt;(); for (int i = 0; i &lt; s.length(); i++) { if (s.charAt(i) == '(') st.push(i); else { if (st.size() &gt; 0) { st.pop(); if (st.size() &gt; 0) res = Math.max(res, i - st.peek()); else res = Math.max(res, i - last); } else { last = i; } } } return res; }}","link":"/2020/08/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/"},{"title":"每日一题：树中距离之和","text":"题目给定一个无向、连通的树。树中有 $N$ 个标记为 $0…N-1$ 的节点以及 $N-1$ 条边 。 第 $i$ 条边连接节点 $edges[i][0]$ 和 $edges[i][1]$ 。 返回一个表示节点 $i$ 与其他所有节点距离之和的列表 $res$。 Solution首先只考虑查询一个点的情况，容易得到状态转移：$dp[u] = \\sum_{v \\in son[u]}{dp[v] + sz[v]}$。 $son[u]$ 表示 $u$ 的所有子节点，$sz[v]$ 表示以 $v$ 为根的子树大小，$dp[u]$ 表示以 $u$ 为根的子树，它的所有子节点到它的距离之和。 那么 $dp[u]$ 就是所有子节点的 $dp[v]$ + 子节点对应的子树大小个点从 $u$ 到 $v$ 的距离。 然后考虑换根，根从 $u$ 变为子节点 $v$，以 $u$ 为根的子树大小减少 $sz[v]$，$dp[u]$ 也要减去 $v$ 的贡献： $sz[u] -= sz[v], dp[u] -= dp[v] + sz[v]$ 然后 $v$ 做为根，获得了 $u$ 结点的贡献，同时以 $v$ 为根的子树大小增大 $sz[u]$： $sz[v] += sz[u], dp[v] += dp[u] + sz[u]$ 同时注意：递归在进行回溯的时候，需要恢复现场，否则在计算兄弟结点时，维护的 $dp$ 和 $sz$ 将是错误的。 需要两次dfs，时间复杂度为 $O(n)$。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution {public: vector&lt;int&gt; g[10005]; vector&lt;int&gt; res; int dp[10005], sz[10005]; void dfs1(int u, int fa) { sz[u] = 1; dp[u] = 0; for (auto v: g[u]) { if (v == fa) continue; dfs1(v, u); sz[u] += sz[v]; dp[u] += dp[v] + sz[v]; } } void dfs2(int u, int fa) { res[u] = dp[u]; for (auto v: g[u]) { if (v == fa) continue; int du = dp[u], dv = dp[v]; int su = sz[u], sv = dp[v]; dp[u] -= dp[v] + sz[v]; sz[u] -= sz[v]; dp[v] += dp[u] + sz[u]; sz[v] += sz[u]; dfs2(v, u); dp[u] = du, dp[v] = dv; sz[u] = su, sz[v] = sv; } } vector&lt;int&gt; sumOfDistancesInTree(int N, vector&lt;vector&lt;int&gt;&gt;&amp; edges) { for (auto edge: edges) { g[edge[0]].push_back(edge[1]); g[edge[1]].push_back(edge[0]); } res.resize(N, 0); dfs1(0, -1); dfs2(0, -1); return res; }};","link":"/2020/10/06/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%A0%91%E4%B8%AD%E8%B7%9D%E7%A6%BB%E4%B9%8B%E5%92%8C/"},{"title":"每日一题：比赛","text":"题意一共12道题，你有 $a_i$ 的概率做对第 $i$ 题，有 $b_i$ 的概率抄到左边的，有 $c_i$ 的概率抄到右边的，问做对 $0-12$ 题的概率是多少。 solution做对的概率不太好求，可以反过来求做错的概率，即 $(1-a[i])\\times(1-b[i])\\times(1-c[i])$，然后 $dp[i][j]$ 表示前 $i$ 道题做对 $j$ 道的概率，设 $dp[0][0] =1$，得到状态转移方程：$dp[i][j]=dp[i-1][j-1]\\times(ac=(1-wa))+dp[i-1][j]*wa$ 。 Code123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;double a[15], b[15], c[15], dp[15][15];int main() { for (int i = 1; i &lt;= 12; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= 12; i++) cin &gt;&gt; b[i]; for (int i = 1; i &lt;= 12; i++) cin &gt;&gt; c[i]; dp[0][0] = 1; for (int i = 1; i &lt;= 12; i++) { dp[i][0] = dp[i - 1][0] * (1 - a[i]) * (1 - b[i]) * (1 - c[i]); for (int j = 1; j &lt;= i; j++) { double wa = (1 - a[i]) * (1 - b[i]) * (1 - c[i]); dp[i][j] = dp[i - 1][j - 1] * (1 - wa) + dp[i - 1][j] * wa; } } for (int i = 0; i &lt;= 12; i++) printf(&quot;%f\\n&quot;, dp[12][i]); return 0;}","link":"/2020/05/19/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%AF%94%E8%B5%9B/"},{"title":"每日一题：滑雪与时间胶囊（最小生成树）","text":"题意给定一个 $n$ 个点 $m$ 条边图，只能从点权高的点走到低的，且可以不计路程的瞬移至之前走过的某个点，求经过最多点的最短路径。 solution求经过最多点显然直接bfs，建图的时候建高到低的单向边即可，（值得注意的是，若点权相同，则为相互可达的，需要建双向边）。然后根据bfs遍历可以走到的点，将走过的边加入边集，建一个新图出来。为了使路径最短，考虑最小生成树，但需要满足题目的条件，因此我们对新的图进行排序，以高度为第一关键字从大到小排，再以路径长度为第二关键字从小到大排，这样可以保证点最多的同时路径最短。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e6 + 5;int n, m, tot, cnt, hi[N], h[N], pre[N], vis[N];struct Node { int from, to, v, next;} g[N], E[N];void add1(int x, int y, int z) { g[tot].from = x, g[tot].to = y, g[tot].v = z, g[tot].next = h[x], h[x] = tot++;}void add2(int x, int y, int z) { cnt++, E[cnt].from = x, E[cnt].to = y, E[cnt].v = z;}bool cmp(Node x, Node y) { if (hi[x.to] == hi[y.to]) return x.v &lt; y.v; return hi[x.to] &gt; hi[y.to];}int xfind(int x) { int i = x, j = x, temp; while (i != pre[i]) i = pre[i]; while (i != j) { temp = pre[j]; pre[j] = i; j = temp; } return i;}void bfs() { int res1 = 1; queue&lt;int&gt; q; vis[1] = true; q.push(1); while (q.size()) { int u = q.front(); q.pop(); for (int i = h[u]; ~i; i = g[i].next) { int v = g[i].to; add2(u, v, g[i].v); if (!vis[v]) { vis[v] = true; res1++; q.push(v); } } } printf(&quot;%d &quot;, res1);}void Kruscal() { long long res2 = 0; int num = 0; for (int i = 1; i &lt;= cnt; i++) { int x = E[i].from, y = E[i].to; int fx = xfind(x), fy = xfind(y); if (fx != fy) { pre[fx] = fy; res2 += E[i].v; num++; } if (num == n - 1) break; } printf(&quot;%lld\\n&quot;, res2);}int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;hi[i]); pre[i] = i; } memset(h, -1, sizeof(h)); for (int i = 1; i &lt;= m; i++) { int x, y, z; scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z); if (hi[x] &gt;= hi[y]) add1(x, y, z); if (hi[x] &lt;= hi[y]) add1(y, x, z); } bfs(); sort(E + 1, E + cnt + 1, cmp); Kruscal(); return 0;}","link":"/2020/04/30/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%BB%91%E9%9B%AA%E4%B8%8E%E6%97%B6%E9%97%B4%E8%83%B6%E5%9B%8A%EF%BC%88%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89/"},{"title":"每日一题：牛牛构造等差数列","text":"题意有 $n$ 个数，他们对每个数可以进行 $+1$ 或 $-1$ 操作，但对于每一个数，该操作最多只能执行一次。使用最少的操作次数，将这几个数构造成一个等差数列。如果完全不能构造成功，就输出 $-1$。 Solution每个数最多只能修改一次，因此我们只要枚举前两个数的修改状态就能确定首项和公差，只有 $9$ 种可能，然后逐一判断取最小值即可。 Code123456789101112131415161718192021222324252627282930313233public class Solution { public int solve(int n, int[] b) { int res = Integer.MAX_VALUE; for (int i = -1; i &lt;= 1; i++) { for (int j = -1; j &lt;= 1; j++) { b[0] += i; b[1] += j; int d = b[1] - b[0]; int pre = b[1], now, cnt = 0; boolean flag = false; if (i != 0) cnt++; if (j != 0) cnt++; for (int k = 2; k &lt; n; k++) { now = pre + d; if (Math.abs(now - b[k]) &gt; 1) { flag = true; } else if (Math.abs(now - b[k]) == 1) { cnt++; } pre = now; } if (flag == false) { res = Math.min(res, cnt); } b[0] -= i; b[1] -= j; } } return res == Integer.MAX_VALUE ? -1 : res; }}","link":"/2020/08/31/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%89%9B%E7%89%9B%E6%9E%84%E9%80%A0%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97/"},{"title":"每日一题：物质分裂","text":"题目一个 $A$ 每天可以生产 $x1$ 个 $B$，$y1$ 个 $C$，一个 $B$ 每天可以生产 $x2$ 个 $A$，$y2$ 个 $C$，一个 $C$ 每天可以生产 $x3$ 个 $A$，$y3$ 个 $B$，最开始各有 $x,y,z$ 个，问 $n$ 天后各有多少个？ $n = 1e9$ Solution$B$ 和 $C$ 每天可以生产 $x2 + x3$ 个 $A$，那么第一天：$x$，第二天：$x(x2+x3)$，第三天：$(x(x2+x3))*(x2+x3)$ … 显然是等比数列求和。 Code12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod = 1e9 + 7;ll x, y, z, n, b1, c1, a1, c2, a2, b2;ll qp(ll a, ll b) { ll sum = 1; while (b) { if (b &amp; 1) sum = sum * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return sum;}int main() { cin &gt;&gt; x &gt;&gt; y &gt;&gt; z &gt;&gt; n; cin &gt;&gt; b1 &gt;&gt; c1 &gt;&gt; a1 &gt;&gt; c2 &gt;&gt; a2 &gt;&gt; b2; ll a = x * (1 - qp(a1 + a2, n + 1) + mod) * qp(1 - a1 - a2 + mod, mod - 2) % mod; ll b = y * (1 - qp(b1 + b2, n + 1) + mod) * qp(1 - b1 - b2 + mod, mod - 2) % mod; ll c = z * (1 - qp(c1 + c2, n + 1) + mod) * qp(1 - c1 - c2 + mod, mod - 2) % mod; cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; &quot; &quot; &lt;&lt; c &lt;&lt; endl; return 0;}","link":"/2020/08/27/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%89%A9%E8%B4%A8%E5%88%86%E8%A3%82/"},{"title":"每日一题：皇家烈焰（线性dp）","text":"题意现在帕秋莉告诉你一部分烈焰的分布情况，请你告诉她可能的情况有多少种 对于一个格子，里面会有以下几种字符： 0：这个格子没有烈焰，且其左右两个格子均没有烈焰 1：这个格子没有烈焰，且其左右两个格子中只有一个烈焰 2：这个格子没有烈焰，且其左右两个格子中均有烈焰 $*$：这个格子有烈焰 ?：未告诉你本格情况 solution$f[i][0/1][0/1]$表示前i位，当前位和下一位是（1）不是（0）烈焰的方案数 转移方程分情况讨论： 当$s[i]=’*’$时： $f[i][1][0]=(f[i-1][0][1]+f[i-1][1][1])$ $f[i][1][1]=(f[i-1][0][1]+f[i-1][1][1])$ 当$s[i]=’0’$时，上一位、当前位和下一位都得是0： $f[i][0][0]=f[i-1][0][0]$ 当s[i]=’1’时，上一位或下一位有一个是1： $f[i][0][1]=f[i-1][0][0]$ $f[i][0][0]=f[i-1][1][0]$ 当s[i]=’2’时，上一位和下一位都是1当前位是0： $f[i][0][1]=f[i-1][1][0]$ 当s[i]=’?’时： $f[i][1][0]=(f[i-1][0][1]+f[i-1][1][1])$ $f[i][1][1]=(f[i-1][0][1]+f[i-1][1][1])$ $f[i][0][0]=(f[i-1][0][0]+f[i-1][1][0])$ $f[i][0][1]=(f[i-1][0][0]+f[i-1][1][0])$ 初值$f[0][0][0] =1,f[0][0][1] = 1$ Code12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6 + 5;const int mod = 1e9 + 7;int dp[N][2][2];char s[N];int main() { cin &gt;&gt; s + 1; dp[0][0][0] = dp[0][0][1] = 1; int len = strlen(s + 1); for (int i = 1; i &lt;= len; i++) { if (s[i] == '0') dp[i][0][0] = dp[i - 1][0][0]; else if (s[i] == '1') { dp[i][0][0] = dp[i - 1][1][0]; dp[i][0][1] = dp[i - 1][0][0]; } else if (s[i] == '2') dp[i][0][1] = dp[i - 1][1][0]; else if (s[i] == '*') { dp[i][1][0] = (dp[i - 1][1][1] + dp[i - 1][0][1]) % mod; dp[i][1][1] = dp[i][1][0]; } else { dp[i][0][0] = (dp[i - 1][1][0] + dp[i - 1][0][0]) % mod; dp[i][0][1] = dp[i][0][0]; dp[i][1][0] = (dp[i - 1][0][1] + dp[i - 1][1][1]) % mod; dp[i][1][1] = dp[i][1][0]; } } cout &lt;&lt; (dp[len][1][0] + dp[len][0][0]) % mod &lt;&lt; '\\n'; return 0;}","link":"/2020/05/10/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%9A%87%E5%AE%B6%E7%83%88%E7%84%B0%EF%BC%88%E7%BA%BF%E6%80%A7dp%EF%BC%89/"},{"title":"每日一题：矩阵中最长递增路径（记忆化搜索）","text":"题意给定一个整数矩阵，找出最长递增路径的长度。 对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。 Solution记忆化搜索模板题。$dp[i][j]$记录之前已经计算得到的结果，之后直接读取即可。 Code123456789101112131415161718192021222324252627282930313233343536373839class Solution329 { /* [7,8,9] [9,7,6] [7,2,3] 输出：6 */ public int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; public int n, m; public int dfs(int[][] a, int[][] dp, int x, int y) { if(dp[x][y] != 0) return dp[x][y]; dp[x][y] = 1; for(int[] dir : dirs) { int fx = x + dir[0], fy = y + dir[1]; if(fx &gt;= 0 &amp;&amp; fx &lt; n &amp;&amp; fy &gt;= 0 &amp;&amp; fy &lt; m &amp;&amp; a[fx][fy] &gt; a[x][y]) dp[x][y] = Math.max(dp[x][y], dfs(a, dp, fx, fy) + 1); } return dp[x][y]; } public int longestIncreasingPath(int[][] a) { n = a.length; if(n == 0) return 0; m = a[0].length; int res = 1; int[][] dp = new int[n][m]; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; m; j++) { res = Math.max(res, dfs(a, dp, i, j)); } } return res; }}","link":"/2020/07/26/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84%EF%BC%88%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%EF%BC%89/"},{"title":"每日一题：竞赛图","text":"题目给定一个 $n$ 元有向完全图，每次操作可以翻转一条边。求最少的操作次数，使得图中不存在三元环。$(n &lt;= 10)$ Solution Code12345678910111213141516171819#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;int n, pre[20];char s[20][20];int main() { while (cin &gt;&gt; n) { for (int i = 0; i &lt; n; i++) cin &gt;&gt; s[i], pre[i] = i; int res = 1e9; do { int sum = 0; for (int i = 0; i &lt; n; i++) for (int j = i + 1; j &lt; n; j++) sum += s[pre[j]][pre[i]] &amp; 1; res = min(res, sum); } while (next_permutation(pre, pre + n)); cout &lt;&lt; res &lt;&lt; endl; } return 0;}","link":"/2020/08/26/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%AB%9E%E8%B5%9B%E5%9B%BE/"},{"title":"每日一题：简单瞎搞题 （STL）","text":"题意一共有 $n$ 个数，第 $i$ 个数是 $x_i$ 可以取 $[l_i , r_i]$ 中任意的一个值。设 $S = \\sum{ {x_i}^2}$，求 $S$ 种类数。（0 ~ n,l,r ~ 100） Solution$dp[i][j]$ 表示前 $i$ 个数能不能组成 $j$，可以得到转移方程：$dp[i][j]=dp[i-1][j-x^2]$，最后统计 $dp[n]$ 层组成的 $j$ 的数量即可。因为 dp 的值只有 0 和 1 ，因此使用 bitset 优化，把第二维看成二进制位，这样就可以用位移的形式来表示加法运算，得到转移方程：dp[i]=dp[i-1] &lt;&lt; (j*j)，复杂度 $10^{10}/64$。 Code1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;bitset&lt;1000005&gt; dp[105];int main() { int n, l, r; scanf(&quot;%d&quot;, &amp;n); dp[0][0] = 1; for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d%d&quot;, &amp;l, &amp;r); for (int j = l; j &lt;= r; j++) dp[i] |= dp[i - 1] &lt;&lt; (j * j); } printf(&quot;%lu\\n&quot;, dp[n].count()); return 0;}","link":"/2020/05/26/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%AE%80%E5%8D%95%E7%9E%8E%E6%90%9E%E9%A2%98-%EF%BC%88STL%EF%BC%89/"},{"title":"每日一题：粉刷匠（背包dp）","text":"题意n 条木板，每条木板都被分成 m 段且每一段都有要涂的颜色，有 t 次机会涂色，每次可以选择一条木板的连续一段涂成同一种颜色，问最多可以涂对多少段。 solution考虑四维dp的做法。$dp[i][j][k][0/1]$ 代表到第 $i$ 条第 $j$ 段时涂 $k$ 次，当前段涂红或蓝$(0/1)$的最大正确数，可以得到转移方程： 当 $j=1$ (属于当前木板第一段) 时，由上一个木板转移过来： $dp[i][j][k][0] = max(dp[i-1][m][k-1][0],dp[i-1][m][k-1][1]) + (s[i][j] == ‘0’)$ $dp[i][j][k][1] = max(dp[i-1][m][k-1][0],dp[i-1][m][k-1][1]) + (s[i][j] == ‘1’)$ 否则，由当前木板的上一段转移过来： $dp[i][j][k][0] = max(dp[i][j-1][k][0],dp[i][j-1][k-1][1]) + (s[i][j] == ‘0’)$ $dp[i][j][k][1] = max(dp[i][j-1][k-1][0],dp[i][j-1][k][1]) + (s[i][j] == ‘1’)$ 最后结果显然为 $max(dp[n][m][t][0], dp[n][m][t][1])$ 。 时间复杂度 $O(nmt)$，空间上可以使用滚动数组压维，空间复杂度为 $O(4mt)$。 Code123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 55;char s[N][N];int n, m, t, dp[2][N][N * N][2];int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;t); for (int i = 1; i &lt;= n; i++) scanf(&quot;%s&quot;, s[i] + 1); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) for (int k = 1; k &lt;= t; k++) for (int l = 0; l &lt;= 1; l++) { if (j == 1) dp[i &amp; 1][j][k][l] = max(dp[(i - 1) &amp; 1][m][k - 1][0], dp[(i - 1) &amp; 1][m][k - 1][1]) + (s[i][j] == l + '0'); else dp[i &amp; 1][j][k][l] = max(dp[i &amp; 1][j - 1][k][l], dp[i &amp; 1][j - 1][k - 1][l ^ 1]) + (s[i][j] == l + '0'); } printf(&quot;%d\\n&quot;, max(dp[n &amp; 1][m][t][0], dp[n &amp; 1][m][t][1])); return 0;}","link":"/2020/05/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%B2%89%E5%88%B7%E5%8C%A0%EF%BC%88%E8%83%8C%E5%8C%85dp%EF%BC%89/"},{"title":"每日一题：编辑距离","text":"题目给你两个单词 $a$ 和 $b$，请你计算出将 $a$ 转换成 $b$ 所使用的最少操作数。 你可以对一个单词进行如下三种操作： 插入一个字符 删除一个字符 替换一个字符 Solution$dp[i][j]$ 表示 $a$ 的前 $i$ 个字母和 $b$ 的前 $j$ 个字母匹配的最少操作次数。 可以从三种状态转移过来： $dp[i][j] = dp[i - 1][j] + 1$ 在 $b[j]$ 后面插入一个字符 $a[i]$ $dp[i][j] = dp[i][j - 1] + 1$ 在 $a[i]$ 后面插入一个字符 $b[j]$ $dp[i][j] = dp[i - 1][j - 1] + (a[i - 1] != b[j - 1])$ 修改一个字符 选择最小的操作步数进行转移即可。 Code123456789101112131415161718192021class Solution {public: int dp[1005][1005]; int minDistance(string a, string b) { int n = a.size(); int m = b.size(); for (int i = 0; i &lt;= n; i++) dp[i][0] = i; for (int i = 0; i &lt;= m; i++) dp[0][i] = i; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { int x = dp[i - 1][j] + 1; // 在 b[j] 后面插入一个字符 a[i] int y = dp[i][j - 1] + 1; // 在 a[i] 后面插入一个字符 b[j] int z = dp[i - 1][j - 1] + (a[i - 1] != b[j - 1]); // 修改一个字符 dp[i][j] = min({x, y, z}); } } return dp[n][m]; }};","link":"/2020/10/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"},{"title":"每日一题：美味菜肴","text":"题意$n$ 件食材（每种食材的数量可以视为无限），小明连续工作 $T$ 时间。每道菜肴的制作需要特定的一种食材以及一段时间，但是食材一旦放久就不新鲜了，菜的美味值会降低。第 $i$ 道菜肴有三个属性 $ai$，$bi$，$ci$，$ai$ 是该菜肴的美味值，$bi$ 是该菜肴所选食材不新鲜的速率，如果在第t时刻完成第i道菜则美味值为：$ai-t*bi$，完成这道菜需要 $ci$ 的时间。求在这 $T$ 时间内能做出菜肴使得总美味值的最大值。 solution首先需要贪心确定顺序，考虑只有两道菜，可以得到：$a_i−b_i∗c_i+(a_j−b_j∗(c_i+c_j))&gt;=a_j−b_j∗c_j+(a_i−b_i∗(c_i+c_j))$，化简后得到：$b_i∗c_i&gt;=b_j∗c_i$。排序后背包即可（需要降维）。 Code12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll INF = 0x3ffffffffffff;const int N = 2e5 + 5;struct Node { ll a, b, c;} q[N];ll res = -INF, s[N], dp[N];bool cmp(Node x, Node y) { return x.c * s[y.a] &lt; y.c * s[x.a]; }int main() { int n, m, t; cin &gt;&gt; n &gt;&gt; m &gt;&gt; t; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; s[i]; for (int i = 1; i &lt;= m; i++) cin &gt;&gt; q[i].a &gt;&gt; q[i].b &gt;&gt; q[i].c; sort(q + 1, q + m + 1, cmp); for (int i = 1; i &lt;= t; i++) dp[i] = -INF; for (int i = 1; i &lt;= m; i++) for (int j = t; j &gt;= q[i].c; j--) dp[j] = max(dp[j], dp[j - q[i].c] + q[i].b - j * s[q[i].a]); for (int i = 1; i &lt;= t; i++) res = max(res, dp[i]); cout &lt;&lt; res &lt;&lt; '\\n'; return 0;}","link":"/2020/04/27/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%BE%8E%E5%91%B3%E8%8F%9C%E8%82%B4/"},{"title":"每日一题：至少被一个元素整除的数个数","text":"题目给定一个 $m$ 个元素的集合，问 $1-n$ 中有多少个数能被集合中至少一个元素整除。$(n &lt;= 1e9, m &lt;= 20)$ Solution容斥原理，二进制枚举集合的所有子集，求子集的 $lcm$，如果子集大小是奇数，则 $res += n / lcm$，否则 $res-= n / lcm$。 Code123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long longLL a[40];int main() { LL N, M, ans = 0, gd; scanf(&quot;%d%d&quot;, &amp;N, &amp;M); for (int i = 1; i &lt;= M; i++) { scanf(&quot;%d&quot;, &amp;a[i - 1]); } LL F = (1 &lt;&lt; M) - 1; for (int i = 1; i &lt;= F; i++) { LL cnt = 0; for (int j = 0; j &lt; M; j++) { if (i &amp; (1 &lt;&lt; j)) { cnt++; if (cnt == 1) gd = a[j]; else gd = gd * a[j] / (__gcd(a[j], gd)); } } if (cnt &amp; 1) { ans += N / gd; } else ans -= N / gd; } printf(&quot;%d\\n&quot;, ans); return 0;}","link":"/2020/09/02/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%87%B3%E5%B0%91%E8%A2%AB%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E6%95%B4%E9%99%A4%E7%9A%84%E6%95%B0%E4%B8%AA%E6%95%B0/"},{"title":"课程安排（状压dp）","text":"题意：让你安排课程，保证每学期的课不能冲突，问最少需要几个学期。 solution： 因为 n 只有15，可以考虑状压dp。用二进制每位的1/0表示当前是否学习该课程，可以得到 n 个二进制位，那么所有的可能性有 1&lt;&lt;n 种，预处理 g[s] 表示 s 所代表课程的是否可以在一个学期内学完（对于当前要学的所有课程的学时进行标记，若有重复标记则不可能在一学期学完），f[s] 维护学完当前课程所花费的最少学期，枚举子集进行转移。答案的状态应该是所有课全部修完，即 $f[(1&lt;&lt;n)-1]$。时间复杂度 $O(2^n m n)$。 Code1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1 &lt;&lt; 15;int n, m, sum, f[N], g[N], b[20], a[20][105], vis[105];bool check(int x) { memset(vis, 0, sizeof(vis)); for (int i = 0; i &lt; n; i++) { if (x &gt;&gt; i &amp; 1) { for (int j = 1; j &lt;= b[i]; j++) { if (vis[a[i][j]]) return false; vis[a[i][j]] = 1; } } } return true;}int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; b[i]; for (int j = 1; j &lt;= b[i]; j++) cin &gt;&gt; a[i][j]; } memset(f, 0x3f, sizeof(f)); // 因为要维护最小值，因此初值赋为最大值 f[0] = 0; // 学完 0 门课需要 0 个学期 sum = (1 &lt;&lt; n) - 1; // 每门课代表一个二进制位，枚举所有可能共有 1&lt;&lt;n 种 for (int s = 0; s &lt;= sum; ++s) { g[s] = check(s); // 验证 s 是否能在一个学期内学完 for (int t = s; t; t = (t - 1) &amp; s) // 从之前的状态（子集）进行转移 if (g[t]) f[s] = min(f[s], f[s ^ t] + 1); // 可以在一个学期学完，则维护最小值 } cout &lt;&lt; f[sum] &lt;&lt; '\\n'; return 0;}","link":"/2020/05/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%AF%BE%E7%A8%8B%E5%AE%89%E6%8E%92%EF%BC%88%E7%8A%B6%E5%8E%8Bdp%EF%BC%89/"},{"title":"每日一题：货币系统 （背包dp）","text":"题意$n$ 种面额货币，数量无限，问最多保留几种，使得原来可以组成的仍然可以组成。（$t&lt;=20,n&lt;=100,a[i]&lt;=25000$） solution由于大的只会被小的组成，所以先排序，对于存在性问题就显然是完全背包了，dp[i] 表示是否能表示出 $i$ 价值，得到状态转移方程：$dp[i]|=dp[i-a[i]]$，对于已经可以表示出来对 $a[i]$，已经可以由小的组成，因此不需要在枚举。 Code12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;int t, n, res, a[105], dp[300005];int main() { cin &gt;&gt; t; while (t--) { cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; sort(a + 1, a + n + 1); memset(dp, 0, sizeof(dp)); res = 0; dp[0] = 1; for (int i = 1; i &lt;= n; i++) { if (!dp[a[i]]) { res++; for (int j = a[i]; j &lt;= a[n]; j++) dp[j] |= dp[j - a[i]]; } } cout &lt;&lt; res &lt;&lt; '\\n'; } return 0;}","link":"/2020/05/29/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%B4%A7%E5%B8%81%E7%B3%BB%E7%BB%9F-%EF%BC%88%E8%83%8C%E5%8C%85dp%EF%BC%89/"},{"title":"每日一题：过河 离散化+dp","text":"题意：桥长度为$L$ ，分布有$n$ 个石子，青蛙每次可以跳 $[S,T]$ 的距离,问青蛙过桥至少要踩多少个石子。 $(1&lt;=S,T&lt;=10,m&lt;=100,a_i&lt;=10^9, a_i 表示第i个石子的位置)$ solution这是个很显然的dp题，难点在于他的 $a_i$ 达到了 $10^9$ ，所以我们需要压缩一下。 当 $s==t$ 时，答案就是位置能被 $s$ 整除的石子个数。 当 $s!=t$ 时，我们可以发现：假设当前位置为 $x$ ，那么 $x+s*t$ 之后的所有位置是一定可以被走到的。（可以看做是 $s$ 个 $t$ 步相加或 $t$ 个 $s$ 步相加，然后调整某些步的长度即可。） 然后，石子之间的距离就被压缩了，只要相邻的两个石子距离 $&gt;=st$ 的变成 $st$ 即可。 但是这样一压缩，最后的落点就不能确定了，但是起点是已知的，所以干脆倒过来dp。 状态转移方程： i 点有石子：$dp[i] = min(dp[i], dp[i+j]+1)$ i 点无石子：$dp[i] = min(dp[i], dp[i+j])$ Code12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5;int l, s, t, n, dis, res, a[N], dp[N], vis[N];int main() { cin &gt;&gt; l &gt;&gt; s &gt;&gt; t &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; if (s == t) { for (int i = 1; i &lt;= n; i++) { if (a[i] % s == 0) res++; } cout &lt;&lt; res &lt;&lt; '\\n'; return 0; } sort(a + 1, a + n + 1); int len = s * t; for (int i = 1; i &lt;= n; i++) { int d = a[i] - a[i - 1]; if (d &gt; len) d = len; dis += d; vis[dis] = 1; } for (int i = dis; i &gt;= 0; i--) { dp[i] = 100; for (int j = s; j &lt;= t; j++) { dp[i] = min(dp[i], dp[i + j] + vis[i]); } } cout &lt;&lt; dp[0] &lt;&lt; '\\n'; return 0;}","link":"/2020/05/13/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%BF%87%E6%B2%B3-%E7%A6%BB%E6%95%A3%E5%8C%96-dp/"},{"title":"每日一题：连通两组点的最小成本","text":"题意给你两组点，其中第一组中有 $size1$ 个点，第二组中有 $size2$ 个点，且 $size1 &gt;= size2$。 任意两点间的连接成本 $cost$ 由大小为 size1 x size2 矩阵给出，其中 $cost[i][j]$ 是第一组中的点 $i$ 和第二组中的点 $j$ 的连接成本。如果两个组中的每个点都与另一组中的一个或多个点连接，则称这两组点是连通的。换言之，第一组中的每个点必须至少与第二组中的一个点连接，且第二组中的每个点必须至少与第一组中的一个点连接。 返回连通两组点所需的最小成本。 Solution$dp[i][j]$ 表示左部前 $i$ 个点连接右部(1&lt;&lt;m)的情况，状态转移方程：dp[i][now | 1 &lt;&lt; j] = min({dpnow | 1 &lt;&lt; j, dp[i - 1][j] + cost[i - 1]j + 当前点连接右边第j个点}, dp[i][j] + cost[i - 1]j + 当前点连接右边第j个点))。 Code1234567891011121314151617181920class Solution { public int connectTwoGroups(List&lt;List&lt;Integer&gt;&gt; cost) { int n = cost.size(); int m = cost.get(0).size(); int all = 1 &lt;&lt; m; int[][] dp = new int[n + 1][all]; for (int i = 0; i &lt;= n; i++) { Arrays.fill(dp[i], 2000000000); } dp[0][0] = 0; for (int i = 1; i &lt;= n; i++) { for (int now = 0; now &lt; all; now++) { for (int j = 0; j &lt; m; j++) { dp[i][now | 1 &lt;&lt; j] = Math.min(dp[i][now | 1 &lt;&lt; j], Math.min(dp[i - 1][now] + cost.get(i - 1).get(j), dp[i][now] + cost.get(i - 1).get(j))); } } } return dp[n][all - 1]; }}","link":"/2020/09/25/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%BF%9E%E9%80%9A%E4%B8%A4%E7%BB%84%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E6%88%90%E6%9C%AC/"},{"title":"每日一题：逆序对","text":"题意题意很简单，求长度为n的01串逆序对数量和。( n &lt;= 1e18 ) solution任意选两个位置 $i, j$ $(i &lt; j)$，令 $a[i] = 1, a[j] = 0$，这样一定能产生逆序对，这样有 $C_n^2$ 种选法。剩下的位置随便放，有$2^{n-2}$种选法，总方案数即为答案。( 注意 1 需要特判 ) 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod = 1e9 + 7;ll qp(ll a, ll b) { if (b == -1) return 0; ll ans = 1; while (b) { if (b &amp; 1) ans = ans * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return ans;}int main() { ll n, res; cin &gt;&gt; n; res = (((n % mod) * ((n - 1) % mod) / 2 % mod) * qp(2, n - 2) % mod); cout &lt;&lt; res &lt;&lt; '\\n'; return 0;}","link":"/2020/04/20/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E9%80%86%E5%BA%8F%E5%AF%B9/"},{"title":"每日一题：队列之和","text":"题目给你两个队列$a$和$b$，问你能否构造出给定的队列$c$。 Solutuon很经典的动态规划，$dp[i][j]$ 表示第一个队列的前 $i$ 个数和第二个队列的第 $j$ 个数能否组成第三个队列的前 $i+j$ 个数。状态转移方程：$dp[i][j] = (dp[i - 1][j]$ $and$ $a[i] == c[i + j]$ $or$ $dp[i][j - 1]$ $and$ $b[j] == c[i + j])$。 Code1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;int dp[1005][1005], T, A, B, a[1005], b[1005], c[2005];int main() { scanf(&quot;%d&quot;, &amp;T); while (T--) { scanf(&quot;%d%d&quot;, &amp;A, &amp;B); for (int i = 1; i &lt;= A; i++) scanf(&quot;%d&quot;, &amp;a[i]); for (int i = 1; i &lt;= B; i++) scanf(&quot;%d&quot;, &amp;b[i]); for (int i = 1; i &lt;= A + B; i++) scanf(&quot;%d&quot;, &amp;c[i]); memset(dp, 0, sizeof(dp)); dp[0][0] = 1; for (int t = 1; t &lt;= A + B; t++) { for (int i = 0; i &lt;= A; i++) { int j = t - i; if (j &lt; 0 || j &gt; B) continue; if (i &amp;&amp; c[t] == a[i] &amp;&amp; dp[i - 1][j]) dp[i][j] = 1; if (j &amp;&amp; c[t] == b[j] &amp;&amp; dp[i][j - 1]) dp[i][j] = 1; } } if (dp[A][B]) puts(&quot;possible&quot;); else puts(&quot;not possible&quot;); } return 0;}","link":"/2020/08/19/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E9%98%9F%E5%88%97%E4%B9%8B%E5%92%8C/"},{"title":"每日一题：高度不超过m的二叉树个数","text":"题目求 $n$ 个节点，高度不超过 $h$ 的二叉树的个数，结果模 $1e9 + 7$。 Solution定义 $f[i][j]$ 为 $i$ 个点组成高度不超过 $j$ 的二叉树的数量，则得到状态转移方程：$f[i][j] = f[k][j-1] * f[i-k-1][j-1]$，表示即选出一个根节点，两边子树高度不超过 $j - 1$ 的数量，初始状态为 $f[0][i] = 1$。 Code12345678910111213141516#include &lt;cstdio&gt;typedef long long ll;const ll mod = 1e9 + 7;int n, h;ll f[100][100];int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;h); for (int i = 0; i &lt;= n; i++) f[0][i] = 1; for (int j = 1; j &lt;= n; j++) for (int i = 1; i &lt;= n; i++) for (int k = 0; k &lt; i; k++) f[i][j] = (f[i][j] + f[k][j - 1] * f[i - k - 1][j - 1]) % mod; printf(&quot;%lld&quot;, f[n][h]); return 0;}","link":"/2020/08/17/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E9%AB%98%E5%BA%A6%E4%B8%8D%E8%B6%85%E8%BF%87m%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AA%E6%95%B0/"},{"title":"牛客国庆集训day1","text":"A. ABB题意在给定的字符串后面最少添加多少个字符可以让整个字符串变成一个回文字符串$(n \\in [1, 4e5])$。 Solution等价于求包含最后一个字符的最长回文子串，可以用前后遍历两次哈希解决。 Code12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;const ull base = 13331;const int N = 5e5 + 5;int n, len, res;char s[N];ull r, l[N], b[N];int main() { scanf(&quot;%d%s&quot;, &amp;n, s + 1); b[0] = 1; for (int i = 1; i &lt;= n; i++) b[i] = b[i - 1] * base; for (int i = 1; i &lt;= n; i++) l[i] = l[i - 1] * base + s[i]; for (int i = n; i &gt;= 1; i--) { r = r * base + s[i]; len++; if (i &gt;= len) { ull now1 = l[i] - l[i - len] * b[len]; if (now1 == r) res = max(res, len * 2 - 1); } if (i &gt;= len + 1) { ull now2 = l[i - 1] - l[i - 1 - len] * b[len]; if (now2 == r) res = max(res, len * 2); } } printf(&quot;%d\\n&quot;, n - res); return 0;} C. Bob in Wonderland题意把一棵树变为一条链的最少操作次数$(n \\in [1, 3e5])$。 Solution其实就是不断把度大于2的点转移到头或者尾，因此答案就是所有度数大于2的点减去2的和。 Code1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;int n, x, y, res, d[500005];int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt; n; i++) { scanf(&quot;%d%d&quot;, &amp;x, &amp;y); d[x]++; d[y]++; } for (int i = 1; i &lt;= n; i++) res += max(d[i] - 2, 0); printf(&quot;%d\\n&quot;, res); return 0;} E. Zeldain Garden题意求给定区间内所有数的因子个数和$(n \\in [1, 1e12])$。 Solution打表发现 $1-n$ 内因子个数和就是 $n / i$ 的和 $(i \\in [1, n])$，然后用除法分块解决。 Code123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll solve(ll n) { ll sum = n; for (ll i = 2; i &lt;= n;) { ll x = n / i; ll y = min(n / x, n); sum += x * (y - i + 1); i = y + 1; } return sum;}int main() { ll a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; solve(b) - solve(a - 1) &lt;&lt; endl; return 0;} F. Light Emitting Hindenburg题意从 $n$ 个正整数中选出k个数字使得进行按位与操作得到的结果最大$(n \\in [1, 2e5])$。 Solution考虑二进制位，当且仅当 $k$ 个数字该位都为1，位与结果才为1。因此从高位开始枚举二进制位，当该位为1的数量超过 $k$ 时，剔除所有不为1的数，最后剩下的数即为可以选择的数，且这些数无论怎么选择 $k$ 个，位与结果都相同。 Code12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5;int n, k, a[N], vis[N];int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;a[i]); for (int i = 30; i &gt;= 0; i--) { int cnt = 0; for (int j = 0; j &lt; n; j++) { if ((a[j] &gt;&gt; i) &amp; 1 &amp;&amp; !vis[j]) cnt++; } if (cnt &gt;= k) { for (int j = 0; j &lt; n; j++) { if (!((a[j] &gt;&gt; i) &amp; 1)) vis[j] = 1; } } } int res = -1; for (int i = 0; i &lt; n; i++) { if (!vis[i]) res &amp;= a[i]; } printf(&quot;%d\\n&quot;, res); return 0;} H. Ponk Warshall题意两个字符串s, t仅包含ATCG，求s最少经过多少次交换可以变为t$(n \\in [1, 1e6])$。 Solution按四种优先级讨论： 同一个位置字符相同，直接跳过无需交换。 交换一次，使得两个字符直接匹配。 交换两次，使得三个字符直接匹配。 交换三次，使得四个字符直接匹配。 数组 $cnt[i][j]$ 表示每个字符的对应关系，按优先级计算累加答案即可。 Code123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;int n, res, mp[200], cnt[4][4];int main() { string s, t; cin &gt;&gt; s &gt;&gt; t; n = s.size(); mp['A'] = 0, mp['T'] = 1, mp['C'] = 2, mp['G'] = 3; for (int i = 0; i &lt; n; i++) { if (s[i] != t[i]) cnt[mp[s[i]]][mp[t[i]]]++; } for (int i = 0; i &lt; 4; i++) { for (int j = 0; j &lt; i; j++) { int x = min(cnt[i][j], cnt[j][i]); res += x; cnt[i][j] -= x, cnt[j][i] -= x; } } for (int i = 0; i &lt; 4; i++) { for (int j = 0; j &lt; i; j++) { for (int k = 0; k &lt; j; k++) { int x = min(cnt[i][j], min(cnt[j][k], cnt[k][i])); int y = min(cnt[i][k], min(cnt[k][j], cnt[j][i])); res += (x + y) * 2; cnt[i][j] -= x, cnt[j][k] -= x, cnt[k][i] -= x; cnt[i][k] -= y, cnt[k][j] -= y, cnt[j][i] -= y; } } } for (int i = 0; i &lt; 4; i++) res += cnt[0][i] * 3; cout &lt;&lt; res &lt;&lt; endl; return 0;}","link":"/2020/10/01/%E7%89%9B%E5%AE%A2%E5%9B%BD%E5%BA%86%E9%9B%86%E8%AE%ADday1/"},{"title":"牛客多校2020第二场补题","text":"F Fake Maxpooling题意规定矩阵对应的值为其下标的 $lcm$ ，求所有 $k * k$ 子矩阵最大值之和。 $( n,m,k = 5000 )$ Solution线性求 $lcm$ + 二维单调队列 线性求 $lcm$ ： 123456789for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) { if (!g[i][j]) { for (int h = 1; h * i &lt;= n &amp;&amp; h * j &lt;= m; h++) { g[h * i][h * j] = h; a[h * i][h * j] = i * j * h; } } } 先对每一行进行单调队列（滑动窗口）维护出最大值矩阵 $g$ ，再对列进行单调队列维护矩阵 $g$ 的最大值即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5005;int n, m, k, a[N][N], g[N][N];long long res;int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) { if (!g[i][j]) { for (int h = 1; h * i &lt;= n &amp;&amp; h * j &lt;= m; h++) { g[h * i][h * j] = h; a[h * i][h * j] = i * j * h; } } } for (int i = 1; i &lt;= n; i++) { deque&lt;int&gt; q; for (int j = 1; j &lt;= m; j++) { while (!q.empty() &amp;&amp; a[i][q.back()] &lt; a[i][j]) q.pop_back(); while (!q.empty() &amp;&amp; j - q.front() &gt;= k) q.pop_front(); q.push_back(j); if (j &gt;= k) g[i][j] = a[i][q.front()]; } } for (int i = k; i &lt;= m; i++) { deque&lt;int&gt; q; for (int j = 1; j &lt;= n; j++) { while (!q.empty() &amp;&amp; g[q.back()][i] &lt; g[j][i]) q.pop_back(); while (!q.empty() &amp;&amp; j - q.front() &gt;= k) q.pop_front(); q.push_back(j); if (j &gt;= k) { a[j][i] = g[q.front()][i]; res += a[j][i]; } } } printf(&quot;%lld\\n&quot;, res); return 0;} C Cover the Tree题意给定无根树，用最少的链覆盖树的所有点。 $( n = 2e5 )$ Solution思维 + dfs序 首先不难想到所取的链两个端点都在叶子上才会是最优的，因此答案应为 $(叶子结点数 + 1)/2$ 。 经过一番玄学证明，得到结论为按 dfs序 构造链会是最优的，任取非叶子结点为根，由 dfs序 得到叶子结点 $l1, l_2 ….l_x$ ，然后将 $l_1$ 与 $l{x/2+1}$ 构成链以此类推，若多出一个点，则与根结点连起来即可。 Code1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5;int n, u, v, root, de[N];vector&lt;int&gt; g[N], res;void dfs(int u, int fa) { if (de[u] == 1) res.push_back(u); for (auto v : g[u]) { if (v == fa) continue; dfs(v, u); }}int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt; n; i++) { scanf(&quot;%d%d&quot;, &amp;u, &amp;v); g[u].push_back(v); g[v].push_back(u); de[u]++; de[v]++; } for (int i = 1; i &lt;= n; i++) { if (de[i] &gt; 1) root = i; } dfs(root, -1); n = res.size(); if (n &amp; 1) res.push_back(root), n++; n &gt;&gt;= 1; printf(&quot;%d\\n&quot;, n); for (int i = 0; i &lt; n; i++) printf(&quot;%d %d\\n&quot;, res[i], res[i + n]); return 0;} B Boundary题意已知一个圆必过点 $(0,0)$ ，需要构造该圆使得尽可能多的给定点在该圆的边界上，问最多能有几个点。 $( n = 2000, |x,y| = 100000 )$ Solution三个点可以确定一个圆，因此不妨枚举两个点，求出圆心，圆心重合次数最多的即为答案。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2005;int n, res;double X, Y, R;struct Point { double x, y;} p[N];map&lt;pair&lt;double, double&gt;, int&gt; mp;bool solve(Point a, Point b, Point c) //三点共圆圆心公式{ if (2 * (a.y - c.y) * (a.x - b.x) - 2 * (a.y - b.y) * (a.x - c.x) == 0 &amp;&amp; 2 * (a.y - b.y) * (a.x - c.x) - 2 * (a.y - c.y) * (a.x - b.x) == 0) return false; X = ((a.x * a.x - b.x * b.x + a.y * a.y - b.y * b.y) * (a.y - c.y) - (a.x * a.x - c.x * c.x + a.y * a.y - c.y * c.y) * (a.y - b.y)) / (2 * (a.y - c.y) * (a.x - b.x) - 2 * (a.y - b.y) * (a.x - c.x)); Y = ((a.x * a.x - b.x * b.x + a.y * a.y - b.y * b.y) * (a.x - c.x) - (a.x * a.x - c.x * c.x + a.y * a.y - c.y * c.y) * (a.x - b.x)) / (2 * (a.y - b.y) * (a.x - c.x) - 2 * (a.y - c.y) * (a.x - b.x)); R = sqrt((X - a.x) * (X - a.x) + (Y - a.y) * (Y - a.y)); return true;}int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) scanf(&quot;%lf%lf&quot;, &amp;p[i].x, &amp;p[i].y); Point o = {0, 0}; for (int i = 1; i &lt; n; i++) { mp.clear(); for (int j = i + 1; j &lt;= n; j++) { if (solve(o, p[i], p[j])) { auto now = make_pair(X, Y); res = max(res, ++mp[now]); } } } printf(&quot;%d\\n&quot;, ++res); return 0;} J Just Shuffle题意一个排列经过质数次置换后得到排列 A ，求原排列。 ( n = 1e5 ) Solution直接拍个置换开根板子就过了。。。 Code1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1000010;int n, m, i, j, k, o, x, l, d, a[N], g[N], nxt[N], t, q[N], b[N], ans[N];bool v[N];int cal(int x) { int i, k = m, t = 1; for (i = 2; i * i &lt;= x; i++) if (x % i == 0) { while (x % i == 0) x /= i, t *= i; while (k % i == 0) k /= i, t *= i; } if (x &gt; 1) for (t *= x; k % x == 0; k /= x, t *= x) ; return t;}int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]); for (i = 1; i &lt;= n; i++) if (!v[i]) { t = v[i] = 1; for (j = a[i]; j != i; j = a[j]) v[j] = 1, t++; nxt[i] = g[t], g[t] = i; } for (i = 1; i &lt;= n; i++) if (g[i]) { for (t = 0, j = g[i]; j; j = nxt[j]) q[++t] = j; d = __gcd(l = cal(i), m); if (t % d) return puts(&quot;1&quot;), 0; for (x = 1; x &lt;= t; x += d) { for (j = 0; j &lt; d; j++) for (k = 0, o = q[x + j]; k &lt; i; k++, o = a[o]) b[(j + 1LL * k * m) % l] = o; for (j = 0; j &lt; l; j++) ans[b[j]] = b[(j + 1) % l]; } } for (i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, ans[i]);}","link":"/2020/07/14/%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A12020%E7%AC%AC%E4%BA%8C%E5%9C%BA%E8%A1%A5%E9%A2%98/"},{"title":"红黑树","text":"","link":"/2020/10/05/%E7%BA%A2%E9%BB%91%E6%A0%91/"},{"title":"设计模式：单例模式","text":"什么是单例模式单例模式，顾名思义，就是整个系统就只有一个实例存在。 特点 单例类只能有一个实例。 单例类必须自己创建自己的唯一实例。 单例类必须给所有其他对象提供这一实例。 讲的通俗一点，我们拿女娲造人来举例： 我们先写一个女娲类： 123public class N_Wa {} 很明显，任何人都不能创造女娲，所以女娲的构造应该是私有的： 123public class N_Wa { private N_Wa() {} // 构造方法私有化} 有人可能要质疑：那女娲应该是谁创造的？这个问题千百万年来都没有人能解开过，所以在我们的潜意识中认为：神是自己创造自己的！ 1234public class N_Wa { private static final N_Wa n_wa = new N_Wa(); // 神自己创造自己 private N_Wa() {} // 构造方法私有化} private 保证了女娲的私有性，毕竟这个世界上没有人见过女娲。static 保证了女娲的静态性，她与类共存亡。final 保证了女娲是“终极”常量，不可能再被修改。 女娲已经出来了，接下来干什么呢？当然就是请她开始造人啦： 1234567public class N_Wa { private static final N_Wa n_wa = new N_Wa(); // 神自己创造自己 private N_Wa() {} // 构造方法私有化 public static N_Wa getInstance() { // 请求女娲 return n_wa; }} getInstance 和 new？new 是重新创建一个对象，且只能单次使用。getInstance 是没有对象的时候创建对象，有了之后就保留在内存中，下次就不用再重新创建了，因此它的对象一定是static的。 这样一来，只需要调用 N_Wa.getInstance(); 女娲就请过来了，而且不论是谁，请来的都是同一个女娲，也就是我们构造的“终极”常量：n_wa。当然你还可以往里面加入其它的功能（造人功能未写出）。 到此为止，我们就已经学会了单例模式——“饿汉模式”，即我们先把女娲给造好，需要的时候直接用就好了。 随之而来的是另一个问题：要是我们根本没有用到女娲呢？那不是白造了？于是又出现了一种叫“懒汉模式”： 12345678910public class N_Wa { private static N_Wa n_wa; // 这里并没有new一个女娲 private N_Wa() {} // 构造方法私有化 public static N_Wa getInstance() { // 请求女娲 if(n_wa == null) { n_wa = new N_Wa(); } return n_wa; }} 可以发现，我们不再是提前造女娲了，而是需要的时候再去造她（实例化），但这样子的坏处就是每次都要重新造一次女娲，所以速度肯定不如之前的“饿汉模式”。而且有个大问题，就是一旦有很多人同时请女娲的话，依然可能造成多个神的情况。 所以我们让这些人排队？看起来挺有道理，但仔细想想，有些人做事总是拖拖拉拉，毛手毛脚的，万一给让它排到前面去了，那后面的人不得等半天吗？等下队伍直接排出地球外了，所以我们干脆让他们直接抢，谁抢到就是谁的，这样一直抢下去： 1234567891011121314public class N_Wa { private static N_Wa n_wa; // 这里并没有new一个女娲 private N_Wa() {} // 构造方法私有化 public static N_Wa getInstance() { // 请求女娲 if(n_wa == null){ // 代表还没有人抢到 synchronized (N_Wa.class) { // 放他们进去抢 if(n_wa == null) { // 第一个抢到的给他 new一个然后返回 n_wa = new N_Wa(); } } } return n_wa; }} synchronized 是一种同步锁，可以防止同步发生，通俗来讲就是第一个人先用，这时锁被锁上，等他用完，锁再打开，以此类推。只有当锁是开着的，才能轮到下一个人。 到此为止，最基础的两种“恶汉模式”和“懒汉模式”就完成了，单例模式还有其它的一些变种，但思想上都大同小异，我们需要灵活运用，发挥出最大的价值！","link":"/2020/09/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"title":"设计模式：策略模式","text":"定义定义一种算法，将每个算法都封装起来，并且使它们之间可以互换。是一种行为类模式。 举例为了通俗易懂，我们拿各国的税率计算来举例子： 假设当前我们的程序只能支持计算中国和美国的税率：12345678910public class Tax_Cal { public int CN_Cal(int x) { // 计算中国税 } public int US_Cal(int x) { // 计算美国税 }}这样写看起来没什么问题，但实际上我们想想，如果以后公司还要拓展，开始支持法国，日本等等国家，那么我们这个类就得不断但改啊改，是不是特别麻烦且危险？比如万一和前面的某个国家冲突了，就会影响到前面的计算。 所以我们干脆分开来写，把所有的国家税的计算都独立出来，实现的都是同一个接口，都有一个共同的参数x。 1234567891011121314151617181920212223242526272829303132public class Strategy { // 策略模式 public int Cal(int x);}public class CN_Tax implements Strategy { // 实现中国税计算接口 @Override public int Cal(int x) { }}public class US_Tax implements Strategy { // 实现美国税计算接口 @jOverride public int Cal(int x) { }}public class Tax_Cal { // 税计算类 private Strategy = strategy; // 定义一个策略 public void setStrategy(Strategy strategy) { // 接入策略 this.strategy = strategy; } public int getTax(int x) { // 得到结果 return this.strategy.cal }} 这样一来，所有的税务计算就互不影响啦，因为它们的计算已经被我们独立出来了，要计算哪一个国家的税，只需要接入该国家的算法，调用一下getTax就可以了。我们来写一下： 1234567public class Test { public static void main(string[] args) { Tax_Cal tax_cal = new Tax_Cal(); // 实例化对象 tax_cal.setStrategy(new CN_Tax()); // 接入中国税计算 int res = tax_cal.getTax(100); // 得到结果 }} 这样就实现了中国的税计算。由此可见，这样设计是更有策略性的，以后要有新的国家加入，不需要再修改原代码，只需要再实现一个新的国家接口就可以了。 总结：优点： 策略间可以自由的切换，因为它们都实现自同一个抽象。 易于拓展，基本上可以在不改变原有代码的基础上进行拓展。 避免使用多重条件语句，否则就得一直if else, switch case，这样非常不利于维护。 策略模式是一种简单常用的设计模式，一般来说不会单独使用，而是和其它模式混合使用。","link":"/2020/09/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"title":"静态代码块，构造代码块，构造函数及其执行顺序和逻辑","text":"静态代码块： 随着类的加载而执行，只执行一次，并优先于主函数。具体说，静态代码块是由类调用的。类调用时，先执行静态代码块，然后才执行主函数的。 静态代码块其实就是给类初始化的，而构造代码块是给对象初始化的。 静态代码块中的变量是局部变量，与普通函数中的局部变量性质没有区别。 一个类中可以有多个静态代码块（顺序由上至下）。 构造代码块 构造代码块的作用是给对象进行初始化。 对象一建立就运行构造代码块了，而且优先于构造函数执行。这里要强调一下，有对象建立，才会运行构造代码块，类不能调用构造代码块的，而且构造代码块与构造函数的执行顺序是前者先于后者执行。 构造代码块与构造函数的区别是：构造代码块是给所有对象进行统一初始化，而构造函数是给对应的对象初始化，因为构造函数是可以多个的，运行哪个构造函数就会建立什么样的对象，但无论建立哪个对象，都会先执行相同的构造代码块。也就是说，构造代码块中定义的是不同对象共性的初始化内容。 构造函数 对象一建立，就会调用与之相应的构造函数，也就是说，不建立对象，构造函数是不会运行的。 构造函数的作用是用于给对象进行初始化。 一个对象建立，构造函数只运行一次，而一般方法可以被该对象调用多次。 Java类初始化顺序 单一类：静态变量，静态代码块 &gt; 变量，构造代码块 &gt; 构造函数12345678910111213141516171819202122232425262728293031public class Test06 { public static String x = &quot;静态变量&quot;; public String y = &quot;变量&quot;; public Test06() { System.out.println(&quot;构造函数&quot;); } static { System.out.println(x); System.out.println(&quot;静态代码块&quot;); } { System.out.println(y); System.out.println(&quot;构造代码块&quot;); } public static void main(String[] args) { /* 输出：静态变量 静态代码块 */ Test06 test06 = new Test06(); /* 输出：变量 构造代码块 构造函数 */ }} 继承情况：父类静态 &gt; 子类静态 &gt; 父类构造代码块 &gt; 父类构造函数 &gt; 子类构造代码块 &gt; 子类构造函数 静态变量是属于类的，和继承无关！！！ 1234567891011121314151617181920212223242526272829303132333435363738394041public class Test06 { public Test06() { System.out.println(&quot;父类构造函数&quot;); } static { System.out.println(&quot;父类静态代码块&quot;); } { System.out.println(&quot;父类构造代码块&quot;); }}class Test06_1 extends Test06 { public Test06_1() { System.out.println(&quot;子类构造函数&quot;); } static { System.out.println(&quot;子类静态代码块&quot;); } { System.out.println(&quot;子类构造代码块&quot;); } public static void main(String[] args) { /* 输出：父类静态代码块 子类静态代码块 */ Test06_1 test06_1 = new Test06_1(); /* 输出：父类构造代码块 父类构造函数 子类构造代码块 子类构造函数 */ }} 练习12345678910111213141516171819202122232425262728293031323334public class StaticTest { public static void main(String[] args) { staticFunction(); } // 静态变量（有实例化的过程,这就是本题的重点） static StaticTest st = new StaticTest(); static { //System.out.println(b); // 编译报错：因为b在构造代码块后边，此处不能引用。因此Java代码是从上到下的顺序 System.out.println(&quot;1&quot;); } { System.out.println(&quot;2&quot;); } StaticTest() { System.out.println(&quot;3&quot;); System.out.println(&quot;a=&quot; + a + &quot;,b=&quot; + b); } public static void staticFunction() { System.out.println(&quot;4&quot;); } // 这两个变量写在最后面 int a = 110; static int b = 112;}/* 输出：2 3 a=110,b=0 1 4*/ 先初始化静态变量，也就是执行new StaticTest()，先执行构造代码块，输出 2 再执行构造函数，输出 3 和 a=110,b=0 在执行构造函数前，必须初始化实例属性，故 a = 110 静态变量从上到下初始化，还没有轮到，因此 b = 0 执行静态代码块，输出 1 最后进入main函数，执行静态方法staticFunction，输出 4 可以发现：static变量并不一定在实例化变量前被初始化。 父类和子类有同名属性时public class Test07 { public static void main(String[] args) { // 使用多态 Parent chidParent = new Child(); System.out.println(&quot;Parent:&quot; + chidParent.getAge()); //40 System.out.println(&quot;Parent:&quot; + chidParent.age); //18 System.out.println(&quot;Parent:&quot; + chidParent.id); //08 // 直接使用原本类型 Child child = new Child(); System.out.println(&quot;Child:&quot; + child.getAge()); //40 System.out.println(&quot;Child:&quot; + child.age); //40 System.out.println(&quot;Child:&quot; + child.id); //8 } } class Child extends Parent { public Integer age = 40; public Integer id = 8; public int getAge() { return age; } } class Parent { public Integer age = 18; public String id = &quot;08&quot;; public int getAge() { return age; } } 对于输出 18 的解释（Java的继承机制）： 属性属于实例自己的，所以Parent的age属性值是18 属性不存在覆盖（即使同名），而方法是实实在在的覆盖（复写）","link":"/2020/07/17/%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%8C%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E5%92%8C%E9%80%BB%E8%BE%91/"},{"title":"继承，虚函数和多态","text":"继承 with virtual function构造由内而外：首先调用父类的构造函数，然后再调用自己。析构由外而内：首先执行自己的析构函数，然后调用父类的析构函数。 non-virtual: 你不希望重新定义（重写）它。virtual: 你希望子类重新定义它，且它有默认定义。pure virtual: 你希望子类一定要重新它，你对它没有默认定义。 123456789class Shape { public: virtual void draw() const = 0; // 纯虚函数 virtual void error(const std::string&amp; msg); // 虚函数 int objectID() const; // 一般成员函数};class Rectangle: public Shape {...};class Ellipse: public Shape {...};","link":"/2020/09/30/%E7%BB%A7%E6%89%BF-%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81/"},{"title":"计算机网络知识点","text":"OSI模型OSI七层模型是一种框架性的设计方法，建立七层模型的主要目的是为解决异种网络互连时所遇到的兼容性问题，其最主要的功能就是帮助不同类型的主机实现数据传输。它的最大优点是将服务、接口和协议这三个概念明确地区分开来，通过七个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯。 OSI七层参考模型的各个层次的划分遵循下列原则： 同一层中的各网络节点都有相同的层次结构，具有同样的功能。 同一节点内相邻层之间通过接口（可以是逻辑接口）进行通信。 七层结构中的每一层使用下一层提供的服务，并且向其上层提供服务。 不同节点的同等层按照协议实现对等层之间的通信。 各层简介物理层主要任务是在物理媒体上实现比特流的透明传输。传输单位是比特。 透明传输：不管所传数据是什么样的比特组合，都应当能够在链路上传送。 主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换），这一层的数据叫做比特。 定义接口特性 定义传输模式：单工，半双工，双工 定义传输速率 比特同步 比特编码 数据链路层主要任务是把网络层传下来的数据报组装成帧。传输单位是帧。 负责物理传输的准备。在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路，通过差错控制提供数据帧（Frame）在信道上无差错的传输，并进行各电路上的动作系列。数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。在这一层，数据的单位称为帧（frame）。数据链路层协议的代表包括：SDLC、HDLC、PPP、STP、帧中继等。MAC地址和交换机在这一层。 成帧：定义帧的开始和结束 差错控制：帧错+位错 流量控制 访问（接入）控制：控制对信道的访问 网络层主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务。网络层的传输单位是数据报。 在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点，确保数据及时传送。网络层将数据链路层提供的帧组成数据包，包中封装有网络层包头，其中含有逻辑地址信息- -源站点和目的站点地址的网络地址。如果你在谈论一个IP地址，那么你是在处理第3层的问题，这是“数据包”问题，而不是第2层的“帧”。IP是第3层问题的一部分，此外还有一些路由协议和地 址解析协议（ARP）。有关路由的一切事情都在这第3层处理。地址解析和路由是3层的重要目的。网络层还可以实现拥塞控制、网际互连等功能。在这一层，数据的单位称为数据包（packet）。网络层协议的代表包括：IP、IPX、RIP、OSPF等。负责管理网络地址、定位设备、决定路由，路由器工作在这层。包括用户数据包，路由更新包。 路由选择：最佳路径 流量控制：控制发送端的速度 差错控制：查错 拥塞控制：若所有结点都来不及接受分组，而要丢弃大量分组的话，网络就处于拥塞状态。因此要采取一定措施，缓解这种拥塞。 传输层负责主机中两个进程的通信，即端到端的通信。传输单位是报文段或用户数据报。 OSI中最重要的一层，负责分割组合数据，实现端到端的逻辑连接。第4层的数据单元也称作数据包（packets）。但是，当你谈论TCP等具体的协议时又有特殊的叫法，TCP的数据单元称为段 （segments）而UDP协议的数据单元称为“数据报（datagrams）”。这个层负责获取全部信息，因此，它必须跟踪数据单元碎片、乱序到达的 数据包和其它在传输过程中可能发生的危险。第4层为上层提供端到端（最终用户到最终用户）的透明的、可靠的数据传输服务。所为透明的传输是指在通信过程中 传输层对上层屏蔽了通信传输系统的具体细节。传输层协议的代表包括：TCP、UDP、SPX等。 可靠传输，不可靠传输 差错控制 流量控制 复用分用 会话层向表示层实体/用户进程提供建立连接并连接上有序地传输数据。 负责在网络中两个节点间建立、维护、控制会话，区分不同的会话，以及提供单工、半双工、全双工三种通信模式服务。通过传输层（端口号：传输端口与接收端口）建立数据传输的通路，主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）。NFS、X Windows、RPC都在这一层。 建立，管理，终止会话 适用于校验点可使会话在通信失效时从校验点/同步点继续恢复通信，实现数据同步。（适用于传输大文件） 表示层用于处理在两个通信系统中交换信息的表示方式（语法和语义）。 可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码（EBCDIC），而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。这一层主要解决信息的语法表示问题。它将欲交换的数据从适合于某一用户的抽象语法，转换为适合于OSI系统内部使用的传送语法。即提供格式化的表示和转换数据服务，数据的压缩和解压缩，加密和解密等工作都由表示层负责。 数据格式变换 数据加密解密 数据压缩和恢复 应用层所有能和用户交互产生网络流量的程序。（比如QQ，邮箱等） 是最靠近用户的OSI层，这一层为用户的操作系统或应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。应用层协议的代表包括：Telnet、FTP、HTTP、SNMP等。 TCP/IP模型 是最基本的Internet协议，有网络层的IP和传输层的TCP构成。指TCP/IP协议簇。 分为四层，每一层都呼叫他的下一层所提供的网络来实现自己的需求。 网络接口层负责实际数据的传输，对应于OSI的物理层和数据链路层，常见协议有Ethernet 802.3 、Token Ring 802.5、X.25等。 网络层负责网络间寻址，数据传输，对应于OSI网络层。 传输层负责可靠的传输服务，对应于OSI传输层。 应用层负责一切与应用程序有关的功能，对应于OSI上三层。 属于TCP/IP协议簇的所有协议都位于该模型的上面三层。","link":"/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"title":"12种Java中常用的语法糖","text":"什么是语法糖语法糖（Syntactic Sugar），也称糖衣语法，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。简而言之，语法糖让程序更加简洁，有更高的可读性。 解语法糖前面提到过，语法糖的存在主要是方便开发人员使用。但其实，Java虚拟机并不支持这些语法糖。这些语法糖在编译阶段就会被还原成简单的基础语法结构，这个过程就是解语法糖。说到编译，大家肯定都知道，Java语言中，javac命令可以将后缀名为.java的源文件编译为后缀名为.class的可以运行于Java虚拟机的字节码。如果你去看com.sun.tools.javac.main.JavaCompiler的源码，你会发现在compile()中有一个步骤就是调用desugar()，这个方法就是负责解语法糖的实现的。Java 中最常用的语法糖主要有泛型、变长参数、条件编译、自动拆装箱、内部类等。 糖块一： switch 支持 String 与枚举从Java 7 开始，switch 开始支持 String。其实Java中的switch自身原本就支持基本类型。比如int、char等。对于int类型，直接进行数值的比较。对于char类型则是比较其 ascii 码。 所以，对于编译器来说，switch中其实只能使用整型，任何类型的比较都要转换成整型。比如byte。short，char(ascii码是整型)以及int。 那么接下来看下 switch 对 String 的支持，有以下代码： 123456789101112131415public class SwitchTest { public static void main(String[] args) { String s = &quot;Shuke&quot;; switch (s) { case &quot;Shuke&quot;: System.out.println(&quot;Shuke&quot;); break; case &quot;Bata&quot;: System.out.println(&quot;Bata&quot;); break; default: break; } }} 反编译后的内容如下： 1234567891011121314151617181920212223242526272829public class SwitchTest { public SwitchTest() { } public static void main(String[] args) { String s = &quot;Shuke&quot;; byte var3 = -1; switch(s.hashCode()) { case 2063116: if (s.equals(&quot;Bata&quot;)) { var3 = 1; } break; case 79866362: if (s.equals(&quot;Shuke&quot;)) { var3 = 0; } } switch(var3) { case 0: System.out.println(&quot;Shuke&quot;); break; case 1: System.out.println(&quot;Bata&quot;); } }} 可以发现字符串的switch是通过equals()和hashCode()方法来实现的，hashCode()方法返回的是int，而不是long。 进行switch的实际是哈希值，然后通过使用equals方法比较进行安全检查，这个检查是必要的，因为哈希可能会发生碰撞。 糖块二： 泛型很多语言都是支持泛型的，但不同的编译器对于泛型的处理方式是不同的。 通常情况下，一个编译器处理泛型有两种方式：Code specialization和Code sharing。 C++和C#是使用Code specialization的处理机制，而Java使用的是Code sharing的机制。 Code sharing方式为每个泛型类型创建唯一的字节码表示，并且将该泛型类型的实例都映射到这个唯一的字节码表示上。将多种泛型类形实例映射到唯一的字节码表示是通过类型擦除（type erasue）实现的。 也就是说，对于Java虚拟机来说，它根本不认识 Map&lt;String, String&gt; map 这样的语法。需要在编译阶段通过类型擦除的方式进行解语法糖。 类型擦除的主要过程如下： 将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。 移除所有的类型参数。 例如: 1234Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();map.put(&quot;111&quot;, &quot;222&quot;);map.put(&quot;333&quot;, &quot;444&quot;);map.put(&quot;555&quot;, &quot;666&quot;); 解语法糖后： 1234Map map = new HashMap();map.put(&quot;111&quot;, &quot;222&quot;);map.put(&quot;333&quot;, &quot;444&quot;);map.put(&quot;555&quot;, &quot;666&quot;); 虚拟机中没有泛型，只有普通类和普通方法，所有泛型类的类型参数在编译时都会被擦除，并没有自己独有的 Class 类对象。比如并不存在 List&lt;String&gt;.class 或是List&lt;Integer&gt;.class，而只有 List.class。 补充： 当泛型遇到重载 12345678 public class GenericTypes { public static void method(List&lt;String&gt; list) { System.out.println(&quot;invoke method(List&lt;String&gt; list)&quot;); } public static void method(List&lt;Integer&gt; list) { System.out.println(&quot;invoke method(List&lt;Integer&gt; list)&quot;); }} 上面这段代码，有两个重载的函数，因为他们的参数类型不同，但是，这段代码是编译不通过的。因为参数 List 和 List 编译之后都被擦除了，变成了一样的原生类型 List，擦除动作导致这两个方法的特征签名变得一模一样。 当泛型遇到catch 泛型的类型参数不能用在 Java 异常处理的 catch 语句中。因为异常处理是由JVM在运行时刻来进行的。由于类型信息被擦除，JVM是无法区分两个异常类型 MyException&lt;String&gt; 和 MyException&lt;Integer&gt; 的。 当泛型内包含静态变量 12345678910111213141516public class StaticTest { public static void main(String[] args) { GT&lt;Integer&gt; gti = new GT&lt;Integer&gt;(); gti.var = 1; GT&lt;String&gt; gts = new GT&lt;String&gt;(); gts.var = 2; System.out.println(gti.var); }}class GT&lt;T&gt; { public static int var = 0; public void nothing(T x) { }} 以上代码输出结果为：2 !!! 由于经过类型擦除，所有的泛型类实例都关联到同一份字节码上，泛型类的所有静态变量是共享的。 糖块三： 自动装箱与拆箱自动装箱就是Java自动将原始类型值转换成对应的对象，比如将int的变量转换成Integer对象，这个过程叫做装箱，反之将Integer对象转换成int类型值，这个过程叫做拆箱。 因为这里的装箱和拆箱是自动进行的非人为转换，所以就称作为自动装箱和拆箱。 原始类型byte, short, char, int, long, float, double 和 boolean 对应的封装类为Byte, Short, Character, Integer, Long, Float, Double, Boolean。 先来看个自动装箱的代码： 1234public static void main(String[] args) { int i = 10; Integer n = i;} 反编译后代码如下: 12345public static void main(String args[]){ int i = 10; Integer n = Integer.valueOf(i);} 再来看个自动拆箱的代码： 1234public static void main(String[] args) { Integer i = 10; int n = i;} 反编译后代码如下： 12345public static void main(String args[]){ Integer i = Integer.valueOf(10); int n = i.intValue();} 从反编译得到内容可以看出，装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的。 补充： 自动装箱与拆箱——对象相等比较： 12345678public static void main(String[] args) { Integer a = 1000; Integer b = 1000; Integer c = 100; Integer d = 100; System.out.println(&quot;a == b is &quot; + (a == b)); System.out.println((&quot;c == d is &quot; + (c == d)));} 在Java 5中，在Integer的操作上引入了一个新功能来节省内存和提高性能。整型对象通过使用相同的对象引用实现了缓存和重用。适用于整数值区间-128 至 +127。只适用于自动装箱。使用构造函数创建对象不适用。数据会被自动装箱成包装类，JVM在比较之前会看在不在常量池范围内，在就字面量比较，不在就比较地址值。 糖块四： 方法变长参数可变参数(variable arguments)是在Java 1.5中引入的一个特性。它允许一个方法把任意数量的值作为参数。 看下以下可变参数代码，其中print方法接收可变参数： 1234567891011public static void main(String[] args){ print(&quot;111&quot;, &quot;222&quot;, &quot;333&quot;, &quot;444&quot;);}public static void print(String... strs){ for (int i = 0; i &lt; strs.length; i++) { System.out.println(strs[i]); }} 反编译后得到： 1234567891011public static void main(String args[]){ print(new String[] { &quot;111&quot;, &quot;222&quot;, &quot;333&quot;, &quot;444&quot; });}public static transient void print(String strs[]){ for(int i = 0; i &lt; strs.length; i++) System.out.println(strs[i]);} 从反编译后代码可以看出，可变参数在被使用的时候，他首先会创建一个数组，数组的长度就是调用该方法是传递的实参的个数，然后再把参数值全部放到这个数组当中，然后再把这个数组作为参数传递到被调用的方法中。 糖块五： 枚举Java SE5 提供了一种新的类型 — Java的枚举类型，关键字enum可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用，这是一种非常有用的功能。enumn就和 class 一样，只是一个关键字，并不是一个类。 123public enum t { SPRING,SUMMER;} 反编译后： 123456789101112131415161718192021222324252627282930public final class T extends Enum{ private T(String s, int i) { super(s, i); } public static T[] values() { T at[]; int i; T at1[]; System.arraycopy(at = ENUM$VALUES, 0, at1 = new T[i = at.length], 0, i); return at1; } public static T valueOf(String s) { return (T)Enum.valueOf(demo/T, s); } public static final T SPRING; public static final T SUMMER; private static final T ENUM$VALUES[]; static { SPRING = new T(&quot;SPRING&quot;, 0); SUMMER = new T(&quot;SUMMER&quot;, 1); ENUM$VALUES = (new T[] { SPRING, SUMMER }); }} public final class T extends Enum 说明该类是继承了Enum类的，同时final关键字意味着这个类也是不能被继承的。 当我们使用enmu来定义一个枚举类型的时候，编译器会自动帮我们创建一个final类型的类继承Enum类，所以枚举类型不能被继承。 糖块六： 内部类内部类又称为嵌套类，可以把内部类理解为外部类的一个普通成员。内部类之所以也是语法糖，是因为它仅仅是一个编译时的概念。 比如在 A.java 里面定义了一个内部类 B，一旦编译成功，就会生成两个完全不同的.class文件，分别是 A.class 和 A$B.class。所以内部类的名字完全可以和它的外部类名字相同。 一个类对应一个.class文件，多个类嵌套就会有多个.class文件。 糖块七：条件编译一般情况下，程序中的每一行代码都要参加编译。但有时候出于对程序代码优化的考虑，希望只对其中一部分内容进行编译，此时就需要在程序中加上条件，让编译器只对满足条件的代码进行编译，将不满足条件的代码舍弃，这就是条件编译。 123456789101112public class ConditionalCompilation { public static void main(String[] args) { final boolean DEBUG = true; if(DEBUG) { System.out.println(&quot;Hello, DEBUG!&quot;); } final boolean ONLINE = false; if(ONLINE){ System.out.println(&quot;Hello, ONLINE!&quot;); } }} 反编译后代码如下： 12345678910public class ConditionalCompilation { public ConditionalCompilation() { } public static void main(String[] args) { boolean DEBUG = true; System.out.println(&quot;Hello, DEBUG!&quot;); boolean ONLINE = false; }} 首先，我们发现，在反编译后的代码中没有 System.out.println(“Hello, ONLINE!”);，这其实就是条件编译。当 if(ONLINE) 为 false 的时候，编译器就没有对其内的代码进行编译。 所以，Java语法的条件编译，是通过判断条件为常量的 if 语句实现的。根据 if 判断条件的真假，编译器直接把分支为 false 的代码块消除。通过该方式实现的条件编译，必须在方法体内实现，而无法在正整个Java类的结构或者类的属性上进行条件编译。 糖块八： 断言在Java中，assert关键字是从JAVA SE 1.4 引入的，为了避免和老版本的Java代码中使用了assert关键字导致错误，Java在执行的时候默认是不启动断言检查的（这个时候，所有的断言语句都将忽略！）。如果要开启断言检查，则需要用开关 -enableassertions 或 -ea来开启。 assert关键字语法很简单，有两种用法： assert boolean表达式 如果为true，则程序继续执行。 如果为false，则程序抛出AssertionError，并终止执行。 assert boolean表达式 : 错误信息表达式 如果为true，则程序继续执行。 如果为false，则程序抛出java.lang.AssertionError，并输入\\&lt;错误信息表达式&gt;。 例：1234567891011public class AssertFoo { public static void main(String args[]) { //断言1结果为true，则继续往下执行 assert true; System.out.println(&quot;断言1没有问题，Go！&quot;); System.out.println(&quot;\\n-----------------\\n&quot;); //断言2结果为false,程序终止 assert false : &quot;断言失败，此表达式的信息将会在抛出异常的时候输出！&quot;; System.out.println(&quot;断言2没有问题，Go！&quot;); }}开启-ea开关，执行程序： 12345C:\\&gt;java -ea AssertFoo断言1没有问题，Go！-----------------Exception in thread &quot;main&quot; java.lang.AssertionError: 断言失败，此表达式的信息将会在抛出异常的时候输出！at AssertFoo.main(AssertFoo.java:10) 其实断言的底层实现就是 if 语言，如果断言结果为 true，则什么都不做，程序继续执行，如果断言结果为 false，则程序抛出 AssertionError 来打断程序的执行。 糖块十： for-each12345678public class ForEachTest { public static void main(String... args) { String[] strs = {&quot;111&quot;, &quot;222&quot;, &quot;333&quot;}; for (String s : strs) { System.out.println(s); } }} 反编译后代码如下： 12345678910111213141516public class ForEachTest { public ForEachTest() { } public static void main(String... args) { String[] strs = new String[]{&quot;111&quot;, &quot;222&quot;, &quot;333&quot;}; String[] var2 = strs; int var3 = strs.length; for(int var4 = 0; var4 &lt; var3; ++var4) { String s = var2[var4]; System.out.println(s); } }} for-each 的实现原理其实就是使用了普通的 for 循环和迭代器。 补充： 1234for (Student stu : students) { if (stu.getId() == 2) students.remove(stu); } 会抛出ConcurrentModificationException异常。 Iterator是工作在一个独立的线程中，并且拥有一个 mutex 锁。 Iterator被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，这个索引表的内容不会同步改变，所以当索引指针往后移动的时候就找不到要迭代的对象，所以按照 fail-fast 原则 Iterator 会马上抛出 java.util.ConcurrentModificationException 异常。 所以 Iterator 在工作的时候是不允许被迭代的对象被改变的。但你可以使用 Iterator 本身的方法remove()来删除对象，Iterator.remove() 方法会在删除当前迭代对象的同时维护索引的一致性。 糖块十一： try-with-resourceJava里，对于文件操作IO流、数据库连接等开销非常昂贵的资源，用完之后必须及时通过close方法将其关闭，否则资源会一直处于打开状态，可能会导致内存泄露等问题。 关闭资源的常用方式就是在 finally 块里是释放，即调用 close 方法。比如，我们经常会写这样的代码： 1234567891011121314151617181920public static void main(String[] args) { BufferedReader br = null; try { String line; br = new BufferedReader(new FileReader(&quot;xxx&quot;)); while ((line = br.readLine()) != null) { System.out.println(line); } } catch (IOException e) { // handle exception } finally { try { if (br != null) { br.close(); } } catch (IOException ex) { // handle exception } }} 从Java 7开始，jdk 提供了一种更好的方式关闭资源，使用 try-with-resources 语句，改写一下上面的代码，效果如下： 12345678910public static void main(String... args) { try (BufferedReader br = new BufferedReader(new FileReader(&quot;xxx&quot;))) { String line; while ((line = br.readLine()) != null) { System.out.println(line); } } catch (IOException e) { // handle exception }} 其实背后的原理也很简单，那些我们没有做的关闭资源的操作，编译器都帮我们做了。 糖块十二： Lambda表达式Labmda 表达式不是匿名内部类的语法糖，但是他也是一个语法糖。实现方式其实是依赖了几个 JVM 底层提供的 lambda 相关 api。 它并不是内部类的语法糖，前面讲内部类我们说过，内部类在编译之后会有对应的 class 文件，但是，包含 lambda 表达式的类编译后只有一个文件。","link":"/2020/09/01/12%E7%A7%8DJava%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96/"},{"title":"Java 注解与反射","text":"注解 Annotation作用 对程序作出解释（类似于注释） 可以被其他程序读取（如：编译器等） 使用方式 注解以 “@注释名” 形式存在，如 “@Override”，有些可以添加一些参数值，如 “@SuppressWarnings(value=”unchecked”)” 附加在package，class，method，field等上方，等于给他们添加额外辅助信息，我们可以通过反射机制编程实现对这些元数据的访问 内置注解 @Override: 此注释只适用于修饰方法，表示一个方法声明打算重写超类中的另一个方法声明 @SuppressWarnings: 用于抑制编译时的警告信息(Warning)，需要添加参数才能使用，如：(“all”),(“unchecked”),(value={“unchecked”,”deprecation”})等等 元注解元注解作用就是负责注解其他注解，Java定义了4个标准的meta-annotation类型，他们被用来提供对其他annotation类型作说明 @Target: 用于描述注解的使用范围（被描述的注解可以用在什么地方） @Retention: 表示需要在什么级别保存该注释信息，用于描述注解的生命周期(SOURCE &lt; CLASS &lt; RUNTIME) @Document: 说明该注解将被包含在javadoc中 @Inherited: 说明子类可以继承父类中的该注解 自定义注解使用@interface自定义注解时，自动继承java.lang.annotation.Annotation接口 @interface用来声明一个注释，格式：@interface 注解名 { 定义内容 } 其中的每一个方法实际上是声明了一个配置参数 方法的名称就是参数的名称 返回值类型就是参数的类型，返回值只能是基本类型(Class, String, enum) 可以通过default来声明参数的默认值 如果只有一个参数成员，一般参数名为value 注解必须要有值，我们定义注解元素时，经常使用空字符串或者0来作为默认值(default) 1234567891011121314151617181920212223242526public class Test01 { // 注解可以显示赋值，没有先后顺序之分，如果没有默认值，就必须给注解赋值 @MyAnnotation01(id = 1, age = 18, name = &quot;Benboby&quot;) public void test01() {} // 当注解只有一个参数时，默认定义为 value() , 则可以省略 &quot;value = &quot; @MyAnnotation02(&quot;Benboby&quot;) public void test02() {}}@Target({ElementType.TYPE, ElementType.METHOD}) // 作用域可以在类上或者方法上@Retention(RetentionPolicy.RUNTIME) // 在运行时有效@interface MyAnnotation01 { // 注解的参数：参数类型 + 参数名() (+ 默认值); String name() default &quot;&quot;; int age(); int id(); String[] schools() default {&quot;本科&quot;,&quot;带专&quot;};}@Target({ElementType.TYPE, ElementType.METHOD}) // 作用域可以在类上或者方法上@Retention(RetentionPolicy.RUNTIME) // 在运行时有效@interface MyAnnotation02 { String value();}反射（Java Reflection）动态 VS 静态语言动态语言：运行时代码可以根据某些条件改变自身结构。如：C#, JavaScript, PHP, Python等。12345function f() { // var 是万能类型 var x = &quot;var a=1; var b=2; alert(a+b)&quot;; // 可以认为目前是字符串类型 eval(x) // 执行 x ，x 变为 a+b 的值}静态语言：运行时结构不可改变的语言就是静态语言。如：Java, C, C++。 Java不是动态语言，但Java有一定的动态性，我们可以利用反射机制获得类似动态语言的特性，使得Java在编程的时候变得更灵活。 简介Reflection是Java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。 加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构，这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射。 正常方式： 引入需要的“包类”名称 -&gt; 通过new实例化 -&gt; 取得实例化对象反射方式： 实例化对象 -&gt; getClass()方法 -&gt; 得到完整的“包类”名称 优点：可以实现创建对象和编译，体现出很大的灵活性缺点：对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于直接执行相同的操作。 123456789public class Test02 { public static void main(String[] args) throws ClassNotFoundException { // 通过反射获取对象类的Class对象 Class c1 = Class.forName(&quot;pers.Shuke.reflection.User&quot;); System.out.println(c1); // 输出：class pers.Shuke.reflection.User }}class User {...} Class类在Object类中定义了以下的方法，此方法将所有子类继承：public final Class getClass() 以上方法的返回值类型是一个Class类，此类是Java反射的源头，即：可以通过对象反射求出类名称。 获取Class类型的几种方式12345678910111213141516171819202122232425262728public class Test03 { public static void main(String[] args) throws ClassNotFoundException { Person person = new Student(); // 方式1：通过对象获得 Class c1 = person.getClass(); // 方式2：forname获得 Class c2 = Class.forName(&quot;pers.Shuke.reflection.Student&quot;); // 方式3：通过类名.class获得 Class c3 = Student.class; System.out.println(c3); // c1 = c2 = c3 = &quot;class pers.Shuke.reflection.Student&quot; // 方式4：基本内置类型的包装类都有一个Type属性 Class c4 = Integer.TYPE; // c4 = int // 方式5： Class c5 = c1.getSuperclass(); // c5 = &quot;class pers.Shuke.reflection.Person&quot; System.out.println(c5); }}class Person {...}class Student extends Person {...}class Teacher extends Person {...} 所有类型的Class对象1234567891011121314151617181920public class Test04 { public static void main(String[] args) { Class c1 = Object.class; // 类 c1 = &quot;class java.lang.Object&quot; Class c2 = Comparable.class; // 接口 c2 = &quot;interface java.lang.Comparable&quot; Class c3 = String[].class; // 一维数组 c3 = &quot;class [Ljava.lang.String;&quot; Class c4 = int[][].class; // 二维数组 c4 = &quot;class [[I&quot; Class c5 = Override.class; // 注解 c5 = &quot;interface java.lang.Override&quot; Class c6 = ElementType.class; // 枚举 c6 = &quot;class java.lang.annotation.ElementType&quot; Class c7 = Integer.class; // 基本数据类型 c7 = &quot;class java.lang.Integer&quot; Class c8 = void.class; // void c8 = &quot;void&quot; Class c9 = Class.class; // Class c9 = &quot;class java.lang.Class&quot; int[] a = new int[10]; int[] b = new int[100]; Class c10 = a.getClass(); Class c11 = b.getClass(); // c10 = c11 // 只有元素类型与维度一样，就是同一个Class }} Java内存分析简介堆：存放new的对象和数组，可以被所有的线程共享，不会存放别的对象引用栈：存放基本变量类型（包含具体数值），引用对象的变量（会存放这个引用在堆里面的具体地址）方法区：可以被所有的线程共享，包含所有的class和static变量 类的加载过程当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过以下三个步骤来对该类进行初始化。 类的加载(Load)：将类的class文件读入内存，并为之创建一个java.lang.Class对象。此过程由类加载器完成。 类的连接(Link)：将类的二进制数据合并到JRE中。 类的初始化(Initialize)：JVM负责对类进行初始化。 类的初始化 类的主动引用（一定会发生类的初始化） 当虚拟机启动，先初始化main方法所在的类 new一个类的对象 调用类的静态成员（除了final常量）和静态方法 使用java.lang.reflect包的方法对类进行反射调用 当初始化一个类，如果其父类没有被初始化，则会先初始化他的父类 类的被动引用 当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类初始化 通过数组定义类引用，不会触发此类的初始化 引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 测试类什么时候会被初始化public class Test08 { static { System.out.println(&quot;main类被加载&quot;); } public static void main(String[] args) throws ClassNotFoundException { // 主动调用 //Son son = new Son(); /* main类被加载 父类被加载 子类被加载 */ // 通过反射 //Class.forName(&quot;pers.Shuke.Initialization.Son&quot;); /* main类被加载 父类被加载 子类被加载 */ // 引用父类常量 //System.out.println(Son.b); /* main类被加载 父类被加载 2 */ // 引用自身常量 //System.out.println(Son.m); /* main类被加载 父类被加载 子类被加载 100 */ // 定义数组 //Son[] array = new Son[5]; /* main类被加载 */ // 引用final常量 //System.out.println(Son.f); /* main类被加载 10 */ }}class Father { static int b = 2; static { System.out.println(&quot;父类被加载&quot;); }}class Son extends Father { static{ System.out.println(&quot;子类被加载&quot;); m = 300; } static int m = 100; static final int f = 10;} 类加载器的作用类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据转化成方法区的运行时数据结构，然后在堆中生成一个代表这个类的Class对象，作为方法区中类数据的访问入口。 类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，他将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象。 源程序(.java文件) -&gt; Java编译器 -&gt; 字节码(.class文件) -&gt; 类装载器 -&gt; 字节码校验器 -&gt; 解释器 -&gt; 操作系统平台 1234567891011121314151617181920212223242526public class Test09 { public static void main(String[] args) throws ClassNotFoundException { // 获取系统类加载器 ClassLoader classLoader = ClassLoader.getSystemClassLoader(); System.out.println(classLoader); // 输出：jdk.internal.loader.ClassLoaders$AppClassLoader@3d4eac69 // 获取系统类父类的加载器 -&gt; 拓展类加载器 ClassLoader parent = classLoader.getParent(); System.out.println(parent); // 输出：jdk.internal.loader.ClassLoaders$PlatformClassLoader@77459877 // 获取拓展类加载器的父类加载器 -&gt; 引导类加载器/根加载器（C/C++） ClassLoader root = parent.getParent(); System.out.println(root); // 输出：null （无法直接获取） // 测试当前类是哪个加载器加载的 ClassLoader classLoader1 = Class.forName(&quot;pers.Shuke.Initialization.Test09&quot;).getClassLoader(); System.out.println(classLoader1); // 输出：jdk.internal.loader.ClassLoaders$AppClassLoader@3d4eac69 // 测试jdk内置的类是哪个加载器加载的 ClassLoader classLoader2 = Class.forName(&quot;java.lang.Object&quot;).getClassLoader(); System.out.println(classLoader2); // 输出：null // 如何获得系统类加载器可以加载的路径 System.out.println(System.getProperty(&quot;java.class.path&quot;)); }} 获取类的运行时结构通过反射获取类运行时的完整结构： 实现的全部接口（Interface） 所继承的父类（Superclass） 全部的构造器（Constructor） 全部的方法（Method） 全部的Field 注解 … PS：public/private/protected区别（默认为friendly） 作用域 当前类 同一public 子孙类 其他package public 1 1 1 1 protected 1 1 1 0 friendly 1 1 0 0 private 1 0 0 0 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Test05 { public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, NoSuchMethodException { Class c1 = Class.forName(&quot;pers.Shuke.reflection.User&quot;); System.out.println(c1.getName()); // 输出：pers.Shuke.reflection.User System.out.println(c1.getSimpleName()); // 输出：User User user = new User(); c1 = user.getClass(); System.out.println(c1.getName()); // 输出：pers.Shuke.reflection.User System.out.println(c1.getSimpleName()); // 输出：User Field[] fields = c1.getFields(); // 输出：null 解释：只能找到public属性 fields = c1.getDeclaredFields(); /* private java.lang.String pers.Shuke.reflection.User.name private int pers.Shuke.reflection.User.age private int pers.Shuke.reflection.User.id 解释：可以找到全部属性 */ for(Field field : fields) { System.out.println(field); } // 获得指定属性的值 //Field name = c1.getField(&quot;name&quot;); // 报错：只能获取public对象 Field name = c1.getDeclaredField(&quot;name&quot;); // 输出：private java.lang.String pers.Shuke.reflection.User.name System.out.println(name); // 获取类的方法 Method[] methods = c1.getMethods(); // 获取本类和父类所有public方法 methods = c1.getDeclaredMethods(); // 获取本类所有方法 for(Method method : methods) { System.out.println(method); } // 获取类的指定方法(需要传参) Method getname = c1.getMethod(&quot;getName&quot;, null); Method setname = c1.getMethod(&quot;setName&quot;, String.class); System.out.println(getname); // 输出：public java.lang.String pers.Shuke.reflection.User.getName() System.out.println(setname); // 输出：public void pers.Shuke.reflection.User.setName(java.lang.String) // 获得指定的构造器 Constructor[] constructors = c1.getConstructors(); // 获取public构造器 constructors = c1.getDeclaredConstructors(); // 获取指定构造器 // 获得指定构造器 Constructor constructor = c1.getDeclaredConstructor(String.class, int.class, int.class); System.out.println(constructor); // 输出：public pers.Shuke.reflection.User(java.lang.String,int,int) }} 动态创建对象执行方法创建类的对象：有无参构造器：调用Class对象的newInstance()方法 类必须有一个无参数构造器 类的构造器的访问权限要足够 没有无参构造器： 通过Class类的getDeclaredConstructor()取得本类的指定形参类型的构造器 向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的哥哥参数 通过Constructor 调用指定的方法：通过反射，调用类中的方法，通过Method完成。 通过Class类的getMethod()方法取得一个Method对象，并设置此方法操作时所需要的参数类型。 之后使用Object invoke()进行调用，并向方法中传递需要设置的obj对象的参数信息。 setAccessible： Method，Field和Constructor对象都有setAccessible()方法 作用为启动和禁用访问安全检查的开关 参数值为true则指示反射的对象在使用时应该取消Java语言访问检测，这样可以提高反射的效率，使得原本无法访问的私有成员也可以访问 123456789101112131415161718192021222324252627282930313233public class Test11 { public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException { // 获取class对象 Class c1 = Class.forName(&quot;pers.Shuke.reflection.User&quot;); // 构造一个对象 User user = (User)c1.newInstance(); // 本质上调用类的无参构造器 System.out.println(user); // pers.Shuke.reflection.User@5b2133b1 // 通过构造器创建对象 Constructor constructor = c1.getDeclaredConstructor(String.class, int.class, int.class); User user2 = (User)constructor.newInstance(&quot;舒克&quot;, 1, 10); System.out.println(user2); // pers.Shuke.reflection.User@72ea2f77 // 通过反射调用普通方法 User user3 = (User)c1.newInstance(); // 通过反射获取一个方法 Method setName = c1.getDeclaredMethod(&quot;setName&quot;, String.class); // invoke : 激活的意思 // {对象，方法的值} setName.invoke(user3, &quot;舒克&quot;); System.out.println(user3.getName()); // 舒克 // 通过反射操作属性 User user4 = (User)c1.newInstance(); Field name = c1.getDeclaredField(&quot;name&quot;); name.setAccessible(false); // 关闭权限检测，否则无法直接修改private变量 name.set(user4, &quot;舒克2&quot;); System.out.println(user4.getName()); }} 性能对比分析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 分析性能问题public class Test12 { // 普通方式调用 public static void Test12_1() { User user = new User(); long startTime = System.currentTimeMillis(); for(int i = 0; i &lt; 1000000000; i++) { user.getName(); } long endTime = System.currentTimeMillis(); System.out.println(&quot;普通方法执行10亿次：&quot; + (endTime - startTime) + &quot;ms&quot;); } // 反射方式调用 public static void Test12_2() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException { User user = new User(); Class c1 = user.getClass(); Method getName = c1.getDeclaredMethod(&quot;getName&quot;, null); long startTime = System.currentTimeMillis(); for(int i = 0; i &lt; 1000000000; i++) { getName.invoke(user, null); } long endTime = System.currentTimeMillis(); System.out.println(&quot;反射调用不关检测执行10亿次：&quot; + (endTime - startTime) + &quot;ms&quot;); } // 反射反射调用（关闭检测） public static void Test12_3() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException { User user = new User(); Class c1 = user.getClass(); Method getName = c1.getDeclaredMethod(&quot;getName&quot;, null); getName.setAccessible(true); long startTime = System.currentTimeMillis(); for(int i = 0; i &lt; 1000000000; i++) { getName.invoke(user, null); } long endTime = System.currentTimeMillis(); System.out.println(&quot;反射调用不关检测执行10亿次：&quot; + (endTime - startTime) + &quot;ms&quot;); } public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { Test12_1(); // 6ms Test12_2(); // 2686ms Test12_3(); // 1065ms }} 根据结果可知：普通调用效率 &gt;&gt; 关闭检测反射调用效率 &gt; 不关闭检测反射调用效率 获取泛型信息Java采用泛型擦除机制来引入泛型，Java中的泛型仅仅是给编译器javac使用的，确保数据的安全性和免去强制类型转换问题，但是，一旦编译完成，所有和泛型相关的类型全部擦除 为了通过反射操作这些类型，Java新增了ParameterizedType，GenericArrayType，TypeVariable和WildcardType这几种类型来代表不能被归一到Class类中的类型但是又和原始类型齐名的类型 ParameterizedType: 表示一种参数化类型，比如Collection GenericArrayType: 表示一种元素类型是参数化类型或者类型变量的数组类型 TypeVariable: 是各种类型变量的公共父接口 WildcardType: 代表一种通配符类型表达式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 通过反射获取泛型public class Test13 { public static void Test13_1(Map&lt;String, User&gt; map, List&lt;User&gt; list) { System.out.println(&quot;test13_1&quot;); } public Map&lt;String, User&gt; Test13_2() { System.out.println(&quot;test13_2&quot;); return null; } public static void main(String[] args) throws NoSuchMethodException { // 获取方法 Method method = Test13.class.getMethod(&quot;Test13_1&quot;, Map.class, List.class); // 获取泛型参数类型 Type[] genericParameterTypes = method.getGenericParameterTypes(); for(Type genericParameterType : genericParameterTypes) { System.out.println(&quot;#&quot; + genericParameterType); /* #java.util.Map&lt;java.lang.String, pers.Shuke.reflection.User&gt; ------------ #java.util.List&lt;pers.Shuke.reflection.User&gt; */ // 是否属于参数化类型 if(genericParameterType instanceof ParameterizedType) { // 强制转化，获得真实的参数类型 Type[] actualTypeArguments = ((ParameterizedType) genericParameterType).getActualTypeArguments(); for(Type actualTypeArgument : actualTypeArguments) { System.out.println(actualTypeArgument); /* class java.lang.String class pers.Shuke.reflection.User ------------ class pers.Shuke.reflection.User */ } } } method = Test13.class.getMethod(&quot;Test13_2&quot;, null); // 获取返回值类型 Type genericParameterType = method.getGenericReturnType(); // 是否为泛型 if(genericParameterType instanceof ParameterizedType) { // 强制转化为具体泛型 Type[] actualTypeArguments = ((ParameterizedType) genericParameterType).getActualTypeArguments(); for(Type actualTypeArgument : actualTypeArguments) { System.out.println(actualTypeArgument); /* class java.lang.String class pers.Shuke.reflection.User */ } } }} 获取注解信息1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// 反射操作注解public class Test14 { public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException { Class c1 = Class.forName(&quot;pers.Shuke.reflection.People&quot;); // 通过反射获得注解 Annotation[] annotations = c1.getAnnotations(); for(Annotation annotation : annotations) { System.out.println(annotation); // @pers.Shuke.reflection.TableShuke(&quot;db_people&quot;) } // 获得注解的value的值 TableShuke tableShuke = (TableShuke)c1.getAnnotation(TableShuke.class); String value = tableShuke.value(); System.out.println(value); // db_people // 获得类的指定注解 Field field = c1.getDeclaredField(&quot;name&quot;); // 获得name属性的注解 FieldShuke annotation = field.getAnnotation(FieldShuke.class); System.out.println(annotation.columnName() + &quot; &quot; + annotation.type() + &quot; &quot; + annotation.length()); // db_name varchar 8 }}@TableShuke(&quot;db_people&quot;)class People { @FieldShuke(columnName = &quot;db_name&quot;, type = &quot;varchar&quot;, length = 8) private String name; @FieldShuke(columnName = &quot;db_age&quot;, type = &quot;int&quot;, length = 4) private int age; @FieldShuke(columnName = &quot;db_id&quot;, type = &quot;int&quot;, length = 12) private int id; public People() {} public People(String name, int age, int id) { this.name = name; this.age = age; this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public int getId() { return id; } public void setId(int id) { this.id = id; }}// 类名的注解@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@interface TableShuke { String value();}// 属性的注解@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@interface FieldShuke { String columnName(); String type(); int length();}","link":"/2020/07/23/Java-%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84/"},{"title":"Java多线程","text":"简介程序：是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念。 进程：执行程序的一次执行过程，它是一个动态的概念，是系统资源分配的单位。 线程：通常在一个进程中可以包含若干个进程，当然一个进程中至少有一个线程，不然没有存在的意义。线程是CPU调度和执行的单位。 多线程：多条执行路径，主线程和子线程并行交替执行。很多多线程是模拟出来的，真正的多线程是指有多个CPU，即多核，如服务器。如果是模拟出来的多线程，即在一个CPU的情况下，在同一个时间点，CPU只能执行一个代码，因为切换的很快，所以就有同时执行的错觉。 线程就是独立的执行路径 在程序运行时，即使没有自己创建线程，后台也会有多个线程，如主线程，gc线程（负责垃圾回收） main()称之为主线程，为系统的入口，用于执行整个程序 在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器是与操作系统密切相关的，先后顺序是不能人为干预的 对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制（如抢票问题，需要让线程排队） 线程会带来额外的开销，如CPU调度时间，并发控制开销 每个线程在自己的工作内存交互，内存控制不会造成数据不一致 线程线程创建方法一： Thread class -&gt; 继承Thread类 自定义线程类继承Thread类 重写run()方法，编写线程执行体 创建线程对象，调用start()方法启动线程 不建议使用：避免OOP单继承局限性 123456789101112131415161718192021// 线程的创建方式一：继承Thread类，重写run()方法，调用start开启线程// 总结：线程开启不一定立即执行，由CPU调度器执行public class Test15 extends Thread { @Override public void run() { for(int i = 0; i &lt; 200; i++) { System.out.println(&quot;看书&quot; + i); } } public static void main(String[] args) { // 创建一个线程对象 Test15 test15 = new Test15(); test15.start(); for(int i = 0; i &lt; 200; i++) { System.out.println(&quot;刷剧&quot; + i); } }} 方法二： Runnable接口 -&gt; 实现Runnable接口 定义MyRunnable类实现Runnable接口 实现run()方法，编写线程执行体 创建线程对象，调用start()方法启动线程 推荐使用：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用 1234567891011121314151617181920212223242526// 创建线程方式2：实现Runnable接口，重写run()方法，执行线程需要丢入runnable接口实现类，调用start()方法。public class Test16 implements Runnable { @Override public void run() { for(int i = 0; i &lt; 200; i++) { System.out.println(&quot;看书&quot; + i); } } public static void main(String[] args) { // 创建Runnable接口的实现类对象 Test16 test16 = new Test16(); // 创建线程对象，通过线程对象来开启线程，代理 //Thread t = new Thread(test16); //t.start(); // 等价于上一种写法 new Thread(test16).start(); for(int i = 0; i &lt; 200; i++) { System.out.println(&quot;追剧&quot; + i); } }} 方法三： Callable接口 -&gt; 实现Callable接口 实现Callable接口，需要返回值类型 重写call方法，需要抛出异常 创建目标对象 创建执行服务：ExecutorService ser = Executors.newFixedThreadPool(1); 提交执行：Futureresult1 = ser.submit(t1); 获取结果：boolean r1 = result1.get(); 关闭服务：ser.shutdownNow(); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 线程创建方式三：实现Callable接口/* callable的好处： 1. 可以定义返回值 2. 可以抛出异常 */public class Test17 implements Callable&lt;Boolean&gt; { private String url; private String name; public Test17(String url, String name) { this.url = url; this.name = name; } @Override public Boolean call() throws Exception { WebDownloader webDownloader = new WebDownloader(); webDownloader.downloader(url, name); System.out.println(&quot;下载图片名为：&quot; + name); return true; } public static void main(String[] args) throws ExecutionException, InterruptedException { Test17 t1 = new Test17(&quot;http://kmlerc.coding-pages.com/images/head.JPG&quot;, &quot;1.jpg&quot;); Test17 t2 = new Test17(&quot;https://www5.jiumodiary.com/images/front/eleps.png&quot;, &quot;2.png&quot;); Test17 t3 = new Test17(&quot;https://pic.cnblogs.com/avatar/1569506/20190731001716.png&quot;, &quot;3.png&quot;); // 创建执行服务 ExecutorService ser = Executors.newFixedThreadPool(1); // 提交执行 Future&lt;Boolean&gt; result1 = ser.submit(t1); Future&lt;Boolean&gt; result2 = ser.submit(t2); Future&lt;Boolean&gt; result3 = ser.submit(t3); // 获取结果 boolean r1 = result1.get(); boolean r2 = result2.get(); boolean r3 = result3.get(); System.out.println(r1 + &quot; &quot; + r2 + &quot; &quot; + r3); // 关闭服务 ser.shutdownNow(); }}// 下载器class WebDownloader { // 下载方法 public void downloader(String url, String name) { try { FileUtils.copyURLToFile(new URL(url), new File(name)); } catch (IOException e) { e.printStackTrace(); System.out.println(&quot;IO异常，downloader方法出现问题&quot;); } }} 线程状态分析 Thread t = new Thread() 线程对象一旦创建就进入到新生状态 当调用start()方法，线程立即进入就绪状态，但不意味着立即调度执行 进入运行状态，线程才真正执行线程体的代码块 当调用sleep,wait或同步锁定时，线程进入阻塞状态，就是代码不往下执行，阻塞事件解除后，重新进入就绪状态，等待cpu调度执行 线程中断或者结束，一旦进入死亡状态，就不能再次启动 线程方法 方法 说明 setPriority(int newPriority) 更改线程的优先级 static void sleep(long millis) 在指定毫秒数内让当前正在执行的线程休眠 void join() 等待该线程终止 static void yield() 暂停当前正在执行的线程对象，并执行线程其他线程 void interrupt() 中断线程，别用这个方式 boolean isAlive() 测试线程是否处于活动状态 线程停止123456789101112131415161718192021222324252627282930313233343536// 线程停止/* 1. 建议让线程正常停止 2. 建议使用标志 3. 不要使用stop或destroy等过时的不推荐使用的方法 */public class Test20 implements Runnable { private boolean flag = true; @Override public void run() { int i = 0; while(flag) { System.out.println(&quot;run...Thread&quot; + ++i); } } public void stop() { this.flag = false; } public static void main(String[] args) { Test20 test20 = new Test20(); new Thread(test20).start(); for(int i = 0; i &lt; 1000; i++) { System.out.println(&quot;main&quot; + i); if(i == 999){ // 修改标志位，让线程停止 test20.stop(); System.out.println(&quot;线程停止了&quot;); } } }} 线程休眠 sleep(时间)指定当前线程阻塞的毫秒数 sleep存在异常InterruptedException sleep时间达到后线程进入就绪状态 sleep可以模拟网络延时，倒计时等 每一个对象都有一个锁，slepp不会释放锁 12345678910111213141516// 线程睡眠：打印时间public class Test21 { public static void getTime() throws InterruptedException { Date date = new Date(System.currentTimeMillis()); while(true) { System.out.println(new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(date)); Thread.sleep(1000); date = new Date(System.currentTimeMillis()); } } public static void main(String[] args) throws InterruptedException { getTime(); }} 线程礼让 让当前正在执行的线程暂停，但不阻塞 将线程从运行状态转为就绪状态 让cpu重新调度，礼让不一定成功！看cpu心情 1234567891011121314151617// 线程礼让public class Test22 { public static void main(String[] args) { MyYield myYield = new MyYield(); new Thread(myYield, &quot;a&quot;).start(); new Thread(myYield, &quot;b&quot;).start(); }}class MyYield implements Runnable { @Override public void run() { System.out.println(Thread.currentThread().getName() + &quot;开始运行&quot;); Thread.yield(); // 礼让 System.out.println(Thread.currentThread().getName() + &quot;停止运行&quot;); }} 线程强制执行（插队） Join合并线程，待此线程完成后，再执行其他线程，其他线程阻塞 1234567891011121314151617181920212223// 线程强制执行public class Test23 implements Runnable { @Override public void run() { for (int i = 0; i &lt; 200; i++) { System.out.println(&quot;vip线程&quot; + i); } } public static void main(String[] args) throws InterruptedException { Test23 test23 = new Test23(); Thread thread = new Thread(test23); thread.start(); // 主线程 for(int i = 0; i &lt; 500; i++) { if(i == 200) { thread.join(); } System.out.println(&quot;main&quot; + i); } }} 线程状态观测Thread.State: 线程状态 NEW 尚未启动的线程处于此状态 RUNNABLE 在Java虚拟机中执行的线程处于此状态 BLOCKED 被阻塞等待监视器锁定的处于此状态 WAITING 正在等待另一个线程执行特定动作的线程处于此状态 TIMED_WAITING 正在等待另一个线程执行达到指定等待时间的线程处于此状态 TERMINATED 已退出的线程处于此状态 一个线程可以在给定时间点处于一个状态。这些状态是不反应任何操作系统线程状态的虚拟机状态。 线程的优先级 Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度那个线程来执行 线程的优先级用数字表示，范围从1-10 Thread.MIN_PRIORITY = 1 Thread.MAX_PRIORITY = 10 Thread.NORM_PRIORITY = 5 使用 getPriority() 获取优先级 使用 setPriority(int x) 改变优先级 守护(daemon)线程 线程分为用户线程和守护线程 虚拟机必须确保用户线程执行完毕 虚拟机不必等待守护线程执行完毕 如：后台记录操作日志，监控内存，垃圾回收等等… 123456789101112131415161718192021222324252627282930313233343536// 守护线程public class Test24 { public static void main(String[] args) { God god = new God(); People people = new People(); Thread thread = new Thread(god); thread.setDaemon(true); // 设置为守护线程 thread.start(); new Thread(people).start(); // 当people结束，守护线程也就自动结束了。。 }}// 上帝线程class God implements Runnable { @Override public void run() { while(true) { System.out.println(&quot;上帝保佑人类&quot;); } }}// 人类线程class People implements Runnable { @Override public void run() { for(int i = 0; i &lt; 30000; i++) { System.out.println(&quot;人类开心的活着&quot;); } System.out.println(&quot;Goodbye, world!&quot;); }} 线程同步(多个线程操作同一个资源) 处理多线程问题时，多个线程访问同一个对象(并发问题)，并且某些线程还想修改这个对象，这时候就需要线程同步。线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个对象的等待池形成队列，等待前面线程使用完毕，下一个线程再使用。 由于同一进程的多个线程共享同一块存储空间，在带来方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问时的正确性，在访问时加入锁机制synchronized，当一个线程获得对象的排它锁，独占资源，其他线程必须等待，使用后释放锁即可，存在以下问题： 一个线程持有锁会导致其他所有需要此锁的线程挂起 在多线程竞争下，加锁，释放锁会导致比较多的上下文切换和调度延时，引起性能问题 如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，引起性能问题 同步方法及同步块 由于我们可以通过private关键字来保证数据对象只能被方法访问，所以我们只需要针对方法提出一套机制，这套机制就是synchronized关键字，它包括两种用法：synchronized方法和synchronized块。 同步方法：public synchronized void method(int args){} synchronized方法控制对”对象”的访问，每个对象对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞。方法一旦执行，就独占该锁，直到方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行。 缺陷：若将一个大的方法声明为synchronized将会影响效率 同步块：synchronized(Obj) {}Obj称之为同步监视器 Obj可以是任何对象，但是推荐使用共享资源作为同步监视器 同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是这个对象本身，或者是class 同步监视器的执行过程 第一个线程访问，锁定同步监视器，执行其中代码 第二个线程访问，发现同步监视器被锁定，无法访问 第一个线程访问完毕，解锁同步监视器 第二个线程访问，发现同步监视器没有锁，然后锁定并访问 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 买票测试synchronized方法public class Test25 { public static void main(String[] args) { BuyTicket buyTicket = new BuyTicket(); new Thread(buyTicket, &quot;小米&quot;).start(); new Thread(buyTicket, &quot;小明&quot;).start(); new Thread(buyTicket, &quot;小红&quot;).start(); }}class BuyTicket implements Runnable { private int ticketNums = 100; boolean flag = true; @Override public void run() { while (flag) { try { buy(); } catch (InterruptedException e) { e.printStackTrace(); } } } // 同步方法 private synchronized void buy() throws InterruptedException { if(ticketNums &lt;= 0) { flag = false; return ; } //Thread.sleep(10); System.out.println(Thread.currentThread().getName() + &quot;抢到&quot; + ticketNums--); } // 同步块class BuyTicket1 implements Runnable { private int ticketNums = 100000; boolean flag = true; @Override public void run() { while (flag) buy(); } private void buy() { synchronized (this) { // 同步块，可以锁任何对象，默认为this if(ticketNums &lt;= 0) { flag = false; return ; } //Thread.sleep(10); System.out.println(Thread.currentThread().getName() + &quot;抢到&quot; + ticketNums--); } }}} 死锁 多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形。某一个同步块同时拥有“两个以上对象的锁”时，就可能会发生”死锁“的问题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 死锁：多个线程互相抱着对方需要的线程，形成僵持public class Test26 { public static void main(String[] args) { Makeup q1 = new Makeup(0, &quot;小明&quot;); Makeup q2 = new Makeup(1, &quot;小红&quot;); q1.start(); q2.start(); }}class Gun {}class Dog {}class Makeup extends Thread { // 需要的资源只有一份，用static来保证只有一份 static Gun gun = new Gun(); static Dog dog = new Dog(); int choice; String name; Makeup(int choice, String name) { this.choice = choice; this.name = name; } @Override public void run() { try { makeup(); } catch (InterruptedException e) { e.printStackTrace(); } } private void makeup() throws InterruptedException { if (choice == 0) { // 小明想要枪，他本来有狗 synchronized(gun) { System.out.println(this.name + &quot;获得枪的锁&quot;); Thread.sleep(1000); /* 发生死锁 synchronized(dog) { System.out.println(this.name + &quot;获得狗的锁&quot;); } */ } synchronized(dog) { // 放到外面即可解决死锁问题 System.out.println(this.name + &quot;获得狗的锁&quot;); } } else if (choice == 1) { // 小红想要狗，她本来有枪 synchronized(dog) { System.out.println(this.name + &quot;获得狗的锁&quot;); Thread.sleep(2000); /* 发生死锁 synchronized(gun) { System.out.println(this.name + &quot;获得枪的锁&quot;); } */ } synchronized(gun) { // 放到外面即可解决死锁问题 System.out.println(this.name + &quot;获得枪的锁&quot;); } } }} 死锁产生的四个必要条件(只需要破解其中一个即可解决死锁问题)： 互斥条件：一个资源每次只能被一个进程使用 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放 不剥夺条件：进程以获得的资源，在未使用完之前，不能强行剥夺 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系 Lock锁 Lock是显式锁（手动开启和关闭锁），synchronized是隐式锁，出了作用域自动释放 Lock只有代码块锁，synchronized有代码块锁和方法锁 使用Lock锁，JVM将花费较少时间来调度线程，性能更好，并且具有更好的拓展性（提供更多子类） 优先使用顺序：Lock &gt; 同步代码块 &gt; 同步方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// Lock锁/* 格式： class A { private final ReentrantLock lock = new ReentrantLock(); public void m() { lock.lock(); try { // 保证线程安全的代码 } finally { lock.unlock(); } } } */public class Test27 { public static void main(String[] args) { BuyTicket1 buyTicket1 = new BuyTicket1(); new Thread(buyTicket1).start(); new Thread(buyTicket1).start(); new Thread(buyTicket1).start(); }}class BuyTicket1 implements Runnable { int TicketNums = 10; // 定义lock锁 private final ReentrantLock lock = new ReentrantLock(); @Override public void run() { while (true) { try { lock.lock(); // 加锁 if(TicketNums &gt; 0) { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(TicketNums--); } else { break; } } finally { lock.unlock(); // 解锁 } } }} 静态代理模式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 静态代理方法/* 总结： 真实对象和代理对象都要实现同一个接口 代理对象要代理真实角色 *//* 优点： 代理对象可以做很多真实对象做不了的事情 真实对象可以专心做自己的事情 */public class Test18 { /* 举例模拟结婚： 你只需要负责结婚，其他的事情都由婚庆公司（代理）帮你包办即可。 */ public static void main(String[] args) { new Thread( () -&gt; System.out.println(&quot;我爱你&quot;) ).start(); new Company(new You()).HappyMarry(); }}interface Marry { void HappyMarry();}// 真实角色，即你自己class You implements Marry { @Override public void HappyMarry() { System.out.println(&quot;新郎结婚中。。。&quot;); }}// 代理角色，即婚庆公司class Company implements Marry { // 要结婚的对象 private Marry target; public Company(Marry target) { this.target = target; } @Override public void HappyMarry() { before(); this.target.HappyMarry(); after(); } public void before() { System.out.println(&quot;布置场地&quot;); } public void after() { System.out.println(&quot;收拾场地&quot;); }} 生产者消费者模式 应用场景：生产者和消费者问题 假设仓库只能存放一件商品，生产者将生产出来的产品放入仓库，消费者将仓库中产品消费取走。 如果仓库没有商品，则生产者将产品放入仓库，否则停止生产并等待，直到仓库中的产品被消费者取走为止 如果仓库中放有产品，则消费者可以将产品取走消费，否则停止消费并等待，直到仓库中再次放入产品为止 这是一个线程同步问题，生产者和消费者共享一个资源，并且生产者和消费者之间相互依赖，互为条件。 对于生产者，没有生产产品之前，要通知消费者等待。而生产之后，又需要通知消费者消费 对于消费者，在消费之后，要通知生产者已经结束消费，需要生产新的产品以供消费 在生产者消费者问题中，仅有synchronized是不够的 synchronized可以阻止并发更新同一个共享资源，实现了同步 synchronized不能用来实现不同线程之间的消息传递（通信） Java提供了几个方法解决线程通信问题 方法名 作用 wait() 表示线程一直等待，直到其他线程通知，与sleep不同，会释放锁 wait(long timeout) 指定等待的毫秒数 notify() 唤醒一个处于等待状态的线程 notifyAll() 唤醒同一个对象上所有调用wait()方法的线程，优先级别高的线程优先调度 注意：均是Object类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常IllegalMonitorStateException 管程法 消费者不能直接使用生产者的数据，他们之间有个“缓冲区”生产者将生产好的数据放入缓冲区，消费者从缓冲区拿出数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101// 测试：生产者消费者模型 --&gt; 利用缓冲区解决：管程法public class Test28 { public static void main(String[] args) { SynContainer container = new SynContainer(); new Productor(container).start(); new Consumer(container).start(); }}// 生产者class Productor extends Thread { SynContainer container; public Productor(SynContainer container) { this.container = container; } @Override public void run() { for(int i = 0; i &lt; 100; i++) { System.out.println(&quot;生产了&quot; + i + &quot;个产品&quot;); try { container.push(new Product(i)); } catch (InterruptedException e) { e.printStackTrace(); } } }}// 消费者class Consumer extends Thread { SynContainer container; public Consumer (SynContainer container) { this.container = container; } @Override public void run() { for(int i = 0; i &lt; 100; i++) { try { System.out.println(&quot;消费了--&gt;&quot; + container.pop().id + &quot;产品&quot;); } catch (InterruptedException e) { e.printStackTrace(); } } }}// 产品class Product { public int id; public Product(int id) { this.id = id; }}// 缓冲区class SynContainer { // 需要一个容器大小 Product[] products = new Product[10]; // 容器计数器 int count = 0; // 生产者放入产品 public synchronized void push(Product product) throws InterruptedException { // 如果容器满了，就需要等待消费者消费 if(count == products.length) { // 通知消费者消费，等待生产 this.wait(); } // 如果没有满，我们就需要丢入产品 products[count] = product; count++; // 通知生产者消费 this.notifyAll(); } // 消费者消费商品 public synchronized Product pop() throws InterruptedException { // 判断能否消费 if(count == 0) { // 等待生产者生产，消费者等待 this.wait(); } // 如果可以消费 count--; Product product = products[count]; // 消费空了，通知生产者生产 this.notifyAll(); return product; }} 线程池 背景：经常创建和销毁，使用量特别大的资源，比如并发情况下的线程，对性能影响很大。思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁，实现重复利用。类似生活中的公共交通工具。 提高响应速度（减少了创建新线程的时间） 降低资源消耗（重复利用线程池中线程，不需要每次都创建） 便于线程管理 corePoolSize：核心池的大小 maximumPoolSize：最大线程数 keepAliveTime：线程没有任务时最多保持多长时间后会终止 123456789101112131415161718192021222324// 测试线程池public class Test29 { public static void main(String[] args) { // 创建服务，创建线程池 // newFixedThreadPool参数为线程池大小 ExecutorService service = Executors.newFixedThreadPool(10); // 执行 service.execute(new MyThread()); service.execute(new MyThread()); service.execute(new MyThread()); service.execute(new MyThread()); // 关闭链接 service.shutdown(); }}class MyThread implements Runnable { @Override public void run() { System.out.println(Thread.currentThread().getName()); }} lambda表达式为什么要使用lambda表达式： 避免匿名内部类定义过多 让代码更加简洁 去掉了没有意义的代码，只留下核心逻辑 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// lambda表达式public class Test19 { // 静态内部类 static class Like2 implements ILike { @Override public void lambda() { System.out.println(&quot;I like lambda2&quot;); } } public static void main(String[] args) { // 实现类 ILike like = new Like1(); like.lambda(); // 静态内部类 like = new Like2(); like.lambda(); // 局部内部类 class Like3 implements ILike { @Override public void lambda() { System.out.println(&quot;I like lambda3&quot;); } } like = new Like3(); like.lambda(); // 匿名内部类，没有类的名称，必须借助父类或接口 like = new ILike() { @Override public void lambda() { System.out.println(&quot;I like lambda4&quot;); } }; like.lambda(); // lambda表达式 like = () -&gt; { System.out.println(&quot;I like lambda5&quot;); }; like.lambda(); ILove love = null; // lambda表达式2 love = (a, b) -&gt; System.out.println(&quot;I like lambda &quot; + a + &quot; &quot;+ b); love.lambda(20, 10); /* 总结： 1. lambda表达式只能在一行代码的情况下简化成一行，否则必须用代码块包装。 2. 使用的前提是接口必须为函数式接口且只有一个函数。 3. 可以都去掉参数类型，且只有一个参数时可以不加括号。 */ }}// 函数式接口interface ILike { void lambda();}// 接口实现类class Like1 implements ILike { @Override public void lambda() { System.out.println(&quot;I like lambda1&quot;); }}interface ILove { void lambda(int a,int b);}","link":"/2020/07/28/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"C++面向对象","slug":"C-面向对象","link":"/tags/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"Makefile","slug":"Makefile","link":"/tags/Makefile/"},{"name":"JVM","slug":"JVM","link":"/tags/JVM/"},{"name":"区间dp","slug":"区间dp","link":"/tags/%E5%8C%BA%E9%97%B4dp/"},{"name":"思维","slug":"思维","link":"/tags/%E6%80%9D%E7%BB%B4/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"贪心","slug":"贪心","link":"/tags/%E8%B4%AA%E5%BF%83/"},{"name":"记忆化搜索","slug":"记忆化搜索","link":"/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"RMQ","slug":"RMQ","link":"/tags/RMQ/"},{"name":"Vim","slug":"Vim","link":"/tags/Vim/"},{"name":"回文","slug":"回文","link":"/tags/%E5%9B%9E%E6%96%87/"},{"name":"STL","slug":"STL","link":"/tags/STL/"},{"name":"并查集","slug":"并查集","link":"/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"C++内存管理","slug":"C-内存管理","link":"/tags/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"name":"多校训练","slug":"多校训练","link":"/tags/%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83/"},{"name":"树状数组","slug":"树状数组","link":"/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"树","slug":"树","link":"/tags/%E6%A0%91/"},{"name":"二分","slug":"二分","link":"/tags/%E4%BA%8C%E5%88%86/"},{"name":"博弈论","slug":"博弈论","link":"/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"},{"name":"状压dp","slug":"状压dp","link":"/tags/%E7%8A%B6%E5%8E%8Bdp/"},{"name":"计数dp","slug":"计数dp","link":"/tags/%E8%AE%A1%E6%95%B0dp/"},{"name":"树形dp","slug":"树形dp","link":"/tags/%E6%A0%91%E5%BD%A2dp/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"字典树","slug":"字典树","link":"/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"},{"name":"最小生成树","slug":"最小生成树","link":"/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"线性dp","slug":"线性dp","link":"/tags/%E7%BA%BF%E6%80%A7dp/"},{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"背包dp","slug":"背包dp","link":"/tags/%E8%83%8C%E5%8C%85dp/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Java基础","slug":"Java基础","link":"/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Java反射","slug":"Java反射","link":"/tags/Java%E5%8F%8D%E5%B0%84/"},{"name":"Java多线程","slug":"Java多线程","link":"/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"categories":[{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"Makefile","slug":"Makefile","link":"/categories/Makefile/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"MySQL","slug":"MySQL","link":"/categories/MySQL/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Vim","slug":"Vim","link":"/categories/Vim/"},{"name":"操作系统","slug":"操作系统","link":"/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"ACM模板","slug":"ACM模板","link":"/categories/ACM%E6%A8%A1%E6%9D%BF/"},{"name":"多校训练","slug":"多校训练","link":"/categories/%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83/"},{"name":"每日一题","slug":"每日一题","link":"/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"设计模式","slug":"设计模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"计算机网络","slug":"计算机网络","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Java基础","slug":"Java基础","link":"/categories/Java%E5%9F%BA%E7%A1%80/"}]}