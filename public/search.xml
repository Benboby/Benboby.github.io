<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>继承，虚函数和多态</title>
      <link href="2021/02/%E7%BB%A7%E6%89%BF-%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81.html"/>
      <url>2021/02/%E7%BB%A7%E6%89%BF-%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81.html</url>
      
        <content type="html"><![CDATA[<h2 id="继承-with-virtual-function"><a href="#继承-with-virtual-function" class="headerlink" title="继承 with virtual function"></a>继承 with virtual function</h2><p><strong>构造由内而外</strong>：首先调用父类的构造函数，然后再调用自己。<br><strong>析构由外而内</strong>：首先执行自己的析构函数，然后调用父类的析构函数。</p><p>non-virtual: 你不希望重新定义（重写）它。<br>virtual: 你希望子类重新定义它，且它有默认定义。<br>pure virtual: 你希望子类一定要重新定义它，你对它没有默认定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;   <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; msg)</span></span>;   <span class="comment">// 虚函数 </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">objectID</span><span class="params">()</span> <span class="keyword">const</span></span>;   <span class="comment">// 一般成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape &#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ellipse</span>:</span> <span class="keyword">public</span> Shape &#123;...&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a> <h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据所指对象的实际类型来调用相应的函数，如果对象类型是派生类，就调用派生类的函数，如果对象类型是基类，就调用基类的函数。</p><p>虚表：虚函数表的缩写，类中含有virtual关键字修饰的方法时，编译器会自动生成虚表</p><p>虚表指针：在含有虚函数的类实例化对象时，对象地址的前四个字节存储的指向虚表的指针</p><ul><li>编译器在发现基类中有虚函数时，会自动为每个含有虚函数的类生成一份虚表，该表是一个一维数组，虚表里保存了虚函数的入口地址</li><li>编译器会在每个对象的前四个字节中保存一个虚表指针，即vptr，指向对象所属类的虚表。在构造时，根据对象的类型去初始化虚指针vptr，从而让vptr指向正确的虚表，从而在调用虚函数时，能找到正确的函数</li><li>在派生类定义对象时，程序运行会自动调用构造函数，在构造函数中创建虚表并对虚表初始化。在构造子类对象时，会先调用父类的构造函数，此时，编译器只“看到了”父类，并为父类对象初始化虚表指针，令它指向父类的虚表；当调用子类的构造函数时，为子类对象初始化虚表指针，令它指向子类的虚表</li><li>当派生类对基类的虚函数没有重写时，派生类的虚表指针指向的是基类的虚表；当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表；当派生类中有自己的虚函数时，在自己的虚表中将此虚函数地址添加在后面</li></ul><h3 id="基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间"><a href="#基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间" class="headerlink" title="基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间"></a>基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间</h3><p>首先整理一下虚函数表的特征：</p><ul><li>虚函数表是全局共享的元素，即全局仅有一个，在编译时就构造完成</li><li>虚函数表类似一个数组，类对象中存储vptr指针，指向虚函数表，即虚函数表不是函数，不是程序代码，不可能存储在代码段</li><li>虚函数表存储虚函数的地址,即虚函数表的元素是指向类成员函数的指针,而类中虚函数的个数在编译时期可以确定，即虚函数表的大小可以确定,即大小是在编译时期确定的，不必动态分配内存空间存储虚函数表，所以不在堆中</li></ul><p>根据以上特征，虚函数表类似于类中静态成员变量。静态成员变量也是全局共享，大小确定，因此最有可能存在全局数据区。</p><p>由于虚表指针vptr跟虚函数密不可分，对于有虚函数或者继承于拥有虚函数的基类，对该类进行实例化时，在构造函数执行时会对虚表指针进行初始化，当一个构造函数被调用时，它做的首要的事情之中的一个是初始化它的VPTR，并且存在对象内存布局的最前面。</p><h3 id="补充：inline内联函数"><a href="#补充：inline内联函数" class="headerlink" title="补充：inline内联函数"></a>补充：inline内联函数</h3><p>内联函数和普通函数的区别在于：当编译器处理调用内联函数的语句时，不会将该语句编译成函数调用的指令，而是直接将整个函数体的代码插人调用语句处，就像整个函数体在调用处被重写了一遍一样。相比之下，普通函数能够避免将相同代码重写多次的麻烦，还能减少可执行程序的体积，但也会带来程序运行时间上的开销；而内联函数省去了调用函数的时间开销。</p><p><strong>在函数调用执行过程中，首先要为在栈中的形参和局部变量分配存储空间，然后再将实参的值复制给形参，然后还要将函数的返回地址放入栈中，最后才跳转到函数内部执行。return语句返回时，还要从栈中回收形参和局部变量占有的存储空间，然后从栈中取出返回地址，跳转到该地址继续执行。</strong></p><p>如果内联函数执行的时间很长，那函数调用的时间相比起来就微不足道，使用内联函数也就没有意义了。从另一方面来说，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。因此，内联函数中的代码应该是很简单，执行起来很快的一些语句。</p><p>Google C++编码规范对于inline的使用说明：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">内联函数：</span><br><span class="line">Tip： 只有当函数只有 <span class="number">10</span> 行甚至更少时才将其定义为内联函数.</span><br><span class="line"></span><br><span class="line">定义: 当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用.</span><br><span class="line"></span><br><span class="line">优点: 当函数体比较小的时候, 内联该函数可以令目标代码更加高效. 对于存取函数以及其它函数体比较短, 性能关键的函数, 鼓励使用内联.</span><br><span class="line"></span><br><span class="line">缺点: 滥用内联将导致程序变慢. 内联可能使目标代码量或增或减, 这取决于内联函数的大小. 内联非常短小的存取函数通常会减少代码大小, 但内联一个相当大的函数将戏剧性的增加代码大小. 现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快。</span><br><span class="line"></span><br><span class="line">结论: 一个较为合理的经验准则是, 不要内联超过 <span class="number">10</span> 行的函数. 谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!</span><br><span class="line"></span><br><span class="line">另一个实用的经验准则: 内联那些包含循环或 <span class="keyword">switch</span> 语句的函数常常是得不偿失 (除非在大多数情况下, 这些循环或 <span class="keyword">switch</span> 语句从不被执行).</span><br><span class="line"></span><br><span class="line">有些函数即使声明为内联的也不一定会被编译器内联, 这点很重要; 比如虚函数和递归函数就不会被正常内联. 通常, 递归函数不应该声明成内联函数.(递归调用堆栈的展开并不像循环那么简单, 比如递归层数在编译时可能是未知的, 大多数编译器都不支持内联递归函数). 虚函数内联的主要原因则是想把它的函数体放在类定义内, 为了图个方便, 抑或是当作文档描述其行为, 比如精短的存取函数.</span><br></pre></td></tr></table></figure><br>PS：内联函数和宏定义的区别：</p><ul><li><strong>内联函数在编译时展开，宏在预编译时展开</strong></li><li>内联函数直接嵌入到目标代码中，宏是简单的做文本替换</li><li><strong>内联函数有类型检测、语法判断等功能，而宏没有</strong></li><li>内联函数是函数，宏不是</li><li>宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义</li><li>内联函数代码是被放到符号表中，使用时像宏一样展开，没有调用的开销，效率很高</li></ul><h3 id="构造函数、析构函数、虚函数可否声明为内联函数"><a href="#构造函数、析构函数、虚函数可否声明为内联函数" class="headerlink" title="构造函数、析构函数、虚函数可否声明为内联函数"></a>构造函数、析构函数、虚函数可否声明为内联函数</h3><p>将这些函数声明为内联函数，在语法上没有错误。因为inline同register一样，只是个建议，编译器并不一定真正的内联。</p><ul><li>register关键字：这个关键字请求编译器尽可能的将变量存在CPU内部寄存器中，而不是通过内存寻址访问，以提高效率</li></ul><p>首先在《Effective C++》中明确阐述：<strong>将构造函数和析构函数声明为inline是没有什么意义的</strong>，即编译器并不真正对声明为inline的构造和析构函数进行内联操作，因为<strong>编译器会在构造和析构函数中添加额外的操作（申请/释放内存，构造/析构对象等）</strong>，致使构造函数/析构函数并不像看上去的那么精简。其次，class中的函数默认是inline型的，编译器也只是有选择性的inline，将构造函数和析构函数声明为内联函数是没有什么意义的。</p><p>虚函数是通过指针或引用调用函数时，通过虚函数表来确定调用的函数，在运行时确定。内联函数是在编译时，将调用函数处插入内联函数的代码，省去了函数调用时的开销。</p><p>表面上看，虚函数不能为内联函数。但如果虚函数在编译期就能够确定要调用哪个函数时，就能够内联。也就是用对象本身去调用虚函数时，会内联展开，当然前提是函数并不复杂的情况下。</p><h3 id="构造函数与虚函数"><a href="#构造函数与虚函数" class="headerlink" title="构造函数与虚函数"></a>构造函数与虚函数</h3><p>构造函数不可以是虚函数。</p><ol><li>从vptr角度解释：虚函数对应一个vtable，可是这个vtable其实是存储在对象的内存空间的。 那么问题来了，如果构造函数是虚函数，就要通过vtable来调用，可是对象空间还没有实例化，也就是内存空间还没有，无法找到vtable，所以构造函数不能是虚函数。</li><li>从使用角度：虚函数主要用于在信息不全的情况下，能够使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义。 </li></ol><h3 id="析构函数与虚函数"><a href="#析构函数与虚函数" class="headerlink" title="析构函数与虚函数"></a>析构函数与虚函数</h3><p>在派生类中的析构函数常常为虚析构函数，是为了避免内存泄露。</p><p>如果不考虑虚函数的状况，给出一个基类和派生类，如果调用派生类的析构函数时，肯定会引发调用基类的析构函数，这和析构函数是不是虚函数没关系。如：[ Derive* p = new Derive(); ]</p><p>现在考虑虚函数的问题，由于使用虚函数使我们可以定义一个基类指针或引用可以直接对派生类进行操作，如：[ Base* p = new Derive(); ]，这就存在两种情况：</p><p>如果，不把基类的析构函数设置为虚函数，则在删除对象时，如果直接删除基类指针，系统就只能调用基类析构函数，而不会调用派生类构造函数。这就会导致内存泄露。</p><p>如果，把基类的析构函数设置为虚函数，则在删除对象时，直接删除基类指针，系统会调用派生类析构函数，之后此派生类析构函数会引发系统自动调用自己的基类，这就不会导致内存泄露。</p><p>所以，在写一个类时，尽量将其析构函数设置为虚函数，但析构函数默认不是虚函数。</p><p>[问] 应该把所有的类的析构函数都设置为虚函数吗？<br>[答] 不一定。使用虚函数后的类对象要比不使用虚函数的类对象占的空间多，而且在查找具体使用哪一个虚函数时，还会有时间代价。即当一个类不打算作为基类时，不用将其中的函数设置为虚函数。</p><h3 id="构造函数和析构函数可以调用虚函数吗，为什么"><a href="#构造函数和析构函数可以调用虚函数吗，为什么" class="headerlink" title="构造函数和析构函数可以调用虚函数吗，为什么"></a>构造函数和析构函数可以调用虚函数吗，为什么</h3><p>不提倡在构造函数和析构函数中调用虚函数。</p><ul><li>因为父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全的，故而C++不会进行动态联编</li><li>析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义。</li></ul><h3 id="动态绑定和静态绑定"><a href="#动态绑定和静态绑定" class="headerlink" title="动态绑定和静态绑定"></a>动态绑定和静态绑定</h3><p>为了支持c++的多态性，才用了动态绑定和静态绑定。</p><ul><li>对象的静态类型：<strong>对象在声明时采用的类型。是在编译期确定的。</strong></li><li>对象的动态类型：<strong>目前所指对象的类型，是在运行期决定的。</strong>对象的动态类型可以更改，但是静态类型无法更改。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span>&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B &#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B &#123;&#125;</span><br><span class="line">D* pD = <span class="keyword">new</span> D();<span class="comment">//pD的静态类型是它声明的类型D*，动态类型也是D*</span></span><br><span class="line">B* pB = pD;<span class="comment">//pB的静态类型是它声明的类型B*，动态类型是pB所指向的对象pD的类型D*</span></span><br><span class="line">C* pC = <span class="keyword">new</span> C();</span><br><span class="line">pB = pC;<span class="comment">//pB的动态类型是可以更改的，现在它的动态类型是C*</span></span><br></pre></td></tr></table></figure><ul><li>静态绑定：绑定的是对象的静态类型，某特性（比如函数）依赖于对象的静态类型，发生在编译期。</li><li>动态绑定：绑定的是对象的动态类型，某特性（比如函数）依赖于对象的动态类型，发生在运行期。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfun</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">()</span></span>;<span class="comment">//首先说明一下，这个子类重新定义了父类的no-virtual函数，这是一个不好的设计，会导致名称遮掩；这里只是为了说明动态绑定和静态绑定才这样使用。</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfun</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfun</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">D* pD = <span class="keyword">new</span> D();</span><br><span class="line">B* pB = pD;</span><br></pre></td></tr></table></figure><p>pD-&gt;DoSomething() 和 pB-&gt;DoSomething() 是no-virtual函数，它是静态绑定的，也就是编译器会在编译期根据对象的静态类型来选择函数。</p><p>pD-&gt;vfun()和pB-&gt;vfun() 是一个虚函数，它动态绑定的，也就是说它绑定的是对象的动态类型，pB和pD虽然静态类型不同，但是他们同时指向一个对象，他们的动态类型是相同的，都是D*，所以，他们的调用的是同一个函数：D::vfun()。</p><p>需要特别注意：虚函数的缺省参数是静态绑定的！！！</p><p>总结：可以认为只有虚函数才使用的是动态绑定，其他的全部是静态绑定。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：最多可以参加的会议数目II</title>
      <link href="2021/02/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%A4%9A%E5%8F%AF%E4%BB%A5%E5%8F%82%E5%8A%A0%E7%9A%84%E4%BC%9A%E8%AE%AE%E6%95%B0%E7%9B%AEII.html"/>
      <url>2021/02/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%A4%9A%E5%8F%AF%E4%BB%A5%E5%8F%82%E5%8A%A0%E7%9A%84%E4%BC%9A%E8%AE%AE%E6%95%B0%E7%9B%AEII.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你一个 $a$ 数组，其中 $a[i] = [startDay_i, endDay_i, value_i]$ ，表示第 $i$ 个会议在 $startDay_i$ 天开始，第 $endDay_i$ 天结束，如果你参加这个会议，你能得到价值 $value_i$ 。同时给你一个整数 $k$ 表示你能参加的最多会议数目。</p><p>你同一时间只能参加一个会议。如果你选择参加某个会议，那么你必须 <strong>完整</strong> 地参加完这个会议。会议结束日期是包含在会议内的，也就是说你不能同时参加一个开始日期与另一个结束日期相同的两个会议。</p><p>请你返回能得到的会议价值 <strong>最大和</strong>。$(k \in [1, n], k * n \in [1, 1e6], startDay_i, endDay_i \in [1, 1e9], value_i \in[1, 1e6])$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><a id="more"></a><p>考虑动态规划。$dp[i][j]$ 表示前 $i$ 个会议刚好选 $j$ 个时，能获得的最大价值。</p><p>那么对于每个 $dp[i][j]$ 有两种情况：</p><ul><li>不参加第 $i$ 个会议，有 $dp[i][j] = dp[i - 1][j]$</li><li>参加第 $i$ 个会议，设第 $i$ 个会议开始时间为 $l$，那么我们应该是从 <strong>所有结束时间小于 $l$ 且刚好选 $j - 1$ 个会议</strong> 的那个状态转移过来。那么最好的方式就是一开始就将 $a$ 按结束时间排序，这样我们就能很快二分出来结束时间刚好（最后一个）小于 $l$ 的那个会议 $p$，有 $dp[i][j] = max(dp[i][j], dp[p][j - 1] + a[i].value)$。</li></ul><p>时间复杂度 $O(nklog_n)$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> l, r, w;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Node&amp; a) <span class="keyword">const</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> r &lt; a.r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; q[<span class="number">1000005</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; a, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (k + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) q[i + <span class="number">1</span>] = &#123;a[i][<span class="number">0</span>], a[i][<span class="number">1</span>], a[i][<span class="number">2</span>]&#125;;</span><br><span class="line">        sort(q + <span class="number">1</span>, q + n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>, r = i, mid;</span><br><span class="line">            <span class="keyword">while</span> (l + <span class="number">1</span> &lt; r) &#123;</span><br><span class="line">                mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (q[mid].r &lt; q[i].l) l = mid;</span><br><span class="line">                <span class="keyword">else</span> r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++) </span><br><span class="line">                dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[l][j - <span class="number">1</span>] + q[i].w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：滑动窗口中位数</title>
      <link href="2021/02/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%AD%E4%BD%8D%E6%95%B0.html"/>
      <url>2021/02/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%AD%E4%BD%8D%E6%95%B0.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你一个数组 nums，有一个长度为 k 的窗口从最左端滑动到最右端。窗口中有 k 个数，每次窗口向右移动 1 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。$(n, k \in [1, 100000])$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>用优先队列+延迟删除有点麻烦，可以考虑直接用 <strong>multiset</strong> 做，本质都是一样的，维护两个大小相同或差一的集合（自动排序）$l 和 r$，$l$ 维护小于等于中位数的值，$r$ 维护大于等于中位数的值，$multiset$ 的优秀特性可以在 $log$ 时间复杂度内进行增删操作。具体细节较多，时间复杂度 $O(nlog(k))$。</p><a id="more"></a><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">medianSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">double</span>&gt; l, r;</span><br><span class="line">        <span class="keyword">int</span> n = a.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k) &#123;           <span class="comment">// 需要移除之前已经加入滑动窗口的元素</span></span><br><span class="line">                <span class="keyword">if</span> (l.count(a[i - k])) l.erase(l.find(a[i - k]));</span><br><span class="line">                <span class="keyword">else</span> r.erase(r.find(a[i - k]));</span><br><span class="line">            &#125;</span><br><span class="line">            l.insert((<span class="keyword">double</span>)a[i]);</span><br><span class="line">            <span class="keyword">while</span> (l.size() &amp;&amp; r.size() &amp;&amp; *(--l.end()) &gt; *r.begin()) &#123;   <span class="comment">// 左集合的元素不可能大于右集合</span></span><br><span class="line">                l.insert(*r.begin());</span><br><span class="line">                r.insert(*(--l.end()));</span><br><span class="line">                l.erase(*(--l.end()));</span><br><span class="line">                r.erase(*r.begin());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (l.size() - <span class="number">1</span> &gt; r.size()) &#123;            <span class="comment">// 左集合元素最多只会比右集合多一（窗口大小为奇数）</span></span><br><span class="line">                r.insert(*(--l.end()));</span><br><span class="line">                l.erase(--l.end());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;         </span><br><span class="line">                <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res.push_back(*(--l.end()));</span><br><span class="line">                <span class="keyword">else</span> res.push_back((*(--l.end()) + *r.begin()) / <span class="number">2.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>123456</title>
      <link href="2021/02/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
      <url>2021/02/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="f862006da249cde4a411d7d32ddfb798e8a447b277c64c0fc1e05f6f457b9e66">88bfb973b5cd9a98289a5356073cb3e5594eb6ba137f50990b97deaa4f5157d6a3dabe6ba7139b261e731e88bf5951f014d88d0bd15817c39eea4c807d1034a17dd240dcfa03f5ba8341e7e8b2bd4f4b23b63c24afcaedee76b28bac83097fa9053e8e0bb0c6629447ece4b7360313bbf458cf0e87bf236e20082b6c2a46626cd6c500c0cd13dac0f2ab450a2a4312ab299c11c0aeda96426db73e64ce3d481ffe04c9cc9c518016285ca83b48325a211c6153bc114b58a9d9d103713e10073ca858ae70b0d56cd6a8b7471c4aa9c225161b3437fefdec3ab76edb551900ae59a7c3d40621df6d54290ba9fce16d194d9d8bb7da09e86e154bd0077842955436cb0e8cef761a6065be2bf0a33bfd51258cefde4413074919363aea385738f6ea65f2d5c384e2186ae40cb7a872939482654c8366bd195e358b518844c0bb05e7a861ede9433dc3823abeb31a62773bb424d4f6f0b3fe5af357ef052e8c1e556bb2aa62db5f79af69fba9ac79e92c82e06cd3c926985731a01f096d2c5b46f502af123deb642fc12f71ce8ac839a2130af0b48f50cbb4141d761856404ca2a18ec953892007b9a539381ba1b11b11f842a0818b8c347032e437fdb5ddf76137f56dca556233facd384fb841822de07f7a70a44d84b8e435f386c42a8dc7074585e5c84cc65bfe1cc627a67f4fc8d81940c476ef5ad6e8a912a058a9dbd66957fd72adce9ec76f19c49cb3f7934a068795250439f0a917a435dd286eac6d4f90a7a1ba83df0979a9f4451fca4d992901fd73b191617d3406a4940451f8ce3e0793487b7e2556c071256b19c471550053dbcb6139aa4e4d47d45eea054effbfda97399fdfa7cb8dfaaa55c37199670eb02958d9bc6b49159b9938902a5761bc301aae45c557b64ab491f515bf6085f673e372545b5ae3e268ecc78f964d94557ae6e510e637e45d65bef5582587f68bf284c162fefb925f41bdc6068a94e26f90f00ce3f6dcac4440a0c2f8f3b4e30c240a39324930095053c1cc0bf329e408f03ae3ac660499bb0575146fdbd3130b1f81b8003d6898270b76fc4ba17dde06af28e8607d7b484043a827cbe598cbd79b4a1364383766c71201bd7777789c1985ce83cf9d16a40cc3a53c2fb77b699f425b99c41e02d43c2cb5a6d4b6ea37e22a10126df6f07151cb8cf56f47c64b72e6ee8f1043918a6b822fd7aababc7bfd3a5a2144834fec6e38da34c6a8fd85da7b4427acb2077f39082c4225cf7263cbeb78a35bc2af70cac42f42caef3d62ec49de4fcdedec9676bf0cd28c03828c89a4b7b1659a047d6b871714eb795b126ba2ea5c5143816a7ecea7d175efac463c3d9b278084272d287b03f762f425221218176ee8b041e5d4f5760a5fb43ef05ab755529dcdbb0c040d653e55363328fd48ade42ac6654097e16355921879c25843cf2426dfbd42b7a3d4e4632e1078bf1906e55074dc6532e435236ec7817e7414a23d59f9b5ef104f5d3040f50cd8da9056c33720348d789d45dab0a25408a65fb474ecf5f4bbe10ae2b573b1498d872338b01f14eea25b40bf687ecc71811f5b643f418f4d9c94514d2433cdea0f701126d7c97a6ceed800ab6037bd64bee6a41f1fd1d4c1fbdfc8df30a9d1e2bf346b408a43bb84b0cc9a2c6f0a6806d07b7ee9a1b43c4f40059e1f2ded7bdfdb048f35fd3c17ec717aaf135b5b07d248d3ff7ecd273d8f73c26fb758a38b8a356b055bf6985817f3cf56332997138bf01f6ace7973dbd1ba25dd6d40c395d0aefdee7cbb22f682b5a9b1bf05447810482bb8e28d5db0e7716f734976177fb09ea176cde09c056c7c627d106570a3effda367f0dd7d2fbdcf48d0f566513e9e9990978400b0cab065b7111a9ef951049371c7c87652c6a31e1d08495faf5e2fecd3650cf3adee41ab0302859e4153f23310d051adb7eccf94be93b90244690aa23cf39cfccf8adc3fa7ef38c0d6eaf596f1479276a2e9063b8035450a8d528913a6f369633c02994c234cd58c8f2607c2e8d8813eb9d4a0c96e4b03d5c3cd0f0f37fb3def534af4bbbe606a1b99310984efb337594902a4a9f2903482a5e34d48011e9861da26ee1bf3d77bf415713343a1e9498d09591a92aa8dceb16e978ca5eaaa1eb0f690fa3f06ff540e156cc833db3ccdfc031419c9bc636f3a81c768795656d22bfdd365674e179ed16f5e08803b5b0d56795fb8f1da65ca6ead57424a409ef7e3719b8bc916fcf72da67d6b14f2d11ec2c6fcd26f09f16489de6f9092f09faa0c8fbf9e11461cc20e395e516566b87c5ee36344ed2e410517852badc89e5ba031516294724e30247b956f5587019538753aaa50d298a175ac5570919d54d591e18355c66794d91bc39bbcd886353267cc4ffeaef7778d36b4dfc600c6686efdd7331c99d618784ac8e1701e0f15dce852be4bae47fb4f3473c0b9a5fe8473671f0f9475b4da2628bd9f378c1d86df6dcf02f32ae7361bcb0b0a70bcabb0f4f33f1ffd4019b67798ffe82bfb8f897eed5e97ab6c6b8a6fc57e207b0600aad5f0f9f41e9a8296dd0ce54ac6bce4bac4a8594b062f905814bffa99ff2934d44f1a75c6fc36750e3a36c0b89b5f160af29b6f20dfc872153d3d4d0b413f661efffb894ba62eafca1b5bfe454546f82cd49a5b00dbc4108b0c4346d8e56e290b7763d12cc2a596873e827594652867c376303c54a245da8cb03a3b415883e7eec0e048900db8a2200320363ad9563d0a55a081cd56c93aea3587ba7cacc3c30fddedb4b644bdf66b50dcbb21062315ffe4ece08645353ec8d030611a030f603f8266d1f2122ed27df46234910b4ad1070bd684e7237be14f0ce7e5d42fb806c3a08338e76e7b816aa83429f2de022437b55cb31d25409c8e1c0831237afe4d2ece7d34ff779a469755bd4be882e7399aaad1c95be67989bb194445fa05438c59b402c0d633a6dffb06f1c607ffd383c4c9906fa1c7a5297271efe09a378c0ed6645e99a68ad662fd12c647780b038cfed7f8f77a023d0984e234e133efcc32a1bcf58dedd53e97c588303c5d0ddc6cd5c7cf8c86e17e04663b2134656ec3bd96ca8de30772060438b3623435d0bad5bd89f9e3a80ecd3b9c3d8a19a14c0e0e9d52250632f6242386c284c9d389ca30634731d310b190b5f796747ad17fc63e67e114bde1fe6a328497e568307e1b6ca2dbab2d85ceee70325efdae8ee41b439c62cc67b1857d4bc06fe54054d1daaa0a2eb0931e515a0d5fbfa9f0d27bbf2f538caf3019a26203b91a96aba167a0f4f1342f7605a59cac718902f8803f300a1100c0dfba863402a42be664bfa495be596936ce9124b0ff5f676f2bea70b3c63d6a53aeac7d63eab4668b0e641383281177689868a82bba51d91600ef99972b52f308531de97d689e77aad27f68d54449987e875ae920956b4c7710bf70295d8d76a78d295f14a74ad3b52008fa090bd8012e40e90d5a3097bde778bd6c5ade4d313a4c141b7e778e4cb140d66f5c476bb1e3f8ee680d5120fd2491fc8aab70bf9dfe9cb095f3578641251af0eca20c66ea1122dd5f5eb63482ed68295f72a0b184d05b1186a0a2996dab947513f56ca1d04a5d599ac605fc0c84b11b8f07b80f183af46b0bdbffb7fcb01a171f0072b33366fd040460369aa981a091961d7d312b61170fa96e325af236e175a26b8ec93dcb0b9fb526ed68d8349a4963b8f2682101957e8d69b2fb1070db0181b1b21093f7f9fc49dca32d26d0a7f41f3234a72d33d86587e0ffffdb7a724c5c4247e70c7bb3c5446da2753e03be1e22b1c37f0bc1479096c22551ecdedb0c1d2c428ac6b3369d4aeb82c94b1036320d5b236a7fd68b908dcecf1ce7b810759ba8028db5693135775eddd0bd5f00463c50378091a33746cbe2e6339d2341062ccbab079dbc9521e12653fdeac3a02db15bdbfd85f07b8fad70acf1c4540570859552ba2915f37bee5511314ff4610d74b9d49e41a68131609aa0ac8f65ef3e288709b2fbc383941b245c68c10ca46d4a0e4fb157e6826e84fa977a49c55555374299ee2217350e5074d3b5d21435c949be5b740db85a059f12282c06f1b232d709a22a195623e15865c0d8987c46b8160f231889eecf63044ac603044910adcdfb478a9cff955869ef778aade22315a2a945f4cd453cad274c0f3b4b8abf098d9c8a8f96965bdca0fbb24dbcd6ec54957c431b1617304b732bdb1da12366204c8ea66e35c3802e0ef61b8c2ddf8a763578571c6c1fed47fa55c64975d7c55bd296d972d5f8476cf77e317494591fc377ce62a6dcad92ed1fa061d0651b013949d9b3ae171954543dd7fcee59b137c0d95fa0c1ee9e592b2be0f32d576d361c578b4768c7fbfe6bc02fc09830ec9b66833e243f790191829053426844142b3e5e37989ae6008bf3f9ea9ab12901b9857dc1ec672fbe0590008bdb71df34308a287e674ae651e19bb82760966c8ea52a38782992bc5254594bf059603863e631b16fe4f25da9deed154881dd54d915d96dea9547a29190c6f887ee82fecf78549de9f8874ef0d9b89b5f6c44065b1e2d45e6655e6efc370a51480c3f45c7aa7023e8b49595cbbe3409b44a656b8e506492590d59b77a081191d04699ef4d39f53822bbbe0bbb367a1911c2ccf0eacbfea24c6fc0e54b8b22058e6236c1e6fb8f9383d25ced40e9cda416af77d14a835a50f0608f0670939844e39569705441c68af041078957cb90c3777899e197a7082dad18b69d74d7141f90efd173d967bcb9b58a056ec6062d3e2ff70dafb8dca4132d016d5383619eb015731b4501fd3657c990797d45a05a061a7da5c30235cd2b705b29b41a98cf3263e2ff789ba836c8994b4d589fda1eee98b0b11178c22934b673708d576b2109cbc501341d84d4523c1c25a26d773b304549fde8432527ed0ce65cb7ca1af4bd5294aec0483a11770152a2757ff059d5d25d70fde60a806b925ab51d72da4a15d9f18807cb7763b46758b936b87b060e13c3febba2de9cf68793ef7d04870a51c934e62d43dee6bd6990486ac57366b4712dee4a233bcabd58ca3d7f12b8e48f2de20138bfd5cd91ebe8d3349d62c13c264fda8af1f38dc4683398292617a7789b5a9772d306280fef0238033c4247bb15f269c928930c90c9088c2bf5848faf6eef8ee7168148e08e5a0a8bebadfb3011912fce30c82a78cd563ada248aca9ce05ca674428a013b997b1d4b7da11f2cee285732745d1b232cbccb4f2aea4676d60d7150ea0a016bb6b2b4aa793eefbc890f881ae407a3c25b9dc624f20bc2fc77d4e73fb374be9c4309e6ff9624b605f937dfd0bb658837e17e92034b2e7360f0d1f16d0c869e096653d76b92c00af78bbcbb86bd7e2318d521b65e431f012d053865ecd6c6edce8c4f49be8c5850cddc12722284ea8bf21a7de84c603c7f7ec2a260c9e9a0e6dea909ea05273c4fe0f2cff0754308336b84f218009442d36e6e143fe07f9b9d07683fd63f3ab69c75ce0a1d245887f35ca091e7cdefa83d7e49e4c9b59db65fde5c01fff8d1095834c0557b4bf79b0f448c7e6f631e77c835cf4e752591cc7191ea39524a87f54f0ae4bd14514b494291f7dbeac3f14cb344f2a7c15fd4115324e36143ff57e0e55dc8ad4bf456da64d4500e331b2f298222ce10e55e4c82f7987c564b0b996bbba4f81c38f85143704aeeedc74a6ef59ccec898a315449d7c6c08586e396b84f19dd65dd4ffdf4a92ae92ae0940b6ab5e558b04e502481492a22f6fa1ddb4e136680c232c685cdb603dbfedd3944741eb9abcb20e1ef81397fe1f62a2ac421f6e8f29bd01dc98eb231302e895781edf84873c173dc46cb7332079c8eab0fb0b7f4cbac488553446d3431b5a22040a214fb8aa7ae57c698d3806f9f50d4c5522b9246a65d4d8f55ebc9dc8bf3cb01a5b6bbfcc8897268963fb511d0a9b5ad58730f0f37ffa3b1c6c82f6aa6240cd75ec20c3d31ca0994abdc2a75730d314eee7ccf49bbcff473d7d9631eee928211df09d6636d75fec1b588982bf547eee5263f81ff420e508e12f6c139d1b08c51d4a2224ff5946c769badc1857a533eb072f4897f150b0600e9e9d34780a05553b196563bb781518441598f2928367cf21cd9dc22dc11403fc998c4aaa071961d184183224f1f57583bd63bed32974f5419e6badf2dc91ce18b2fb3fee837f23121ea531430d78212119b3f626bcac902925b4f2fe8f0af16f6a8629eb67cccf59573ba95697e7e3ace9b7e6eebca8ccd725dae049dc09a44548b2c4d53f3bdeb1d29f7ec7a80ecddeda7b49d02f4b27e66ffeddbdc99c4cf188add9375dfc7987b5cc052c0212ea004a82797c1af1daa23bc3e7634d3c133413ae35ff49d80f04efed7f411cc46f6366014946f91000c82c506d3301a09bb283dcdfd18cd7378a35ec52a99bda5b7313a039d66327ab735844dc979b3d20b628191ff26d316646f821b545deb01f52a54859ee45787a7b4c895436c2e9648fd8e968925e5c8e7ba8dd8860438ff939d2cb4902e0ec75b0ad163c1c900ae31703a637767cf7454d13d7864428ab8cc08d8bcac9d8e1ecd495572bb25ed157b069f09bd98d98a50cf773c59c76b2a31c937d662e671c71eed3b1802ae194d21f2f013d5116cd5723ab96a545923d900ba5b331045783ae2c5ca09b300de0c6d0e838312bb58ba3603f39a5d8cd7435d7ea67414442a46460cb1aea2cc8aaa6d4b86df123943d6204e786ef42112b86a2400b080a7ef93e04839095572de6cbd59c3d42f1c64c7e6d1a48abf1a7efb06c9c77ebde8b94981565d47522234ad4ffe6aa9f137efe727aeb9c8e75d44a3255e6fc3e0b26aeac59cd62112714b334b4fb127ce340cab042c59673547fb15bd0bf70fa1ac676bca6eba2cc1cab7df681736c97172051f0c9cc9728838c8f919f23d4029378d8bd5b34ff3a0c9af862e00950b82147b10b9c2a415f98eb128b6503cbf5bdf5753c8d176dcb04b51b8058fd590fbb34440336889413117871d54a39812cf30839f8bd35732617105ed6ed6dd23694d85d4940b59821116742b09f18880631b894d87bb0a7798236f2d4d53b44033b58151a7a9ef1f9787c1e50fe67c1b035cd56f20f914f03394afa3b1721b02e509cfee868ed334a22852977e423313c09b0a1b8fe005f33d111fb415a8c1ed34ec8cc4fe7b9acdfdf052174a6229a23b28ef0663e420e2b7d3468bc1761b26e5fa104fe4ea1dfb400d38d8da6b1af9b2630b81db81f1e0f79f180170b8ef67840c348ece9f90a879e255621d60890fba880e7ff7c5ff9625c8c8cc333f42ac712fee3858434f7c57827e316eacd467f710998d1a96fe443c5ce4c267bf3e84c92c541113537e81c0fabbf9bf7929e798d69a827ac8a4d2de07dba6d5bd19812e302c6ffd49d473943c1ada49d7f3dd5c870ab91599693f5093615f92a28b2abc4ba9d73c84f8fe91c34d7bcae12ecccd6cf22007e85056da47e826369a42c88889c9f4c7099acf1f5cd4d8ce2fa708d849b49aeae3b36503d9ae63f85a91841d138702ad3e9aab9212d390b872e18ccd856125a09bf203957705a1ad2342d8a09d0540c1da220bd63f36d78a3f4e97cc5ba3fd9cfeebcad4ff767846b1f15dc052175f52dd5d8e5ae04dd9e7005f5b087762901f64bc6edae67d74a94e4703acc10cbd727e212a064e981e840e6fea5b745a2af631be43847dd915856e69a51da6710fec49a2e828a042ea2269a4c25aa111f7b541c78777399253b32956da518bf2f8a0c605dd54072adadd92ab6970b0e6bfb7719f81fca560433dfe365ae2d72cc72f2d3ea42f8e1a612d3f213d5f13975212f2bfefc77e4515e39691c476d9f626861234c2af89767afe6de31529e570f453bd6672392c0e598340ef21faab10d28cc2c96dfa4b219bca9ef6011ce6e5eb81774bc3a40ef1e14141283a1c2ae6ecc4d8f214204811be8db985e0d756c4da5522b47cdf7f9f2e9a0a1c9824e9d1539ae7788860ed795496d7156111adb3b3eed6e4b6da5f41a91946deb634539dca74291c200b2d29a222239233ab609dc6d452b0367b48401b1ec11df8a2ed0c216afe216ba1a3fa11f2c4b0c1f43a20f78ff54bd6106149b1c54d9e917e912ce87cdace7f3d26db25971245557726a8b1a55782aa2f8f6e9785b6b113acf911fe31677ec7b32553d939a07286268071cd470785991d8bd914f86de61f985cafba7941d1637736d511d17407559a930e743cd84831b9850e52273845f6aa83727fe45ccb872dd303018e5b61ffcbc1c536a4b4d3e628be9d8f84f63441488a45acbd397fd58ef02bce4e84f5dad78855704a39ed5809b569a0d18407e5739b6d0acdee778853fdf6b4dcf465c317f0f41148606e0635f09e4cb7e3ef8ea0833e7eff49f2e48e1b6dd1a5769594721e9ff31b611b6be93d9f13f82ff4a5703a5c81297a893afabc60c0a94a5e56f91e8523b304cb4ab9f6f1a977a6e553962892e8e1c960577353a39f6303f2193cbe4770b0c5984903242ba0e36f6cefa3d49711d44ddeae99c5f3fbb54adce07d660809e731f06dd502190f3c9429852fe823486e77425650efd8e641b2ac6d475100d434e6e82da9bda40f62d51b081e3fd25091510f66157fb60e21172d8c139401fdf788b8f6219fc2d79f14ae6eba3c4f89c2d02d4c50e05ec1eedac29504e5854c6a0ad9f9cc00c1d78886ca461859d570fb773ad5bc7c63b7b496ca22984541e4289d464a0167b9d8b50168150da3b2290ab6df96d6c89231574fb92dfd0d299645b7ca83145f8fd338e0e0892d0f7e4eb66db302f9e2706b2e2b4c1e49b8110fd133b149011bb28023b04f5fa9b5ec4714166a31ca67af53196d922059b385e4a5c7ce5f02b51de64df7ea8d7ac130b6424ff4d2b73575ce292f3cec484afc528dea481e02f8ddaed76a99c16f61bfde65c26888bf7a4b0a9d81afc1b63984150600c5ee012ce0689c9685109202533de86b9913849e3a0b3cf8a04aecb68840d9b33d7a496a2dc5c2058d7204a4aa81171d5b14e9739f2dcec3f54bdfbe93f7574a48b8e91e90af44b97c0dc49b54f527715b4e8641b231f79eb12c64240570357161fe713a7f3e26e7f758c3ff2de258ae0e2e176e8d2670053df8c81ff4e5995b9410237c224a1c44f462d7325deb4cd18a2a32e810ee909a5c78a45a891c22e00c66e66f0acaf40dd39b68cc14e703eb3e5ac603de7cebfc107108931920ea18142f198c13e7704b5e829bf1bbbc92f5f8afddac121082172387c941d1fd8d03c6fae60d73eac03bcc26150d8f046fc6b62a1493b620bf014e10cb548ed746137ecbd0976baa20846fc68586c510f86c5d25e4bbfcef46205c71ac63ef53de06b760ea4771d40d9daa63a4c94718b425412be56974542023a0032e51af3402ffafd27ec1b4b09c8c34d40cf47492ae1dacc1f56e15a73a90d4421f52c73a3f0eff391171d47ca6e9aa4d645e2797ef33bddb1d46cd879f9695e63a597c0da0a466d2be3454454fff0e207167c9d146989b2b0b8a2c580ed86db3664e65e4991d8fe1011ad19c275ba5f10204235d3757d835b70733241008edbda5b1397c2e4c54a1f4bcb042e47ca9131dad2610a52c9746e212c731e33b04119b54e3f550e2cfbba6ec0c366f5282d150e7a9f24049aaed53d8fc04993bdbea9e30fe1bbf18b0d076acc6fdc8744646944c8c2457f58baf58592dbc878905ce3fd936159993ae2a54ced0022eb7eae4f2bb4f468a3ad7acf8cdb5186568255cc30e7936668d1e71e2d8c934d684601dc7917fa159fa4a1cb6fbe8b579f1d4d7cf9953a31fface3e7bd8e09602b7d52ac3cd431853eadab2a463c8ade005788a015b7d03b761500eb957bfc12c5b0eed9ad76897e7436529f63213a0b867e751dc8c3ab458e1cb37cdd2ec204fd52241e1d6a1d9421227d9089b9b5ac32efaafd2ae7462d38d7c419eb5d1885761a311883c2862ed1337f7f4bcceb5e6900002ad07fbeb558fbd9888fc9cab82bef19d037a5b1d4d2d10cc381b1b8d1796e9cf222fb90200504f212751a73ee9e1c9a155c9202ce6e3b7ec7687c16f2cb791e1b5aa3bfebbc6f4ae9a1681220447c518933212c2d5a6fd4f0e97ce61bfe2f81dcdcf4f1051be58d6fefcff7e513a9b8a77851ab49bb4e37cb1e7fdc48dad1079c5416a53d2d969c88c7549b243e805036e3d82cd06f72d9fea0e146a5211ceb53c067581590deef6ef86ddebf43d4a1f099695d2768ff8a75895e51e3f4f27f49667a7bea4dcfe4b5255d95442a5fae0d35b4fc003fa46f940d33bc6ef557ba3365682099eb881a4fb15b57e7e6647eb4cfd56599f563ffe774b7e8b28f925da0bfa8f3c965d26c2e896dd36dd769612acbc94042275e7624db6630a781485149484ae568a1c29ff03eec02cbd7f77365ca448e1f4aac03d40588d81b9958e891c6e3f78083fe8d02af4e983b5238b0f554db1d94f0d06167428c887aedb7921de5de1a0bb4d88d2421b05652cfcc09369e82749e721e883c25127dae02d9501187638c30e2c41cfb477bf5f7fae293fbc555dd982bb2a73ec89cc45eac8560705c0d795460a592941b1eb5ea6e7fd8dcde047caffe4ec02902367d21bdfb51e1acf6816dc0abe3f2c9a2646808ed5401e16c69b34ea68d1c1f9a33af444667551d19e3664c006e3b9d7cf92ff6d1582279116cf070c6613c12b6675c7e3accb0052cae38dc3d69a9f1adc24c2362e3694914bfa8970f033ecac5b4ec61f0e0cf850612a81691287e758e4ac65b2f84ba5b08d326e9bc9c0e0a64e45053e69bb13900ddec1dd5a6b59d74e78452d3a3a638796657cd467d7a8820df5f75ec3346d64e33ec15261ef977875753cdc4d6c70cd06b8f2df61770d32dcc70eaaedef4cc8f119f63be03552fa321e054cbf812fe52490a5e8a9b74606f9f35d86e942ffe053795ee92684bfc7dac7af0654dbe5a411cfc90935d2afb6e71bdd835a788c53448f66d86612be2d59621a99b5fc526841a5d645c45b1c821bcff1753ac107ab32d1099876c65a27c5ce3584d61045c6d419559e317a126e4e7f72baf922ff1efa759ab4ee6cc5c63d24b04d8d61a90f086c1a2f91a5c25d0d7d9331c8c67bd091aedb0a4ad720f121939a3f3c54cb66d256c21bd29b61da004e0492011eed2d0ae43d18480f8adf3e708cc5e5524c035ffd0e483fd03d5b0a9c62782e2e01b2e04c14a6c112bac7416a3cff75aa7999a15701ea455932bd98f00fcb56d9734b22ccb683f82c952af6f03aa60c9a895abf4077e24a52eb3607a1a70d95c2347eb5595761da2fedcc28418024e3b4814d7227bbb45e455c345b2846f3165ec0f621700ec612a417fcfbd755720293c7fc8d6915b49ed46992d7ed8a4ad9d1562db6e9a7e887fdc4c4ffec35d6fdd3efa8da7e4aa4eb2c47452071a03aed35923433198104c0fc525452b10e9cb746506a2fac8aebb4471c9fc99da384a07ab66d2e1b96485ccbbf11c94a7ab75bfa040053e0d7a1be8bf2be4c2686c75190484d82b7d6585a5c209ea270f330b92c6328a74826493918bcad7697d2a83960e9dd74af1f9c39e9af5c1c14de846d9a624fafe45b76ee06854d6620e32b26159cab6326c7501ebbddbc263df899d10bfb8b960e05d75b124b9ba04437173b73aeab4e88debd74570873bf4d4b2f43a6f76441a07c314638dc384abdf1693903ca44def36c132e7b4793ad07d86b684eb43e214feb32e437894265f85ee7db731eeaecd0c6f2085f350e1a1170643b2a2ce5f663850b0df43ea17c39f2dbbb51a65d749ef87e975817c5b39bbd73c06e36c514a59a3b5b609e8360c7a750a753f429de40b7ebe45f2935655fd9c271086751883f796fc1a6fedc5f1e331541f913b228b44e6dda9d2398a06af2349b5b37910bb4f1e9907dcaf1f359aea064dfc9e38d4cbf58bab4d19b37313b70fd4930d6145aa692c57fb404497c206d818dea578a54839b83cbcdac82c8db14847921343d9a0e14a2e3c35f3ea822bfa6653043335e888c43941380ff5b53e6e1a275121433d1092301658602ab6d47b338df7469f6f897a4b3340cb2a6a3237d38e4effc04b9b5e08d691f56a24f701785fa0f825cf8c307936aa53b54d02c317e43085547b701288377e5bc3a36ace59eb194a75f5ba03f9a74320fa8269c2a976472dcff09b385fae4a794e3c7582aad9a6cc0e3ead61f300383c921cfbb5f6d962e5712a9b0681fcc187233e5d7b708d5f5a8200b28279dd6cbdd802d90323454ec6e39da688a5d806fd73aa685d08bd9122b3e3432a6f02dfab08392fd949e4d32f7865a7ec8e9730b498ce1d18f8ddb80f721bcc3302a7b2cd615e4a1a7c3507410cc3f96afdcee5e7cf7c91e1e0edc961904647e2e11c6e9a35c1f400c969d0407b9bc85bb263df75a43dd34ad137dac675cdbc0a3cda11d649083d853510118cdae4c7b31c8d29a9b351636a8be22fe5e69c2c090565de33f7b08da4a2bf9e55e191faccdf24a0c132489b774654f9ffebf776260f77999ff8917076c41c139af50654b68e5d6b5363967f892e1c4aa475090ab935fe72725a1c9b9a48b3899ac8d801a22859e9854c04166bc80f5909b95089b4192be909459dffcf9fdf005759113a0cea51d0fe82b6a430d0f0ee0baf3b554489f0bb051db8bf7daa39c6ae7c3094858630be4806e2ff1293e43884260f39c0f559e5aa94f217982c5751901788875105f389f27ba6e0208b70f28fac8eafdfb90246e27ce9b9d8c99bf7662ddb3709ba10c73bb10fd781944b0f780da62544979a789cdf8580199757e5e22a48e23a0622d3d93d7ec60b707b52af4574dbf36d894ff50b7e6f2bde232a0c8dcc10daf4083f13a58b942021c5fd0b1bcc5d8018fd86935524a372037007793244c9fb613ef0eb72760bd1188dda95d372f37981320c80b66f11c155d2d79ea2c29161335ec23e717deaeb768facdd4a8e245882b1737a2ea563e726062e56ee2983b7ef26303838b6d3cbbeacbd9b5a5a65913bb587b5b43ecee7661fc5fa486e150949b85d929cc18005fbdc9a3d97c715d4f03345dd1a83c8fc2df6bac1b32112521cea549ca6eefbac58fef0d043e872d2b011063098b1c47e7a28e2f7e69c17f6498d018cc6664a9491f86870b5067b128e746c1d720c8c1623718667cb5bafd832de49673f8f3e84234cb509283e730bd37a6890698fefc96121a9ce8540ae3238fa2612ba0c83e02204ff86b80fee6bed78262ad3a9a8dfe10938ac2f2003a52fcf5fb8fbd86c7d5f1a8908f790c79e1a43abb909489eb303e6e88d7e55fd70d02f3af16771b9dcee983145d838079d4c60c50417b445936ea2b154f4e5a9f943ed829a31b0d5d7a06c379340b311473d98bb4479b18625627a867ebca638b2daf30795d4ad64ca2ef5b4fe07a7738de83a4105ba0673f16246db9d2534582e9df358357587d25a4bba4feafae80bf05fc2a96f0c2da182eecb17b654c1767dc3805eae14c99b7fbfb25b46f0587c90f79e03a26bd10a06fbc887041737dabc660cfd247d99df128852409fdabaf8048ce3f5bf1e838920b8ff5cb07c84d1b356e31ec83ae19b9567f336ea1038478228a0b647b61988868cef42cb3f95d3fa1529da3b428f165563393ea8b1c40b9843fa9abed93917cf1493344d212a49baa3a181b7194d9711435ec2a6a50f1888abfb46b664412efd496063c93a10679ab2f895a952f71a880fb3f8bde4517105a318f4bcbe54bb9ce82a705182511831a3b80b12a57d74338e139c835c7cccdd29474d944e81817346678e6912cdefcc7ee15645df9663607fa723a71a0007b7d1d5188739094876c4a1d439028ca411ce8c2d792db2c2a0f267482e26971f476eb40fc53f1e6cd615ad7535f097139254ba4ea7b950be47ae393f92124f2c48e72c5d579eaceeedceacd8bf9770aa7fffa6576d21f67741cfdf8437373180e26394727d9a0f4ea5f44c15e8c21758d888864833d100a7e673ba11c131f31975646aaa45d58818403078d616596f73e324848b7b29d06f8651cf6de028bb4f7a714a857e31b1a98aaf4198640a1f8a70ba4cb11d03dea5d705a92c77c8795a36a752bc6772ed384b20e866025b35d22184c7769469c3002210bafd7e3080237b5369efc104c814ff3755d2701396e454364fcd7f9181c63030f868b766eea8bb052084cf3aa00a8699209b4c8350972808fe6d6d262ac778ae1b8a9e8eb7f76f8ec44b891340417f3c69c0390cc01e189fe30c20ea2a85b1fb871d8ff50099edecd0fe1d5d9d917f055b5a8cab371bff903a476b3e3e7f9d7b7d33918cc16a815d2fd53b1e931dec8b18a93cb283f9a3a31a89570f4b79d92587dec7bbbcc4b9446945103df20ad53ff9ce3d3588df77406a8b18d6f66cf444f9eabe7372805ad9ec20155ed5d053e7e47a6a5d003fa8b892831aebda141bc0fb8a40abf94f26d9e7d6a6392de6557650a7cb7b1f3d9c5156497634baeeaab1e796a59b2c36c69e764e973c31dba47f28dd55b1758c4c652df8c5c0955f001ee82b4911e29b3c1a778536848923ad43b116abc675b82d4c4ef27740954dd4cb2b9639ebe9c434a360b7fe39ad3e1bb3333c9c0f82e174f3b12303896abdb893c9a5c8a78d61b5dc54597aabedede06cd13ecbd6ee64c4a9244b32d78b844426359eda014ddcbad3bf751b8cd89e37b065fa97bff9c5abd463e7d923e308b50dadab39dbca9cd3bb8aff92ab1be2de2c836ccdcd3f0975f6bc52d47b5bc76cdad13d538cf3bb81aec28fa835ece6c79152a6e01a591880d128bf083e9c44321976ac7c1d9f385365d995c9656011e7387fab44f50a88425358a5f606553d3cf840c0ed39da72bdcacbd8629290bc7168f569c5fea2c540ee587a1468caec26f5dda816f4cc5b2e83ddcdd6dc92d52b9ddd5595c3175780873fa767e161aa336233b3cfcdc2f901f8577cf772d6c017be483d12405e6c26d9a6670453f25c9ffc4661860d3247e43ce2ef40e98b9cf94e183b1b7779478d2a5c2dbcba3c7a25452b4ca3b2ce7cd2b9e0e12395fd82642ba448b0e122c7e61d42a1bd3e3fe2e93457e372c18bfecef689303476b467ac1a82be141e01dcb1df2919dc5357defd7cf281a0fb7684808058b1e9734c4af995358228391f5f7d31608b6d51d486c101778f8a54e51832e766b6721d3d84d0d9b4021e30f4e476768069b6a07ab6226802de1bc32e108e0b7937002763d8ed27749dd817cb97b67cc371b8eb20e2790392a13a176a78b71b87b5719365643a4ee35bb8512380a3d2330b8d7e5d58dd45eb15cb31ee9f59109af105e43a5cf102a59b482381ac0997b79ba8c32c3d98fd083a52751b95d603fa8021b4e8f97d8f09bb50aba4f62c4e3bc5c537476fbf6579d3baf21ab3456564ce718beacc6a341c5205a8c99341ffbde7558a528252e686cc07b27a02a015f913c5251d58d206d75a10ea250269338d55802712b8104235bcba5ddae1360aa6ae21cf30e33a992b9d7a007d9d565841e95c40e730348788ee1f542e99a40c6b24099e41da00fc2b535c38e9042724d2bb77e60217fac4ac6359155fd2c071123df88b3bed6b9dce54761b9d9ce926c046b63d3b534b1b9ea4ea84e3f27bb71f99d1c38c5b9b3c506e8b413dc1bae723feceef8bd243369869404116161f1d64b678e7dd2b2a3824be370654ff9c686f73affd0b525f873746ba939d41f6d30aaa03b9cab73a2a92427618562b78671ca71e7c7554c6c1dc6c187face673fd769339273bea8664a4a6698f62967adc0447641ca307487a7894e8b854eca6303d8e864e9d7a3806072709743218af87faed3a327940097fecb20f6da03496a4b2b4b674fd7a58cec024b207cd8408c691a27f7cbd2e76474ed369ba9cebd66f457f1706c13cac7486b94428fcfe960b810f7c3c74802372049958512fe4e803186d770c571d3aa06f6d0bf7458e5a4f195fa3ccfa07ce88fbaa47f8bc86fd71f1b5b6dc6bfc7141687fce05583750f9c4150efa1357bcd0b18d87aec5df1da593b553b2188d67579b80e3ec6f6ee73ed65d498a3839b1c9996ddaf7d0b842c8d94abd66f6798c4c12515110d7ffcefdd627b61c07389c964d1ac4be9e60d0b17c1e7c42d1686f04dd03b66a4140570bf98d6587692d53d025468869d6407ed7169d71776df62bea7503e83b9a055d425ed0868808ec7c6ec7a0b56f9f859263cd67faeff9ac8f27bdc18491c55707452b413d1bf144ed76357a2646583c93ea3320bbd9c21180a20a32fdf5af4f4d59c5a406a3411ccf7315a62f4149dd8f24bc8e212e97dd5bcd2293dfd09037eaefc39fdf8e483cba48d907adb2a2e75e9e3f23076a5db4c468dbd367fa8a493b429762e4c64adcf898bafabfb48e008622e8485474ce7897c88ec62b4d6950f5de368ad55f0b823d2b9ce62018cd3484289a8494e58976913f6dd3ee7edb82a5689cd637144a2d6c9bfba6140e614dcd88db4261731f7e5482e341a9d5c724b801fd7563a34feb4fa4dcb9c1a9bd4cf0f32021962da2d0ccde458a523de454f11d5e2857c30371609870d7c4f7b917d4a4147348777a24b3370ac4477e8607313f93bf13b4af20e06c4c0e206ab0fd09a840b3a6bb4920b90e51837ff823c54ef3306406be0e2288c20e9e97ffae62ee9c595975e7a143fadd36ac122475e0271fac2a29e4e9f9705515829fdd747dda1e6cec5ea67739aa0048905b021d80a8af75332d5caace73b3dfbc2fb6f8d76122295cd09f820a99877870115cf2418b15c0ee7d3921cc198bf98200cf6a222fce9930788c37f7f8414fea25d6e9e19a61960951595d50bc4470a9bbadcb951391eda7c753770bc736d9b064992e1127ebf338157d143017826b657dbe2206bf7273487c3a21fc3ef65d0f908e2c85d5479188207bae3e1d645de9e846dd3da2ab1b3463d7906992bb2034dddf1bccc756c4ddaffaa4c09fafb7e0c9cc65913baf8c58aadc12a0c643b62dd56316a33ad3454cb8dea5b32cf6edcb97957eb7bb161462cb78697d11ed437357e3ad9b98152e9630b19bb0ffa19f25e78910dd7610f91b4d0d4809c7072dd427fe5f507d35f3e28cfbedf108d679603883b44af524c6673a76581229528ab4d1cdc516d0ded66d0256c9abec937f93ec235964474d135c12eab6ee6cdf33531925e52248de19f114ebaa6cf25bf622c33ba496ecb93bd42810e44c508604894d3ea5fc34221926e1c25fccc22eb443c68a0219b0718956e87a27c716ec83dc924bdddc2d242154ba5eec266173d18442b565ea8c4a5577e6b5f8bc911938cae94cb92a7c6117cdc3f02e1e3148c41f08c7aa9b6a8d4dc918bca1a5b532a6fda6d6a50bb3666a51d3a09742f14804b8023f50227af23f6039edf7684c4d23e64a007f34a9100cd26eec30b81798226e6b12c3316bf2d4f251e498b06c07993b3b1ccb468e699ec6dc52790882c6892060e4bd7719fb2865f698df5c1fbd07c6bded2e6639bf3d686e3b4fb6d9230a0f228fd658e19c4678a1a4fd02aa6d61cd9f353c319f4bfb40c4ddf822add95a835b07922f03a364c38c0a1d68b844363dc685cda0d5086cc51385397e3ec9c808793eb7208eb565ebdb09ce4c47534b52d387c35e5605ddbf0ae89f309a2cda7bb4cfa26cf51279930847b96a391e019b3f7418a4c8ecdc08b98d0420e301a38bf0631c348e2f1187e4f552668678645b0e8d6e5382c63b01f7a1db90f431d820475b2e08f92dc348dba6482521f98e89580b27c322cb52e7ebe95d02899d7265ea545225106c792bb54615003ece3b8c06ec3d05fc345e8a5c1c6cbfa9181b624af9c4ae559b6ee709f885823574c84e57fd9f93d24e1d6f46aa196c751102c34e02b90cd42d8d579b5f4d3f4d8f59af45fef005f3aaff21dacb2c0420e0aad6fca52539364464cf6da0e93a4b676b7d1d1afbf14366b23ec8c1d7dbae61faecf2bd46f1d7daceae53c7010f488114b5ea379281a25799bec4a0bcd83a87c64599c497b3d92b8abf4744d21810b3f3c756ae3f3fa561c2c67a8d5e6b0ba65a45e5b322d09e755b9fd521c9c42c234562439b766dc66ee11b7bdedf5574388096757815e6a971e3463e72dd0bd2539846e3844c0d1b9928b7151a5bb7eef5742b7493924ad1d0b39795ea1deb6fb1f7e79b1adf8e2eda21d5793a114d8d4d1445bd15affc1601c7b82ff9cfb4d1ac2ac08233acc1e4c3d8827fdbe3168fde7805d1621402c859ab31e05bd0867b1544e5e8ca82063c9e1ad799f6b5b189c8b96bfddd8f5d567afc3cca0ea050f7793be02dd3416ca1d627eba1350e65d3d10c5c2f2e8c52b4f200ce55b31372d2a941984729807ec40a2c0adc89d9ae225879f5a1d6e1211b1d039aacf2d6a5239915943b4d7bb81ecb4484fdedf7b16a02b16100ca09077b3b03980f75f3e76c0b20da6098e826334a4b1bbd5e0c476fc46991eb308a85deb6c4d6988db01062dcfe57fc063ea76f7f5dddb38bf3c5a81f695f1c8c60b363f8fae0e59225ec8a689be0a6b9033c00fbf304d8d5e0b7c3ad44ce0fa807e49e79dba4e3bc53239820fb73ba78a99bc7faeed72556c0737d6136c4fa4977d1a45820454da23454d5d511c5a67f9931359fb911d3283ec4455376d869a6fd255b387cd14f04b655915170f872168a85870369dabeeca4b37b818a4b1c5cf54c2e44c87e0666c56d7a179a085221859ade720f8ba1caa844a8e645b58ccd6d8b6afa0199c34a56c75fc130e9dc960cd6269311d1c38914154729565f0670c5cce09b6f023cb1a77974e59891beaf5599e785889c17d53ff0b29763bdd9838ead6b11759a29695800f7a9cc2a1c341f5f680a2cff13f24d1dd17d2177ecd8c8a5554326fe1ea8dab5f2629072a1c62cbe127f447c53adf5a63ae3464f4d7ec198b059184fc48266b636e155e197be9e2f9c0085c76e49d278d140d44207a5b7f5f8bc7d167b7dab6af5c83bc810263f4ee42a6299f8032584c1864a655efa88f1b925afd8647b320d9d9151730921ba1583452b06fc5c839db4c6c7547b2bf2f88224676e1081fa2cb805ce4cc4d76cedc03c2502d269499ebce81f442921dff1ce9cf2cc95e7cab7e5929c82a5f515e44129f76003ed6ed32464c03c41408f4138b7c4e2c46ab5d79baefa69673a68695c7e94d90acd9ac787408dd6de0764ea62b501236946224b5b8b1b6b3e57848a2e8323891528012c9abf839e40fc0011adb5b132037a85f4fd018e8889cd5e4b207f9c496325e8202a7060381122268c19dc0466b35b0b9099a1e9ccb220846fb7edc12fb1e382a335668c4191160b955f07f9363b4cd90f118b16fb9c691c3fed920416a920e6f4222267997ad9c7ead88883eb0e8066ac0c34e13fc8aa073484bce98275ff2ad4625bb2bc68e22286464798ac02ccee71cead2bf11bbe54e6f19ad0ba129b898727414c7f5bd020edc36bcd15fe46e5b33a12a31b89014fa7f15908a867bd51e6b4e3c1e03faac45c380af91e5d9759e2e1253788bf65ad080a278d55f5a896216788fcb78caeee96b9b5841bb785f04b8ea89c4b5d036771f5a326b52b516157eb2d8fe66ad6c78665b53661a205273155e719069b2961838e90b5ed5c2e208f32c6f7fe956f05709f755380a8c30abb587196d47c9a46c35533824008004d7589b448f9eda438c8abb938ba5101215f867fcf4b96262cbea44c558f884419831c5fd62da60330228a951154a2aad39f20f4891a6307d47403f0b121056254eb4c56d6f3e6cd16c59d3c1689514243cd6451c0ed3df1ded32d9f7f212da2d06b3728f8a1e74f7d627bd3a74dbf24e1f9884daf8096ab4a173aa6f9c37770a23ede4bf9e5a22b95e416bc3d4a356e7e68e2ad7e0b9812284eda26b4a94c37890fec843c9c5511edbf83b2e3f89b9b507cf85fd0149627b6621421f98acf1866ccbfe3cfb7e966c434029f919c054516dbe3be9d660a543c80e617b7fafe2dd22a600bddda55ec558fc287c8a42054e125116819a691f2688a6d28cf4c4312ffbba241afe7b0faac13f754c34f340b8e10bea168a2c52c1af331df5312e6a04584b3b1c23fb6aececb130bd528ce29c820842358db473cd023a5447532efce9f1e42ae786ba7e890957ded306676dd9638145b9b228c85d510cef58e85d7fbdfe9c8fd3ec4da939ef4d53805305f0b72152b3e44f2697ebdac528d936c698eb2eabb2829f784dbefd75adf3a80bb22be7bee3c59448fd517564c1a8dfd2486c46fd0c39014a17a585b841a04a7453de999e4ab830f06d6356db32a0f6c7778453eeaf0c1b320c3bc63647689f90739f59b37fccc73dc62eb749e9d8e0a027719e4cb63bf17faa46c7d0a584fae1a12beb6960ece21cb7e71fa31156783e780c2aebca205ead7945946021f87468eba1b60c935f20a0b363f1a5f0be3c00c400e45613e31f3186b5f544d380221233749dade9f30df3c70a0ba5cde59f14fb3707231e727e524a9fd100c2417648c9e1b0377b74fce10fade72a0bb374b2e36efa3ba84aa5bb852b1133cfa38dc6e5d3480a77ba77bfce5f51f2a616d4a328721ce5a55be67b12225675144465148a77868707c5509b23031ef72bb5186cb0ae23528043241e816e4e91157d89e4810d575ccc6a92f2237780aeb6d132bf565f3c65fd425ca204508ff4b66350981aa469e33edd241ed99074e7ec56f6b00390299b2f65d7d385f58a2169c02f8ccd2f11d78d4581ff62320cbfa6b323fad2ab4ca35659768641470585c74b358a527a8393c84ed919935e0c0803836556f033c03e20af108b2a03b6511b84edeebed895019e9c974b6c8e0e28d6a2aae5a84676207dd78c8150d2142c51326b13a3ad6da773a4841e0cda50c22354a57e71f6da4ff2222c3e2469435171f6ba178222105435a8acb7ac083f40c2aa440b49d53ca06c3e552d062f7191f8fb9cff7516cdc411d1c443a6c672cb8d78f887a4f9c89015902a230f62cc176b8c267c5500a656a9d1befd9ed9e0303e5c28be0da0294ef2661fabdc99f99a7e95ca1ecf3c7f46d689dbd28fd43f32f8d6d9c4534d05f791c729b12087fa229f8358bd859c4839b1aa821b2d3838ee435f38f8d93082c980099c6a921ebc70fe8d8dc9175bd418c1df03bacf064df073ecd2d22928efdc3b4c1b6353c92452f19e4df278d0c52556cf53228ae80ad96b767fc6d335336ba4ef88d796445ff3e4d0c2631d7605224e7cd934ca2df24376a9ad5f3c16d8acf5d462039c4c07dba57fab5126a9fa40a1f616def3cc08837844a69c7af8a5f8f84636c7d7333df1bf6ad091d829615de6cefd93c77ee5f3c3b6dcad90a4db8f91d6c78fb120069d059bd894c0ce06e0741fb0a64b345a65ae4ef6ac393e6929b3c746c384f2551fcb3e7f38c7cc188575ac70665957a65f2983b274a7d265f37b3fea905b26f27c7487905a58ac06a5064189a2e638faadea07aaa4b6136295c1a6fd0c90e6ab1a26999af1a9eedf514896a77c778ec9267f3b923189f9afdc9fee5361b998be0db8490f3a7a489c3c0e3e68987b02b63678ae3b90b9062b280190db4661c97a0fcc22587bd8f4183fb16cae12563c2745dd04e596a5719eed0e57f915213e7eb02f36b534e82247768c5f544b5159bcc807258be0b0f44d3bbf920cfedcda573a1574cc57c7822a249aa69cfc349e7b6de60132496e83a02d3ee98dd066a6cf0782ceaaa4671408bb2a4e58f948eeef5e9127717f675788f404fd89a9d21368fc2b6ecddc625f2cf085dd7454fefc811dfc09bbaaa80239ea7d2091a8d7cbd29d7a89fbff0c6c97f9c2ef8854baa0ae5e7c0be6de716e995fd724cdf114c2de44767b4b0fdc83a88ecf615c6ab4551664967cb877756245b2eea3bc46ff0908ed959ea2eec3907e85acf846aa1ce88231832de61f58749c869d2485c833679676eb5d0372c1323d30e8ee799cd31f10e7a0580ea02156e6300ee3af29cbaadf3640ad196c7f26c0aa6b09188815255706de17389ecd589a24e6ec7ac9fe32038f01527d78c72b1f747cd9c32c079ad3c72827011560506a0ba3cbe60dc29ae4618a252d65c0483788f71664f16949ca7a267d1ad4ed5e19cf5b644f414c87fdef9619c35b038957bb6577516a891ca3133a27d4abedf6c9691e498ea3bcbbd2715b7ab06600155a5d974b27390f8ef0661bda4733509d6220a5f229e55ebaa1325ddf4c87bf8037361eb9a704b8660e4d07c72ef149a22379254b80b4da02f023a2cecff6422ba3b928a749c19dead34ce353d28755177c835d68b019bb69dfe9766211413b4d824a51f532da5e7734b399de3d91e403fc61baaa2d3961176047fbb5d557feef9ecbf928e05985cac57b39c2aa0971f020ea478917c99b570305b8685f62b50eb194d084e3d7b468766ae6c7c09f9d1fb0bb506f4562e3e4fb1672eb11acd5b7d015cb249060b8c399ec3d449928684c1fa95040517a7212fac189c6f4f34980892b1c0f19eaa8140a728417b8d0b737bb199a56ea4dcc7a94ed8243604c592584517881962d7e74d5abe1b7c56abaf44196267b06eb36ef25a5eb4d167427588decf6e21bd7b6eb964d93545cef6ab89d7a8bb1469618ec6b0c874522fb85fd824870661de5fb5e7778f78ce73e104ebc5d4e29663b093d1ef65e7580eeaca070ca37280096d98489e9517fcd1256b3179c637497a03e209a8bfb544d009440f05cf68fe50cd646379fda5268ea05fc5b2a4cd6e04fcd5c58978dbcc828fa4697369dbfd2407a9e89f94d19cbcf25d8a368e2b04bef933ee5e117506d68689bd43c98beb7ec21b3f145d3840e0488e34e09b6e6e9f7810099021130349b5803acf66f9f8bdd1c8e10694a555b5587eff6a6b1c01bd06133a22cee117365342794a77e210a2371c21314399fee208d17a0f78bd6df48533407102939010311dbf44e6f17684b0523c5abe27790f84a388c13563131f3c429f26ff2b8f24b34ce9ab99ad1549a6981a6c372be4714b56051ba3fa5cb78ce70374c7ef1711d395f03c0d34b118f31fe168d33115be78633f068ef16d25603354faee84a003b6965a2e0feb5b70963319e85f3c10d83a777ab444289d6a674e03e48f3fd78a88a752f10055a3bd95dec2f19f4d1d7821611acbb841fec8b4b329fdb9a83cf55aaebd8a1f71ade6367e00a83d075f88653682b5669bfe0c3a305d0c1c1809ba26de055e985bcd4513efe206c67b2832caf18abc77a66f2d46fb0363cd65304ab1e5878e239db1ee16abe218ae3d9fafe5f779faf7b1a360df38d0dfd449042c88257adaac1daec4f371fe2c603fa659a25dbe3594e4b75c16c832916a29ac31b67b3dd277fe6bbc5749b1cc1e40db60d6892de309de3f6d549711d465bdb0263fa762cbfaf8be74485a849db4fdfb40eba71fa76fffd9bfb73e4551aa7eb5b4560b3676a1abd95cfa327416f204719ea1d2f9638bdd4f1ab695e7b197d76450cdeda70bf7618c8dc36fa5776b64f7475c67ac701a793057d0b4e8ad2ba8e116f9f9833442bc635773d79c3537b762b7048e72bfa1870e61a87cc4a0bec5c5e531b9e085af8e116abbfb21c6c1049aaf14519206d934998c33ad33ff9263b357c4b056cf25ea9d69430b53708a67b9b1f53dfb32d23b25228dddcfca01026a9528e921ff18c1ec2e1fe2a005f807daeb3054c548676522586745938fa0de8b628e24baa407927f796e365ccf8080008c5a7d7c2a0df9e7783dd083587de9317a3bfa219038eb7a30f1977245a662920d187258957259821a83961300077fef49743a7495843628256b5c97689b3148ce5a6ddbf4d27532f85677b16121fb4906f5ed2c93ce5124cf89a3f6e620c6a8bb6458a372ed7411233c7e7b6eff0f35ccbeda457771373fb30edb8c0d9c5ad526c016dcb2cb4a47dcdf4f87373ec2014235eb7c66cc05e07b1d4e804d6b0bb0012e2193ce54853143a376688e3ecd780932d0a025e87f7b47424e8316c2d1eb49edf8c088f8de18261141438921ace8f4f3788e909e9bb6a4873cd1ea1232d02166c5751984b178df67b94405320792ee805939170ee1ccc4a831b4c7d8a96ed18a8fb5c7efee288dd695cf2e20a63a4989a520b985609c2db3450d2255d6dfe0a5ae810d96c5347aa80325c112a1d0f52e0b806567f882e5ffd25fd72024b3a0dfa9902474693e76663a2afb50a028fe764d8e094cfe43749fc230e69c38b20d6554e4317feacfc113410264efe2e498a1bf327f48cabbd1580839a3766bccf347bab2c04af8e0a26272c0a27f6e1cbe1c193a1aff6e9900b0502b989ffc4aedef83bdc010746b875c14f30a2a99a72e6bc98a8fb087eb6a68ba4598efb9a6c66420efa6df10190541e65169b39fceb803d48b370b6ec254949f126c83b4bb8c03efa15635cb26123d6619a5214dbde01236dafd0d38a0782e68a67afd3f441e9a0feb9f0e235a4480476e2c4a08604abbdf2e157c639592c67fd6bd06f33bdf3217e780eb5c1da132be577f5256220cc1f15c874665a880b9b3d1579926cebdba2b4e1fd87f52d33cafcebc375aa41b9b8fe9f73299285ebf1dd3e1d72afb77fa45f088c957a295c39a6d452d02f203b1a04ac8597985a9c4eff52e9cf5db48052ad2eff916cfc133a01ace41ac5a28a7322f9584b0291ad9e79b479e97cadb27ff68a3c02d09fef2db3d51d896484222ddd179949dd5ab23fc612af51d019715ef0d074ea0eae5e45d1b75a1024877fda079a48c59acd0f8d411996ce84fce9612d4e3947fe06b49a09226b366c69e52c6d4e19d7ad9ff1e8f0478abaa2e662f7a1c1a469f232652ec003ebbda3028e434af7da10ae1d2c839ebd092278f4a7d14f98aeecc336ed83d6d694c09d1d5b112089f026d49ad88ca958ef874703b5c6c9a15b182a137b25274753ab094046f9f641e9173b21491aff7cdde64104c51c50a98b627998a9f289e694481ca010d5b027c13b4cd003c39a23a40a88c78f44cf5b4ed52f9af77d515ffa016c4d7ecb308eb963a65be37bca291a5f62300e7044c7a1e635b5ee32bd212603fd4b444c4a6766d80bf1d6986948bec286ea3e01a7e4a563b8d2adf63fe4409d06b36e98179069b94451af4c6ec0e45a1800e18980e65b88bbe534482f0cbf7b60649e8893588140951d4429761fb5c19e1e99e550c81466a85ac7c253052a3ca0e17b38fb3175e429856109718a840fd454f333deb04dea4c388282c41c5b7d96b08213b78f30d53fd80f74becaeb119050506f033d711f5726c6bf5669df16116942c0619fb5e0bc9651a0cb47132e17fb522bb22c45b48c06a21b31eab39f90836be1d74ac10317858bfa604e2569c6ae47f354757586f9f05ee7cbdecbf817395dd5ccb805e865a3743290847e3024be3f179089d3bef074aa2038cbc7717bcc397760f57e483ec95990c4015cfec4ea818e6cace491971df7540a231e2fbc566b900dd6eb34f31b40078600a23d429688f124ecdbdd9b8acb09c00bdaff72e0b1257facee235cbc1e284497821925e44264be707058943bda8ddf7b4463de32c28ec27f20a473fde2271bcd9e17b023f8f3e1ed3a93b3a07c1e17e556eb0302b9f257e19f2e98d2a7f6d553562c2c5dfd52fccc0011dae8f97feee1a1f24cfb8259ab099626f558497a323c34ed3632afbbe959985493c7a44fc672fdb504e188f85ed0bc36bca83e397e7badfeea5fd3d561dcde7f53691f5f11d5744d29d1aa369564ef63d90cc646da20ac7ecf3d373a854962dea0afeeaeca79ac952ce2b6ff535bbde437d0df1dc80a49ee1946a19837097ceaced1f43532dd761946fea767bfeb32916cf9522e0114dfdab850ce207e58c22679a855e9c80b0219ce05aa7b4770d22ebdff567128bca1a6271a4d8887fa325daf813d71e6c509f7aff2873b8b53b03622904b0d33baf0b92dddf6ec6fcf2c237658f8d7ebdfb3e8976b31628310dd29f42414704b08ef0263e2ce54331bd5f6300c626668c73a5a723b191f3a82553da53fd5d5c3e384fe1e65aa78fa7970574150b5b80a1f307de74ad972225806a78e758c4459252371b6c95010ed4ded764752790a50ea2870909a2ec481b846797031b7e6f46c62e341420318c8bdb22396a0f2ae3f59b80649c8f7c093ccc50d60ec3136ce20e3859151840bd13ff9bc6055dfca22926e185cd2b9f36319b8265a0feb325eda94265c9dad3c699edb6253dd0af1c2df0861f5bee814d200b9dfe3f64b92a602cb2f316c34850daa0b8ca86ac142be01aa6ed97422ec49d9be0de020175909cd62bd1fbbe8336edc0171a1349ad9d64e9a76cfff0f3fe95c4282ab32c4c48d526ac2cf777ec0816694e9ad8173de4568ef996d2f8b8f9e388f410c9d9b0fb45cb1af5f1a21bfaccbff3823af40f15f809e9fd4b19e7a366a59b6b13c57fa62e34075956cc632fda10f4866d8deb0ce56136fe38ebc225964460f6015ae530ceacf9139e3afd1817129ee74b927a8ff5308af090c0da3bbf485b5d70a42b11505dfa61179e0b08384847d8e453b50ce286c679cf429a1fa6153b3dc7b78fe62ae47ea1fd7f9d6eba2a32ee450d7f7afe54c91ec2b7662ba51c7c0ce05497109543297816a31337db0322a3eef0668974c65f270444948f3cfb9ad8d4b4d7c331626cee66e04f054428b4dd197ce1a688ce7f9df36899068eb9e33abfb69a6c3007ce011571812a550f426fa708907101da9467b6057ce06744c30a14572257f0046128308467f7a6a3de1c6dc87a50b4366df1d81c157f46cac911186cb288ba3627e5b697f86ca26b291856775b40c035043c33918efc7fd39c353f39bb71603d4c3eff8eff28723a5a81b78d0c88cebddf18bb9884c389b22aec04900a6b9c5f3fda15c31011c9aba37c115b8f2ed849d293f3e0e3a9bbdb587dbd63ca9e8c7ba1e1780c48ec5ff9bdb3af8983a3ce43311f6df9c57e4775b274655daadb9ac75e50dd42cd5fa9d42488de3735a80c0e149188f56f448c41bcb66359d73096c5a48a85ce2a71ec1d590f59c57ac66767bc732279d56a4ac8dc459ba195994c1386ff6d3d67b26479c8f26521b9abe430490cdd0f6993de89ec7758990b30ae38ab3d381f151918d9669d0cef07198947b4c8b475eb79e04772609468b34d95d09366ebb5f294e7283dc197ad45649b6127e822f004a5e086c9380f23210b73981c66f98bb65010eefacca0dcc3880a2a015dca687fb2a42a7a67cd0253aad141ee29daf2189aa7c15dbd09edc68c4d4793a8bea87094e8e555d751d9937280b759da043ab68a1cbad738ea6db48c0b308bdf103dbf861a07e84ca8bb832dbadc2df34ac06887bf62af1bb39e6f69f86b6e915796d25bf396735a276c52ea92fb91b8917394eb700752df76410e3fe557334f60b48c5bb9d65a271f0905e8ff1994e016dbc68a35b26624c0468a8618b8407b1b9df38ab1b9705cd62081b0bd9f694f53d22acb527a7324a69202f5e401e841364ca17e25f76d4b22c37e2c8785f6d7808033e24478f835a8ff259a75ffc05aa643533ceb507eff9dcd5c899b5dd42949fcd3c51c6c538c8abb95a62d6149eedfb5f8f9c5628c842b62e752e277a60028dcb452cbaa4842e86abbadbe3d6a37f6cf38fc07c3cba4093ffa47e4ecbca2403009b5dcde63c6f0246471c9f5615ef2c1bb923957a5ce5221775cf78ae2f347ac667947e3094b11f555242036ce6af91a63e4143bb266f273d32377c1c79b541063e9866fb9c5a3d6329b5e6194bc51043eaaa4773ae5ba2a47d5b6a923a6ea18bbf8a69a3f88e7b0e6b77db9dc36c3abcd112744e76ae7b8a29300e5b967490716a36d2dea98b1e3bfa28b634f7083b910ed8754ff0df1bb8df1cfe71c529621a560bf487dc362bf74e7ba3baabeacd280d65d83fb74f499e114d734d2cef1f2a67fff530e5ff631f874a80bdea4b7730f705d01b9bafe43caf66a18bbc59887997e68f2e97e559e19d3bbef69ae85984fd09f649e83c458b6cf37cf3abbdd84ed27b49f4199f61c9c5ea2136578aac304ae4e6eac678d550a5ce7e2e95496ab979fc813c387d23cb3723cfbc5b753a031b9f0ec0d3278b8755aa072a380af9ca672224f4faf0777bef9549737f28a522cab0d8a896606527aec30aba7a46ddd3946a10cdda46cd676e100bf4489336a032766270708aebe63033f6cad4feba49affa93328961de37cdc5206ab1f7819946275dbf5b01c496fe797c6caa1ab8f4569f7ee887bfc84c047ecfb482d2f7a794fbd0d970989ea0cb9ce5f804389f6db49e08cc51ecba41cc15d9c57317c1bc0e2416f69b6dd0f9f708a07bc8bd0b3a2f2738fd12aed5950967bd6471e41ac229378616b2bd8a08891ce2cdb21a0331d0b67bbd76a5444b9b6fcfbee37844c495de3a759cb15ce5b745c2fb453cbbbf9ef5521551deda19d26b71fcb59455260527a684479da47e716c6a7a64c32fe00bbea00016dd53089668ecf73ce3563edfcc7298d93d114613a02c2f744833524a0a437248404bc355dc6649eea73c8e3d7437db6e2b2e421ecb4cad439c6ba0549d47cf49c28e642d2a998cc70fcb4a3630e244f21938b2b4ce80d212c6e9be72675f5d43d2a22aefad4cbcbb0bad28d594f9fe3f20c27d2e244246152431fe75822ce4245cb5cd4662837fb517411d6e1a5fbf69f431f4c69bb2f4ebee96a6106997721f64a32f205a53b8e63232e37bccb81a9c6397c2bfca28c3c1ae3ea18506d93c422bf2c712da0eb7211846ba63e18e43b25970127a523a217e41d6d366b540f833a613974171769612d1b87fa86e3fe2524bd39afb96f605d777eec9db3f6c448080a3211da4dd7d6a5188f737828a73959e7f35c56c342305db568998358b1127ea0635426e6dcc33081cd4f9f51fd95518fad106c46069cdf3feaf8fc5b8bd3392239c7fab462f4ffea1c006da21004f2730a987058ed29e2251e82a78e2067f3039a3876a3d45a0110852a937f9e346b77de85607da01dd7bdcfca436223c3b818b98bf1f08eb9a676496efcb66cfa611fe93f2e68c98d07be7a9c00424161cc65e77c071d54dd77bbaae35dd4020de444887947b7414597d26054d3ece9d94750a273deffcbb8e0d15fc51a81152f4a13b3e4b901d1762654b25ac3212f527e79566995c7d39f32d7d2bfd1bb0dd1ae54453291eccd7e8fdda953cd3826fe6bfbd6bccbc3f1133a087a1a90e257bbce40acfa39f2c7f82ddbc08d1337b1084053af2081be9f892ccecb47eb3fefa371d64f23b9792d545208eb0a8a3b9640136fabe7acaa75dd9697f6a2baa2d55b09abcd5ce9cdc95c2d9633cb5041cbcd1b366599bb7451460c83a904b728763b0a429e083871d2aeced5cd8e191cf2b769bb6818c04a0cdc8120e214070944e8e18e494c50c876ae41ff7380eb4696e838c0ad9dc1c41a3bde06fb8e8edbf53c048bfd87f30feffedf2bce2fee8d5dc3688080cbb78523f5f4cfe947ec4d6e1b4c97139c69c905</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 123 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 123 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++语言基础</title>
      <link href="2021/01/C-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80.html"/>
      <url>2021/01/C-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="c730abe676eac256a2d37773399817ff1fb1f22d5d4d0f4916089b4b4fed7898">88bfb973b5cd9a98289a5356073cb3e561ba3d32e73d841574e69103b5f1f9aa0c598a741ff12e1904e95cf8d09e492f2918890f88ae3ce3e9904e4d8036138fe4bf2f0ecc47f1df3a7d4b3fb3ad0885888c8eeebe9d6d45e034be6c8cf2e12e9751ef0ec2cb5c17db40ee54c8386f1d14a3b9e3f8bd00751bca74638367f91b7e0134158f5c7856100a74abd7cae4945775999b7d9f4709d7eaf9b226b79b8b1c4e83f17081ec0351649e6e76c5064ca80344c3fbb12fac550e96f7c77de1fd1dfb2dc9136440940227e2dd88322017afe20c193c2492bb78257d8d772b6ef306186739405997f2a8b00a3673ad77c15c4eb641fc6ef73bdd3ac6c482b1bfc6ee23b18f8fe1623b89669c7724beb8141865d8a82a478b434546b53d6a79131a43c1dcebfdd75068f81a0e51d359b6c93cb58ba9dffed56e8d9be85a207dd3ce4a58682cc4b5e4f186371e43dd78b87bfd62bbfc664c21eb0daf9deb2e4978a73a8d67d2928e15280bd61cf7d9ba69f521a438e924e214e1dfdf059b8262321fea6aaa9c0467d6f8ce311ce17fa061a71ce16b34aa3e3f188f65d15700a9b28c0acfd055bbc818ec0140962ebf841ccff58c260a9217c05876bba9599db7c42b9c399514e4008acd06765c91257ff4d2f73d37b559c17be6f6b3315db13f29503ea6d90e448c302bcfc56114f349ca629bf327f3493d7f6c486fa45d2381a862e188134a26a01d6bcd0e374f9d346ecbbdd8161a415b1c341b505de3ff12f02935410e4136ed7fd64e8a8fd3834ba32a8ec1a64f6564a19254453b76d953ae63bb88cfd6279df4f088452b996c43427bd80d98eda6f0ec0767e3de9b7b8c348530209987c707fa71386909f7fd6f4e5453dd1223a95d2c121f0b3834a13f0d381fcb861a285f5d3585ae961b243acbb538aceec04207f4c29ec43c53500d2d844b657ae7e607e83ebc273d261e90f613d30d67c93b7d60942cfccfc057a1fc1098b4d80bccc6e1b67c07cb6e1310c9939dbd61f9f8e45bddfce4981996d6752f11fb68db43c3909a62517f6d7bde47fbd525bb2c411dbee497809f3e5a988f74ca204eb44821a7058fde8921fbcb0323a99699b5a942b70964e51b8fbc7cfedaae7a75c816d33a2bb2a72effc3b800c79a789fd93389a15c8d4ba9c608450e0646a7f423120a5c6abd2dae447daaa4b0e401ea4e0a02ab55c6620280b5bb32d28322c87d3a77b7253a8614ec3b6e8337f4d81e6321528d99196ec032b337626a945f58d3f586c682ac03aea0c93f2aafe1f7544a92e6cbfc194a1795fb9b4e386b563c4f0a2a2c86b5da9f5295bfede296a0dd33d69676492aca241ed8190e2a2ba91b4ba544b0988e2669bd04d73ade05baa7a5f2ab28e80d01e18c07afb4530f47d285f44b861b9efe63a214adfbcc68705b160c6bb562e411cbc527dafbfe2a7f63eaaaa4a65710a35f63a32254a8dd311a7ca56e53686b75ef7bf3fa9113dbbd3d561b6248f615328ce5569d177ab63fc2364a8983237ee0e2bab5f7bf1fbc7f34a85d839ed0b2936542d4ffedd869a6ccaa0a16849189ac28a9f3c3380b3157553b3b71b1f5533ba8bc66791d163b6374d2795ab6ca730763e0a7f939918ebb0458cfa8af8cb8d5b8a5d675afd53602bd8b30756f9440460071aafae981b7b9c5b94636f429a5de0d9a648a7b61a54ef790c4dbdb6776a0de8166b975447beb894e81d1e9ee6038d24e32bd98d32a9dbd08f4af46e7cb9e99a5e59d9f58e25e7aaff9567671a1ecc7fb0095e7c6c55f46498053fccce7ed5d4e1e917dae6348e50207591684bfddc02e253e2a31858ffd059d9c7affa3fd5e8986d1603b279a732c006d91e8fd0f58770aae8c3de6f1d3ecd74871a6d4fda56b7e713bb916043b8187683438984dde49bfabce50beef60758f46ec7359d05813827dfb18022df8fa4d0d41c4f7f838750467dc7ef189ce4d70af120fe4a7bbcb1341152dc5a5d0eab14d2d5050942ea837a58aa86b96ce8968b6f8203deced4c18eff07020ff65d8b64cf0e099016956eecce87ff5a9e286f352dbdf1c0fa402f5f8e0a77dfca3f5c7c2e1de2c04c712668dc0677c528dff8d94f61cd68ffb5db8373ae85a7313a35ea38c614638fb2917173b015252aefe1e93a4cbda2b65c12a6493ca0a546e5a41db5350116aaed4f1c624c5ec222a82939dfe6639e1d0cbcbc94a3db4126d3d15c3ddbdf061f32412e5879ddf73c057f505850ab4f3b3a7c66381598e4e1cb49884ef69ec1227b85e787171ec37f4e556f1dba2cfe06becc68ff9e87e779306df4b914fe8150b9fd17cbfd055e30a9de45b7534230ac7d9c30de212529ac3bc10878509a6a61d10ace607844c73d2f2e55a5ad4d3d15f7b95cc019fc34531105ea1df1305334c665c3cfe24a76b319cedcb9405d7d80c33130b40560500f0b30d154e336e2de5b3e6b318af0fbe0a67eb21ea2cc2577235be615c900d316c49bbf2989eec1da2a09f7a354c0c1b862b9549c5d5c08127eefc7787c93cefef0d5b8a5076ab53a6c570961546553f668bc171b62e03a6e34a1bdb64d36451876c941c85da7ad12eafe2b9a32508672e37132121340ab993b931a532a101b8d774b765d5789bf4dcd5e2c2c272e547cfbbc3c30cfbb8c1e6079b65d20e5466cf60724b7fc021cba710189c56c3328895e73aa5b83d5c21e24767023ee2b5796f347ef1348b803fdeb348a4f2750c94b127c66a83b9befee000668803acdb760e31bc206fbeb24bf48476227215ca208a32ceb7b43aa5984e8334f70932dadeddf28f47680836e2f9fb1af3e22c543c2ff46793e7084ef06c3eb05883b60fc40c9922b7d7b994320a47ce47fbe04b1429cbdc5b20a7e3ac67250a052f8d0a8580893111fbd765cb1dc3ca39f36939f97c61d7f680f4253f3f98833222f85c0726e0696c7099762b468e7a7a3b531489256e224a677b2f36a73eabbcdf62475a0370a22785931a67bfa5ed19dd16929cbc2355e25beacc4f186c02cd0ec92aab8712c782d49cf661be95fecaa69ccc55a6f343ebc4e42dd5bc7852425f57762fa24f6b346a4e7480ff4ec4f954ac69fc606b0a4bcb3a0c045e71bb889103cce5a3aa1cf3eee5f9edcbadf78b07fe171bf233627bdaaa9c075d16bdb43411a5a9449aa0ce6738e4c21ca02e4c794d3d91fea0bb5821b8629a5e8098c359eeb6794bac46c5aaf85bf6261cf8059cd0718f3ec22c9392f3f20361cf886b4964b4878638827c63f9225dcfe5ca33dbefc4bdc88c40f7e8340b99ff156285e3cad94f7f0968e0df1729a5c8c4bbade7fed6f9a806e56d53ce25d17588f275ee26ad1cdcf9de606aae45f7f8ab25368d6c1fa4dada1e4ef62315468cddf6a273edba47d1b79bb46900241ac98bfac3894e98e92ba803cd4d908b32774b6adf94cbc2ae31cee306debcbd046b083cf93e7d117f7be2e6746591e1766c1e45f8368a49e87736774495d126f5e6b93a327661a88db25aff11581eaaef85304cd529ddb88b7cbe8bcf68465ee7d876e0b5ccd4eaaa955b3b05b6d90712f82dc9aa84e0c93e6c31617bb9923790e723c8b2711dd57d57ed217edaf63f69fc2d023ea330c33bccad2423d669d5ca6a56cb79cc412e4277e1a3453412b589c85ed92c274a68038d796dca82ed3cfb7192a7ca9bf8f4121980bd92d21168ee42594c8b24812c207fb729b5217b4b0ee7b5547bf6fa3c171d3664cd9d60dfdc6ac3903e4d1bb555872b0f388e97c88984c80d09d21ba4e47cefd4b1de032d56cc38d6e74ac18b87861b2b1b493b209979e6baeace9a814a04a0a45353be964cb0a6f07ce72306e943dc7bdbf30fede74ecbe49ead3866b4b92e1b8e18b8ec21e9f88d4bf382ffaefca7ac3a25ebdcfac5d3a6ab0b65283994883ad9369a6ac8dd29e1434e9b3f73c71586cc4736f731619d96d3221446239b7719f00b75d8705ee96a67e2a48d377859ae1d3157e18215e816cc2d3ae428802e77116771919c1b58730131a0e01c66e6c3c68fe393e9531ff8c1a72aa06af7a45652b6c229fc24aa4ccab5407c85ef6c9d3354e7dcafe485fef60068b05b2672b1dae4ad20e33d1fe2fca39d64c080f1bf87a31f198d5966284a6b782d0abe2a7513707d6e537d9b1350aac50b9472398f8c77c6061e2b4d076a45cd68a555a97aa60c1a99394805fa397869b6a9dbeb06a7b120278e2ee5e7fac39c53b101f2803d45d4f344603d1f0abd17d5a828fa2d5236adf7aa17bd9b7b2288fc12bfef121985f9af9a4eab7f6b5a5d62916c163190e08dee90e84f1183a29d4163eba584da0469de3ade4b0eb8fea702fc480dd7a72cf66f28a1424943aefb6ed9ad2e75e81bca48ce9fbd9c794669733507ce363b74f3a2ddd563da4758f52236b91b7e04ac92dc1e714e3c65b28b80aa8396db41f14f256f4d0b73ad99d5efa84d206db9cf4e57784a2f5caf5f083c1bb867afa75b336a643ce13c589a4fa18a9abf0c88bb9b461ffdc795648bcc68bd02ba8a131471a2489cfcbfde22d275aaca642627d65d8edd8e6046a231eb3a3852121e3432520e4067df314afc8d6987563342e5b1fe1ea886681b04efddf90d26e35c9b7b13949118bf385e656f52cba9f87ac17f5cbe984be42bc1e2b380e3255384a4b761fe2ad91f8ac6959df3456683ce4dbf949206ad973152f1885c98069117a48adba3b208b903fb7c93d7767098568d96debb6732f16c8708e66e2b4fc3546b7ddc2aa8dcd6a4e4698d8f777f085028d0d97324c2d2f951976e112bb38eebf720c2278ffbab29b3fd3dce8259d3063fe4a9804a0eb664639551defc8b665ab03a2060dd340a502365ecfca7a120de84dc36f872a0f30dfb08f8993376f448839293ce58fe7f58d89622a7c845495d68f0e6d900a58d931730a668ec5d4a466f9b4a8533d7c648aefd900cbbe72a2cedaac7de3bbd6177122f76548c8cad15010da3312bbaa95eb8ba43e558c8b512840fb85026de1596099a4be73a9cdb051193531fdfd27d90eb6716b8acace7c21bb42f2ba8da01138e38a02c142df2d28d681935ee3bdece3d396e5e9af65f8abb33ab9327128eef935a92b0838785bebf321738149eefdb6d6598e8a5670a9fd2e4ce80dcaeb4f8261e9352f9ad3f302bfbcae6f28ab894e78ffcc2ff2df05bd27fc69778a26eacb2df98beb94f1c04da9aad6524e27aec7f8f60c5b072e16f9563b654bcef01a562bd2ede97c0857600ae0712dfc0e5849585797297c3a0f84fbb2ac9c9e1913a1c6f8ae3bea0712ca0246cdbb5535fa83c61bd231b9997f72a9086702f2dc8d52c82ba74c59522467e79a8a98fc69717dc2829beb1cca398564c340ab9360da43d6662b7a0dccb8dbc7a9747cbffc99c2a1c3021c7ae3aa7a9b2b2cfd0ea7346ed234f28c427b4fbaba332be62bdd8749cfa3149a0eb2b039e2ba2f0eb9d9e3c11cf0a812586358ae95e76577860a068ecef9783b3ba1a5ddd2e082160961127e526b20a4deb34790a93ad4b7869e2b1b54a482efc1986685759c703e153ee62e691f055df3ada8751210d253ff2d8628c6de83df0955a378bce692f1d96a8316fb21de513664370294752d32a7adeb36299bc20bb6113d569203b8c8bdfcd7b9841fbb09b041b4e923da1c492547b10278871820dc67b3f27e0fca68ab1fd227fef0e4a619e6dfc28d733ea91ff19e27210e922f959d3f20f20781e3d7c5ab52fd9d431e9d97aed9bf046bf91e40cbb3fa57b8a0730e6978becc7590dca0b4849418d6cbaadf5171d25b5af9d005579706d211c4ae706b830ee371ce6217717378dee62eb290a3ec5f27004f242c838dbeb56f5b9ee8fa1df431f8f052f2d15a248e5a4fa828333d99df53ea3c4035fc39dd5196d780081adc1a2ccd1ec53ed7fbc8abdb3af2de3ea5ddfd79f16e2a2e5c770b1afba39fd4c1a461260124cc90b45e588d4f71ab05eda2d271d2078e1dabe0413f8c4c8238550bdd9c72a48fd6d42975a7c2d184fecf00a999a75690cd2d023de5250c76e48c5d26d65b7817a19b1fa917325e0ded1e6ba5aa23c6cb8d9f8ae4a15a7afdb696a0168cc77f6a6ce1350cf13a954639b0eb8ebaac24dc686e29d0e63938224e5f1566cf052c512c02d6760b0209045650970d005fdce7d20f7f94bea15c20bf0a273f85b4716227a4c0d048b700b4d0f46857fd4b82e5ede569769361d46e76021a8e6275bdae190efed93dc01c8f091404c6dbcf55f204ca84a5e535ad0fee456e7879300db99166feb507498a78238812fd65884cfff299f26b45b9705f9a9bd00e841b30bb471f95c82237470bbeb333bba9b6c8b29cfce5e9cdd1ce6bb4d5302ea20d80501627154b5bfc5a6807361e2b7d98e70b3a857559d6f096ab95f793f8cdf138ffc0e918266ef2815976f9efea29a23941939712c6078da7731a82e2247c683f5f2b80fa76bb172212cfb0f12091ea22826557802586c8b41752ab7b6f3537de8ee820819fb209e9bb96def39e86dc1cbb52194f44a31eb7211cd32eb587a3dfd1ab0821c7e9e25a3c694d612757731ccefd8ebb248c17f854938639e3ca78750a1e94158d643ada472e3c754a6a4a342e8764c488c663a93900b638580b545e8526944e1a223fb5d93f82036cb6b41559f7cd0ce2c08297c8636e1c0248fd3e5631c44a1bae2f285431304e3786cecdc5581020826a995c9e9bca1cf994f24f84544c185e052680ab4cbc5cb79c06dd0c0f0ca968f212f6594fc7172fc455da808e5878c3562ea2b488cedb2440c1fd2a6ff3f699f277af7e889c804f887f6defaffbc8a7ce452608422332a4cc957c39055a3335cf1e8fedeedd17bab7945f5de27cc842e5e9d9d473a0d079d249a93a5c56c74e40ef657e88b2eaeafd99ad7bfeb9c8d5a50c76884a0551dcf81d3782ba2b143d11be3deaa77a6d29c15e512fc31c5c51264666d3f6468887666f338bfb83ee4be738ec5979fa7668e60c521662b9bf540d10c2e44cf308845dc3d6d269dfebf326fbd40c9f56136f3ccc90156b9ee59590dbf9eb8bf3fde9bee99dfcc4ce9ef4345daa98189e8f47ffea32092ec99de49551d50b4678499f62b2d53291ad27dde6c0da44eba6bbb92f477a3807b740c7a8882fd85c6cbfae8e32d77229320dc2869a798223737550021d3e6cac981cc788710970a777f00f2d5179a15af7f7d867c748f1d090a2f78e28d36674559edaabc7bd9a313bd636c87d070d413eff79c7c3dbd2c3a35418ea5222b8c2710f7d9c9072f79cd0dd3f84f8ad77b02b23f34ae352184650d64872a733ec0e675c1422201c73c07dddbc51c6807339ebdaf449c2c8f6ae191bbcbb49da16ff8b0e6b2fab377a34f5e62bb4abd1f78a469f8dd58ef605342dad5ffa87584fbf654639f6d0e960a9692438c70b583b603ebd6825765dd5d60b7d2f53a6900bf5be65bfbfb3d0dcfc67205d20d1e6af7e8992cb609e40cd5e6481657091a015a0cc0ea51bb67776bcbb2fc1eca1b00a65456380e235476300322b515d0367b3337f2d6cadf48a62c8e67a3ab523d5378e696ca33969bd87876021fed9b51fdb93af9b5ce57d08bfded9377d28779eb59b4673e7250361a9ecc9907126cbe33f11080fdde61a8e75578dc7c62c40641ca57190feb81fd50ea66fd0875725f1404493f0371bc512b7771988414a5ddf7ffcb5d4339c9d0b0d563b1ce7453c53a16696103af147a827182365708fb779198de2db5af3a3e824fd9ab15c170ab182efe10690d161af4ed63c26016158978ecf955124211f81b1d5b54dbcd134bd9a06909feea208f22b52b4c2649905b5e053a33c2269724df1aa9c27018f2ff7b31b5b08b07c9628098adc4751e63b232a068a3f60bee3e877cf81c3448aa4cd64c8f87aa9279cc9ee4e2c38d28b1a12d37fe1a975bf3578e5523b892a1ad7ec1f8d13d6db99797a4cd4f86e69d188f8e7d52c1a19664730e0639c5099dc7858e304313ab795a9e67735c6805cacde9471310b8f7d57288b670ce26690c88b6da1bd4e94c685afa401bc40931ef325edceee9625f43ccb3ab13dee322b3e2ef2fb73551e86ac5c286dfb15f3ecd7a398f9c6faf1c395098a2a730f5fad2930b2329418262dd692f4cc68935dfc86b82a5ba76c17d49f28a9888da628fdc21c8ff93eccf9967d62f0897f391e08ea252eaf2abf18e79b69541876bb990a8a1eec6337a73ce1b2029e2d8f5f597c1ef053123aa780858d9b0fcdbc262118f0c886c300012e348ae541003f4e08f31afe87d73556ebbdad3049a74bfdd2762f61c76c91e94b6a5e4af56cfa678dfbb48bd0bea28d8e05124b0557ed289c24f4e6cdd6dd3518a7e09cdf24b28d7fba4c47e26236e3af689c58e80b3e9ce674a6ce43b87f0e4ca423079e061a55a6c7d71aa899b56b4fe1f348ab8e7e63f204c4c9f0b582b0ab3a23aeab06da94fa6bf693828fd288b198715feee2788cf3a938ed94dfa59aacef5f01f0a81a3a5b3e805613e4424245d75d0441c9ba23ed93ec23ecc2c35907c28456b9b91f1f4db640227e25fa2bafec23bdb7df99a6c42ec2b3d0819cabecc5e44ce6bd583b6eab4d0bf315ef9464e4e2583ea23f2da455d3e1922ecd3a029a17c331a7cbe72ff81c5249a5a7bb20414c1bb008db377e524bcb1ab59e435e881cb47321c7f837769999b8fa470eda890113cd7697dcf13fac48828759a377c43f7016a5ed94a78da0d4f4e96fc07ccb05ad8d94fdf3816c0232295b87e8952c431d401181957a78ef4f62cfd6d62bf67823d34cc2d31d2759e0e462dce04ded949f5d01434ee49e472f92747069996127188d4e49f2482b36252c276128beb377990731ef646de242768a0a0d11d85bac2b84403461f18a19896fb2757cfd3c52a8e6f886e72bd5fb64a8d6f7919f300de5b6d7d4e94ec9dfc291b1084dbd7efa356b5991b9d0bdb68b1f6e4d5b1d3712b5d85cf07720a7482b034c092143ad67149e0c2d52e3c802c89d927e9e8f250f169f6a375f5f53a2cc117c5d28cf772af4c3efcb99275ea7ab98333596c07c879a4aac8e4202454b9acaedc06c12e5730fef7fe02be9b9d82215ab1be2870c95d4b7286ce3b9194b2ece76856ef687361d8a74f301bf5b56bb93bb286d98534f5e070623f6a65af81ecf6ad9d015a3a6a1919ad8b2997f5de19341dc145e42645084634c1ed487fcb020bfded2aa65911533aafec95b20fd09d47c14625536dd02a9fcefbc3c7117c40b48a7ff75d45bee794b551eb1b1db36895f94add3f9a887149008b21767358b4ce194d3e58da89374956f205371a1595df389151151e32dcce83e9da9852d0be084acdacf76142c5cb18791e92586c1ba42027424919bf69507480327ab1aecd8b6806163e3e0d7e91bdd1a5beef1ae9442310539055db434974da088c21948cd96d483fc43118a079c07f69f21ce881e6385c65f12af2de2459c709be58922226510d1346fc7f5f0d72b0565a3e53fbab95e477eaa721eddea77fc2cfe09f3e435c2b5b0e9d66cdde23753149bd36ab96553869430d491efa40d5a5c7575b74447f1b9abaa8b93dd955581fc061ad3cf26d2e7e0c6a0f288f49fd75a6134288360949a1cbd7a73b1ac5bd2c709fff6c5f857b653b6e84a3133c0cf05e6ef3354ed8bda569668a640e26b543b46990f79ee1b2f9221bd487f13379a5e9f28aeb5ec1d66890e5b40ad8ead9d60c9064d769d20ccd47434d673342e5f0372bf740617b2ec62e0f63511a968ad10c10571087b9300079855cb1de5f8147e97a7b90535f2dc8510690f3ed5c781525c3b7c5b22c9e852cd4105960e4fa03b47d98a9adf2b59b91f82fe90458b94ecce7eb5f1c548d32afd15f604a0356463cb887f5ed2050ae3cbf290045c2e387c1906ce4f880b27c14804795ab36e2e6b2d047ee1d18a69f2f1235f77dc043899452acb0dde3a1cde756fe2354ed87687b5c0580d30341b2ce1c99a293d265acd9dfdfb5382d33b740fa0c6ce47db2b412bed16bec86e100dfbeebe9f1760b51a41611b9760c72419ebd11aca9d9852d04f778221e42a8cbab3ececc1db5a8f2704db7f48a0e2d2284354a50332bc3b9bb6e2bbb445cd183fa44cb27aaa0b0b09cb73149e2abd67eebd683ab5fd5bcfb77c4b8381cdab09f50650354cdce7aa3a89fad1e716c76aa9db8073bb32ee2d8bd740fb778ab08afbaa3e5e207014b9081ada88823462d01d723acd6eb25ce30678a671eb4059631870eda8341328c7617cfa8c8837cb8ce351fca30b54890f5284ea248e9a220735b2448a0d3f918dbc588d5c58cf26d3a100d1a348137287024628e097e901a0cf582ae921d20898a64d9d8681a2273923cd691a4538d57c9f23c874afb11fad3316483ecaefd772ed4c8ccc2b60e252d563bde90ca445f7cd6c2740ba382e74a2bab18b9430a2bc531eb95bc9758552611df7c6ffd04b7d12a295d4559623d948cece3cb11d17ed5fec95b4829d5622791151fa8aaec8b313e9fd3c4b50331708c44b67aebd482bf7e3c2505b6a20df91c31dc58fffcb283c184ed596f0f9e0dc9318d55dbed190d91e2f527495c8c4c12d132da256bfa02e06e7b5a3eecd085ba1f8d7875482de8e117019da6d02bbd04a943780c0611366c11fd8ea052767b04723c08672143ce4e7fa0128c476eb93194f1cbc08fafac1247ea9e50d14f1349b66b1a61cc781404cf5db6fa9e0eeb65be8db75e289ac93f7a370f91cb440bd9706a461bfb1f1038ac9e68379071dbc6aa609039ea7811b28b8c646360fece85b0e0db04a0144af39ec854e06103c425eb5368f8cdb7d97bcf38c5d3bf5bca5dd1138c41485cd14b9ad7ec4ae5c10cd131d592f73e9ae0720cb1af75dd3e5e6a824442db61d97f64758d0c86f24dbb58b129a219a7f0ae57a8cf7bcf9be0d5148e26add50a589a271d0a01ea4d3ef9c35db38039f872b38fef9ce3f34031e50ad271357833c4d48bfdfbc2d64065d7fd99e13ea96c65ef70602f2aede2d22ee3159611dffc385abf51b971bc3b23e950d6d89d3a5b40e76a192d45660b99f0c493691c15f2874e0856c0c0d7d3619ea54d4e12341701ce9178a2dd90f9ac2277802ac18a4b354183d5a31d9395442b7c4b55cc3576060ba465ff496046a9e97a7990e2b9a9d23a9660f7955bc13339b945c07923429c7bd47641a38f21a000d19ded411e38fea7a26fba25736cd20d96346eb2da5e6b76922dab708ad0100c86877186d3bef240965d346de7a4ec6d44157e3afff5b6286fd483b1ec78073eda89c3d65cc0ab721c0cceae3caa84b5fd9b36be31ffd82c2da6885af322c920122f6a5ea8ca098319c2a740474dcb05732412001501ee9b4fe1d17807c6e894f450498682346d3bea62ca2406d3bc154f90a300dbe7987e380125a4f94394dd7daa4802640f671eba0e8293e5fb38557e1775e0a8ac99dec86965786098410ce3284174cfb313a866513d501ac8ea253392831f3162aa50d1f999821b4ea56d549c3edb0597bec77c43e83ea112781c81b8204e187c2e1337e58a98d8c94bd21821a5963c0b0f0e1f259edbcab5fe5eda0242b5b46591aded32d105e4dc163c3fd8d0096f7a17b41436984f42f57f736a01cb93a3b071f1d819983a7176de3e426efa5b5f800d53668344dc7705430615e76f822bae383f3e95a681234a2a7b701e78bebe81a678834104af35dd2b0be0167f515ae2245470d09405a85cd6865bc316bb617789063083a6aabf709ea5cf02a5c1c0886df84889d0324464cb232b97eef20362485e6ead15457b68b92158720902d9d25708ab590a3698814d2ec4d9d6393601a090a60fc1d1f4891a02f8cceaa8fa84f7e65aa4daaa7d26e0ed2cbd587e819907be21472f0372704b4835233ac457437303518c32a81ca3ce56ab59992766ab6f408cfad2f7ab717e3eb8687b704150156b130a133b7e6aa95eb4610844a3434639f7661e6b79059745e154832c936646ab1dc50ce65c04f3737d2c0c4fc5718e78f6144a73b126fdd3dac6d45fcbdbcfa8b7199aeff1096c9f2889f8282ffdf469f316f25b84886fe4201cd54cf7e28923b7054883a722b7e539a30deb9a08b051226df4e7582110f8bde334147fd09bfbc54ab8d2ca6bb65a0a5b42e0eb61bdeb9f57ad920cf4299b709358a9160d4d5d676477c1923eec9ee703aa41f1fcab715201760b592e598897da20f416bbcf4b5a20a8034d0cc60df9143317bc5db8b6d38380787fcc54c11fdfdbc5feb866169f8abb575b495c030bd1c87e0581502cdb7afafe9094197826a02803be62dda9ec1646f325e83b05fedb9312274b8260ae5ac7f390297b252800f94b30c5d646520b555d25f3d991065fa462fb5a1dcfa6d6b55faaa12ffcc831eba2d03119e51c8d9b12c055c35305f9d4d900b8b564efc3421afcbe74ab380616351d3b0cac3921c27a245728acb148f5956d95ec34c6bb898a1787613e3b28e45324908bbdca2a6f3d087c06cf66a1477306ec8e1209ee05d3b6a6f01d2ac7adfdcf658c98cf958f85b6fe706ea625d707f66eec1faa11cbc1b8faf16480fb77c827d9d73e9c6b641ed3b2dc59a4bc6bfb063ff0b504b240e81a694c49fb7c54e1e9f53ec2259502da20784be92239319e5572c2ca10e4fef249a90a394c93c61f3a707741aa8ba37817dbfdc23c93530fd974e32a942b5aef860e88c84c979c6605c870afefc20d5e44b83820dac595303d0a66b27b75e18d939353cdddb2ff1ddbc1fc5886162b7c53ab2d5e217f2742a9b561ffec030351978ef7dfac5d98bc5e43a1fd864c5429b2e0e007b892eab5641d198b0a7f9d49f89d3b1715f5e03b490876e872d25575e50ae852e09022d9106247c962bed52cd3580b600b83fea1cadb00643a27ec276b66ae634da85f0de52d39e63b3bb2e8b82b680308cd0dd340f3f96f801db2fa7dc52c471e4461400d280ecadc912a642d5768840b6ad32870902c8eac88659fdc76de8dd70367c135c242ca525ab38b0d60e5e6004b30d0d6359d004d0530183b38539f39e0b4ad577dd8315424f54422c51b1f6c932c83b65b3864b17352a348f2a12978ad2e376d7d3d6da1b7d939d9ebe0ffd9c5add6c9d6a5b6bf6ab52dbada3a3e8e5cccb686a8cf6373450943871c92cfc986de7b5c66a597581fdc3f3a02bea08ad0093a2081a54f78b2e06959acc55a5536403b54f2b299dbd4b6aeb34e042c09f2075b1d5118ec2b6afb1debb39e7232adf8a7b07aa5ea291175992cf97a4279856d63ce1e471f07698389b02c8d025c84ea806469b2e35659c7c2deedc60d6434a41d2315bbac9aca21c6d6b3a6121686b7dec91dbc759c26e2f15a3b3ea43591db7c8fdff3c13e868b8dc2a38fa8a715a9a649f116be42c4ffc7d3b6d472d43940640a475f5aa09d71742a1460791266388d3a11f83b26a38af57bf2b72c5bfbba62eef056b391c9a1a6151815e4f26468c20a485f88b45e471d6662dad4b750373f3df7cfb1b5bb7b8881cd95c0437d76f055e39e9843ac5487dfdf6edbf85da3168f4241cbddf9dcfb857766e5233214fb4f3f65398fdc70a55e3c217b71fa51b10cd207124dfb54c25344a969b8e25fb90b992a59bcd0e2a68a36ea8883a4fed59fd72c433e5ed347161f1a11949b54fd6cfccf1ccc7414f352ce73f30ac75260f9a7325c821a6e11c2066695e0d827ce9cbe2be6b130036c7c3cc847b60e15be2ec103aeaabc7f3dd61a4854897741cff45e3ea630a44c6ade97f213df90d5cc955ff6a85109c77632ac4245d103cf303389c92f28e21d1d9674874cb67a512533eeb3852608a0adeb240eb46f52ebe6ea407158b7ff93f73a8be5b0116526ebc185196f00e975df8364d749e744eb765eea6dc18498335b1902b06ffd2b660d2b00d1dd9399b61bea98fd415e0e06203a23d3ad949ee7a4f3b5fd4362d24511fc74640a25b61c2191205eff0102b4cc3ae601a93827fe561ee68a6cf785d992746ad8c4139395bbd5ac8c5e9aa8872c5de2d64d3dd20eb76abef82b3fe30411445b4dfbfc1ec67c9fcb302229b7164e8685daa2206f7876748da893f64ad7b4d7920bc81ed5867a921e21514f0aa10b4a068c2d1bbb8f87452799bd3277a5725fe14083886c2702984dee05b412d529a6301e22c7f66a895189dcb98e82c12db1a01293324eded79e9798cfb04c9e4aa575fdb501cdbcb0644cb7844ab4e7aa433b2193db775eeddf7083afb02ebee5127d087568294c6e856b3fc34487fdb63ccf982b85acf52e166ad415639f6529258643000601208c4d7cc4f4d84e454e70bf3ad71a5572d471eea72f0cde5631b642261e6d14edba24874c9a894836d0b83b6043ef0bcb3912d3b7f23f72c1a0915bbda65af25f624367fa8c6fc8a53413c65c734f5ebcbfefeb3b30c81d63e43eeb0a140002327cc65708a6618415e883613f06685316a35bdfbe39d2629a67442c6e4a857425dabb06abdbef83bfa11498ff78133deb72ff8077a709112b458ecc8bd1e615712b405038741c4b097f00678129ae88fa4b70225402424bef7307116673b5e245fa52490c313bd2d284cd34514b8438a75c1fc881d925ea521ea4c233714244f1c35048fda9c3419d3e8d7b1a1a7c0413dfbecca2ec47309274ddd67750735297f4bb28674be7714a786ee6113b6f7add04e93e29aa0a30572cffdd4f6ef6297098feb6925168ea74875ceb93c7a9f3efb6ab0d6952985cfda823860c5040356d282dfd93607f782ab8d2ae443692f4c7554d2d578efe3c837c8c7d7843b00b0257e5ddd0f06b85e1ffa82a83adf0aac5688d15db641a77bfc3ac5743d1693cf305aa3ffc7c51fc6bbe4d35246bb7d11696f4485daeaba4919faf69887a04a2cd3916b6a4dcbbd890c8cd2b57442a6e9de667ffe7f2dde75b179fa5c7cc055f16c288c84eaec534dcec5ce3252ee56dae3ca63a6b5e55c91ade7064690f1a5a996206fdca7179b30d19bd19c7198624278b7d9b4dd622916878da1f7c464dbb674c71093825315f5398638d81e39ce20bb8726eb0558e5579ba6e0a2ca6cae912f081cf85d4b5bd04b45d8e802587acc5722297773c77081c301043c04c24f3d6224f167a163c18dc97166eabce83b61e97e716eadfcece141262d3961c6496c1365bd5da619c08dfa5eb2f503df53d3517bbcdc146d39937174e17db168c3e028f50c0f0b0c4bd0ba4c0df6b58b809fee5cd9ed5f0cd32fa3189d6e21127e33cb47450a27b31e2060e6f681bfc00110cb192c6a327f434ed7fab42bb5563bfe330bf1265b0bb656d726f08f852dca1e741eaafeea0e41f2076b5d765c27a2481f05d81b43fec7af5475597c8e81a173a1cc0249cc3f9c3632d5626bdf97e9224dae9273ef24ca2b097948121f8b1ebe5fa6415cbd3ebf25b74df458a9512f7fc9f3ff2f7e4fa557b546df4c6fb55be248948c2595f6b32bf62184991195beef9e0c4f77608d48e21481f6195982463248df45c8360d806945567f9bd36fff7e87a9eae9e095b</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：最小体力消耗路径</title>
      <link href="2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.html"/>
      <url>2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个 $nm$ 的权值矩阵，求从左上角走到右下角。$(n, m \in [1, 100], w \in [1, 1e6])$</p><p>一条路径耗费的体力值是路径上相邻格子之间 <strong>高度差绝对值的最大值</strong> 决定的。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ol><li>二分答案：由于答案具有单调性，所以可以二分答案，然后通过 $bfs$ 进行验证。</li><li>并查集：类似于最小生成树，将所有的边都建出来，然后贪心的将当前权值最小的边加入集合，判断起点和终点是否联通即可。</li><li>最短路：将所有的边建出来，做一次起点到终点的最短路径即可。</li></ol><a id="more"></a><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仅给出第二种做法的代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 并查集模板</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; size;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="comment">// 当前连通分量数目</span></span><br><span class="line">        <span class="keyword">int</span> setCount;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        UnionFind(<span class="keyword">int</span> _n): n(_n), setCount(_n), parent(_n), size(_n, <span class="number">1</span>) &#123;</span><br><span class="line">            iota(parent.begin(), parent.end(), <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">findset</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> parent[x] == x ? x : parent[x] = findset(parent[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            x = findset(x);</span><br><span class="line">            y = findset(y);</span><br><span class="line">            <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (size[x] &lt; size[y]) &#123;</span><br><span class="line">                swap(x, y);</span><br><span class="line">            &#125;</span><br><span class="line">            parent[y] = x;</span><br><span class="line">            size[x] += size[y];</span><br><span class="line">            --setCount;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            x = findset(x);</span><br><span class="line">            y = findset(y);</span><br><span class="line">            <span class="keyword">return</span> x == y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> x, y, w;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumEffortPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = h.size(), m = h[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;Node&gt; g;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>) g.push_back(Node&#123;i * m + j, i * m + j - m, <span class="built_in">abs</span>(h[i][j] - h[i - <span class="number">1</span>][j])&#125;);</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) g.push_back(Node&#123;i * m + j, i * m + j - <span class="number">1</span>, <span class="built_in">abs</span>(h[i][j] - h[i][j - <span class="number">1</span>])&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(g.begin(), g.end(), [](Node&amp; a, Node&amp; b) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="function">UnionFind <span class="title">uf</span><span class="params">(n * m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : g) &#123;</span><br><span class="line">            uf.unite(p.x, p.y);</span><br><span class="line">            <span class="keyword">if</span> (uf.connected(<span class="number">0</span>, n * m - <span class="number">1</span>)) <span class="keyword">return</span> p.w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：解码异或后的排列</title>
      <link href="2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%A7%A3%E7%A0%81%E5%BC%82%E6%88%96%E5%90%8E%E7%9A%84%E6%8E%92%E5%88%97.html"/>
      <url>2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%A7%A3%E7%A0%81%E5%BC%82%E6%88%96%E5%90%8E%E7%9A%84%E6%8E%92%E5%88%97.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你一个整数数组 $g$，它是前 $n$ 个正整数的排列，且 $n$ 是个 <strong>奇数</strong> 。</p><p>它被加密成另一个长度为 $n - 1$ 的整数数组 $a$ ，满足 $a[i] = g[i]$ ^ $g[i + 1]$。比方说，如果 $g = [1,3,2]$，那么 $a = [2,1]$。</p><p>给你 $a$ 数组，请你返回原始数组 $g$。题目保证答案存在且唯一。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><a id="more"></a><p>可以发现如果对 $a$ 数组做前缀异或和得到 $sum$ 数组，那么 $sum[i]$ 就表示 $g[0]$ ^ $g[i + 1]$ 的值。$n$ 恰好为奇数，因此如果将数组 $sum$ 全部异或起来，$g[0]$ 刚好为被异或偶数次而抵消，得到的结果为 $g[1]$ ^ $g[2]$ ^ … ^ $g[n]$，恰好只有 $g[0]$ 没有出现。然后将这个结果与 $1-n$ 的所有数异或，得到的就是 $g[0]$ 的值，然后递推即可。时间复杂度 $O(n)$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">decode</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.size(), sum = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">g</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) g[<span class="number">0</span>] ^= (sum ^= a[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++) g[<span class="number">0</span>] ^= i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) g[i + <span class="number">1</span>] = g[i] ^ a[i];</span><br><span class="line">        <span class="keyword">return</span> g;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：最小高度树</title>
      <link href="2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91.html"/>
      <url>2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一颗树，求当树的高度最小时根的编号为多少。$(n \in [1, 2e4])$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：交换字符串中的元素</title>
      <link href="2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E4%BA%A4%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0.html"/>
      <url>2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E4%BA%A4%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你一个字符串 $s$，以及该字符串中的一些「索引对」数组 $pairs$，其中 $pairs[i] = [a, b]$ 表示字符串中的两个索引（编号从 $0$ 开始）。</p><p>你可以 任意多次交换 在 $pairs$ 中任意一对索引处的字符。</p><p>返回在经过若干次交换后，$s$ 可以变成的按字典序最小的字符串。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><a id="more"></a><p>假设 $i$ 可以和 $j$ 交换，$j$ 可以和 $k$ 交换，那么 $i$ 就可以和 $k$ 交换，因此是具有传递关系的。因此将互相具有传递关系的索引看作一个集合，用并查集维护。然后对于每个集合，将字母从小到大排序放置即可。时间复杂度 $O(nlog(n))$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> fa[<span class="number">100005</span>], v[<span class="number">100005</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fa[x] == x ? x : fa[x] = find(fa[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">smallestStringWithSwaps</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) fa[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : pairs) &#123;</span><br><span class="line">            <span class="keyword">int</span> fx = find(p[<span class="number">0</span>]), fy = find(p[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (fx != fy) fa[fx] = fy;</span><br><span class="line">            v[p[<span class="number">0</span>]] = v[p[<span class="number">1</span>]] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; id[<span class="number">100005</span>];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; ch[<span class="number">100005</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!v[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> fx = find(i);</span><br><span class="line">            <span class="keyword">if</span> (!mp[fx]) mp[fx] = ++cnt;</span><br><span class="line">            id[mp[fx]].push_back(i);</span><br><span class="line">            ch[mp[fx]].push_back(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">            sort(ch[i].begin(), ch[i].end());</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ch[i].size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="keyword">int</span>)id[i].size(); j++) </span><br><span class="line">                s[id[i][j]] = ch[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP学习笔记</title>
      <link href="2021/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9.html"/>
      <url>2021/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9.html</url>
      
        <content type="html"><![CDATA[<h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><p>ISO七层：物理层，数据链路层，网络层，传输层，会话层，表示层，应用层。<br>TCP/IP分层模型：</p><ul><li>网络接口层，ARP地址解析协议，提供硬件间接口。</li><li>网间层，IP协议，负责数据的包装，寻址，和路由。</li><li>传输层，TCP协议提供可靠数据流传输服务，UDP协议提供不可靠的用户数据报服务。</li><li>应用层，FTP（文件传输协议），HTTP（超文本传输协议），Telent（远程终端协议）。</li></ul><h3 id="TCP与UDP区别"><a href="#TCP与UDP区别" class="headerlink" title="TCP与UDP区别"></a>TCP与UDP区别</h3><h3 id="TCP超时重传"><a href="#TCP超时重传" class="headerlink" title="TCP超时重传"></a>TCP超时重传</h3><p>出现以下情况，TCP就会超时重传：</p><ul><li>数据包中途丢失</li><li>数据包顺利到达，ACK报文中途丢失</li><li>数据包到达对端，但对端未响应ACK或被对端丢失</li></ul><p>TCP每发送一个报文段，就会设置一次计时器。计时器设置的重传时间到了，还没有收到确认，就要重传这一报文段，称为“超时重传”。</p><p>RTO：重传超时时间，<strong>发送端发送数据到重传数据</strong>的这一段等待时间<br>RTT：连接往返时间，<strong>发送端从发送TCP包接受到对应的立即响应</strong>所耗费的时间</p><p><img src="http://img.benboby.top/%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0.png" alt="RTO 和 RTT 比较示意图"></p><h2 id="三次握手与四次挥手"><a href="#三次握手与四次挥手" class="headerlink" title="三次握手与四次挥手"></a>三次握手与四次挥手</h2><p><strong>简单示意图</strong><br><img src="http://img.benboby.top/三次握手.png" alt="三次握手"></p><ul><li>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 SYN_Send 状态。</li><li>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。 同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。</li><li>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 establised 状态。</li><li><p>服务器收到 ACK 报文之后，也处于 establised 状态，此时，双方已建立起了链接。</p><p>  因此三次握手可以确认双发收发功能都正常，缺一不可。</p></li></ul><p><img src="http://img.benboby.top/四次挥手.png" alt="四次挥手"></p><p>[问]：为什么要传回 SYN：接收端告诉发送端，我接收到的信息确实就是你所发送的信号。<br>[问]：为啥还要传 ACK：SYN 只能证明发送端到接受端的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来验证。</p><ul><li>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。</li><li>第二次握手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。</li><li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。</li><li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。 需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态</li><li>服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</li></ul><p>[问]：为什么连接的时候是三次握手，关闭的时候却是四次握手？<br>答：连接时，当服务端收到客户端的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文，其中 ACK 报文是用来应答的，SYN 是用来同步的。但关闭连接时，服务端收到 FIN 报文后，可能不会立即发送 FIN 报文，因为服务端可能该发送的报文还没有发完，因此只能先回复一个 ACK 报文表示确认收到了。等服务端所有报文都发送完了，才回复 FIN 信号关闭连接。故需要四次握手。</p><p>[问]：为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</p><p>答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p><p>[问]：为什么不能用两次握手进行连接？<br>答：考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发送了确认应答分组。按照两次握手的协定，S 认为连接已经成功地建立了，可以开始发送数据分组。可是，如果这个应答分组丢失了，C 就不知道 S 是否已准备好，C 就会怀疑 S 是否收到自己的连接请求分组。在这种情况下，C 认为连接还未建立成功，将忽略 S 发来的任何数据分组，只等待连接确认应答分组。而 S 在发出的分组超时后，重复发送同样的分组。这样就形成了<strong>死锁</strong>。</p><p>[问]：如果已经建立了连接，但是客户端突然出现故障了怎么办？<br>答：TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><p><img src="http://img.benboby.top/字段含义.png" alt></p><h2 id="从输入URL到页面加载发生了什么？"><a href="#从输入URL到页面加载发生了什么？" class="headerlink" title="从输入URL到页面加载发生了什么？"></a>从输入URL到页面加载发生了什么？</h2><ol><li>DNS 域名解析<br> 当你输入了 www.google.com 并按下回车后，浏览器检查输入框，发现不是 ip 地址，于是去 <strong>浏览器缓存</strong> 里面找有没有相关记录，发现没有，那就继续去 <strong>系统缓存</strong> 找，也就是系统中的 hosts 文件，还是没有，又继续去 <strong>路由器缓存</strong> 里面找，查看的是路由器映射表。接着，计算机将域名发送给 <strong>本地DNS服务器</strong>，也就是 <strong>提供本地连接的服务商</strong>，本地DNS服务器找不到的话，会将域名发送到 <strong>根域名服务器</strong>，也就是 <strong>‘.’</strong>，找不到就返回 <strong>顶级域名服务器 —— .com 的IP地址</strong>，再请求 <strong>顶级域名服务器IP</strong> 返回 <strong>二级域名服务器 —— google.com 的IP地址</strong>…直到找到对应的IP地址，然后返回给浏览器。</li><li>发起 TCP 连接（三次握手）<br> 知道IP地址后，<strong>传输层的TCP协议</strong>就可以向远端服务器发起连接请求了。</li><li>发送 HTTP 请求，接受 HTTP 响应<br> 连接上了，可以传输了。计算机需要将用户输入的地址封装成 <strong>HTTP Request 请求报文</strong>，发送到服务器，服务器收到请求后会发出应答，即响应数据。<br> HTTP请求报文格式：请求行+请求头+空行+消息体，请求行包括请求方式（GET/POST/DELETE/PUT）、请求资源路径（URL）、HTTP版本号。<br> HTTP响应报文格式：状态行+响应头+空行+消息体，状态行包括HTTP版本号、状态码、状态说明。<br>   常见的状态码：<ul><li>200 响应成功</li><li>302 跳转</li><li>400 客户端请求有语法错误，不能被服务端识别</li><li>403 服务器收到请求，但拒绝提供服务（认证失败）</li><li>404 请求资源不存在</li><li>500 服务器内部错误</li></ul></li><li>断开 TCP 连接（四次挥手）<br> 完成一次 HTTP 请求后，服务器并不是马上断开与客户端的连接。默认启用 <strong>持久连接</strong>，以便处理不久后到来的新请求，无需重新建立连接而增加慢启动开销，提高网络的吞吐能力。在反向代理软件 Nginx 中，持久连接超时时间默认值为 75 秒，如果 75 秒内没有新到达的请求，则断开与客户端的连接。同时，浏览器每隔 45 秒会向服务器发送 TCP keep-alive 探测包，来判断 TCP 连接状况，如果没有收到 ACK 应答，则主动断开与服务器的连接。</li><li>浏览器解析 HTML 代码，请求js，css等资源，最后进行页面渲染，显示出来</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：货仓选址</title>
      <link href="2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%B4%A7%E4%BB%93%E9%80%89%E5%9D%80.html"/>
      <url>2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%B4%A7%E4%BB%93%E9%80%89%E5%9D%80.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>在数轴上找到一个点，使得到其余 $n$ 个点距离之和最小。$(n \in [1, 1e5])$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>考虑绝对值不等式：<br><a id="more"></a> </p><p>当只有两个点 $a, b$ 时，有 $|a - x| + |b - x| &gt;= |a - b|$，为了满足 $|a - x| + |b - x| = |a - b|$ 关系，$x$ 必须选在 $a,b$ 两点之间。</p><p>拓展为 $n$ 个点，距离为 $|a[1] - x| + |a[2] - x| + … + |a[n - 1] - x| + |a[n] - x|$，收尾两两分组有 $(|a[1] - x| + |a[n] - x|) + (|a[2] - x| - |a[n - 2] - x| + …)$，两两应用绝对值不等式，$x$ 的位置必须满足在各个对应区间里。</p><p>得出结论：当 $n$ 为奇数时，$x$ 位置为中间那个点（因为刚好分组多出单独一个，满足最小性则必须将 $x$ 的位置选择为那个点，距离刚好为 $0$）；当 $n$ 为偶数时，$x$ 位置为中间两个点之间的任意位置都可。 </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, res, a[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    sort(a, a + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) res += <span class="built_in">abs</span>(a[i] - a[n &gt;&gt; <span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：按要求补齐数组</title>
      <link href="2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%8C%89%E8%A6%81%E6%B1%82%E8%A1%A5%E9%BD%90%E6%95%B0%E7%BB%84.html"/>
      <url>2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%8C%89%E8%A6%81%E6%B1%82%E8%A1%A5%E9%BD%90%E6%95%B0%E7%BB%84.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个已排序的正整数数组 $nums$，和一个正整数 $n$ 。从 $[1, n]$ 区间内选取任意个数字补充到 $nums$ 中，使得 $[1, n]$ 区间内的任何数字都可以用 $nums$ 中某几个数字的和来表示。请输出满足上述要求的最少需要补充的数字个数。</p><h2 id="Soluiton"><a href="#Soluiton" class="headerlink" title="Soluiton"></a>Soluiton</h2><p>容易证明，对于正整数 $x$，如果区间 $[1,x−1]$ 内的所有数字都已经被覆盖，且 $x$ 在数组中，则区间 $[1,2x−1]$ 内的所有数字也都被覆盖。<br><a id="more"></a> </p><p>由此可以提出一个贪心的方案。每次找到未被数组 $nums$ 覆盖的最小的整数 $x$，在数组中补充 $x$，然后寻找下一个未被覆盖的最小的整数，重复上述步骤直到区间 $[1,n]$ 中的所有数字都被覆盖。</p><p>具体实现：</p><p>$x$ 表示当前能表示出 $[1, x - 1]$ 的所有数字，初始化为 $1$，枚举数组。</p><ul><li>若枚举到的数小等于 $x$，则加上，表示能表示出 $[1, x + num[i] - 1]$ 的所有数字，然后下标加 $1$</li><li>若枚举到的数大于 $x$，则说明 $x$ 无法被表示出来，我们需要增加一个数 $x$，然后$x$ 加上 $x$，表示能表示出 $[1, x + x - 1]$ 的所有数字</li></ul><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPatches</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, i = <span class="number">0</span>, m = a.size();</span><br><span class="line">        <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; m &amp;&amp; a[i] &lt;= x) &#123;</span><br><span class="line">                x += a[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                x *= <span class="number">2</span>;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：最大矩形</title>
      <link href="2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2.html"/>
      <url>2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个仅包含 $0$ 和 $1$ 、大小为 $n * m$ 的二维二进制矩阵，找出只包含 $1$ 的最大矩形，并返回其面积。$(n, m \in [1, 200])$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>有一个子问题，求柱状图最大矩形。预先求出 $1-i$ 层的 $h[i]$ 然后利用套用子问题的模板即可，复杂度 $O(n * m)$.<br><a id="more"></a> </p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; h)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        st.push(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> n = h.size();</span><br><span class="line">        vector&lt;int&gt; l(n), r(n, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (st.top() != <span class="number">-1</span> &amp;&amp; h[st.top()] &gt;= h[i]) &#123;</span><br><span class="line">                r[st.top()] = i;</span><br><span class="line">                st.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            l[i] = st.top();</span><br><span class="line">            st.push(i); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) res = max(res, (r[i] - l[i] - <span class="number">1</span>) * h[i]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = a[<span class="number">0</span>].size(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">h</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) </span><br><span class="line">                h[j] = (a[i][j] == <span class="string">&#x27;1&#x27;</span> ? h[j] + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">            res = max(res, largestRectangleArea(h));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：共鸣问题</title>
      <link href="2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%85%B1%E9%B8%A3%E9%97%AE%E9%A2%98.html"/>
      <url>2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%85%B1%E9%B8%A3%E9%97%AE%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>现在有 $n$ 个音符和 $m$ 对共鸣关系，编号为 $1-n$，每个音符自己有一个奏响时的优美程度，共鸣关系 $(x,y,z)$ 表示音符 $x$ 和 $y$ 同时奏响的额外优美程度是 $z$，同时不奏响则为 $-z$，其他情况为 $0$，求最大优美程度。$(n,m \in [1,1e5])$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对于一对共鸣关系而言，在不选的情况下收益为 $-z$，则选择一个的话，收益为 $-z + z = 0$，都选择的话为 $-z + 2z = z$。因此可以预先把每对关系的两个数都加上 $z$，刚开始我们是不选任何有联系的音符的，因此初值为 $-z$，那么选择一个数就会加上 $z$，选择两个就会加上 $2z$，满足了之前所讨论的关系。答案初始化为所有关系都不选的情况，即 $-sum(z)$，然后只要贪心的选择对答案有正贡献的值就行了。<br><a id="more"></a> </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param n int整型 </span></span><br><span class="line"><span class="comment">     * @param m int整型 </span></span><br><span class="line"><span class="comment">     * @param a int整型vector </span></span><br><span class="line"><span class="comment">     * @param b int整型vector&lt;vector&lt;&gt;&gt; </span></span><br><span class="line"><span class="comment">     * @return long长整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">wwork</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; c;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : a) c.push_back(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : b) &#123;</span><br><span class="line">            c[v[<span class="number">0</span>] - <span class="number">1</span>] += v[<span class="number">2</span>];</span><br><span class="line">            c[v[<span class="number">1</span>] - <span class="number">1</span>] += v[<span class="number">2</span>];</span><br><span class="line">            res -= v[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : c) res += max(x, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：大逃离</title>
      <link href="2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%A4%A7%E9%80%83%E7%A6%BB.html"/>
      <url>2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%A4%A7%E9%80%83%E7%A6%BB.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>从 $n$ 个数中任选 $k$ 个数，取得这 $k$ 个数中最大的一个数，求每个数被取得的概率。$(n, k \in [1, 2e5])$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>将数组排序后，枚举每个数被作为最大值的可能性，当第 $i$ 个数作为最大值时，其它 $k - 1$ 个一定从前 $i - 1$ 个里面选，即方案数为 $C(i - 1, k - 1)$，将其除以总方案数 $C(n, k)$ 即为被取得概率。<br><a id="more"></a> </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param n int整型 </span></span><br><span class="line"><span class="comment">     * @param k int整型 </span></span><br><span class="line"><span class="comment">     * @param Point int整型vector </span></span><br><span class="line"><span class="comment">     * @return int整型vector</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> f[<span class="number">200005</span>];</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">qp</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (b) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b &amp; <span class="number">1</span>) sum = sum * a % mod;</span><br><span class="line">            a = a * a % mod;</span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == m || m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> f[n] * qp(f[m], mod - <span class="number">2</span>) % mod * qp(f[n - m], mod - <span class="number">2</span>) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">city</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">auto</span> b = a;</span><br><span class="line">        sort(a.begin(), a.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">long</span> <span class="keyword">long</span>&gt; mp;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= <span class="number">200000</span>; ++i) &#123;</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &gt;= k) </span><br><span class="line">                mp[a[i]] = C(i, k - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = C(n, k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            g.push_back(mp[b[i]] * qp(sum, mod - <span class="number">2</span>) % mod);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> g;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GCC编译器和GDB调试器</title>
      <link href="2020/12/GCC%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8CGDB%E8%B0%83%E8%AF%95%E5%99%A8.html"/>
      <url>2020/12/GCC%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8CGDB%E8%B0%83%E8%AF%95%E5%99%A8.html</url>
      
        <content type="html"><![CDATA[<h2 id="GCC编译器"><a href="#GCC编译器" class="headerlink" title="GCC编译器"></a>GCC编译器</h2><p>GCC 编译器支持编译 Go、Objective-C，Objective-C++，Fortran，Ada，D 和 BRIG（HSAIL）等程序。</p><p>实际使用中，使用 gcc 指令编译 C 代码，使用 g++ 指令编译 C++ 代码。</p><h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p>例如 <strong>g++ test.cpp -o test</strong> 可拆解为以下步骤：</p><a id="more"></a> <ol><li><p>预处理</p> <figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># -E 选项指示编译器仅对输入文件进行预处理</span></span><br><span class="line"><span class="meta"># test.i 文件将头文件及宏定义具体内容全部展开，其余保持不变</span></span><br><span class="line">g++ -E test.cpp -o test.i    <span class="comment">// 生成.i文件</span></span><br></pre></td></tr></table></figure></li><li><p>编译</p> <figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># -S 编译选项告诉 g++ 在为 C++ 代码产生了汇编语言文件后停止编译</span></span><br><span class="line"><span class="meta"># g++ 产生的汇编语言文件缺省拓展名是 .s</span></span><br><span class="line"><span class="meta"># test.s 汇编语言文件内容为汇编指令</span></span><br><span class="line">g++ -S test.i -o test.s</span><br></pre></td></tr></table></figure></li><li><p>汇编</p> <figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># -c 选项告诉 g++ 仅把源代码编译为机器语言的目标代码</span></span><br><span class="line"><span class="meta"># 缺省时 g++ 建立的目标代码文件有一个 .o 的拓展名</span></span><br><span class="line"><span class="meta"># test.o 为机器语言识别的二进制代码</span></span><br><span class="line">g++ -c test.s -o test.o</span><br></pre></td></tr></table></figure></li><li><p>链接</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -o 编译选项来为将产生的可执行文件用指定的文件名</span></span><br><span class="line"><span class="comment"># test 为可执行文件</span></span><br><span class="line">g++ <span class="keyword">test</span>.o -o <span class="keyword">test</span></span><br></pre></td></tr></table></figure><h3 id="g-重要编译参数"><a href="#g-重要编译参数" class="headerlink" title="g++重要编译参数"></a>g++重要编译参数</h3></li><li><p>-g 编译带调试信息的可执行文件</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -g 选项告诉 GCC 产生能被 GNU 调试器 GDB 使用的调试信息，以调试程序。</span></span><br><span class="line"><span class="comment"># 产生带调试信息的可执行文件 test（不加则 test 不包含调试信息）</span></span><br><span class="line">g++ -g <span class="keyword">test</span>.cpp -o <span class="keyword">test</span></span><br></pre></td></tr></table></figure></li><li><p>-O[n] 优化源代码</p> <figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 所谓优化，比如省略代码中从未使用过的变量，直接将常量表达式用结果值来替代等等，这些操作会缩减目标文件所包含的代码量，提高最终生成的可执行文件的运行效率。</span></span><br><span class="line"><span class="meta"># -O 选项告诉 g++ 对源代码进行基本优化。这些操作在大多数情况下都会使程序执行的更快。-O2 选项告诉 g++ 产生尽可能小和尽可能快的代码。</span></span><br><span class="line"><span class="meta"># -O 同时减小代码长度和执行时间，效果等价为 -O1</span></span><br><span class="line"><span class="meta"># -O0 表示不做优化</span></span><br><span class="line"><span class="meta"># -O1 默认优化</span></span><br><span class="line"><span class="meta"># -O2 除了完成 -O1 的优化之外，还进行一些额外的调整工作，如指令调整等</span></span><br><span class="line"><span class="meta"># -O3 包括循环展开和其他一些与处理特性相关的优化操作</span></span><br><span class="line"><span class="meta"># 选项将使编译的速度比使用 -O 时慢，但通常产生的代码执行速度会更快</span></span><br><span class="line"><span class="meta"># 可以用如 &quot;time ./test&quot; 来查看可执行文件的运行效率，比较优化效果</span></span><br><span class="line">g++ -O2 test.cpp</span><br></pre></td></tr></table></figure></li><li><p>-l 和 -L 指定库文件 ｜ 指定库文件路径</p> <figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># -l 参数就是用来指定程序要链接的库，-l 参数紧接着就是库名</span></span><br><span class="line"><span class="meta"># 在 /lib 和 /usr/lib 和 /usr/local/lib 里的库可以直接用 -l 来进行链接</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 链接 glog库</span></span><br><span class="line">g++ -lglog test.cpp</span><br><span class="line"></span><br><span class="line"><span class="meta"># 如果库文件没放在上面三个目录里，需要使用 -L 参数指定库文件所在目录</span></span><br><span class="line"><span class="meta"># -L 参数紧接着的是库文件所在的目录名</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 链接 mytest 库，libmytest.so 在 /home/Test 目录下</span></span><br><span class="line">g++ -L/home/Test -lmytest test.cpp</span><br></pre></td></tr></table></figure></li><li><p>-I 指定头文件搜索目录</p> <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 若头文件在 /usr/<span class="keyword">include</span> 目录下一般是不需要指定的，否则就需要 -I 参数来指定了，比如头文件放在 /myinclude 目录里，否则会报错 “xxxx.<span class="keyword">h</span>: <span class="keyword">No</span> such <span class="keyword">file</span> or directory” 。</span><br><span class="line"><span class="keyword">g</span>++ -I/myinclude <span class="keyword">test</span>.cpp</span><br></pre></td></tr></table></figure></li><li><p>-Wall 打印警告信息 | -w 关闭警告信息</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印出 gcc 的警告信息</span></span><br><span class="line">g++ -Wall <span class="keyword">test</span>.cpp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭所有警告信息</span></span><br><span class="line">g++ -w <span class="keyword">test</span>.cpp</span><br></pre></td></tr></table></figure></li><li><p>-std=c++11 设置编译标准</p> <figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span> <span class="comment">使用</span> <span class="comment">c</span>++<span class="comment">11</span> <span class="comment">标准编译</span> <span class="comment">test</span><span class="string">.</span><span class="comment">cpp</span></span><br><span class="line"><span class="comment">g</span>++ <span class="literal">-</span><span class="comment">std=c</span>++<span class="comment">11</span> <span class="comment">test</span><span class="string">.</span><span class="comment">cpp</span></span><br></pre></td></tr></table></figure></li><li>-o 指定输出文件名 <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定即将产生的文件名</span></span><br><span class="line"><span class="comment"># 指定输出可执行文件名为test</span></span><br><span class="line">g++ <span class="keyword">test</span>.cpp -o <span class="keyword">test</span></span><br></pre></td></tr></table></figure></li><li><p>-D 定义宏</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 在使用gcc/g++编译的时候定义宏</span><br><span class="line"># 常用场景：</span><br><span class="line"># -DDEBUG 定义 DEBUG 宏，可能文件中有DEBUG宏部分的相关信息，用 DDEBUG 来选择开启或关闭 DEBUG</span><br><span class="line"># 举例：</span><br><span class="line"><span class="comment">// -Dname 定义宏 name，默认定义内容为字符串 “1”</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;DEBUG LOG\n&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;in\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1. 在编译的时候，使用g++ -DDEBUG main.cpp</span></span><br><span class="line"><span class="comment">// 2. 第七行代码可以被执行</span></span><br></pre></td></tr></table></figure><h2 id="GDB调试器"><a href="#GDB调试器" class="headerlink" title="GDB调试器"></a>GDB调试器</h2></li></ol><p>GDB(GNU Debugger) 是一个用来调试C/C++程序的功能强大的调试器，是 Linux 系统开发 C/C++ 最常用的调试器。</p><p>GDB主要功能：</p><ul><li>设置断点(断点可以是条件表达式)</li><li>使程序在指定的代码行上暂停执行，便于观察</li><li>单步执行程序，便于调试</li><li>查看程序中变量值的变化</li><li>动态改变程序的执行环境</li><li>分析崩溃程序产生的core文件</li></ul><p>调试开始：执行gdb [filename] ，进入gdb调试程序，其中 filename 为要调试的可执行文件名。</p><p>编译程序时需要加上 -g，之后才能用 gdb 进行调试：g++ -g main.cpp -o main<br>回车键：重复上一命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">help</span>(h)        <span class="comment"># 查看命令帮助，具体命令查询在gdb中输入help + 命令</span></span> </span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)run(r)         <span class="comment"># 重新开始运行文件（run-text：加载文本文件，run-bin：加载二进制文件）</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)start          <span class="comment"># 单步执行，运行程序，停在第一行执行语句</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)list(l)        <span class="comment"># 查看原代码（list-n,从第n行开始查看代码。list+ 函数名：查看具体函数）</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">set</span>            <span class="comment"># 设置变量的值</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)next(n)        <span class="comment"># 单步调试（逐过程，函数直接执行）</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)step(s)        <span class="comment"># 单步调试（逐语句：跳入自定义函数内部执行）</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)backtrace(bt)  <span class="comment"># 查看函数的调用的栈帧和层级关系</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)frame(f)       <span class="comment"># 切换函数的栈帧</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)info(i)        <span class="comment"># 查看函数内部局部变量的数值</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)finish         <span class="comment"># 结束当前函数，返回到函数调用点</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">continue</span>(c)    <span class="comment"># 继续运行</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">print</span>(p)       <span class="comment"># 打印值及地址</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)quit(q)        <span class="comment"># 退出gdb</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">break</span>+num(b)                 <span class="comment"># 在第num行设置断点</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)info breakpoints             <span class="comment"># 查看当前设置的所有断点</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)delete breakpoints num(d)    <span class="comment"># 删除第num个断点</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)display                      <span class="comment"># 追踪查看具体变量值</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)undisplay                    <span class="comment"># 取消追踪观察变量</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)watch                        <span class="comment"># 被设置观察点的变量发生修改时，打印显示</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)i watch                      <span class="comment"># 显示观察点</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">enable</span> breakpoints           <span class="comment"># 启用断点</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">disable</span> breakpoints          <span class="comment"># 禁用断点</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)x                            <span class="comment"># 查看内存x/20xw 显示20个单元，16进制，4字节每单元</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)run argv[1] argv[2]          <span class="comment"># 调试时命令行传参</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">set</span> follow-fork-mode child   <span class="comment"># Makefile项目管理：选择跟踪父子进程（fork()）</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：区间和的个数</title>
      <link href="2020/11/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%8C%BA%E9%97%B4%E5%92%8C%E7%9A%84%E4%B8%AA%E6%95%B0.html"/>
      <url>2020/11/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%8C%BA%E9%97%B4%E5%92%8C%E7%9A%84%E4%B8%AA%E6%95%B0.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 $a$，返回区间和在 $[lower, upper]$ 之间的个数，包含 $lower$ 和 $upper$。<br>区间和 $S(i, j)$ 表示在 $a$ 中，位置从 $i$ 到 $j$ 的元素之和，包含 $i$ 和 $j$ $(i ≤ j)$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><a id="more"></a> <p>维护前缀和，对于每个前缀和 $sum[i]$，等价于 $sum[0…i-1]$ 里面有多少个数满足差值在 $[lower, upper]$ 之间。</p><p>$sum[i] - sum[j] = [lower, upper]$ 等价于求出现在区间 $sum[j] \in [sum[i] - upper, sum[i] - lower]$ 的数的个数，故可以用树状数组维护。</p><p>遍历前缀和数组，对于当前前缀和 $sum[i]$，满足的个数便为：$query(sum[i] - lower) - query(sum[i] - upper - 1)$，累加答案即可。</p><p>由于数很大，故需要将所有出现的数离散化。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BIT</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span>* c;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        BIT(<span class="keyword">int</span> _n) &#123;</span><br><span class="line">            n = _n;</span><br><span class="line">            c = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) c[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">                c[x]++;</span><br><span class="line">                x += lowbit(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x) &#123;</span><br><span class="line">                sum += c[x];</span><br><span class="line">                x -= lowbit(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countRangeSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> lower, <span class="keyword">int</span> upper)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> m = a.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> *sum = <span class="keyword">new</span> <span class="keyword">long</span> <span class="keyword">long</span>[m + <span class="number">1</span>];</span><br><span class="line">        sum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i) sum[i] = sum[i - <span class="number">1</span>] + a[i - <span class="number">1</span>];</span><br><span class="line">            s.insert(sum[i]);</span><br><span class="line">            s.insert(sum[i] - upper);</span><br><span class="line">            s.insert(sum[i] - lower);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">int</span> n = s.size(), idx = <span class="number">0</span>;</span><br><span class="line">        <span class="function">BIT <span class="title">bit</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : s) mp[x] = ++idx;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = mp[sum[i] - upper], r = mp[sum[i] - lower];</span><br><span class="line">            res += bit.query(r) - bit.query(l - <span class="number">1</span>);</span><br><span class="line">            bit.add(mp[sum[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++内存管理</title>
      <link href="2020/11/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"/>
      <url>2020/11/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html</url>
      
        <content type="html"><![CDATA[<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="内存管理详解"><a href="#内存管理详解" class="headerlink" title="内存管理详解"></a>内存管理详解</h3><h4 id="内存分配方式"><a href="#内存分配方式" class="headerlink" title="内存分配方式"></a>内存分配方式</h4><h5 id="分配方式简介"><a href="#分配方式简介" class="headerlink" title="分配方式简介"></a>分配方式简介</h5><p>在C++中，内存分为5个区：</p><ol><li>栈：执行函数时，函数内部局部变量存储单元在栈上创建，结束时自动释放。效率很高，但存储容量有限。</li><li>堆：由 <strong>new</strong> 分配的内存块，编译器不会自动释放，需要应用程序对应的 <strong>delete</strong> 进行释放。如果没有释放，则程序运行结束后会由操作系统自动回收。</li><li>自由存储区：由 <strong>malloc</strong> 等分配的内存块，类似堆，由 <strong>free</strong> 结束自己的生命。</li><li>全局/静态存储区：存储全局变量和静态变量。</li><li>常量存储区：存放常量，不允许修改。</li></ol><a id="more"></a> <h5 id="明确区分堆和栈"><a href="#明确区分堆和栈" class="headerlink" title="明确区分堆和栈"></a>明确区分堆和栈</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在栈内存中存放了一个指向一块堆内存的指针 p。程序会先确定在堆中分配内存的大小，然后调用 <strong>operator new</strong> 分配内存，然后返回这块内存的首地址，放入栈中。</p><p>这里并没有释放内存，因此需要 <strong>delete[] p</strong>，告诉编译器删除的是数组，然后编译器根据Cookie信息去释放内存。</p><h5 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h5><ol><li>管理方式：栈由编译器自动管理，无需手动控制；堆的释放工作由程序员控制，容易产生内存泄露。</li><li>空间大小：堆栈的内存都可以自己设定，堆内存一般不超过系统内存都是可以申请，栈内存个人测试默认值为8M。</li><li>碎片问题：对于堆而言，频繁的 <strong>new/delete</strong> 势必会造成内存空间的不连续，造成大量的碎片，使程序的效率降低；对于栈而言，则不会发生这样的情况，先进后出排列有序，以至于永远不可能有一个内存块从非栈顶位置弹出。</li><li>生长方向：对于堆而言，生长方向向上，向着内存地址增加的方向增长；对于栈而言，生长方向向下，向着内存地址减小的方向增长。</li><li>分配方式：堆都是动态分配的，没有静态分配的堆。栈有动态分配和静态分配两种，静态分配由编译器完成，比如局部变量的分配；动态分配由 <strong>alloca</strong> 函数进行分配，都由编译器进行释放。</li><li>分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持，这就决定了栈的效率比较高。堆则是 C/C++ 函数库提供的，机制比较复杂，用到许多算法的实现内存的分配。显然，堆的效率比栈要低得多。</li></ol><p>因此，更推荐尽量使用栈而不是堆。但是栈和堆相比并不灵活。如果需要分配大量内存空间，还是堆好一些。</p><h4 id="控制-C-的内存分配"><a href="#控制-C-的内存分配" class="headerlink" title="控制 C++ 的内存分配"></a>控制 C++ 的内存分配</h4><p>无论如何，一定要保守的使用内存分配。<br>一个防止堆破碎的通用方法是从不同固定大小的内存池中分配不同类型的对象。对每个类重载 <strong>new</strong> 和 <strong>delete</strong> 就提供了这样的控制。</p><h5 id="重载全局的new和delete操作"><a href="#重载全局的new和delete操作" class="headerlink" title="重载全局的new和delete操作"></a>重载全局的new和delete操作</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">void</span> *p = <span class="built_in">malloc</span>(size); </span><br><span class="line">    <span class="keyword">return</span> (p); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *p)</span></span>; </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">free</span>(p); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以对单个类的 new 和 delete 操作符重载。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *p)</span></span>; </span><br><span class="line">    <span class="comment">// .. other members here ... </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">void</span> *TestClass::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">void</span> *p = <span class="built_in">malloc</span>(size); <span class="comment">// Replace this with alternative allocator </span></span><br><span class="line">    <span class="keyword">return</span> (p); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> TestClass::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *p)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">free</span>(p); <span class="comment">// Replace this with alternative de-allocator</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="为单个类重载-new-和-delete"><a href="#为单个类重载-new-和-delete" class="headerlink" title="为单个类重载 new[] 和 delete[]"></a>为单个类重载 new[] 和 delete[]</h5><p>C++将对象数组的内存分配作为一个单独的操作，而不同于单个对象的内存分配。为了改变这种方式，同样需要重载 new[] 和 delete[]操作符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">void</span> * <span class="keyword">operator</span> <span class="keyword">new</span>[ ](<span class="keyword">size_t</span> size); </span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[ ](<span class="keyword">void</span> *p); </span><br><span class="line">    <span class="comment">// .. other members here .. </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">void</span> *TestClass::<span class="keyword">operator</span> <span class="keyword">new</span>[ ](<span class="keyword">size_t</span> size) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">void</span> *p = <span class="built_in">malloc</span>(size); </span><br><span class="line">    <span class="keyword">return</span> (p); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">void</span> TestClass::<span class="keyword">operator</span> <span class="keyword">delete</span>[ ](<span class="keyword">void</span> *p) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">free</span>(p); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    TestClass *p = <span class="keyword">new</span> TestClass[<span class="number">10</span>]; </span><br><span class="line">    <span class="comment">// ... etc ... </span></span><br><span class="line">    <span class="keyword">delete</span>[ ] p; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：对于多数 C++ 的实现，<strong>new[]</strong> 操作符中的个数参数是数组的大小加上额外的存储对象数目的一些字节。因此应该尽量避免分配对象数组，使内存分配策略简单。</p><h4 id="常见的内存错误"><a href="#常见的内存错误" class="headerlink" title="常见的内存错误"></a>常见的内存错误</h4><ol><li>内存分配未成功，却使用了它。<ul><li>如果是用 malloc 或 new 来申请内存，应该用 if(p==NULL) 或 if(p!=NULL)进行防错。</li></ul></li><li>内存分配虽然成功，但未初始化就引用它。<ul><li>无论用何种方式创建数组，都要赋初值，即便是零值。</li></ul></li><li>内存分配成功并且已经初始化，但操作越界。<ul><li>多发生在下标“多1”或“少1”。</li></ul></li><li>忘记了释放内存，造成内存泄漏。<ul><li>动态内存的申请与释放必须配对，程序中 <strong>malloc</strong> 与 <strong>free</strong> 的使用次数一定要相同，否则肯定有错误（new/delete同理）。</li></ul></li><li>释放了内存却继续使用它。<ul><li>程序过于复杂，难以分清是否释放了内存，此时应当重新设计数据结构，解决混乱。</li><li>return语句写错，不要返回指向“栈内存”的指针或引用，因为该内存在函数体结束时被自动销毁。</li><li>free或delete释放内存后，没有将指针设为NULL，导致“野指针”。</li></ul></li></ol><h4 id="指针与数组对比"><a href="#指针与数组对比" class="headerlink" title="指针与数组对比"></a>指针与数组对比</h4><p>数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。数组名对应着（<strong>而不是指向</strong>）一块内存，其地址和容量在生命周期内保持不变，只有数组的内容可以改变。</p><p>指针可以随时指向任何类型的内存块，它的特征是“可变”的，所以常用指针来操作动态内存，指针远比数组灵活，但也更危险。</p><h5 id="修改数组内容"><a href="#修改数组内容" class="headerlink" title="修改数组内容"></a>修改数组内容</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[] = “hello”; </span><br><span class="line">a[<span class="number">0</span>] = ‘X’; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"><span class="comment">// 可以拆分为 char s[] = &quot;world&quot;; char *p = str;</span></span><br><span class="line"><span class="keyword">char</span> *p = “world”; <span class="comment">// 注意 p 指向常量字符串</span></span><br><span class="line">p[<span class="number">0</span>] = ‘X’; <span class="comment">// 编译器不能发现该错误，但运行时产生[Bus error]</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h5 id="内容复制与比较"><a href="#内容复制与比较" class="headerlink" title="内容复制与比较"></a>内容复制与比较</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组… </span></span><br><span class="line"><span class="keyword">char</span> a[] = <span class="string">&quot;hello&quot;</span>; </span><br><span class="line"><span class="keyword">char</span> b[<span class="number">10</span>]; </span><br><span class="line"><span class="built_in">strcpy</span>(b, a); <span class="comment">// 不能用 b = a; </span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(b, a) == <span class="number">0</span>) <span class="comment">// 不能用 if (b == a) </span></span><br><span class="line">… </span><br><span class="line"><span class="comment">// 指针… </span></span><br><span class="line"><span class="comment">// 语句 p = a 并不能把 a 的内容复制给指针 p，而是把 a 的地址赋给了 p。</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(a); </span><br><span class="line"><span class="keyword">char</span> *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*(len+<span class="number">1</span>)); </span><br><span class="line"><span class="built_in">strcpy</span>(p, a); <span class="comment">// 不要用 p = a; </span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(p, a) == <span class="number">0</span>) <span class="comment">// 不要用 if (p == a) </span></span><br></pre></td></tr></table></figure><h5 id="计算内存容量"><a href="#计算内存容量" class="headerlink" title="计算内存容量"></a>计算内存容量</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[] = <span class="string">&quot;hello world&quot;</span>; </span><br><span class="line"><span class="keyword">char</span> *p = a; </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(a) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 12 字节</span></span><br><span class="line"><span class="comment">// sizeof(p) 等价于 sizeof(char *)，没有办法的值指针所指的内存容量，除非申请内存时就记住它</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(p) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 4 字节</span></span><br></pre></td></tr></table></figure><p>注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(<span class="keyword">char</span> a[<span class="number">100</span>])</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// 不论数组 a 的容量是多少，sizeof(a)始终等于 sizeof(char *)。</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(a) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 4 字节而不是 100 字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="指针参数如何传递内存"><a href="#指针参数如何传递内存" class="headerlink" title="指针参数如何传递内存"></a>指针参数如何传递内存</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetMemory</span><span class="params">(<span class="keyword">char</span> *p, <span class="keyword">int</span> num)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    p = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * num); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>; </span><br><span class="line">    GetMemory(str, <span class="number">100</span>); <span class="comment">// str 仍然为 NULL </span></span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello&quot;</span>); <span class="comment">// 运行错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.benboby.top/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%89%AF%E6%9C%AC.png" alt></p><p>如果函数的参数是一个指针，不要指望用该指针去申请动态内存。编译器总是要为函数的每个参数制作临时副本，指针参数 p 的副本是 _p，编译器使 _p = p。如果函数体内的程序修改了_p 的内容，就导致参数 p 的内容作相应的修改。这就是指针可以用作输出参数的原因。_p 申请了新的内存，只是把 _p 所指的内存地址改变了，但是 p 丝毫未变。所以函数 GetMemory 并不能输出任何东西。事实上，每执行一次 GetMemory 就会泄露一块内存，因为没有用 free 释放内存。</p><p>如果非得要用指针参数去申请内存，那么应该改用“指向指针的指针”:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetMemory2</span><span class="params">(<span class="keyword">char</span> **p, <span class="keyword">int</span> num)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * num); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test2</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>; </span><br><span class="line">    GetMemory2(&amp;str, <span class="number">100</span>); <span class="comment">// 注意参数是 &amp;str，而不是 str </span></span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello&quot;</span>); </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; str &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">free</span>(str); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="/2020/11/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.htm/指针的指针.png" alt></p><p>比较好的方法是 <strong>传指针的引用</strong>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetMemory</span><span class="params">(<span class="keyword">char</span> *&amp;p, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    GetMemory(str, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">free</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以用函数返回值来传递动态内存。这种方法更加简单：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">GetMemory3</span><span class="params">(<span class="keyword">int</span> num)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * num); </span><br><span class="line">    <span class="keyword">return</span> p; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test3</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>; </span><br><span class="line">    str = GetMemory3(<span class="number">100</span>); </span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello&quot;</span>); </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; str &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">free</span>(str); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在使用返回值时，千万别返回 <strong>指向“栈内存”</strong> 的指针、引用，因为该内存在函数结束时 <strong>自动消亡</strong> 了，返回的指针是个野指针了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">GetString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> p[] = <span class="string">&quot;hello world&quot;</span>; <span class="comment">//数组内容存储在栈区，函数结束时，会释放掉</span></span><br><span class="line">     <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    str = GetString();      <span class="comment">//因为非配的内存早已释放掉，此时的str是个野指针，内容是垃圾</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在函数中不定义数组，定义指针：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">GetString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> *p = <span class="string">&quot;hello world&quot;</span>; <span class="comment">//数组内容存储在静态区，函数结束时，不会释放掉</span></span><br><span class="line">     <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    str = GetString();      </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h4 id="杜绝“野指针”"><a href="#杜绝“野指针”" class="headerlink" title="杜绝“野指针”"></a>杜绝“野指针”</h4><p>“野指针”不是 NULL 指针，是指向“垃圾”内存的指针。“野指针”是很危险的，if 语句对它不起作用。出现的原因有：</p><ol><li>指针变量没有被初始化。任何指针变量刚被创建时不会自动成为 NULL 指针，它的缺省值是随机的。所以，指针变量在创建的同时应当被初始化，要么将指针设置为 NULL，要么让它指向合法的内存。</li><li>指针 p 被 free 或者 delete 之后，没有置为 NULL，让人误以为 p 是个合法的指针。</li><li>指针操作超越了变量的作用域范围。</li></ol><h4 id="有了-malloc-free-为什么还要-new-delete？"><a href="#有了-malloc-free-为什么还要-new-delete？" class="headerlink" title="有了 malloc/free 为什么还要 new/delete？"></a>有了 malloc/free 为什么还要 new/delete？</h4><p><strong>malloc 与 free</strong> 是 C++/C 语言的标准库函数，<strong>new/delete</strong> 是 C++ 的运算符。它们都可用于申请动态内存和释放内存。<br>对于非内部数据类型的对象而言，光用 <strong>malloc/free</strong> 无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于 <strong>malloc/free</strong> 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于 <strong>malloc/free</strong>。<br>而C++程序经常要调用 C 函数，而 C 程序只能用 <strong>malloc/free</strong> 管理动态内存，因此不能只用 <strong>new/delete</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">public</span> : </span><br><span class="line">    Obj(<span class="keyword">void</span>)&#123; <span class="built_in">cout</span> &lt;&lt; “Initialization” &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">    ~Obj(<span class="keyword">void</span>)&#123; <span class="built_in">cout</span> &lt;&lt; “Destroy” &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Initialize</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; “Initialization” &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Destroy</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; “Destroy” &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UseMallocFree</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Obj *a = (obj *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(obj)); <span class="comment">// 申请动态内存</span></span><br><span class="line">    a-&gt;Initialize(); <span class="comment">// 初始化</span></span><br><span class="line">    <span class="comment">//… </span></span><br><span class="line">    a-&gt;Destroy(); <span class="comment">// 清除工作</span></span><br><span class="line">    <span class="built_in">free</span>(a); <span class="comment">// 释放内存</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UseNewDelete</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Obj *a = <span class="keyword">new</span> Obj; <span class="comment">// 申请动态内存并且初始化</span></span><br><span class="line">    <span class="comment">//… </span></span><br><span class="line">    <span class="keyword">delete</span> a; <span class="comment">// 清除并且释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内存耗尽怎么办？"><a href="#内存耗尽怎么办？" class="headerlink" title="内存耗尽怎么办？"></a>内存耗尽怎么办？</h4><p>如果在申请动态内存时找不到足够大的内存块，<strong>malloc</strong> 和 <strong>new</strong> 将返回 <strong>NULL</strong> 指针，表示内存申请失败。<br>处理“内存耗尽”问题，一般可以通过判断指针是否为 <strong>NULL</strong>，是的话用 <strong>return</strong> 或 <strong>exit(1)</strong> 终止整个程序的运行，也可以自己为 <strong>new 和 molloc</strong> 设置异常处理函数。<br>如果一个函数内有多处需要申请动态内存，那么应该用 <strong>exit(1)</strong> 及时终止程序。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树状数组经典题</title>
      <link href="2020/10/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%BB%8F%E5%85%B8%E9%A2%98.html"/>
      <url>2020/10/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%BB%8F%E5%85%B8%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<h2 id="一个简单的整数问题"><a href="#一个简单的整数问题" class="headerlink" title="一个简单的整数问题"></a>一个简单的整数问题</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>第一类指令形如 “C-l-r-d”，表示把数列中第 $l-r$ 个数都加 $d$。</p><p>第二类指令形如 “Q-X”，表示询问数列中第 $x$ 个数的值。<br><a id="more"></a> </p><p>对于每个询问，输出一个整数表示答案。</p><p>数据范围：$(n, m \in [1, 100000])$</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>用树状数组解决动态差分问题。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">ll c[N], a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">        c[x] += y;</span><br><span class="line">        x += lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        sum += c[x];</span><br><span class="line">        x -= lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">int</span> x, y, z;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">&quot;Q&quot;</span>) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; query(x) + a[x] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">            add(x, z);</span><br><span class="line">            add(y + <span class="number">1</span>, -z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="谜一样的牛"><a href="#谜一样的牛" class="headerlink" title="谜一样的牛"></a>谜一样的牛</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定序列长度 $n$ 和 数组 $a$，$a[i]$ 表示第 $i$ 个数前面有多少个数比它小，复原原序列，原序列为 $1-n$ 的排列。$(n \in [1, 100000])$</p><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>最后一个数的大小明显是一开始就可以推断出来的，假设其大小是 $x$，接着从 $1-n$ 这 $n$ 个数字中把 $x$ 删掉，然后再看倒数第二个数，假设其前面有 $y$ 个数比它小，说明这个数是剩下的数里面第 $y + 1$ 大的数。</p><p>由此可以发现，我们可以倒推过来，第 $i$ 个数的大小便是当前还没有被选的数中第 $a[i] + 1$ 小的数。</p><p>可以使用树状数组解决，将每个位置置为 $1$ 表示未被选，$0$ 表示已被选，得到的前缀和是单调递增的，因此每次只需要二分查找满足前缀和刚好等于 $a[i] + 1$ 的位置即为当前数的大小。</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, c[N], a[N], res[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">        c[x] += y;</span><br><span class="line">        x += lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        sum += c[x];</span><br><span class="line">        x -= lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    add(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        add(i, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n + <span class="number">1</span>, mid;</span><br><span class="line">        <span class="keyword">while</span> (l + <span class="number">1</span> &lt; r) &#123;</span><br><span class="line">            mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (query(mid) &lt; a[i] + <span class="number">1</span>) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        res[i] = r;</span><br><span class="line">        add(r, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cout</span> &lt;&lt; res[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集拓展</title>
      <link href="2020/10/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%8B%93%E5%B1%95.html"/>
      <url>2020/10/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%8B%93%E5%B1%95.html</url>
      
        <content type="html"><![CDATA[<h2 id="边带权"><a href="#边带权" class="headerlink" title="边带权"></a>边带权</h2><h3 id="银河英雄传说"><a href="#银河英雄传说" class="headerlink" title="银河英雄传说"></a>银河英雄传说</h3><p>有 $T$ 条指令，每条指令格式为以下两种之一：</p><ol><li><p>$M-i-j$，表示让第 $i$ 号战舰所在列的全部战舰保持原有顺序，接在第 $j$ 号战舰所在列的尾部。</p><a id="more"></a> </li><li><p>$C-i-j$，表示询问第 $i$ 号战舰与第 $j$ 号战舰当前是否处于同一列中，如果在同一列中，它们之间间隔了多少艘战舰。</p></li></ol><p>数据范围：$N≤30000, T≤500000$</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>维护数组 $dp$ 表示 $i$ 到 $root$ 的距离，那么查询的答案便是 $abs(dp[a] - dp[b]) - 1$。</p><p>当 $a$ 向 $b$ 连一条边时，有 $fa[a] = b$，此时根结点 $a$ 的深度会增加 $b$ 的集合大小，因此我们需要一个 $sz$ 数组维护集合大小。</p><p>同时在进行路径压缩时，对于未更新的结点也要一同更新深度。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[N], sz[N], fa[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != fa[x]) &#123;</span><br><span class="line">        <span class="keyword">int</span> root = find(fa[x]);</span><br><span class="line">        dp[x] += dp[fa[x]];</span><br><span class="line">        fa[x] = root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t, a, b;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">30000</span>; i++) &#123;</span><br><span class="line">        dp[i] = <span class="number">0</span>;</span><br><span class="line">        sz[i] = <span class="number">1</span>;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">int</span> pa = find(a), pb = find(b);</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">&quot;M&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pa != pb) &#123;</span><br><span class="line">                fa[pa] = pb;</span><br><span class="line">                dp[pa] = sz[pb];</span><br><span class="line">                sz[pb] += sz[pa];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (pa != pb) <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; max(<span class="built_in">abs</span>(dp[a] - dp[b]) - <span class="number">1</span>, <span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓展域"><a href="#拓展域" class="headerlink" title="拓展域"></a>拓展域</h2><h3 id="食物链"><a href="#食物链" class="headerlink" title="食物链"></a>食物链</h3><p>动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。</p><ol><li><p>$1-X-Y$，表示 $X$ 和 $Y$ 是同类。</p></li><li><p>$2-X-Y$，表示 $X$ 吃 $Y$。</p></li></ol><p>判断有多少句假话。$(1≤N≤50000,0≤K≤100000)$</p><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>$1-n$ 表示动物 $i$ 的同类，$n+1-2n$ 表示动物 $i$ 的猎物，$2n+1 - 3n$ 表示动物 $i$ 的天敌。</p><p>对于操作1: 查询 $x$ 和 $y$ 的天敌域，猎物域是不是在一个集合，是则累加答案，否则进行合并。</p><p>对于操作2: 查询 $x$ 和 $y$ 的同类域，猎物域是不是在一个集合，是则累加答案，否则进行合并。</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">1000005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != fa[x]) </span><br><span class="line">        fa[x] = find(fa[x]);</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    a = find(a), b = find(b);</span><br><span class="line">    <span class="keyword">if</span> (a != b) fa[a] = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k, a, b, c, res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;  i &lt;= n * <span class="number">3</span>; i++) fa[i] = i;</span><br><span class="line">    <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; c &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; n || b &gt; n) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (find(a) == find(b + n) || find(a) == find(b + <span class="number">2</span> * n)) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/// a和b是同类，a和b的猎物也是同类，a和b的天敌也是同类</span></span><br><span class="line">                join(a, b);</span><br><span class="line">                join(a + n, b + n);</span><br><span class="line">                join(a + <span class="number">2</span> * n, b + <span class="number">2</span> * n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (a == b || find(a) == find(b) || find(a) == find(b + n)) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/// a的猎物是b， b的天敌是a，b的猎物是a的天敌</span></span><br><span class="line">                join(a, b + <span class="number">2</span> * n);</span><br><span class="line">                join(a + n, b);</span><br><span class="line">                join(a + <span class="number">2</span> * n, b + n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="奇偶游戏"><a href="#奇偶游戏" class="headerlink" title="奇偶游戏"></a>奇偶游戏</h3><p>给你 $m$ 个询问，每一个询问给出一个区间的左右端点和区间中的 $1$ 的数量的奇偶性，输出不出现矛盾的最大的 $k$ 值，即 $1-k$ 无矛盾，$1- k + 1$ 矛盾。$(N≤10^9,M≤10000)$</p><h3 id="Solution1（边带权）"><a href="#Solution1（边带权）" class="headerlink" title="Solution1（边带权）"></a>Solution1（边带权）</h3><ol><li>我们可以用 $sum$ 数组表示序列 S 的前缀和,那么会得到以下性质.</li></ol><p>$s[l~r]$ 有偶数个 $1$，等价于 $sum[l-1]$ 与 $sum[r]$ 奇偶性相同 $(1+0=1,0+0=0,1是奇数,0是偶数)$<br>$s[l~r]$ 有奇数个 $1$，等价于 $sum[l-1]$ 与 $sum[r]$ 奇偶性不同 $(1+1=0,0+1=0,1是奇数,0是偶数)$</p><ol><li><p>根据传递性，可以使用边带权，边权 $d[x] = 0$，表示 $x$ 与 $f[x]$ 的奇偶性相同; 为 $1$，表示 $x$ 与 $fa[x]$ 的奇偶性不同,在路径压缩的过程中,对 $x$ 到树根路径的所有边权做异或$(xor)$。</p></li><li><p>对于每个问题, 设离散化后 $l - 1$ 和 $r$ 的值分别是 $x$ 和 $y$ , 设 $c$ 表示当前问题的回答($c = 0$ 表示偶数个, $c = 1$ 表示奇数个)</p></li></ol><p>若 $x$ 和 $y$ 在一个集合中, 直接判断 $d[x] xor d[y]$ 是否等于 $c$，若不等于,则矛盾，直接输出结果。</p><p>若 $x$ 和 $y$ 不在一个集合中，说明无法判断，此时合并两个集合，得到俩个的树根 $p$ 和 $q$, $d[x]$ 与 $d[y]$ 分别表示 $x - p$ 与 $y - q$ 之间所有边权的 “xor” 和，$p - q$ 之间的边权为 $d[p]$, 显然, 路径 $x - y$ 由 $x - p$, $p - q$, $q - y$ 组成，所以 $x$ 与 $y$ 的奇偶性关系 $c = d[x] (xor) d[y] (xor) d[p]$，得到 $d[p] = d[x] (xor) d[y] (xor) c$。</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[N], d[N];</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">&#125; q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != fa[x]) &#123;</span><br><span class="line">        <span class="keyword">int</span> root = find(fa[x]);</span><br><span class="line">        d[x] ^= d[fa[x]];</span><br><span class="line">        fa[x] = root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L, n, a, b, pa, pb;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; L &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; q[i].a &gt;&gt; q[i].b &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;e&#x27;</span>) q[i].c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> q[i].c = <span class="number">1</span>;</span><br><span class="line">        g.push_back(q[i].a - <span class="number">1</span>);</span><br><span class="line">        g.push_back(q[i].b);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(g.begin(), g.end());</span><br><span class="line">    g.erase(unique(g.begin(), g.end()), g.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= (<span class="keyword">int</span>)g.size(); i++) &#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">        mp[g[i - <span class="number">1</span>]] = i;</span><br><span class="line">        d[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= n; i++) &#123;</span><br><span class="line">        a = mp[q[i].a - <span class="number">1</span>], b = mp[q[i].b];</span><br><span class="line">        pa = find(a), pb = find(b);</span><br><span class="line">        <span class="keyword">if</span> (pa != pb) &#123;</span><br><span class="line">            fa[pa] = pb;</span><br><span class="line">            d[pa] ^= d[a] ^ d[b] ^ q[i].c;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (d[a] ^ d[b] != q[i].c) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i - <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Solution2（拓展域）"><a href="#Solution2（拓展域）" class="headerlink" title="Solution2（拓展域）"></a>Solution2（拓展域）</h3><p>$1 - n$ 表示 $sum[i]$ 为奇，$n + 1 - 2 * n$ 表示 $sum[i]$ 为偶。</p><p>当查询区间为奇数时：判断 $a$ 的奇数域是否与 $b$ 的奇数域同在一个集合，是则矛盾，否则合并 $a$ 的奇数域与 $b$ 的偶数域，$a$ 的偶数域与 $b$ 的奇数域。</p><p>当查询区间为偶数时：判断 $a$ 的奇数域是否与 $b$ 的偶数域同在一个集合，是则矛盾，否则合并 $a,b$ 的奇数域和偶数域。</p><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">&#125; q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != fa[x]) </span><br><span class="line">        fa[x] = find(fa[x]);</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x = find(x), y = find(y);</span><br><span class="line">    <span class="keyword">if</span> (x != y) fa[x] = y;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L, m, n, a, b;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; L &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; q[i].a &gt;&gt; q[i].b &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">&quot;even&quot;</span>) q[i].c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> q[i].c = <span class="number">1</span>;</span><br><span class="line">        g.push_back(q[i].a - <span class="number">1</span>);</span><br><span class="line">        g.push_back(q[i].b);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(g.begin(), g.end());</span><br><span class="line">    g.erase(unique(g.begin(), g.end()), g.end());</span><br><span class="line">    n = g.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        mp[g[i - <span class="number">1</span>]] = i;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">        fa[i + n] = i + n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= m; i++) &#123;</span><br><span class="line">        a = mp[q[i].a - <span class="number">1</span>], b = mp[q[i].b];</span><br><span class="line">        <span class="keyword">if</span> (q[i].c) &#123;</span><br><span class="line">            <span class="keyword">if</span> (find(a) == find(b) || find(a + n) == find(b + n)) <span class="keyword">break</span>;</span><br><span class="line">            join(a, b + n); <span class="comment">// 合并a的奇数域和b的偶数域</span></span><br><span class="line">            join(a + n, b); <span class="comment">// 合并a的偶数域和a的奇数域</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (find(a) == find(b + n) || find(a + n) == find(b)) <span class="keyword">break</span>;</span><br><span class="line">            join(a, b);     <span class="comment">// 合并a的奇数域和b的奇数域</span></span><br><span class="line">            join(a + n, b + n);  <span class="comment">// 合并a的偶数域和b的偶数域</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i - <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反向并查集"><a href="#反向并查集" class="headerlink" title="反向并查集"></a>反向并查集</h2><h3 id="星球大战"><a href="#星球大战" class="headerlink" title="星球大战"></a>星球大战</h3><p>求每次拆边后的连通块个数。$(m \in [1, 2e5], n \in [1, 2*m])$</p><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>拆边很难维护集合数量，考虑离线后反过来建图。这样便相当于每次增加增加一条边，查询两个点是否为同一个集合即可知道集合数量是否减少。</p><h3 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k, pre[N], b[N], vis[N];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = x, j = x;</span><br><span class="line">  <span class="keyword">while</span> (i != pre[i])</span><br><span class="line">    i = pre[i];</span><br><span class="line">  <span class="keyword">while</span> (i != j) &#123;</span><br><span class="line">    <span class="keyword">int</span> temp = pre[j];</span><br><span class="line">    pre[j] = i;</span><br><span class="line">    j = temp;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> fx = find(x), fy = find(y);</span><br><span class="line">  <span class="keyword">if</span> (fx != fy) &#123;</span><br><span class="line">    pre[fx] = fy;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    pre[i] = i;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    g[x].push_back(y);</span><br><span class="line">    g[y].push_back(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">    vis[b[i]] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> res = n - k;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; g[i].size(); j++) &#123;</span><br><span class="line">      <span class="keyword">int</span> x = g[i][j];</span><br><span class="line">      <span class="keyword">if</span> (!vis[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (join(i, x)) res--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  b[k + <span class="number">1</span>] = res;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">    res++;</span><br><span class="line">    vis[b[i]] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; g[b[i]].size(); j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!vis[g[b[i]][j]] &amp;&amp; join(b[i], g[b[i]][j])) </span><br><span class="line">        res--;</span><br><span class="line">    &#125;</span><br><span class="line">    b[i] = res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k + <span class="number">1</span>; i++) </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Total-Eclipse"><a href="#Total-Eclipse" class="headerlink" title="Total Eclipse"></a>Total Eclipse</h3><p>给你 $n$ 个节点 $m$ 条边的图，每个点有一个权值，你现在要做的操作是选择一个连通图，并将其中的每一个点的权值都减一，问你最少需要多少次才能将所有的点都变为0。$(1≤n≤100000, 1≤m≤200000)$</p><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>贪心地想，每次必然是选择权值最小的点，然后联通的边都减少该权值，但这样很难维护，因此可以考虑反向。</p><p>每次选择权值最大的点，然后这个点需要减少到和次小的点一样的权值，即减少的权值为和次小点权值之差。由于一次可以减少一个联通块，因此我们只需要乘以当前点联通块个数即可。</p><h3 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, n, m, pre[N], vis[N];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> w;</span><br><span class="line">  <span class="keyword">int</span> id;</span><br><span class="line">&#125; q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node x, Node y)</span> </span>&#123; <span class="keyword">return</span> x.w &gt; y.w; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = x, j = x;</span><br><span class="line">  <span class="keyword">while</span> (i != pre[i]) i = pre[i];</span><br><span class="line">  <span class="keyword">while</span> (j != i) &#123;</span><br><span class="line">    <span class="keyword">int</span> temp = pre[j];</span><br><span class="line">    pre[j] = i;</span><br><span class="line">    j = temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> fx = find(x), fy = find(y);</span><br><span class="line">  <span class="keyword">if</span> (fx != fy) &#123;</span><br><span class="line">    pre[fx] = fy;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">  <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;q[i].w);</span><br><span class="line">      q[i].id = i;</span><br><span class="line">      pre[i] = i;</span><br><span class="line">      g[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> u, v;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">      g[u].push_back(v);</span><br><span class="line">      g[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> cnt = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + n + <span class="number">1</span>, cmp);</span><br><span class="line">    q[n + <span class="number">1</span>].w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      cnt++;</span><br><span class="line">      vis[q[i].id] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> x : g[q[i].id]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[x] &amp;&amp; join(x, q[i].id)) cnt--;</span><br><span class="line">      &#125;</span><br><span class="line">      res += cnt * (q[i].w - q[i + <span class="number">1</span>].w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：编辑距离</title>
      <link href="2020/10/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.html"/>
      <url>2020/10/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两个单词 $a$ 和 $b$，请你计算出将 $a$ 转换成 $b$ 所使用的最少操作数。</p><p>你可以对一个单词进行如下三种操作：</p><ol><li>插入一个字符<a id="more"></a> </li><li>删除一个字符</li><li>替换一个字符</li></ol><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>$dp[i][j]$ 表示 $a$ 的前 $i$ 个字母和 $b$ 的前 $j$ 个字母匹配的最少操作次数。</p><p>可以从三种状态转移过来：</p><p>$dp[i][j] = dp[i - 1][j] + 1$    在 $b[j]$ 后面插入一个字符 $a[i]$</p><p>$dp[i][j] = dp[i][j - 1] + 1$    在 $a[i]$ 后面插入一个字符 $b[j]$</p><p>$dp[i][j] = dp[i - 1][j - 1] + (a[i - 1] != b[j - 1])$    修改一个字符</p><p>选择最小的操作步数进行转移即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.size();</span><br><span class="line">        <span class="keyword">int</span> m = b.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">            dp[<span class="number">0</span>][i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = dp[i - <span class="number">1</span>][j] + <span class="number">1</span>;   <span class="comment">// 在 b[j] 后面插入一个字符 a[i]</span></span><br><span class="line">                <span class="keyword">int</span> y = dp[i][j - <span class="number">1</span>] + <span class="number">1</span>;   <span class="comment">// 在 a[i] 后面插入一个字符 b[j]</span></span><br><span class="line">                <span class="keyword">int</span> z = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + (a[i - <span class="number">1</span>] != b[j - <span class="number">1</span>]);   <span class="comment">// 修改一个字符</span></span><br><span class="line">                dp[i][j] = min(&#123;x, y, z&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二维差分</title>
      <link href="2020/10/%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86.html"/>
      <url>2020/10/%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86.html</url>
      
        <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="http://img.benboby.top/%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86.png" alt></p><p>紫色部分为所求区域，黄色区域为当前覆盖的区域。</p><p>$d[x1][y1] += w$ 表示将 $[x1, y1]$ 右下部分全部加上增量 $w$。<br><a id="more"></a> </p><p>$d[x1][y2 + 1] -= w$ 用于抵消对 $y2$ 右边元素的影响，即图三蓝色区域。</p><p>$d[x2 + 1][y1] -= w$ 用于抵消对 $x2$ 下边元素的影响，即图四蓝色区域。</p><p>$d[x2 + 1][y2 + 1] += w$ 由于绿色区域被抵消了两次，因此需要加回增量 $w$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1005</span>][<span class="number">1005</span>], d[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, m, q, x1, y1, x2, y2, w;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) <span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">  <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; w;</span><br><span class="line">    d[x1][y1] += w;</span><br><span class="line">    d[x1][y2 + <span class="number">1</span>] -= w;</span><br><span class="line">    d[x2 + <span class="number">1</span>][y1] -= w;</span><br><span class="line">    d[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += w;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">      d[i][j] -= d[i - <span class="number">1</span>][j - <span class="number">1</span>] - d[i - <span class="number">1</span>][j] - d[i][j - <span class="number">1</span>];</span><br><span class="line">      a[i][j] += d[i][j];</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RMQ算法原理及实现</title>
      <link href="2020/10/RMQ%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0.html"/>
      <url>2020/10/RMQ%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0.html</url>
      
        <content type="html"><![CDATA[<p>RMQ（Range Minimum/Maximum Query），区间最值查询问题，是指：对于长度为 $n$ 的数列A，回答若干次询问 $RMQ(i,j)$，返回数列A中下标在区间 $[i,j]$ 中的最小/大值。</p><p>这里介绍Tarjan的Sparse-Table算法，预处理时间为 $O(nlogn)$，但查询只需要 $O(1)$，并且常数很小，算法也很容易写出。</p><p>1）预处理：</p><p>　设 $A[i]$ 是要求区间最值的数列，$d[i, j]$ 表示从第i个数起连续 $2^j$ 个数中的最小值。(DP的状态)<br><a id="more"></a> </p><p>　显然 $d[i][0]$ 的值就是 $A[i]$ (DP初值)，我们把 $d[i，j]$ 平均分成两段(因为 $d[i，j]$ 一定是偶数个数字)，从 $i$ 到 $i + 2 ^ (j - 1) - 1$ 为一段，$i + 2 ^ (j - 1)$ 到 $i + 2 ^ j - 1$ 为一段(长度都为 $2 ^ (j - 1)$)。于是我们得到了状态转移方程 $d[i, j] = min(d[i，j-1], d[i + 2^(j-1)，j-1])$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RMQ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) d[i][<span class="number">0</span>] = a[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) &lt;= n; ++j)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt; n; ++i)</span><br><span class="line">      d[i][j] = min(d[i][j - <span class="number">1</span>], d[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）查询：</p><p>　假如我们需要查询的区间为 $(i,j)$ ，那么我们需要找到覆盖这个闭区间(左边界取 $i$，右边界取 $j$)的最小幂（可以重复，比如查询1，2，3，4，5，5不是2的任意次方，但我们可以查询1234和2345）。</p><p>　这个查询长度我们取范围小于等于区间长度的最大 $(2^k)$，这样我们查询 $i$ 到 $i + (2^k)$ 与 $j - (2^k) + 1$ 到 $j$ 的值，取二者最小值即可，代码实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; (k + <span class="number">1</span>)) &lt;= R - L + <span class="number">1</span>) ++k;</span><br><span class="line">  <span class="keyword">return</span> min(d[L][k], d[R - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：树中距离之和</title>
      <link href="2020/10/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%A0%91%E4%B8%AD%E8%B7%9D%E7%A6%BB%E4%B9%8B%E5%92%8C.html"/>
      <url>2020/10/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%A0%91%E4%B8%AD%E8%B7%9D%E7%A6%BB%E4%B9%8B%E5%92%8C.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个无向、连通的树。树中有 $N$ 个标记为 $0…N-1$ 的节点以及 $N-1$ 条边 。</p><p>第 $i$ 条边连接节点 $edges[i][0]$ 和 $edges[i][1]$ 。</p><p>返回一个表示节点 $i$ 与其他所有节点距离之和的列表 $res$。<br><a id="more"></a> </p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>首先只考虑查询一个点的情况，容易得到状态转移：$dp[u] = \sum_{v \in son[u]}{dp[v] + sz[v]}$。</p><p>$son[u]$ 表示 $u$ 的所有子节点，$sz[v]$ 表示以 $v$ 为根的子树大小，$dp[u]$ 表示以 $u$ 为根的子树，它的所有子节点到它的距离之和。</p><p>那么 $dp[u]$ 就是所有子节点的 $dp[v]$ + 子节点对应的子树大小个点从 $u$ 到 $v$ 的距离。</p><p>然后考虑换根，根从 $u$ 变为子节点 $v$，以 $u$ 为根的子树大小减少 $sz[v]$，$dp[u]$ 也要减去 $v$ 的贡献：</p><p>$sz[u] -= sz[v], dp[u] -= dp[v] + sz[v]$</p><p>然后 $v$ 做为根，获得了 $u$ 结点的贡献，同时以 $v$ 为根的子树大小增大 $sz[u]$：</p><p>$sz[v] += sz[u], dp[v] += dp[u] + sz[u]$</p><p>同时注意：递归在进行回溯的时候，需要恢复现场，否则在计算兄弟结点时，维护的 $dp$ 和 $sz$ 将是错误的。</p><p>需要两次dfs，时间复杂度为 $O(n)$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[<span class="number">10005</span>];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">10005</span>], sz[<span class="number">10005</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        sz[u] = <span class="number">1</span>;</span><br><span class="line">        dp[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v: g[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">            dfs1(v, u);</span><br><span class="line">            sz[u] += sz[v];</span><br><span class="line">            dp[u] += dp[v] + sz[v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        res[u] = dp[u];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v: g[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> du = dp[u], dv = dp[v];</span><br><span class="line">            <span class="keyword">int</span> su = sz[u], sv = dp[v];</span><br><span class="line">            dp[u] -= dp[v] + sz[v];</span><br><span class="line">            sz[u] -= sz[v];</span><br><span class="line">            dp[v] += dp[u] + sz[u];</span><br><span class="line">            sz[v] += sz[u];</span><br><span class="line">            dfs2(v, u);</span><br><span class="line">            dp[u] = du, dp[v] = dv;</span><br><span class="line">            sz[u] = su, sz[v] = sv;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sumOfDistancesInTree</span><span class="params">(<span class="keyword">int</span> N, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> edge: edges) &#123;</span><br><span class="line">            g[edge[<span class="number">0</span>]].push_back(edge[<span class="number">1</span>]);</span><br><span class="line">            g[edge[<span class="number">1</span>]].push_back(edge[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        res.resize(N, <span class="number">0</span>);</span><br><span class="line">        dfs1(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">        dfs2(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL学习</title>
      <link href="2020/10/%E7%BA%A2%E9%BB%91%E6%A0%91.html"/>
      <url>2020/10/%E7%BA%A2%E9%BB%91%E6%A0%91.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：小y的序列</title>
      <link href="2020/10/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%B0%8Fy%E7%9A%84%E5%BA%8F%E5%88%97.html"/>
      <url>2020/10/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%B0%8Fy%E7%9A%84%E5%BA%8F%E5%88%97.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>最少修改几个数，使得数列满足 $a[i + 1] - a[i] = i$。$(n \in [1, 1e5], a[i] \in [-1e9, 1e9])$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>先构造一个长度为 $n$ 满足题意的初始数列，然后将所给的数减去对应的初始构造的数，差值出现的次数最多的就是最长的满足题意的序列，要修改的就是剩余的那些数。<br><a id="more"></a> </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, x, p = <span class="number">0</span>, res;</span><br><span class="line">  <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; x;</span><br><span class="line">  res = mp[x] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    p += i;</span><br><span class="line">    res = max(res, ++mp[x - p]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; n - res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：Arithmetic Progressions</title>
      <link href="2020/10/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AArithmetic-Progressions.html"/>
      <url>2020/10/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AArithmetic-Progressions.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>从给定数列中能选出组成的最长等差数列长度为多少？$(n \in [1, 5000], a[i] \in [1, 1e9])$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>$dp[i][j]$ 表示 $a[i]$ 为等差数列最后一个数，$a[j]$ 为倒数第二个数。<br><a id="more"></a> </p><p>排序后二维枚举 $i$ 和 $j$，二分找到对应的下标 $k$ 使得 $a[k]+a[i]=2*a[j]$ ，直接转移 $dp[i][j] = max(dp[i][j], dp[j][k] + 1)$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, res, a[<span class="number">5005</span>], dp[<span class="number">5005</span>][<span class="number">5005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">  sort(a, a + n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="keyword">int</span> k = lower_bound(a, a + n, a[j] * <span class="number">2</span> - a[i]) - a;</span><br><span class="line">      <span class="keyword">if</span> (a[k] == a[j] * <span class="number">2</span> - a[i]) dp[i][j] = max(dp[i][j], dp[j][k] + <span class="number">1</span>);</span><br><span class="line">      res = max(res, dp[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res + <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++条款总结</title>
      <link href="2020/10/Effective-C-%E6%9D%A1%E6%AC%BE%E6%80%BB%E7%BB%93.html"/>
      <url>2020/10/Effective-C-%E6%9D%A1%E6%AC%BE%E6%80%BB%E7%BB%93.html</url>
      
        <content type="html"><![CDATA[<h2 id="尽量用-const-和-inline-而不用-define"><a href="#尽量用-const-和-inline-而不用-define" class="headerlink" title="尽量用 const 和 inline 而不用 #define"></a>尽量用 const 和 inline 而不用 #define</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VAR 1.653</span></span><br></pre></td></tr></table></figure><p>在语句进入编译器之前，就已经完成字符串替换，被预处理程序去掉，即便报错，也是 1.653 的报错信息，而不是 <strong>ASPECT_RATIO</strong>，这样容易造成混淆。因此应该定义一个常量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> ASPECT_RATIO = <span class="number">1.653</span>;</span><br></pre></td></tr></table></figure><p>另一个 define 用法是实现看起来像函数实际上又不会导致函数调用的宏：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) ((a) &gt; (b) ? (a) : (b))</span></span><br></pre></td></tr></table></figure><br>会发生以下问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>, b = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 等价于 ((++a) &gt; (b) ? (++a) : (b))</span></span><br><span class="line">max(++a, b); <span class="comment">// a 的值增加了两次</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于 ((++a) &gt; (b + 10) ? (++a) : (b + 10))</span></span><br><span class="line">max(++a, b + <span class="number">10</span>); <span class="comment">// a 的值增加了一次</span></span><br></pre></td></tr></table></figure><p>因此可以用内联函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a &gt; b ? a : b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 套用模板适用多种类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> T&amp; <span class="title">max</span><span class="params">(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> a &gt; b ? a : b; &#125;</span><br></pre></td></tr></table></figure><br>由于不知道 T 的类型，传递引用可以提高效率。</p><h2 id="尽量用-而不用"><a href="#尽量用-而不用" class="headerlink" title="尽量用  而不用 "></a>尽量用 <iostream> 而不用 <stdio.h></stdio.h></iostream></h2><ol><li><p>scanf 和 printf 不是类型安全的，而且没有拓展性。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">Rational r; <span class="comment">// r 是个有理数</span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; i &gt;&gt; r;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; r;</span><br></pre></td></tr></table></figure><p> >&gt; 和 &lt;&lt; 必须是可以处理 Rational 类型对象的重载函数(可能要通过隐式类型转换)。编译器自己可以根据不同的变量类型选择操作符的不同形式，所以不必去指定第一个要读写的对象是 int 还是 Rational。</p></li><li><p>在传递读和写的对象时采用的语法形式相同。<br> scanf 没有得到指针，必须加上地址符；而如果已经得到了指针，又要确定不要加上地址符。这样比较麻烦，而完全可以交给 C++ 编译器去做。对于 cin,cout 来说，只要重载了符号，那么读写的方式就都是一样的。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Rational(<span class="keyword">int</span> numerator = <span class="number">0</span>, <span class="keyword">int</span> denominator = <span class="number">1</span>);</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n, d; <span class="comment">// 分子，分母</span></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; s, <span class="keyword">const</span> Rational&amp; r);</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; s, <span class="keyword">const</span> Rational&amp; r)</span><br><span class="line">&#123;</span><br><span class="line">    s &lt;&lt; r.n &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; r.d;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尽量用-new-和-delete-而不用-malloc-和-free"><a href="#尽量用-new-和-delete-而不用-malloc-和-free" class="headerlink" title="尽量用 new 和 delete 而不用 malloc 和 free"></a>尽量用 new 和 delete 而不用 malloc 和 free</h2><p>malloc 和 free <strong>不会</strong>调用构造和析构函数。<br>假设用两种方法给一个包含 10 个 string 对象的数组分配空间，一个用 malloc，另一个用  new：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *stringArray1 = <span class="keyword">static_cast</span>&lt;<span class="built_in">string</span>*&gt;(<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="built_in">string</span>)));</span><br><span class="line"><span class="built_in">string</span> *stringArray2 = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">free</span>(stringArray1);</span><br><span class="line"><span class="keyword">delete</span> [] stringArray2;</span><br></pre></td></tr></table></figure><p>其结果是，stringArray1 确实指向的是可以容纳 10 个 string 对象的足够空<br>间，但内存里并没有创建这些对象，只是简单的分配内存。相反，stringArray2 指向的是一个<br>包含 10 个完全构造好的 string 对象的数组,每个对象可以在任何读取 string 的<br>操作里安全使用。</p></li></ol><p>同时需要注意，如果不加 []，那么只会销毁一个对象，剩下的9个不能被正确的销毁，因为他们的析构函数永远不会被调用。只要你没有正确的使用 delete，那么结果就是不可预测的。</p><p>如果用 new 创建了一个 typedef 定义的类型的对象后，应该说明用什么形式的 delete 来删除。为了避免混乱，最好杜绝对数组类型用 typedef，毕竟 C++ 有 stirng 和 vector 模板，使用他们将会使对数组的需求减少到几乎零。</p><h2 id="析构函数里对指针成员调用-delete"><a href="#析构函数里对指针成员调用-delete" class="headerlink" title="析构函数里对指针成员调用 delete"></a>析构函数里对指针成员调用 delete</h2><p>增加一个指针成员意味着几乎都要进行下面的工作：</p><ul><li>在每个构造函数里对指针进行初始化。对于一些构造函数，如果没有内存要分配给指针的话，指针要被初始化为 0(即空指针)。</li><li>删除现有的内存，通过赋值操作符分配给指针新的内存。</li><li>在析构函数里删除指针。</li></ul><p><strong>除非类成员最初用了 new，否则是不用在析构函数里用 delete 的。</strong></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：Medians and Partition</title>
      <link href="2020/10/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AMedians-and-Partition.html"/>
      <url>2020/10/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AMedians-and-Partition.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>最多可以把数组分成几个部分，使得每部分中位数都大于等于$m$。$(n,m,a[i] \in [1,5000])$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>思维题，可以发现答案就是大于等于 $m$ 的个数减去小于 $m$ 的个数。<br><a id="more"></a> </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, x, s1 = <span class="number">0</span>, s2 = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= m)</span><br><span class="line">            s1++;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            s2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; max(<span class="number">0</span>, s1 - s1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客国庆集训day1</title>
      <link href="2020/10/%E7%89%9B%E5%AE%A2%E5%9B%BD%E5%BA%86%E9%9B%86%E8%AE%ADday1.html"/>
      <url>2020/10/%E7%89%9B%E5%AE%A2%E5%9B%BD%E5%BA%86%E9%9B%86%E8%AE%ADday1.html</url>
      
        <content type="html"><![CDATA[<h2 id="A-ABB"><a href="#A-ABB" class="headerlink" title="A. ABB"></a>A. ABB</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>在给定的字符串后面最少添加多少个字符可以让整个字符串变成一个回文字符串$(n \in [1, 4e5])$。</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><a id="more"></a> <p>等价于求包含最后一个字符的最长回文子串，可以用前后遍历两次哈希解决。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> ull base = <span class="number">13331</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, len, res;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line">ull r, l[N], b[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;n, s + <span class="number">1</span>);</span><br><span class="line">  b[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) b[i] = b[i - <span class="number">1</span>] * base;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) l[i] = l[i - <span class="number">1</span>] * base + s[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">    r = r * base + s[i];</span><br><span class="line">    len++;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= len) &#123;</span><br><span class="line">      ull now1 = l[i] - l[i - len] * b[len];</span><br><span class="line">      <span class="keyword">if</span> (now1 == r) res = max(res, len * <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= len + <span class="number">1</span>) &#123;</span><br><span class="line">      ull now2 = l[i - <span class="number">1</span>] - l[i - <span class="number">1</span> - len] * b[len];</span><br><span class="line">      <span class="keyword">if</span> (now2 == r) res = max(res, len * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n - res);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Bob-in-Wonderland"><a href="#C-Bob-in-Wonderland" class="headerlink" title="C. Bob in Wonderland"></a>C. Bob in Wonderland</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>把一棵树变为一条链的最少操作次数$(n \in [1, 3e5])$。</p><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>其实就是不断把度大于2的点转移到头或者尾，因此答案就是所有度数大于2的点减去2的和。</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, x, y, res, d[<span class="number">500005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">    d[x]++;</span><br><span class="line">    d[y]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res += max(d[i] - <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-Zeldain-Garden"><a href="#E-Zeldain-Garden" class="headerlink" title="E. Zeldain Garden"></a>E. Zeldain Garden</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>求给定区间内所有数的因子个数和$(n \in [1, 1e12])$。</p><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>打表发现 $1-n$ 内因子个数和就是 $n / i$ 的和 $(i \in [1, n])$，然后用除法分块解决。</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">  ll sum = n;</span><br><span class="line">  <span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt;= n;) &#123;</span><br><span class="line">    ll x = n / i;</span><br><span class="line">    ll y = min(n / x, n);</span><br><span class="line">    sum += x * (y - i + <span class="number">1</span>);</span><br><span class="line">    i = y + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll a, b;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; solve(b) - solve(a - <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-Light-Emitting-Hindenburg"><a href="#F-Light-Emitting-Hindenburg" class="headerlink" title="F. Light Emitting Hindenburg"></a>F. Light Emitting Hindenburg</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>从 $n$ 个正整数中选出k个数字使得进行按位与操作得到的结果最大$(n \in [1, 2e5])$。</p><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>考虑二进制位，当且仅当 $k$ 个数字该位都为1，位与结果才为1。因此从高位开始枚举二进制位，当该位为1的数量超过 $k$ 时，剔除所有不为1的数，最后剩下的数即为可以选择的数，且这些数无论怎么选择 $k$ 个，位与结果都相同。</p><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, a[N], vis[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((a[j] &gt;&gt; i) &amp; <span class="number">1</span> &amp;&amp; !vis[j]) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt &gt;= k) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!((a[j] &gt;&gt; i) &amp; <span class="number">1</span>)) vis[j] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[i]) res &amp;= a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="H-Ponk-Warshall"><a href="#H-Ponk-Warshall" class="headerlink" title="H. Ponk Warshall"></a>H. Ponk Warshall</h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>两个字符串s, t仅包含ATCG，求s最少经过多少次交换可以变为t$(n \in [1, 1e6])$。</p><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><p>按四种优先级讨论：</p><ol><li>同一个位置字符相同，直接跳过无需交换。</li><li>交换一次，使得两个字符直接匹配。</li><li>交换两次，使得三个字符直接匹配。</li><li>交换三次，使得四个字符直接匹配。</li></ol><p>数组 $cnt[i][j]$ 表示每个字符的对应关系，按优先级计算累加答案即可。</p><h3 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, res, mp[<span class="number">200</span>], cnt[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> s, t;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; s &gt;&gt; t;</span><br><span class="line">  n = s.size();</span><br><span class="line">  mp[<span class="string">&#x27;A&#x27;</span>] = <span class="number">0</span>, mp[<span class="string">&#x27;T&#x27;</span>] = <span class="number">1</span>, mp[<span class="string">&#x27;C&#x27;</span>] = <span class="number">2</span>, mp[<span class="string">&#x27;G&#x27;</span>] = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s[i] != t[i]) cnt[mp[s[i]]][mp[t[i]]]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="keyword">int</span> x = min(cnt[i][j], cnt[j][i]);</span><br><span class="line">      res += x;</span><br><span class="line">      cnt[i][j] -= x, cnt[j][i] -= x;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; j; k++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = min(cnt[i][j], min(cnt[j][k], cnt[k][i]));</span><br><span class="line">        <span class="keyword">int</span> y = min(cnt[i][k], min(cnt[k][j], cnt[j][i]));</span><br><span class="line">        res += (x + y) * <span class="number">2</span>;</span><br><span class="line">        cnt[i][j] -= x, cnt[j][k] -= x, cnt[k][i] -= x;</span><br><span class="line">        cnt[i][k] -= y, cnt[k][j] -= y, cnt[j][i] -= y;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) res += cnt[<span class="number">0</span>][i] * <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 多校训练 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多校训练 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：不相交线段的最小最大值</title>
      <link href="2020/09/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%BA%BF%E6%AE%B5%E7%9A%84%E6%9C%80%E5%B0%8F%E6%9C%80%E5%A4%A7%E5%80%BC.html"/>
      <url>2020/09/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%BA%BF%E6%AE%B5%E7%9A%84%E6%9C%80%E5%B0%8F%E6%9C%80%E5%A4%A7%E5%80%BC.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>在一维数轴上给出 $m$ 个线段，每个线段都都有 $l,r,w$ 三个数据代表这个线段的左右端点和这个区间权值。 从中取出若干个不相交的线段(区间端点可以共用)，在覆盖满 $[1,n]$ 的情况下，取出的线段中 $权重的最大值]$ 最小能为多少？</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>$dp[i]$ 代表覆盖满 $[1,i]$ 最大权值最小为多少，然后按左端点从小到大枚举线段，就有 $dp[r_i]=min(dp[r_i],max(dp[l_i],w_i))$。<br><a id="more"></a> </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> l, r;</span><br><span class="line">  ll w;</span><br><span class="line">&#125; q[<span class="number">200005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node x, Node y)</span> </span>&#123; <span class="keyword">return</span> x.l &lt; y.l; &#125;</span><br><span class="line"></span><br><span class="line">ll dp[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, m;</span><br><span class="line">  <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>, &amp;q[i].l, &amp;q[i].r, &amp;q[i].w);</span><br><span class="line">    sort(q + <span class="number">1</span>, q + m + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) dp[i] = <span class="number">1e18</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">      dp[q[i].r] = min(dp[q[i].r], max(dp[q[i].l], q[i].w));</span><br><span class="line">    <span class="keyword">if</span> (dp[n] == <span class="number">1e18</span>)</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;invalid data&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, dp[n]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：连通两组点的最小成本</title>
      <link href="2020/09/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%BF%9E%E9%80%9A%E4%B8%A4%E7%BB%84%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E6%88%90%E6%9C%AC.html"/>
      <url>2020/09/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%BF%9E%E9%80%9A%E4%B8%A4%E7%BB%84%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E6%88%90%E6%9C%AC.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你两组点，其中第一组中有 $size1$ 个点，第二组中有 $size2$ 个点，且 $size1 &gt;= size2$。</p><p>任意两点间的连接成本 $cost$ 由大小为 size1 x size2 矩阵给出，其中 $cost[i][j]$ 是第一组中的点 $i$ 和第二组中的点 $j$ 的连接成本。如果两个组中的每个点都与另一组中的一个或多个点连接，则称这两组点是连通的。换言之，第一组中的每个点必须至少与第二组中的一个点连接，且第二组中的每个点必须至少与第一组中的一个点连接。</p><p>返回连通两组点所需的最小成本。<br><a id="more"></a> </p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>$dp[i][j]$ 表示左部前 $i$ 个点连接右部(1&lt;&lt;m)的情况，状态转移方程：dp[i][now | 1 &lt;&lt; j] = min({dp<a href="当前状态">now | 1 &lt;&lt; j</a>, dp[i - 1][j] + cost[i - 1]<a href="前i-1个状态(当前点没连接任何点">j</a> + 当前点连接右边第j个点}, dp[i][j] + cost[i - 1]<a href="前i个状态(当前点可能之前连接了别的点">j</a> + 当前点连接右边第j个点))。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">connectTwoGroups</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cost.size();</span><br><span class="line">        <span class="keyword">int</span> m = cost.get(<span class="number">0</span>).size();</span><br><span class="line">        <span class="keyword">int</span> all = <span class="number">1</span> &lt;&lt; m;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][all];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i], <span class="number">2000000000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> now = <span class="number">0</span>; now &lt; all; now++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                    dp[i][now | <span class="number">1</span> &lt;&lt; j] = Math.min(dp[i][now | <span class="number">1</span> &lt;&lt; j], Math.min(dp[i - <span class="number">1</span>][now] + cost.get(i - <span class="number">1</span>).get(j), dp[i][now] + cost.get(i - <span class="number">1</span>).get(j)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][all - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状压dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统知识点</title>
      <link href="2020/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9.html"/>
      <url>2020/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9.html</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>操作系统</strong>（Operating System，OS）是指控制系统和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户其他软件方便的接口和环境，它是计算机系统中最基本的<strong>系统软件</strong>。</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>一个程序的执行过程。执行前<strong>需要将该程序放到内存中</strong>，才能被CPU处理。</p><h2 id="功能和目标"><a href="#功能和目标" class="headerlink" title="功能和目标"></a>功能和目标</h2><a id="more"></a> <h3 id="作为系统资源的管理者"><a href="#作为系统资源的管理者" class="headerlink" title="作为系统资源的管理者"></a>作为系统资源的管理者</h3><p><img src="http://img.benboby.top/%E5%8A%9F%E8%83%BD%E5%92%8C%E7%9B%AE%E6%A0%87.png" alt></p><ol><li><p>进程管理<br> 进程控制、进程同步、进程通信、死锁处理、处理机调度等。</p></li><li><p>内存管理<br> 内存分配、地址映射、内存保护与共享、虚拟内存等。</p></li><li><p>文件管理<br> 文件存储空间的管理、目录管理、文件读写管理和保护等。</p></li><li><p>设备管理<br> 完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。<br> 主要包括缓冲管理、设备分配、设备处理、虛拟设备等。</p></li></ol><ul><li>找到QQ的安装位置  逐层打开文件夹，找到QQ的存放位置  -&gt;  文件管理</li><li>双击打开QQ程序  把程序相关数据放入内存  -&gt;  存储器管理（内存管理）</li><li>程序正常运行  对应的进程被处理机处理（CPU）  -&gt;  处理机管理</li><li>开始和朋友视频聊天  需要将摄像头设备分配给进程  -&gt;  设备管理</li></ul><h3 id="作为用户和计算机硬件之间的接口"><a href="#作为用户和计算机硬件之间的接口" class="headerlink" title="作为用户和计算机硬件之间的接口"></a>作为用户和计算机硬件之间的接口</h3><p><img src="http://img.benboby.top/%E6%8E%A5%E5%8F%A3%E5%8A%9F%E8%83%BD%E5%92%8C%E7%9B%AE%E6%A0%87.png" alt></p><ol><li>命令接口：允许用户直接使用</li><li>程序接口：允许用户通过程序间接使用</li><li>GUI：现代操作系统中最流行的图形用户接口</li></ol><h3 id="作为最接近硬件的层次-——-实现对硬件机器的拓展"><a href="#作为最接近硬件的层次-——-实现对硬件机器的拓展" class="headerlink" title="作为最接近硬件的层次 —— 实现对硬件机器的拓展"></a>作为最接近硬件的层次 —— 实现对硬件机器的拓展</h3><p>通常把覆盖了软件的机器称为<strong>扩充机器</strong>，又称之为<strong>虚拟机</strong>。</p><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>指两个或多个事件在同一时间间隔内发生。这些事件<strong>宏观上是同时发生</strong>，但<strong>微观上是交替发生</strong>。</p><p><strong>区别于并行：同一时刻同时进行两个约会任务</strong></p><p><strong>操作系统的并发性指计算机系统中同时存在着多个运行着的程序。</strong></p><p>一个单核处理机（CPU）同一时刻只能执行一个程序，因此操作系统会负责协调多个程序交替执行。<strong>操作系统和程序并发是一起诞生的。</strong></p><h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><p>共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。</p><p><img src="http://img.benboby.top/%E4%B8%A4%E7%A7%8D%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F.png" alt></p><p>生活实例：<br>互斥共享方式：使用QQ和微信视频，同一时间段内摄像头只能分配给其中一个进程。<br>同时共享方式：使用QQ发送文件A，同时使用微信发送文件B。宏观上看，两边都在同时读取并发送文件，说明两个进程都在访问硬盘资源，从中读取数据。从微观上看，两个进程是交替着访问硬盘的。</p><ul><li><p>并发和共享的关系<br>  <strong>并发性</strong>指计算机系统中同时存在多个运行着的程序。<br>  <strong>共享性</strong>指系统中的资源可供内存中多个并发执行的进程共同使用。</p><p>  使用QQ发送文件A，同时使用微信发送文件B：</p><ol><li>两个进程正在并发执行（并发性）</li><li>需要共享地访问硬盘资源（共享性）</li></ol></li></ul><h3 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h3><p><strong>虚拟</strong>是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。</p><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p><strong>异步</strong>是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</p><p><strong>只有系统拥有并发性，才有可能导致异步性。</strong></p><h2 id="大内核和微内核"><a href="#大内核和微内核" class="headerlink" title="大内核和微内核"></a>大内核和微内核</h2><ol><li><p>大内核<br> 大内核是将操作系统功能作为一个紧密结合的整体放到内核。<br> 由于各模块共享信息，因此有很高的性能。</p></li><li><p>微内核<br> 由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。</p><p> 在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。</p><p> 因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。</p></li></ol><h2 id="中断机制"><a href="#中断机制" class="headerlink" title="中断机制"></a>中断机制</h2><p>为了解决串行导致效率，利用率低的问题，引入了中断机制，实现了多道程序并发执行。<br><strong>本质：发生中断就意味着需要操作系统介入，开展管理工作</strong></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础</title>
      <link href="2020/09/MySQL%E5%9F%BA%E7%A1%80.html"/>
      <url>2020/09/MySQL%E5%9F%BA%E7%A1%80.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java常量池</title>
      <link href="2020/09/Java%E5%B8%B8%E9%87%8F%E6%B1%A0.html"/>
      <url>2020/09/Java%E5%B8%B8%E9%87%8F%E6%B1%A0.html</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="什么是常量"><a href="#什么是常量" class="headerlink" title="什么是常量"></a>什么是常量</h3><p>用final修饰的成员变量表示常量，值一旦给定就无法改变！</p><p>final修饰的变量有三种：<strong>静态变量</strong>、<strong>实例变量</strong>和<strong>局部变量</strong>，分别表示三种类型的常量。</p><h3 id="Class文件中的常量池"><a href="#Class文件中的常量池" class="headerlink" title="Class文件中的常量池"></a>Class文件中的常量池</h3><p>在Class文件结构中，最头的4个字节用于存储魔数Magic Number，用于确定一个文件是否能被JVM接受，再接着4个字节用于存储版本号，前2个字节存储次版本号，后2个存储主版本号，再接着是用于存放常量的常量池，由于常量的数量是不固定的，所以常量池的入口放置一个U2类型的数据(constant_pool_count)存储常量池容量计数值。<br><a id="more"></a> </p><p>常量池主要用于存放两大类常量：字面量(Literal)和符号引用量(Symbolic References)，字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等，符号引用则属于编译原理方面的概念，包括了如下三种类型的常量：<strong>类和接口的全限定名</strong>，<strong>字段名称和描述符</strong>，<strong>方法名称和描述符</strong>。</p><h3 id="方法区中的运行时常量池"><a href="#方法区中的运行时常量池" class="headerlink" title="方法区中的运行时常量池"></a>方法区中的运行时常量池</h3><p>运行时常量池是方法区的一部分。</p><p>CLass文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p><p>运行时常量池相对于CLass文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入CLass文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是String类的intern()方法。</p><h3 id="常量池的好处"><a href="#常量池的好处" class="headerlink" title="常量池的好处"></a>常量池的好处</h3><p>常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。</p><p>例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。<br>（1）节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。<br>（2）节省运行时间：比较字符串时，== 比 equals()快。对于两个引用变量，只用 == 判断引用是否相等，也就可以判断实际值是否相等。</p><h3 id="双等号-的含义"><a href="#双等号-的含义" class="headerlink" title="双等号==的含义"></a>双等号==的含义</h3><p><strong>基本数据类型</strong>之间应用双等号，比较的是他们的<strong>数值</strong>。</p><p><strong>复合数据类型(类)</strong>之间应用双等号，比较的是他们在<strong>内存中的存放地址</strong>。</p><h2 id="8种基本类型的包装类和常量池"><a href="#8种基本类型的包装类和常量池" class="headerlink" title="8种基本类型的包装类和常量池"></a>8种基本类型的包装类和常量池</h2><p>java中基本类型的包装类的大部分都实现了常量池技术，即Byte,Short,Integer,Long,Character,Boolean；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;</span><br><span class="line">Integer i2 = <span class="number">40</span>;</span><br><span class="line">System.out.println(i1==i2);<span class="comment">//输出TRUE</span></span><br></pre></td></tr></table></figure><p>这5种包装类默认创建了数值[-128，127]的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Integer 缓存代码 ：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">     <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">         <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">400</span>;</span><br><span class="line">Integer i2 = <span class="number">400</span>;</span><br><span class="line">System.out.println(i1==i2);<span class="comment">//输出false</span></span><br></pre></td></tr></table></figure><p>两种浮点数类型的包装类Float,Double并没有实现常量池技术。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Double i1=<span class="number">1.2</span>;</span><br><span class="line">Double i2=<span class="number">1.2</span>;</span><br><span class="line">System.out.println(i1==i2);<span class="comment">//输出false</span></span><br></pre></td></tr></table></figure><h3 id="应用常量池的场景"><a href="#应用常量池的场景" class="headerlink" title="应用常量池的场景"></a>应用常量池的场景</h3><ol><li><p>Integer i1=40; Java在编译的时候会直接将代码封装成 Integer i1=Integer.valueOf(40);，从而使用常量池中的对象。</p></li><li><p>Integer i1 = new Integer(40); 这种情况下会创建新的对象。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;</span><br><span class="line">Integer i2 = <span class="number">40</span>;</span><br><span class="line">Integer i3 = <span class="number">0</span>;</span><br><span class="line">Integer i4 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i5 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i6 = <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;i1=i2   &quot;</span> + (i1 == i2));</span><br><span class="line">System.out.println(<span class="string">&quot;i1=i2+i3   &quot;</span> + (i1 == i2 + i3));</span><br><span class="line">System.out.println(<span class="string">&quot;i1=i4   &quot;</span> + (i1 == i4));</span><br><span class="line">System.out.println(<span class="string">&quot;i4=i5   &quot;</span> + (i4 == i5));</span><br><span class="line">System.out.println(<span class="string">&quot;i4=i5+i6   &quot;</span> + (i4 == i5 + i6));</span><br><span class="line">System.out.println(<span class="string">&quot;40=i5+i6   &quot;</span> + (<span class="number">40</span> == i5 + i6));</span><br><span class="line"></span><br><span class="line">i1=i2   <span class="keyword">true</span></span><br><span class="line">i1=i2+i3   <span class="keyword">true</span></span><br><span class="line">i1=i4   <span class="keyword">false</span></span><br><span class="line">i4=i5   <span class="keyword">false</span></span><br><span class="line">i4=i5+i6   <span class="keyword">true</span></span><br><span class="line"><span class="number">40</span>=i5+i6   <span class="keyword">true</span></span><br></pre></td></tr></table></figure><p> 解释：语句i4 == i5 + i6，因为 + 这个操作符不适用于Integer对象，首先 i5 和 i6 进行自动拆箱操作，进行数值相加，即i4 == 40。然后Integer对象无法与数值进行直接比较，所以i4自动拆箱转为int值40，最终这条语句转为40 == 40进行数值比较。</p></li></ol><h2 id="String类和常量池"><a href="#String类和常量池" class="headerlink" title="String类和常量池"></a>String类和常量池</h2><h3 id="String对象创建方式"><a href="#String对象创建方式" class="headerlink" title="String对象创建方式"></a>String对象创建方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">System.out.println(str1==str2);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>这两种不同的创建方法是有差别的，第一种方式是在常量池中拿对象，第二种方式是直接在堆内存空间创建一个新的对象。<br>只要使用new方法，便需要创建新的对象。</p><h3 id="连接表达式"><a href="#连接表达式" class="headerlink" title="连接表达式 +"></a>连接表达式 +</h3><ol><li>只有使用引号包含文本的方式创建的String对象之间使用“+”连接产生的新对象才会被加入字符串池中。</li><li>对于所有包含new方式新建对象（包括null）的“+”连接表达式，它所产生的新对象都不会被加入字符串池中。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;str&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"></span><br><span class="line">String str3 = <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;</span><br><span class="line">String str4 = str1 + str2;</span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">String str5 = <span class="string">&quot;string&quot;</span>;</span><br><span class="line">System.out.println(str3 == str5);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>特例1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String A = <span class="string">&quot;ab&quot;</span>; <span class="comment">// 常量A</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String B = <span class="string">&quot;cd&quot;</span>; <span class="comment">// 常量B</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String s = A + B;  <span class="comment">// 将两个常量用+连接对s进行初始化</span></span><br><span class="line">String t = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (s == t) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;s等于t，它们是同一个对象&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;s不等于t，它们不是同一个对象&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// s等于t，它们是同一个对象</span></span><br></pre></td></tr></table></figure><p>A和B都是常量，值是固定的，因此s的值也是固定的，它在类被编译时就已经确定了。也就是说：String s = A + B; 等同于：String s = ”ab” + ”cd”;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String A; <span class="comment">// 常量A</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String B; <span class="comment">// 常量B</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    A = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    B = <span class="string">&quot;cd&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将两个常量用+连接对s进行初始化</span></span><br><span class="line">    String s = A + B;</span><br><span class="line">    String t = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (s == t) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;s等于t，它们是同一个对象&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;s不等于t，它们不是同一个对象&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// s不等于t，它们不是同一个对象</span></span><br></pre></td></tr></table></figure><p>A和B虽然被定义为常量，但是它们都没有马上被赋值。在运算出s的值之前，他们何时被赋值，以及被赋予什么样的值，都是个变数。因此A和B在被赋值之前，性质类似于一个变量。那么s就不能在编译期被确定，而只能在运行时被创建了。</p><h3 id="String-s1-new-String-“xyz”-创建了几个对象？"><a href="#String-s1-new-String-“xyz”-创建了几个对象？" class="headerlink" title="String s1 = new String(“xyz”); 创建了几个对象？"></a>String s1 = new String(“xyz”); 创建了几个对象？</h3><p>考虑类加载阶段和实际执行时。</p><ol><li><p>类加载对一个类只会进行一次。”xyz”在类加载时就已经创建并驻留了（如果该类被加载之前已经有”xyz”字符串被驻留过则不需要重复创建用于驻留的”xyz”实例）。驻留的字符串是放在全局共享的字符串常量池中的。</p></li><li><p>在这段代码后续被运行的时候，”xyz”字面量对应的String实例已经固定了，不会再被重复创建。所以这段代码将常量池中的对象复制一份放到heap中，并且把heap中的这个对象的引用交给 s1 持有。</p></li></ol><p>这条语句创建了2个对象。</p><h3 id="java-lang-String-intern"><a href="#java-lang-String-intern" class="headerlink" title="java.lang.String.intern()"></a>java.lang.String.intern()</h3><p>运行时常量池相对于CLass文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入CLass文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是String类的intern()方法。</p><p>String的intern()方法会查找在常量池中是否存在一份equal相等的字符串,如果有则返回该字符串的引用,如果没有则添加自己的字符串进入常量池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   String s1 = <span class="keyword">new</span> String(<span class="string">&quot;计算机&quot;</span>);</span><br><span class="line">   String s2 = s1.intern();</span><br><span class="line">   String s3 = <span class="string">&quot;计算机&quot;</span>;</span><br><span class="line">   System.out.println(<span class="string">&quot;s1 == s2? &quot;</span> + (s1 == s2));</span><br><span class="line">   System.out.println(<span class="string">&quot;s3 == s2? &quot;</span> + (s3 == s2));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// s1 == s2? false</span></span><br><span class="line"><span class="comment">// s3 == s2? true</span></span><br></pre></td></tr></table></figure><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   String hello = <span class="string">&quot;Hello&quot;</span>, lo = <span class="string">&quot;lo&quot;</span>;</span><br><span class="line">   System.out.println((hello == <span class="string">&quot;Hello&quot;</span>) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">   System.out.println((Other.hello == hello) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">   System.out.println((other.Other.hello == hello) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">   System.out.println((hello == (<span class="string">&quot;Hel&quot;</span>+<span class="string">&quot;lo&quot;</span>)) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">   System.out.println((hello == (<span class="string">&quot;Hel&quot;</span>+lo)) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">   System.out.println(hello == (<span class="string">&quot;Hel&quot;</span>+lo).intern());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Other</span> </span>&#123; <span class="keyword">static</span> String hello = <span class="string">&quot;Hello&quot;</span>; &#125;</span><br><span class="line"><span class="keyword">package</span> other;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Other</span> </span>&#123; <span class="keyword">public</span> <span class="keyword">static</span> String hello = <span class="string">&quot;Hello&quot;</span>; &#125;</span><br><span class="line"><span class="comment">// true true true true false true</span></span><br></pre></td></tr></table></figure><p>在同包同类下，引用自同一String对象。</p><p>在同包不同类下，引用自同一String对象。</p><p>在不同包不同类下，依然引用自同一String对象。</p><p>在编译成.class时能够识别为同一字符串的，自动优化成常量，引用自同一String对象。</p><p>在运行时创建的字符串具有独立的内存地址，所以不引用自同一String对象。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMakeLists的编写</title>
      <link href="2020/09/CMakeLists%E7%9A%84%E7%BC%96%E5%86%99.html"/>
      <url>2020/09/CMakeLists%E7%9A%84%E7%BC%96%E5%86%99.html</url>
      
        <content type="html"><![CDATA[<h2 id="CMake简介："><a href="#CMake简介：" class="headerlink" title="CMake简介："></a><strong>CMake简介：</strong></h2><p>CMake是一种跨平台的开源项目管理工具，所做的事其实就是告诉编译器如何去编译链接源代码。与之相似的是直接编写makefile文件，但makefile最大的缺点就是不能跨平台，一旦更换环境就要重新编写，于是我们可以使用CMake编写CMakeLists文件来解决此问题。</p><h2 id="检查是否安装CMake"><a href="#检查是否安装CMake" class="headerlink" title="检查是否安装CMake"></a>检查是否安装CMake</h2><p>首先检查是否安装CMake，在终端输入cmake —version来检查，若显示未安装，可以使用sudo apt-get install camke ( ubuntu)，或者brew install cmake (macos)，windows直接去官网下载，来安装CMake。</p><a id="more"></a> <h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#cmake最小版本需求</span></span><br><span class="line">cmake_minimum_required(VERSION xxx)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置此项目的名称</span></span><br><span class="line">project(xxx)</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成可执行文件target ，后面填写的是生成此可执行文件所依赖的源文件列表。</span></span><br><span class="line">add_executable(target target_source_codes)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置一个名字var_name 的变量，同时给此变量赋值为var_value</span></span><br><span class="line">SET(var_name var_value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定编译器</span></span><br><span class="line"><span class="comment"># CMAKE_C_FLAGS_DEBUG          ----  C 编译器</span></span><br><span class="line"><span class="comment"># CMAKE_CXX_FLAGS_DEBUG        ----  C++ 编译器</span></span><br><span class="line"><span class="comment"># -std=c++11  使用 C++11</span></span><br><span class="line"><span class="comment"># -g：只是编译器，在编译的时候，产生调试信息。</span></span><br><span class="line"><span class="comment"># -Wall：生成所有警告信息。一下是具体的选项，可以单独使用</span></span><br><span class="line"><span class="built_in">set</span> (CMAKE_CXX_FLAGS &amp;quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++<span class="number">11</span>   -g  -wall  &amp;quot;)</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定编译类型，debug 或者为 release</span></span><br><span class="line"><span class="comment"># debug 会生成相关调试信息，可以使用 GDB 进行</span></span><br><span class="line"><span class="comment"># release 不会生成调试信息。当无法进行调试时查看此处是否设置为 debug.</span></span><br><span class="line"><span class="built_in">set</span>(CMAKE_BUILD_TYPE Debug)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印消息</span></span><br><span class="line">MESSAGE(&amp;quot;MSG&amp;quot;)</span><br><span class="line"></span><br><span class="line"><span class="comment">#给变量var_name赋值为var_value，comment是此变量的注释，和SET 有类似的功效，用于给某变量设置默认值</span></span><br><span class="line">option(var_name &amp;quot;comment&amp;quot; var_value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加include路径，也就是头文件路径</span></span><br><span class="line">include_directories(xxx)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用xxx子目录的CMakeLists.txt执行</span></span><br><span class="line">add_subdirectory(xxx)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给编译器添加xxx参数</span></span><br><span class="line">add_compile_options(xxx)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给编译器添加库目录，</span></span><br><span class="line">link_directories(xxx)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成库文件，SHARED代表动态库，STATIC代表静态库， 最后一个参数代表此库的源文件列表</span></span><br><span class="line">add_library(lib_name SHARED <span class="keyword">or</span> STATIC lib_source_code)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给目标添加依赖库</span></span><br><span class="line">target_link_libraries(target_name lib_name ...)</span><br></pre></td></tr></table></figure><h2 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h2><p>下图是一般的项目文件格式，include 存放头文件，src存放源代码文件，build存放临时编译文件。<br><img src="https://uploadfiles.nowcoder.com/files/20200501/391840006_1588307113197_20200407144630731.png" alt><br>假设工程文件夹名为Test，我们可以将CMakeLists.txt文件放在Test文件夹下，也就是src，include的同级目录下，以下是简单的CMakeLists文件编写格式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最低指定的CMake版本</span></span><br><span class="line">cmake_minimum_required(VERSION <span class="number">3.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 括号里面填你的工程名</span></span><br><span class="line">PROJECT(Test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 头文件路径</span></span><br><span class="line">INCLUDE_DIRECTORIES(include)</span><br><span class="line">INCLUDE_DIRECTORIES(/usr/local/include/)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找src下的所有cpp文件，然后将结果存进指定变量名(这里是DIR_SRCS)</span></span><br><span class="line">AUX_SOURCE_DIRECTORY(src DIR_SRCS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定语言要求，以下命令为c++ 11</span></span><br><span class="line">SET(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成可执行文件，生成的test即为可执行文件</span></span><br><span class="line">add_executable(test $&#123;DIR_SRCS&#125;)</span><br></pre></td></tr></table></figure><p>由于该过程中会产生很多中间文件，因此我们在build文件夹下使用cmake命令，这样这些文件就都放在build文件夹下，然后make运行就好：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">./test</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Makefile </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式：策略模式</title>
      <link href="2020/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.html"/>
      <url>2020/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.html</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>定义一种算法，将每个算法都封装起来，并且使它们之间可以互换。是一种行为类模式。</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>为了通俗易懂，我们拿各国的税率计算来举例子：</p><p>假设当前我们的程序只能支持计算中国和美国的税率：<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tax_Cal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CN_Cal</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;       <span class="comment">// 计算中国税</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">US_Cal</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;       <span class="comment">// 计算美国税</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样写看起来没什么问题，但实际上我们想想，如果以后公司还要拓展，开始支持法国，日本等等国家，那么我们这个类就得不断但改啊改，是不是特别麻烦且危险？比如万一和前面的某个国家冲突了，就会影响到前面的计算。</p><p>所以我们干脆分开来写，把所有的国家税的计算都独立出来，实现的都是同一个接口，都有一个共同的参数x。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Strategy</span> </span>&#123;          <span class="comment">// 策略模式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Cal</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CN_Tax</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;     <span class="comment">// 实现中国税计算接口</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Cal</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">US_Tax</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;     <span class="comment">// 实现美国税计算接口</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@jOverride</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Cal</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tax_Cal</span> </span>&#123;            <span class="comment">// 税计算类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Strategy = strategy;         <span class="comment">// 定义一个策略</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStrategy</span><span class="params">(Strategy strategy)</span> </span>&#123;     <span class="comment">// 接入策略</span></span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTax</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;      <span class="comment">// 得到结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.strategy.cal</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，所有的税务计算就互不影响啦，因为它们的计算已经被我们独立出来了，要计算哪一个国家的税，只需要接入该国家的算法，调用一下getTax就可以了。我们来写一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(string[] args)</span> </span>&#123;</span><br><span class="line">        Tax_Cal tax_cal = <span class="keyword">new</span> Tax_Cal();       <span class="comment">// 实例化对象</span></span><br><span class="line">        tax_cal.setStrategy(<span class="keyword">new</span> CN_Tax());     <span class="comment">// 接入中国税计算</span></span><br><span class="line">        <span class="keyword">int</span> res = tax_cal.getTax(<span class="number">100</span>);       <span class="comment">// 得到结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就实现了中国的税计算。由此可见，这样设计是更有策略性的，以后要有新的国家加入，不需要再修改原代码，只需要再实现一个新的国家接口就可以了。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>优点：</p><ol><li>策略间可以自由的切换，因为它们都实现自同一个抽象。</li><li>易于拓展，基本上可以在不改变原有代码的基础上进行拓展。</li><li>避免使用多重条件语句，否则就得一直if else, switch case，这样非常不利于维护。</li></ol><p>策略模式是一种简单常用的设计模式，一般来说不会单独使用，而是和其它模式混合使用。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式：单例模式</title>
      <link href="2020/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html"/>
      <url>2020/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h2><p>单例模式，顾名思义，就是整个系统就只有一个实例存在。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>单例类只能有一个实例。</li><li>单例类必须自己创建自己的唯一实例。</li><li>单例类必须给所有其他对象提供这一实例。</li></ol><a id="more"></a> <p>讲的通俗一点，我们拿女娲造人来举例：</p><p>我们先写一个女娲类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">N_Wa</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，任何人都不能创造女娲，所以女娲的构造应该是私有的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">N_Wa</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">N_Wa</span><span class="params">()</span> </span>&#123;&#125;   <span class="comment">// 构造方法私有化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有人可能要质疑：那女娲应该是谁创造的？<br>这个问题千百万年来都没有人能解开过，所以在我们的潜意识中认为：神是自己创造自己的！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">N_Wa</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> N_Wa n_wa = <span class="keyword">new</span> N_Wa();   <span class="comment">// 神自己创造自己</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">N_Wa</span><span class="params">()</span> </span>&#123;&#125;     <span class="comment">// 构造方法私有化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>private 保证了女娲的私有性，毕竟这个世界上没有人见过女娲。<br>static   保证了女娲的静态性，她与类共存亡。<br>final     保证了女娲是“终极”常量，不可能再被修改。</p><p>女娲已经出来了，接下来干什么呢？<br>当然就是请她开始造人啦：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">N_Wa</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> N_Wa n_wa = <span class="keyword">new</span> N_Wa();   <span class="comment">// 神自己创造自己</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">N_Wa</span><span class="params">()</span> </span>&#123;&#125;     <span class="comment">// 构造方法私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> N_Wa <span class="title">getInstance</span><span class="params">()</span> </span>&#123;    <span class="comment">// 请求女娲</span></span><br><span class="line">        <span class="keyword">return</span> n_wa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getInstance 和 new？<br>new 是重新创建一个对象，且只能单次使用。<br>getInstance 是没有对象的时候创建对象，有了之后就保留在内存中，下次就不用再重新创建了，因此它的对象一定是static的。</p><p>这样一来，只需要调用 N_Wa.getInstance(); 女娲就请过来了，而且不论是谁，请来的都是同一个女娲，也就是我们构造的“终极”常量：n_wa。当然你还可以往里面加入其它的功能（造人功能未写出）。</p><p>到此为止，我们就已经学会了单例模式——<strong>“饿汉模式”</strong>，即我们先把女娲给造好，需要的时候直接用就好了。</p><p>随之而来的是另一个问题：要是我们根本没有用到女娲呢？那不是白造了？于是又出现了一种叫“<strong>懒汉模式</strong>”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">N_Wa</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> N_Wa n_wa;   <span class="comment">// 这里并没有new一个女娲</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">N_Wa</span><span class="params">()</span> </span>&#123;&#125;     <span class="comment">// 构造方法私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> N_Wa <span class="title">getInstance</span><span class="params">()</span> </span>&#123;    <span class="comment">// 请求女娲</span></span><br><span class="line">        <span class="keyword">if</span>(n_wa == <span class="keyword">null</span>) &#123;</span><br><span class="line">            n_wa = <span class="keyword">new</span> N_Wa();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n_wa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，我们不再是提前造女娲了，而是需要的时候再去造她（实例化），但这样子的坏处就是每次都要重新造一次女娲，所以速度肯定不如之前的“饿汉模式”。而且有个大问题，就是一旦有很多人同时请女娲的话，依然可能造成多个神的情况。</p><p>所以我们让这些人排队？看起来挺有道理，但仔细想想，有些人做事总是拖拖拉拉，毛手毛脚的，万一给让它排到前面去了，那后面的人不得等半天吗？等下队伍直接排出地球外了，所以我们干脆让他们直接抢，谁抢到就是谁的，这样一直抢下去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">N_Wa</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> N_Wa n_wa;   <span class="comment">// 这里并没有new一个女娲</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">N_Wa</span><span class="params">()</span> </span>&#123;&#125;     <span class="comment">// 构造方法私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> N_Wa <span class="title">getInstance</span><span class="params">()</span> </span>&#123;    <span class="comment">// 请求女娲</span></span><br><span class="line">        <span class="keyword">if</span>(n_wa == <span class="keyword">null</span>)&#123;      <span class="comment">// 代表还没有人抢到</span></span><br><span class="line">            <span class="keyword">synchronized</span> (N_Wa.class) &#123;    <span class="comment">// 放他们进去抢</span></span><br><span class="line">                <span class="keyword">if</span>(n_wa == <span class="keyword">null</span>) &#123;       <span class="comment">// 第一个抢到的给他 new一个然后返回</span></span><br><span class="line">                    n_wa = <span class="keyword">new</span> N_Wa();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n_wa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>synchronized 是一种同步锁，可以防止同步发生，通俗来讲就是第一个人先用，这时锁被锁上，等他用完，锁再打开，以此类推。只有当锁是开着的，才能轮到下一个人。</p><p>到此为止，最基础的两种“恶汉模式”和“懒汉模式”就完成了，单例模式还有其它的一些变种，但思想上都大同小异，我们需要灵活运用，发挥出最大的价值！</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：至少被一个元素整除的数个数</title>
      <link href="2020/09/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%87%B3%E5%B0%91%E8%A2%AB%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E6%95%B4%E9%99%A4%E7%9A%84%E6%95%B0%E4%B8%AA%E6%95%B0.html"/>
      <url>2020/09/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%87%B3%E5%B0%91%E8%A2%AB%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E6%95%B4%E9%99%A4%E7%9A%84%E6%95%B0%E4%B8%AA%E6%95%B0.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个 $m$ 个元素的集合，问 $1-n$ 中有多少个数能被集合中至少一个元素整除。$(n &lt;= 1e9, m &lt;= 20)$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>容斥原理，二进制枚举集合的所有子集，求子集的 $lcm$，如果子集大小是奇数，则 $res += n / lcm$，否则 $res-= n / lcm$。<br><a id="more"></a> </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line">LL a[<span class="number">40</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  LL N, M, ans = <span class="number">0</span>, gd;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;N, &amp;M);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i - <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  LL F = (<span class="number">1</span> &lt;&lt; M) - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= F; i++) &#123;</span><br><span class="line">    LL cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; j)) &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">1</span>)</span><br><span class="line">          gd = a[j];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          gd = gd * a[j] / (__gcd(a[j], gd));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt &amp; <span class="number">1</span>) &#123;</span><br><span class="line">      ans += N / gd;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      ans -= N / gd;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>存在负数的背包问题</title>
      <link href="2020/09/%E5%AD%98%E5%9C%A8%E8%B4%9F%E6%95%B0%E7%9A%84%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98.html"/>
      <url>2020/09/%E5%AD%98%E5%9C%A8%E8%B4%9F%E6%95%B0%E7%9A%84%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h2><p>体积和价值可能为负数的01背包。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>逆向思维，对于体积为负的物品，我们可以一开始就装进去，背包对应的进行扩容，物品的体积和价值也对应取反。这样在进行背包dp 的时候就代表移除这个物品，答案取最大值即可。<br><a id="more"></a> </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">410</span>;</span><br><span class="line"><span class="keyword">int</span> c[N], v[N], ans;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">40010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N, M;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;N, &amp;M);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;c[i], &amp;v[i]);</span><br><span class="line">    <span class="keyword">if</span> (c[i] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      ans += v[i];</span><br><span class="line">      M -= c[i];</span><br><span class="line">      c[i] = -c[i];</span><br><span class="line">      v[i] = -v[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = M; j &gt;= c[i]; j--) dp[j] = max(dp[j], dp[j - c[i]] + v[i]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= M; i++) &#123;</span><br><span class="line">    dp[M] = max(dp[M], dp[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans + dp[M]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h2><p>体积和价值可能为负数且要求所取的物品体积之和和价值之和都大于0的条件下，两者总和最大的01背包。$(n = 100, -1000&lt;=v,w&lt;=1000)$</p><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2><p>由于体积可能为负，因此需要负数转化为正数，以 $100000$ 为分界线划分为左边代表正数，右边代表负数做背包dp即可，当体积为负时，转移是由大的容量转移过来，需要从小到大遍历。最后取分界线右侧且dp值大于 0 的体积加价值最大值即可。</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> m = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, x, y, res, dp[m];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) dp[i] = -m;</span><br><span class="line">  dp[<span class="number">100000</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= x; j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[j - x] != -m) dp[j] = max(dp[j], dp[j - x] + y);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m + x; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[j - x] != -m) dp[j] = max(dp[j], dp[j - x] + y);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">100000</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dp[i] &gt; <span class="number">0</span>) res = max(res, dp[i] + i - <span class="number">100000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12种Java中常用的语法糖</title>
      <link href="2020/09/12%E7%A7%8DJava%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96.html"/>
      <url>2020/09/12%E7%A7%8DJava%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是语法糖"><a href="#什么是语法糖" class="headerlink" title="什么是语法糖"></a>什么是语法糖</h2><p>语法糖（Syntactic Sugar），也称糖衣语法，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。简而言之，语法糖让程序更加简洁，有更高的可读性。</p><h2 id="解语法糖"><a href="#解语法糖" class="headerlink" title="解语法糖"></a>解语法糖</h2><p>前面提到过，语法糖的存在主要是方便开发人员使用。但其实，Java虚拟机并不支持这些语法糖。这些语法糖在编译阶段就会被还原成简单的基础语法结构，这个过程就是解语法糖。说到编译，大家肯定都知道，Java语言中，javac命令可以将后缀名为.java的源文件编译为后缀名为.class的可以运行于Java虚拟机的字节码。如果你去看com.sun.tools.javac.main.JavaCompiler的源码，你会发现在compile()中有一个步骤就是调用desugar()，这个方法就是负责解语法糖的实现的。Java 中最常用的语法糖主要有泛型、变长参数、条件编译、自动拆装箱、内部类等。</p><h2 id="糖块一：-switch-支持-String-与枚举"><a href="#糖块一：-switch-支持-String-与枚举" class="headerlink" title="糖块一： switch 支持 String 与枚举"></a>糖块一： switch 支持 String 与枚举</h2><p>从Java 7 开始，switch 开始支持 String。其实Java中的switch自身原本就支持基本类型。比如int、char等。对于int类型，直接进行数值的比较。对于char类型则是比较其 ascii 码。<br><a id="more"></a> </p><p>所以，对于编译器来说，<strong>switch中其实只能使用整型，任何类型的比较都要转换成整型</strong>。比如byte。short，char(ascii码是整型)以及int。</p><p>那么接下来看下 switch 对 String 的支持，有以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwitchTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;Shuke&quot;</span>;</span><br><span class="line">        <span class="keyword">switch</span> (s) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Shuke&quot;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;Shuke&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Bata&quot;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;Bata&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后的内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwitchTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SwitchTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;Shuke&quot;</span>;</span><br><span class="line">        <span class="keyword">byte</span> var3 = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">switch</span>(s.hashCode()) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2063116</span>:</span><br><span class="line">            <span class="keyword">if</span> (s.equals(<span class="string">&quot;Bata&quot;</span>)) &#123;</span><br><span class="line">                var3 = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">79866362</span>:</span><br><span class="line">            <span class="keyword">if</span> (s.equals(<span class="string">&quot;Shuke&quot;</span>)) &#123;</span><br><span class="line">                var3 = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(var3) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;Shuke&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;Bata&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现字符串的switch是通过equals()和hashCode()方法来实现的，hashCode()方法返回的是int，而不是long。</p><p>进行switch的实际是哈希值，然后通过使用equals方法比较进行安全检查，这个检查是必要的，因为<strong>哈希可能会发生碰撞</strong>。</p><h2 id="糖块二：-泛型"><a href="#糖块二：-泛型" class="headerlink" title="糖块二： 泛型"></a>糖块二： 泛型</h2><p>很多语言都是支持泛型的，但不同的编译器对于泛型的处理方式是不同的。</p><p>通常情况下，一个编译器处理泛型有两种方式：Code specialization和Code sharing。</p><p>C++和C#是使用Code specialization的处理机制，而Java使用的是Code sharing的机制。</p><p>Code sharing方式为每个泛型类型创建唯一的字节码表示，并且将该泛型类型的实例都映射到这个唯一的字节码表示上。将多种泛型类形实例映射到唯一的字节码表示是通过类型擦除（type erasue）实现的。</p><p>也就是说，对于Java虚拟机来说，它根本不认识 Map&lt;String, String&gt; map 这样的语法。需要在编译阶段通过类型擦除的方式进行解语法糖。</p><p>类型擦除的主要过程如下：</p><ol><li><p>将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。</p></li><li><p>移除所有的类型参数。</p></li></ol><ul><li><p>例如:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">map.put(<span class="string">&quot;111&quot;</span>, <span class="string">&quot;222&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;333&quot;</span>, <span class="string">&quot;444&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;555&quot;</span>, <span class="string">&quot;666&quot;</span>);</span><br></pre></td></tr></table></figure><p>  解语法糖后：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">map.put(<span class="string">&quot;111&quot;</span>, <span class="string">&quot;222&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;333&quot;</span>, <span class="string">&quot;444&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;555&quot;</span>, <span class="string">&quot;666&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><p><strong>虚拟机中没有泛型，只有普通类和普通方法，所有泛型类的类型参数在编译时都会被擦除</strong>，并没有自己独有的 Class 类对象。比如并不存在 List&lt;String&gt;.class 或是List&lt;Integer&gt;.class，而只有 List.class。</p><p>补充：</p><ol><li>当泛型遇到重载</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTypes</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;invoke method(List&lt;String&gt; list)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;invoke method(List&lt;Integer&gt; list)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码，有两个重载的函数，因为他们的参数类型不同，但是，这段代码是编译不通过的。因为参数 List 和 List 编译之后都被擦除了，变成了一样的原生类型 List，擦除动作导致这两个方法的特征签名变得一模一样。</p><ol><li>当泛型遇到catch</li></ol><p>泛型的类型参数不能用在 Java 异常处理的 catch 语句中。因为异常处理是由JVM在运行时刻来进行的。由于类型信息被擦除，JVM是无法区分两个异常类型 MyException&lt;String&gt; 和 MyException&lt;Integer&gt; 的。</p><ol><li>当泛型内包含静态变量</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GT&lt;Integer&gt; gti = <span class="keyword">new</span> GT&lt;Integer&gt;();</span><br><span class="line">        gti.<span class="keyword">var</span> = <span class="number">1</span>;</span><br><span class="line">        GT&lt;String&gt; gts = <span class="keyword">new</span> GT&lt;String&gt;();</span><br><span class="line">        gts.<span class="keyword">var</span> = <span class="number">2</span>;</span><br><span class="line">        System.out.println(gti.<span class="keyword">var</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GT</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="keyword">var</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nothing</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码输出结果为：2 !!! 由于经过类型擦除，所有的泛型类实例都关联到同一份字节码上，泛型类的所有静态变量是共享的。</p><h2 id="糖块三：-自动装箱与拆箱"><a href="#糖块三：-自动装箱与拆箱" class="headerlink" title="糖块三： 自动装箱与拆箱"></a>糖块三： 自动装箱与拆箱</h2><p>自动装箱就是Java自动将原始类型值转换成对应的对象，比如将int的变量转换成Integer对象，这个过程叫做装箱，反之将Integer对象转换成int类型值，这个过程叫做拆箱。</p><p>因为这里的装箱和拆箱是自动进行的非人为转换，所以就称作为自动装箱和拆箱。</p><p>原始类型byte, short, char, int, long, float, double 和 boolean 对应的封装类为Byte, Short, Character, Integer, Long, Float, Double, Boolean。</p><p>先来看个自动装箱的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    Integer n = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    Integer n = Integer.valueOf(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看个自动拆箱的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> n = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Integer i = Integer.valueOf(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">int</span> n = i.intValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从反编译得到内容可以看出，<strong>装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的</strong>。</p><p>补充：</p><p>自动装箱与拆箱——对象相等比较：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer a = <span class="number">1000</span>;</span><br><span class="line">    Integer b = <span class="number">1000</span>;</span><br><span class="line">    Integer c = <span class="number">100</span>;</span><br><span class="line">    Integer d = <span class="number">100</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;a == b is &quot;</span> + (a == b));</span><br><span class="line">    System.out.println((<span class="string">&quot;c == d is &quot;</span> + (c == d)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Java 5中，在Integer的操作上引入了一个新功能来节省内存和提高性能。整型对象通过使用相同的对象引用实现了缓存和重用。适用于整数值区间-128 至 +127。只适用于自动装箱。使用构造函数创建对象不适用。数据会被自动装箱成包装类，JVM在比较之前会看在不在常量池范围内，在就字面量比较，不在就比较地址值。</p><h2 id="糖块四：-方法变长参数"><a href="#糖块四：-方法变长参数" class="headerlink" title="糖块四： 方法变长参数"></a>糖块四： 方法变长参数</h2><p>可变参数(variable arguments)是在Java 1.5中引入的一个特性。它允许一个方法把任意数量的值作为参数。</p><p>看下以下可变参数代码，其中print方法接收可变参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    print(<span class="string">&quot;111&quot;</span>, <span class="string">&quot;222&quot;</span>, <span class="string">&quot;333&quot;</span>, <span class="string">&quot;444&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String... strs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(strs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后得到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    print(<span class="keyword">new</span> String[] &#123;</span><br><span class="line">    <span class="string">&quot;111&quot;</span>, <span class="string">&quot;222&quot;</span>, <span class="string">&quot;333&quot;</span>, <span class="string">&quot;444&quot;</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">transient</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String strs[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++)</span><br><span class="line">    System.out.println(strs[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从反编译后代码可以看出，可变参数在被使用的时候，他首先会创建一个数组，数组的长度就是调用该方法是传递的实参的个数，然后再把参数值全部放到这个数组当中，然后再把这个数组作为参数传递到被调用的方法中。</p><h2 id="糖块五：-枚举"><a href="#糖块五：-枚举" class="headerlink" title="糖块五： 枚举"></a>糖块五： 枚举</h2><p>Java SE5 提供了一种新的类型 — Java的枚举类型，关键字enum可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用，这是一种非常有用的功能。enumn就和 class 一样，只是一个关键字，并不是一个类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">t</span> </span>&#123;</span><br><span class="line">        SPRING,SUMMER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> <span class="keyword">extends</span> <span class="title">Enum</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="title">T</span><span class="params">(String s, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s, i);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> T[] values()</span><br><span class="line">     &#123;</span><br><span class="line">        T at[];</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        T at1[];</span><br><span class="line">        System.arraycopy(at = ENUM$VALUES, <span class="number">0</span>, at1 = <span class="keyword">new</span> T[i = at.length], <span class="number">0</span>, i);</span><br><span class="line">        <span class="keyword">return</span> at1;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">valueOf</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T)Enum.valueOf(demo/T, s);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> T SPRING;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> T SUMMER;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> T ENUM$VALUES[];</span><br><span class="line">     <span class="keyword">static</span></span><br><span class="line">     &#123;</span><br><span class="line">        SPRING = <span class="keyword">new</span> T(<span class="string">&quot;SPRING&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        SUMMER = <span class="keyword">new</span> T(<span class="string">&quot;SUMMER&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        ENUM$VALUES = (<span class="keyword">new</span> T[] &#123;</span><br><span class="line">        SPRING, SUMMER</span><br><span class="line">     &#125;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>public final class T extends Enum 说明该类是继承了Enum类的，同时final关键字意味着这个类也是不能被继承的。</p><p>当我们使用enmu来定义一个枚举类型的时候，编译器会自动帮我们创建一个final类型的类继承Enum类，所以枚举类型不能被继承。</p><h2 id="糖块六：-内部类"><a href="#糖块六：-内部类" class="headerlink" title="糖块六： 内部类"></a>糖块六： 内部类</h2><p>内部类又称为嵌套类，可以把内部类理解为外部类的一个普通成员。内部类之所以也是语法糖，是因为它仅仅是一个编译时的概念。</p><p>比如在 A.java 里面定义了一个内部类 B，一旦编译成功，就会生成两个完全不同的.class文件，分别是 A.class 和 A$B.class。所以内部类的名字完全可以和它的外部类名字相同。</p><p><strong>一个类对应一个.class文件，多个类嵌套就会有多个.class文件</strong>。</p><h2 id="糖块七：条件编译"><a href="#糖块七：条件编译" class="headerlink" title="糖块七：条件编译"></a>糖块七：条件编译</h2><p>一般情况下，程序中的每一行代码都要参加编译。但有时候出于对程序代码优化的考虑，希望只对其中一部分内容进行编译，此时就需要在程序中加上条件，让编译器只对满足条件的代码进行编译，将不满足条件的代码舍弃，这就是条件编译。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionalCompilation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(DEBUG) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello, DEBUG!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> ONLINE = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(ONLINE)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello, ONLINE!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionalCompilation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConditionalCompilation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> DEBUG = <span class="keyword">true</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, DEBUG!&quot;</span>);</span><br><span class="line">        <span class="keyword">boolean</span> ONLINE = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们发现，在反编译后的代码中没有 System.out.println(“Hello, ONLINE!”);，这其实就是条件编译。当 if(ONLINE) 为 false 的时候，编译器就没有对其内的代码进行编译。</p><p>所以，Java语法的条件编译，是通过判断条件为常量的 if 语句实现的。根据 if 判断条件的真假，编译器直接把分支为 false 的代码块消除。通过该方式实现的条件编译，必须在方法体内实现，而无法在正整个Java类的结构或者类的属性上进行条件编译。</p><h2 id="糖块八：-断言"><a href="#糖块八：-断言" class="headerlink" title="糖块八： 断言"></a>糖块八： 断言</h2><p>在Java中，assert关键字是从JAVA SE 1.4 引入的，为了避免和老版本的Java代码中使用了assert关键字导致错误，Java在执行的时候默认是不启动断言检查的（这个时候，所有的断言语句都将忽略！）。如果要开启断言检查，则需要用开关 -enableassertions 或 -ea来开启。</p><p>assert关键字语法很简单，有两种用法：</p><ol><li><p>assert boolean表达式</p><p> 如果为true，则程序继续执行。</p><p> 如果为false，则程序抛出AssertionError，并终止执行。</p></li><li><p>assert boolean表达式 : 错误信息表达式</p><p> 如果为true，则程序继续执行。</p><p> 如果为false，则程序抛出java.lang.AssertionError，并输入\&lt;错误信息表达式&gt;。</p></li></ol><p>例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AssertFoo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="comment">//断言1结果为true，则继续往下执行</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">true</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;断言1没有问题，Go！&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;\n-----------------\n&quot;</span>);</span><br><span class="line">        <span class="comment">//断言2结果为false,程序终止</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">false</span> : <span class="string">&quot;断言失败，此表达式的信息将会在抛出异常的时候输出！&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;断言2没有问题，Go！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>开启-ea开关，执行程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt;java -ea AssertFoo</span><br><span class="line"></span><br><span class="line">断言<span class="number">1</span>没有问题，Go！</span><br><span class="line">-----------------</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.AssertionError: 断言失败，此表达式的信息将会在抛出异常的时候输出！at AssertFoo.main(AssertFoo.java:<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>其实断言的底层实现就是 if 语言，如果断言结果为 true，则什么都不做，程序继续执行，如果断言结果为 false，则程序抛出 AssertionError 来打断程序的执行。</p><h2 id="糖块十：-for-each"><a href="#糖块十：-for-each" class="headerlink" title="糖块十： for-each"></a>糖块十： for-each</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForEachTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        String[] strs = &#123;<span class="string">&quot;111&quot;</span>, <span class="string">&quot;222&quot;</span>, <span class="string">&quot;333&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (String s : strs) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForEachTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForEachTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        String[] strs = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;111&quot;</span>, <span class="string">&quot;222&quot;</span>, <span class="string">&quot;333&quot;</span>&#125;;</span><br><span class="line">        String[] var2 = strs;</span><br><span class="line">        <span class="keyword">int</span> var3 = strs.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> var4 = <span class="number">0</span>; var4 &lt; var3; ++var4) &#123;</span><br><span class="line">            String s = var2[var4];</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for-each 的实现原理其实就是使用了普通的 for 循环和迭代器。</p><p>补充：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Student stu : students) &#123; </span><br><span class="line">    <span class="keyword">if</span> (stu.getId() == <span class="number">2</span>) </span><br><span class="line">    students.remove(stu); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会抛出ConcurrentModificationException异常。</p><p>Iterator是工作在一个独立的线程中，并且拥有一个 mutex 锁。 Iterator被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，这个索引表的内容不会同步改变，所以当索引指针往后移动的时候就找不到要迭代的对象，所以按照 fail-fast 原则 Iterator 会马上抛出 java.util.ConcurrentModificationException 异常。</p><p>所以 Iterator 在工作的时候是不允许被迭代的对象被改变的。但你可以使用 Iterator 本身的方法remove()来删除对象，Iterator.remove() 方法会在删除当前迭代对象的同时维护索引的一致性。</p><h2 id="糖块十一：-try-with-resource"><a href="#糖块十一：-try-with-resource" class="headerlink" title="糖块十一： try-with-resource"></a>糖块十一： try-with-resource</h2><p>Java里，对于文件操作IO流、数据库连接等开销非常昂贵的资源，用完之后必须及时通过close方法将其关闭，否则资源会一直处于打开状态，可能会导致内存泄露等问题。</p><p>关闭资源的常用方式就是在 finally 块里是释放，即调用 close 方法。比如，我们经常会写这样的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String line;</span><br><span class="line">        br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;xxx&quot;</span>));</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// handle exception</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (br != <span class="keyword">null</span>) &#123;</span><br><span class="line">                br.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="comment">// handle exception</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从Java 7开始，jdk 提供了一种更好的方式关闭资源，使用 try-with-resources 语句，改写一下上面的代码，效果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;xxx&quot;</span>)))            &#123;</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// handle exception</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实背后的原理也很简单，那些我们没有做的关闭资源的操作，编译器都帮我们做了。</p><h2 id="糖块十二：-Lambda表达式"><a href="#糖块十二：-Lambda表达式" class="headerlink" title="糖块十二： Lambda表达式"></a>糖块十二： Lambda表达式</h2><p>Labmda 表达式不是匿名内部类的语法糖，但是他也是一个语法糖。实现方式其实是依赖了几个 JVM 底层提供的 lambda 相关 api。</p><p>它并不是内部类的语法糖，前面讲内部类我们说过，内部类在编译之后会有对应的 class 文件，但是，包含 lambda 表达式的类编译后只有一个文件。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode486：预测赢家</title>
      <link href="2020/09/LeetCode486%EF%BC%9A%E9%A2%84%E6%B5%8B%E8%B5%A2%E5%AE%B6.html"/>
      <url>2020/09/LeetCode486%EF%BC%9A%E9%A2%84%E6%B5%8B%E8%B5%A2%E5%AE%B6.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个表示分数的非负整数数组。 玩家 1 从数组任意一端拿取一个分数，随后玩家 2 继续从剩余数组任意一端拿取分数，然后玩家 1 拿，…… 。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。</p><p>给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。<br><a id="more"></a> </p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>很容易想到递归解决，但显然复杂度太大。所以我们采用记忆化搜索，把已经搜索过的状态记录下来，回溯过程中取最大值。</p><p>$dp[l][r]$ 表示在区间 $[l,r]$ 中，能赢过对方的最大分数。</p><p>状态转移：$dp[l][r] = max(nums[l] - dp[l + 1][r], nums[r] - dp[l][r - 1])$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">30</span>][<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[l][r] != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> dp[l][r];</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> dp[l][r] = nums[l];</span><br><span class="line">        <span class="keyword">return</span> dp[l][r] = Math.max(nums[l] - dfs(l + <span class="number">1</span>, r, nums), nums[r] - dfs(l, r - <span class="number">1</span>, nums));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i], <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, n - <span class="number">1</span>, nums) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 记忆化搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：牛牛构造等差数列</title>
      <link href="2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%89%9B%E7%89%9B%E6%9E%84%E9%80%A0%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97.html"/>
      <url>2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%89%9B%E7%89%9B%E6%9E%84%E9%80%A0%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有 $n$ 个数，他们对每个数可以进行 $+1$ 或 $-1$ 操作，但对于每一个数，该操作最多只能执行一次。使用最少的操作次数，将这几个数构造成一个等差数列。如果完全不能构造成功，就输出 $-1$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>每个数最多只能修改一次，因此我们只要枚举前两个数的修改状态就能确定首项和公差，只有 $9$ 种可能，然后逐一判断取最小值即可。<br><a id="more"></a> </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = -<span class="number">1</span>; i &lt;= <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = -<span class="number">1</span>; j &lt;= <span class="number">1</span>; j++) &#123;</span><br><span class="line">                b[<span class="number">0</span>] += i;</span><br><span class="line">                b[<span class="number">1</span>] += j;</span><br><span class="line">                <span class="keyword">int</span> d = b[<span class="number">1</span>] - b[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> pre = b[<span class="number">1</span>], now, cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span>)</span><br><span class="line">                    cnt++;</span><br><span class="line">                <span class="keyword">if</span> (j != <span class="number">0</span>)</span><br><span class="line">                    cnt++;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt; n; k++) &#123;</span><br><span class="line">                    now = pre + d;</span><br><span class="line">                    <span class="keyword">if</span> (Math.abs(now - b[k]) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                        flag = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Math.abs(now - b[k]) == <span class="number">1</span>) &#123;</span><br><span class="line">                        cnt++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    pre = now;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (flag == <span class="keyword">false</span>) &#123;</span><br><span class="line">                    res = Math.min(res, cnt);</span><br><span class="line">                &#125;</span><br><span class="line">                b[<span class="number">0</span>] -= i;</span><br><span class="line">                b[<span class="number">1</span>] -= j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == Integer.MAX_VALUE ? -<span class="number">1</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：Playing Tag on Tree</title>
      <link href="2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9APlaying-Tag-on-Tree.html"/>
      <url>2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9APlaying-Tag-on-Tree.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一棵树，A 在 $x$ 点，B 在 $y$ 点，B 追 A，两人每次可以往相邻点移动，A 先跑，问 A 最晚什么时候被追上。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>结论：找到一个点，满足 $dis_B &gt; dis_A$ 且 $dis_B$ 最大，即为最终落脚点。<br><a id="more"></a> </p><p>因为直观上来说，明显最后的点离 B 越远越好，但这个点可能离 A 更远，因此需要满足 $dis_B &gt; dis_A$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">2</span>][N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> be, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">  q.push(be);</span><br><span class="line">  dis[id][be] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = q.front();</span><br><span class="line">    q.pop();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : g[u]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!dis[id][v]) &#123;</span><br><span class="line">        dis[id][v] = dis[id][u] + <span class="number">1</span>;</span><br><span class="line">        q.push(v);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, x, y, u, v, res = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; x &gt;&gt; y;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    g[u].push_back(v);</span><br><span class="line">    g[v].push_back(u);</span><br><span class="line">  &#125;</span><br><span class="line">  bfs(x, <span class="number">0</span>);</span><br><span class="line">  bfs(y, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dis[<span class="number">0</span>][i] &lt; dis[<span class="number">1</span>][i]) res = max(res, dis[<span class="number">1</span>][i] - <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode：最短回文串</title>
      <link href="2020/08/LeetCode214%EF%BC%9A%E6%9C%80%E7%9F%AD%E5%9B%9E%E6%96%87%E4%B8%B2.html"/>
      <url>2020/08/LeetCode214%EF%BC%9A%E6%9C%80%E7%9F%AD%E5%9B%9E%E6%96%87%E4%B8%B2.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个字符串 $s$，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>等价于求字符串 $s$ 以 $s_0$ 开头的最长回文串，然后多出来的后缀翻转后就是需要补足的最小长度，判断回文可以采用哈希。<br><a id="more"></a> </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">shortestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">long</span> left = <span class="number">0</span>, right = <span class="number">0</span>, base = <span class="number">13331</span>, mod = <span class="number">1000000007</span>, pre = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pos = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            left = (left * base + s.charAt(i)) % mod;</span><br><span class="line">            right = (right + pre * s.charAt(i)) % mod;</span><br><span class="line">            <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">                pos = i;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = pre * base % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        String add = (pos == n-<span class="number">1</span> ? <span class="string">&quot;&quot;</span> : s.substring(pos+<span class="number">1</span>,n));</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder(add).reverse();</span><br><span class="line">        res.append(s);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：Assassin’s Creed</title>
      <link href="2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AAssassin%E2%80%99s-Creed.html"/>
      <url>2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AAssassin%E2%80%99s-Creed.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>有 $n$ 个敌人，你现在的武器的耐久度为 $m$,杀每个敌人要消耗 $a_i$ 点耐久度，同时得到可以再杀死 $b_i$ 个人的权利。问最多可以杀死多少人，在杀人最多的情况下最少要消耗多少耐久度？</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>首先会想到对人进行分类，一类是 $b_i$ 为 $0$ 的，一类是 $b_i$ 不为 $0$ 的。<br><a id="more"></a> </p><p>杀死一个 $b_i$ 不为 $0$ 的，一定能杀死所有 $b_i$ 不为 $0$ 的，而且还能再额外杀死 $b_i$ 为 $0$ 的，显然只要杀 $a_i$ 最小的那个人即可。</p><p>分两种情况：</p><ol><li><p>只杀 $b_i$ 为 $0$ 的，可能原因：没有 $b_i$ 不为 $0$ 的，或者耐久度不够，或者消耗耐久度过大，还不如直接杀 $b_i$ 为 $0$ 来的划算。</p></li><li><p>杀一个 $b_i$ 不为 $0$的，且消耗耐久度最小的，那么所有的 $b_i$ 不为 $0$ 都将被杀死，额外的免费杀人机会都拿来杀 $b_i$ 为 $0$ 的，用剩下的耐久度从小到大杀剩下的怪即可。但这样有缺陷，可能存在手动杀 $b_i$ 不为 $0$ 的人会更划算，因为这个怪可能消耗的耐久度非常小，而你用这次机会杀 $b_i$ 为 $0$ 的人可能消耗非常大。于是得出结论：所有 $b_i$ 不为 $0$ 的人肯定会被杀死，但我只要把所有的怪按耐久度从小到大杀即可。</p></li></ol><p>两种情况取最大值即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g1, g2, g3;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> t, n, m, x, y, c = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">  <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    g1.clear();</span><br><span class="line">    g2.clear();</span><br><span class="line">    g3.clear();</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">      <span class="keyword">if</span> (y) </span><br><span class="line">        g1.push_back(x);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        g2.push_back(x);</span><br><span class="line">      sum+=y;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(g1.begin(), g1.end());</span><br><span class="line">    sort(g2.begin(), g2.end());</span><br><span class="line">    <span class="keyword">int</span> cost1 = <span class="number">0</span>, cost2 = <span class="number">0</span>, num1 = <span class="number">0</span>, num2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g2.size(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (cost1 + g2[i] &gt; m) <span class="keyword">break</span>;</span><br><span class="line">      cost1 += g2[i];</span><br><span class="line">      num1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (g2.size() == n || m &lt; g1[<span class="number">0</span>])</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %d %d\n&quot;</span>, ++c, num1, cost1);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      cost2 = g1[<span class="number">0</span>];</span><br><span class="line">      sum++;</span><br><span class="line">      num2 = min(sum, n);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g2.size(); i++) g3.push_back(g2[i]);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; g1.size(); i++) g3.push_back(g1[i]);</span><br><span class="line">      sort(g3.begin(), g3.end());</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g3.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num2 &gt;= n || cost2 + g3[i] &gt; m) <span class="keyword">break</span>;</span><br><span class="line">        cost2 += g3[i];</span><br><span class="line">        num2++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (num1 &gt; num2 || num1 == num2 &amp;&amp; cost1 &lt; cost2)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %d %d\n&quot;</span>, ++c, num1, cost1);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %d %d\n&quot;</span>, ++c, num2, cost2);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：物质分裂</title>
      <link href="2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%89%A9%E8%B4%A8%E5%88%86%E8%A3%82.html"/>
      <url>2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%89%A9%E8%B4%A8%E5%88%86%E8%A3%82.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>一个 $A$ 每天可以生产 $x1$ 个 $B$，$y1$ 个 $C$，一个 $B$ 每天可以生产 $x2$ 个 $A$，$y2$ 个 $C$，一个 $C$ 每天可以生产 $x3$ 个 $A$，$y3$ 个 $B$，最开始各有 $x,y,z$ 个，问 $n$ 天后各有多少个？ $n = 1e9$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>$B$ 和 $C$ 每天可以生产 $x2 + x3$ 个 $A$，那么第一天：$x$，第二天：$x<em>(x2+x3)$，第三天：$(x</em>(x2+x3))*(x2+x3)$ … 显然是等比数列求和。<br><a id="more"></a> </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">ll x, y, z, n, b1, c1, a1, c2, a2, b2;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qp</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">  ll sum = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (b) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>) sum = sum * a % mod;</span><br><span class="line">    a = a * a % mod;</span><br><span class="line">    b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; z &gt;&gt; n;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; b1 &gt;&gt; c1 &gt;&gt; a1 &gt;&gt; c2 &gt;&gt; a2 &gt;&gt; b2;</span><br><span class="line">  ll a =</span><br><span class="line">      x * (<span class="number">1</span> - qp(a1 + a2, n + <span class="number">1</span>) + mod) * qp(<span class="number">1</span> - a1 - a2 + mod, mod - <span class="number">2</span>) % mod;</span><br><span class="line">  ll b =</span><br><span class="line">      y * (<span class="number">1</span> - qp(b1 + b2, n + <span class="number">1</span>) + mod) * qp(<span class="number">1</span> - b1 - b2 + mod, mod - <span class="number">2</span>) % mod;</span><br><span class="line">  ll c =</span><br><span class="line">      z * (<span class="number">1</span> - qp(c1 + c2, n + <span class="number">1</span>) + mod) * qp(<span class="number">1</span> - c1 - c2 + mod, mod - <span class="number">2</span>) % mod;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：竞赛图</title>
      <link href="2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%AB%9E%E8%B5%9B%E5%9B%BE.html"/>
      <url>2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%AB%9E%E8%B5%9B%E5%9B%BE.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个 $n$ 元有向完全图，每次操作可以翻转一条边。求最少的操作次数，使得图中不存在三元环。$(n &lt;= 10)$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p><img src="http://img.benboby.top/%E8%AF%81%E6%98%8E.png" alt></p><a id="more"></a> <h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, pre[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; s[i], pre[i] = i;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) sum += s[pre[j]][pre[i]] &amp; <span class="number">1</span>;</span><br><span class="line">      res = min(res, sum);</span><br><span class="line">    &#125; <span class="keyword">while</span> (next_permutation(pre, pre + n));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode1563：石子游戏V</title>
      <link href="2020/08/LeetCode1563%EF%BC%9A%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8FV.html"/>
      <url>2020/08/LeetCode1563%EF%BC%9A%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8FV.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>几块石子 排成一行 ，每块石子都有一个关联值，关联值为整数，由数组 stoneValue 给出。</p><p>游戏中的每一轮：Alice 会将这行石子分成两个 非空行（即，左侧行和右侧行）；Bob 负责计算每一行的值，即此行中所有石子的值的总和。Bob 会丢弃值最大的行，Alice 的得分为剩下那行的值（每轮累加）。如果两行的值相等，Bob 让 Alice 决定丢弃哪一行。下一轮从剩下的那一行开始。</p><p>只 <strong>剩下一块石子</strong> 时，游戏结束。Alice 的分数最初为 <strong>0</strong> 。</p><a id="more"></a> <p>返回 Alice 能够获得的最大分数 。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>$dp[l][r]$ 表示区间 $[l,r]$ Alice能得到的最大值，然后区间dp。</p><p>若$sum[l…mid] == sum[mid+1…r]$ ，则 $dp[l][r] = max(dp[l][r], dp[l][mid] + dp[mid + 1][r] + sum[l…mid])$。</p><p>若$sum[l…mid] != sum[mid+1…r]$ :</p><ul><li>$sum[l…mid] &gt; sum[mid + 1][r]$ ，则 $dp[l][r] = max(dp[l][r], dp[mid + 1][r] + sum[mid+1…r])$。</li><li>$sum[l…mid] &lt; sum[mid + 1][r]$ ，则 $dp[l][r] = max(dp[l][r], dp[l][mid] + sum[l…mid])$。</li></ul><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">stoneGameV</span><span class="params">(<span class="keyword">int</span>[] stoneValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = stoneValue.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">int</span>[] sum = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        sum[<span class="number">0</span>] = stoneValue[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] + stoneValue[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; len++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l + len - <span class="number">1</span> &lt; n; l++) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = l + len - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> mid = l; mid &lt; r; mid++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> fl = sum[mid] - (l &gt; <span class="number">0</span> ? sum[l - <span class="number">1</span>] : <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">int</span> fr = sum[r] - sum[mid];</span><br><span class="line">                    <span class="keyword">if</span> (fl == fr) &#123;</span><br><span class="line">                        dp[l][r] = Math.max(dp[l][r], Math.max(dp[l][mid], dp[mid + <span class="number">1</span>][r]) + fl);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (fl &gt; fr) &#123;</span><br><span class="line">                            dp[l][r] = Math.max(dp[l][r], dp[mid + <span class="number">1</span>][r] + fr);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            dp[l][r] = Math.max(dp[l][r], dp[l][mid] + fl);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区间dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：二维网格图中探测环</title>
      <link href="2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E4%BA%8C%E7%BB%B4%E7%BD%91%E6%A0%BC%E5%9B%BE%E4%B8%AD%E6%8E%A2%E6%B5%8B%E7%8E%AF.html"/>
      <url>2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E4%BA%8C%E7%BB%B4%E7%BD%91%E6%A0%BC%E5%9B%BE%E4%B8%AD%E6%8E%A2%E6%B5%8B%E7%8E%AF.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>问二维矩阵中是否存在相同字母构成的环。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>判环问题，显然可以想到并查集。遍历矩阵，若该点与之前遍历过的相邻点字符相同且是同一个根的话，说明存在环，否则合并这两个点。<br><a id="more"></a> </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] pre = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">500005</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pre[x] == x ? x : (pre[x] = find(pre[x]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fx = find(x), fy = find(y);</span><br><span class="line">        <span class="keyword">if</span> (fx == fy) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        pre[fx] = fy;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsCycle</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.length, m = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n * m; i++)</span><br><span class="line">            pre[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; grid[i][j] == grid[i - <span class="number">1</span>][j] &amp;&amp; join(i * m + j, (i - <span class="number">1</span>) * m + j)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; grid[i][j] == grid[i][j - <span class="number">1</span>] &amp;&amp; join(i * m + j, i * m + j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：数数组</title>
      <link href="2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%95%B0%E6%95%B0%E7%BB%84.html"/>
      <url>2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%95%B0%E6%95%B0%E7%BB%84.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>构造一个长度为 $n$ 的序列，每个数字大小必须满足 $l &lt;= a[i] &lt;= r$，且和被 3 整除，问有多少种方法？</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><a id="more"></a> <p>$dp[i][j]$ 表示长度为 $i$，余数为 $j$ 的构造数量。$a,b,c$ 表示区间内余数为 $0,1,2$ 的数的数量。</p><p>转移方程：</p><p>$dp[i][0] = a <em> dp[i - 1][0] + b </em> dp[i - 1][2] + c <em> dp[i - 1][1]$;<br>$dp[i][1] = (a </em> dp[i - 1][1] + b <em> dp[i - 1][0] + c </em> dp[i - 1][2]$;<br>$dp[i][2] = (a <em> dp[i - 1][2] + b </em> dp[i - 1][1] + c * dp[i - 1][0]$;</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll n, l, r, dp[<span class="number">200005</span>][<span class="number">3</span>], a, b, c;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; l &gt;&gt; r;</span><br><span class="line">  <span class="keyword">while</span> (l % <span class="number">3</span> != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = l % <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span>)</span><br><span class="line">      b++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">2</span>)</span><br><span class="line">      c++;</span><br><span class="line">    l++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (r % <span class="number">3</span> != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = r % <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">2</span>)</span><br><span class="line">      c++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">1</span>)</span><br><span class="line">      b++;</span><br><span class="line">    r--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> p = (r - l) / <span class="number">3</span>;</span><br><span class="line">  a += p;</span><br><span class="line">  b += p;</span><br><span class="line">  c += p;</span><br><span class="line">  a++;</span><br><span class="line">  dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = (a * dp[i - <span class="number">1</span>][<span class="number">0</span>] + b * dp[i - <span class="number">1</span>][<span class="number">2</span>] + c * dp[i - <span class="number">1</span>][<span class="number">1</span>]) % mod;</span><br><span class="line">    dp[i][<span class="number">1</span>] = (a * dp[i - <span class="number">1</span>][<span class="number">1</span>] + b * dp[i - <span class="number">1</span>][<span class="number">0</span>] + c * dp[i - <span class="number">1</span>][<span class="number">2</span>]) % mod;</span><br><span class="line">    dp[i][<span class="number">2</span>] = (a * dp[i - <span class="number">1</span>][<span class="number">2</span>] + b * dp[i - <span class="number">1</span>][<span class="number">1</span>] + c * dp[i - <span class="number">1</span>][<span class="number">0</span>]) % mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; dp[n][<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 计数dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机类加载机制</title>
      <link href="2020/08/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.html"/>
      <url>2020/08/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>虚拟机把描述类的数据从 Class 文件<strong>加载到内存</strong>，井对数据进行<strong>校验</strong>、转换<strong>解析</strong>和<strong>初始化</strong>，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。</p><h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>类从被加载到虚拟机内存中开始，到卸栽出内存为止，它的整个生命周期包括了：加载、验证、准备、解析、初始化、使用和卸载七个阶段。其中验证、准备和解析三个部分统称为连接。</p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>加载是类加载过程中的一个阶段，这个阶段虚拟机要完成3件事。<br><a id="more"></a> </p><ol><li><p>通过一个类的全限定名来获取定义此类的二进制字节流。</p></li><li><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</p></li><li><p>会在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个 Class 文件获取，这里既可以从 ZIP 包中读取（比如从 jar 包和 war 包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将 JSP 文件转换成对应的 Class 类）</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>这一阶段的主要目的是为了确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，保证被加载类的正确性，不会危害虚拟机自身的安全。验证主要包含4个阶段的校验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。</p></li></ol><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。注意这里所说的初始值概念，比如一个类变量定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>实际上变量 value 在准备阶段过后的初始值为 0 而不是 123，将 value 赋值为 123 的 putstatic 指令是程序被编译后，存放于类构造器方法之中。</p><p>但是注意如果声明为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>在编译阶段会为 value 生成 ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 属性将 value 赋值为 123。</p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是在 class 文件中以： CONSTANT_Class_info、CONSTANT_Field_info<br>、CONSTANT_Method_info等类型的常量出现。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由 JVM 主导。到了初始阶段，才开始真正执行类中定义的 Java 程序代码。</p><p>那么，什么时候开始初始化？</p><p>使用 new 该类实例化对象的时候；</p><p>读取或设置类静态字段的时候（但被final修饰的字段，在编译器时就被放入常量池的静态字段除外static final）；</p><p>调用类静态方法的时候；</p><p>使用反射 Class.forName(“xxxx”) 对类进行反射调用的时候，该类需要初始化；</p><p>初始化一个类的时候，有父类，先初始化父类（注：1. 接口除外，父接口在调用的时候才会被初始化；2.子类引用父类静态字段，只会引发父类初始化）；</p><p>被标明为启动类的类（即包含main()方法的类）要初始化；</p><p>当使用 JDK1.7 的动态语言支持时，如果一个 java.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</p><p>以上情况称为对一个类进行主动引用，且有且只要以上几种情况需要对类进行初始化。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现kth_element</title>
      <link href="2020/08/%E5%AE%9E%E7%8E%B0kth-element.html"/>
      <url>2020/08/%E5%AE%9E%E7%8E%B0kth-element.html</url>
      
        <content type="html"><![CDATA[<p>快排的思想，选定一个基准数，将大于 $mid$ 的数放到右边，小于的放到左边，然后比较 $mid$ 和 $k$ 的位置，递归重复操作即可。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">&quot;Ofast&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&lt;!--more--&gt; </span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">0</span>, w = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> c = getchar();</span><br><span class="line">  <span class="keyword">while</span> (c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) w ^= <span class="number">1</span>;</span><br><span class="line">    c = getchar();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (c &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; c &gt;= <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">    x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    c = getchar();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> w &amp; <span class="number">1</span> ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kth_element</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> mid = l - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; r; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] &lt; a[r] &amp;&amp; a[i] ^ a[++mid]) a[i] ^= a[mid] ^= a[i] ^= a[mid];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (a[++mid] ^ a[r]) a[mid] ^= a[r] ^= a[mid] ^= a[r];</span><br><span class="line">  <span class="keyword">if</span> (mid == k) <span class="keyword">return</span> a[mid];</span><br><span class="line">  <span class="keyword">return</span> (mid &gt;= k) ? kth_element(a, l, mid - <span class="number">1</span>, k)</span><br><span class="line">                    : kth_element(a, mid + <span class="number">1</span>, r, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">2000006</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, k;</span><br><span class="line">  n = read();</span><br><span class="line">  k = read();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) a[i] = read();</span><br><span class="line">  <span class="comment">// random_shuffle(a, a + n);</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, kth_element(a, <span class="number">0</span>, n - <span class="number">1</span>, n - k));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：队列之和</title>
      <link href="2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E9%98%9F%E5%88%97%E4%B9%8B%E5%92%8C.html"/>
      <url>2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E9%98%9F%E5%88%97%E4%B9%8B%E5%92%8C.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两个队列$a$和$b$，问你能否构造出给定的队列$c$。</p><h2 id="Solutuon"><a href="#Solutuon" class="headerlink" title="Solutuon"></a>Solutuon</h2><p>很经典的动态规划，$dp[i][j]$ 表示第一个队列的前 $i$ 个数和第二个队列的第 $j$ 个数能否组成第三个队列的前 $i+j$ 个数。状态转移方程：$dp[i][j] = (dp[i - 1][j]$ $and$ $a[i] == c[i + j]$ $or$ $dp[i][j - 1]$ $and$ $b[j] == c[i + j])$。<br><a id="more"></a> </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1005</span>][<span class="number">1005</span>], T, A, B, a[<span class="number">1005</span>], b[<span class="number">1005</span>], c[<span class="number">2005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;A, &amp;B);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= A; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= B; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= A + B; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c[i]);</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">1</span>; t &lt;= A + B; t++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= A; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = t - i;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; <span class="number">0</span> || j &gt; B) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; c[t] == a[i] &amp;&amp; dp[i - <span class="number">1</span>][j]) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (j &amp;&amp; c[t] == b[j] &amp;&amp; dp[i][j - <span class="number">1</span>]) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dp[A][B])</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;possible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;not possible&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杭电多校：Tree</title>
      <link href="2020/08/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%EF%BC%9ATree.html"/>
      <url>2020/08/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%EF%BC%9ATree.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一颗树，路径只能由父节点指向子节点，你可以增加一条有向边，使得联通点对最多。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>容易发现，当叶子结点往根结点连一条边时，增加的点对会是最多的。$dp1[i]$ 表示从 $i$ 结点出发可以到达多少点，$dp2[i]$ 表示当前以 $i$ 为根结点，能增加的最大点对数（最大值）。<br><a id="more"></a> </p><p>对于 $dp1[i]$，状态转移方程：$dp1[fa] += dp1[son]$。</p><p>对于 $dp2[i]$，状态转移方程：$ for All(son): dp2[fa] = max(dp2[fa], dp2[son]), dp2[fa] += n - dp1[fa]$。</p><p>$sum(dp1)$ 即为不加边的点对数和，$dp2[1]$ 得到的即为增加一条边能增加的最大点对数。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"><span class="keyword">int</span> t, n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> res, dp1[N], dp2[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">  dp1[u] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> v : g[u]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">    dfs(v, u);</span><br><span class="line">    dp2[u] = max(dp2[u], dp2[v]);</span><br><span class="line">    dp1[u] += dp1[v];</span><br><span class="line">  &#125;</span><br><span class="line">  dp2[u] += n - dp1[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">  <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      g[i].clear();</span><br><span class="line">      dp1[i] = <span class="number">0</span>;</span><br><span class="line">      dp2[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> x;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">      g[x].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res += dp1[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res + dp2[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 多校训练 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多校训练 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：高度不超过m的二叉树个数</title>
      <link href="2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E9%AB%98%E5%BA%A6%E4%B8%8D%E8%B6%85%E8%BF%87m%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AA%E6%95%B0.html"/>
      <url>2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E9%AB%98%E5%BA%A6%E4%B8%8D%E8%B6%85%E8%BF%87m%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AA%E6%95%B0.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>求 $n$ 个节点，高度不超过 $h$ 的二叉树的个数，结果模 $1e9 + 7$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><a id="more"></a> <p>定义 $f[i][j]$ 为 $i$ 个点组成高度不超过 $j$ 的二叉树的数量，则得到状态转移方程：$f[i][j] = f[k][j-1] * f[i-k-1][j-1]$，表示即选出一个根节点，两边子树高度不超过 $j - 1$ 的数量，初始状态为 $f[0][i] = 1$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, h;</span><br><span class="line">ll f[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;h);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) f[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; k++)</span><br><span class="line">        f[i][j] = (f[i][j] + f[k][j - <span class="number">1</span>] * f[i - k - <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, f[n][h]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 计数dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：完美对物品</title>
      <link href="2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%AE%8C%E7%BE%8E%E5%AF%B9%E7%89%A9%E5%93%81.html"/>
      <url>2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%AE%8C%E7%BE%8E%E5%AF%B9%E7%89%A9%E5%93%81.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>$n$ 个物体，每个物品都有 $k$ 个属性，实际上就是 $a[n][k]$ 的数组，满足 $a[i][0]+a[j][0]=a[i][1]+a[j][1]=…=a[i][k−1]+a[j][k−1]$ 的物体 $i$ 和物体 $j$ 称为一对完美对，求完美对对数。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><a id="more"></a> <p>公式变形：$x1 + y1 = x2 + y2 -&gt; x1-x2 = -(y1-y2)$，用一个 $map(vector, int)$ 来记录每件物品的差值即可，然后去 $map$ 里面查找有几个正好是相反数 $vector$，累加答案即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">15</span>];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, k, res = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++) </span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; a[j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= k; j++) &#123;</span><br><span class="line">      g.push_back(a[j] - a[j - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    res += mp[g];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; g.size(); j++) &#123;</span><br><span class="line">      g[j] = -g[j];</span><br><span class="line">    &#125;</span><br><span class="line">    mp[g]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：Optimal Sum</title>
      <link href="2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AOptimal-Sum.html"/>
      <url>2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AOptimal-Sum.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你长度为 $n$ 的序列，你有一种能力可以将序列中的任意一个数变为相反数，在你不超过 $k$ 次使用能力的情况下，长度为 $len$ 的子区间的和的绝对值的最大值是多少？</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>用两个multiset维护区间前k大的负数，扫一遍就好了，细节略多。<br><a id="more"></a> </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, len, k;</span><br><span class="line">ll x1, x2, a[<span class="number">200005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll sum = <span class="number">0</span>, ma = <span class="number">-1e18</span>;</span><br><span class="line">  <span class="built_in">multiset</span>&lt;ll&gt; s1, s2;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] &gt;= <span class="number">0</span>)</span><br><span class="line">      sum += a[i];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s1.size() &lt; k) &#123;</span><br><span class="line">      s1.insert(a[i]);</span><br><span class="line">      sum -= a[i];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &amp;&amp; a[i] &lt; *(--s1.end())) &#123;</span><br><span class="line">      ll x = *(--s1.end());</span><br><span class="line">      sum += <span class="number">2</span> * x;</span><br><span class="line">      s1.erase(--s1.end());</span><br><span class="line">      s2.insert(x);</span><br><span class="line">      s1.insert(a[i]);</span><br><span class="line">      sum -= a[i];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      s2.insert(a[i]);</span><br><span class="line">      sum += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> j = i - len;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j] &gt;= <span class="number">0</span>)</span><br><span class="line">        sum -= a[j];</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (s1.find(a[j]) != s1.end()) &#123;</span><br><span class="line">        s1.erase(s1.find(a[j]));</span><br><span class="line">        sum += a[j];</span><br><span class="line">        <span class="keyword">if</span> (s2.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          ll x = *(s2.begin());</span><br><span class="line">          s1.insert(x);</span><br><span class="line">          s2.erase(s2.begin());</span><br><span class="line">          sum -= <span class="number">2</span> * x;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s2.erase(s2.find(a[j]));</span><br><span class="line">        sum -= a[j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt;= <span class="number">0</span>) ma = max(ma, sum);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ma;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;len);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">  x1 = solve();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = -a[i];</span><br><span class="line">  x2 = solve();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, max(x1, x2));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：异或</title>
      <link href="2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%BC%82%E6%88%96.html"/>
      <url>2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%BC%82%E6%88%96.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定整数 $m$ 以及 $n$ 各数字 $A_1,A_2,..A_n$，将数列 $A$ 中所有元素两两异或，共能得到 $n(n-1)/2$ 个结果，请求出这些结果中大于 $m$ 的有多少个。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>为了避免重复计算，字典树可以边维护边插入，先查询之前有多少个数与当前数 $x$ 异或和大于 $m$，我们从高位向低位枚举，对于两个数的同一个二进制位，需要分四种情况讨论：<br><a id="more"></a> </p><ol><li><p>$x_i = 1, m_i = 1$，则查询的数当前位必须为 $0$ 才可。</p></li><li><p>$x_i = 0, m_i = 1$，则查询的数当前位必须为 $1$ 才可。</p></li><li><p>$x_i = 1, m_i = 0$，则查询数当前位为 $0$ 的直接满足条件计入答案，当前位为 $1$ 的继续向下查找。</p></li><li><p>$x_i = 0, m_i = 0$，则查询数当前位为 $1$ 的直接满足条件计入答案，当前位为 $0$ 的继续向下查找。</p></li></ol><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">6e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, m, idx, cnt[N], trie[N][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p = <span class="number">0</span>, y;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; ~i; i--) &#123;</span><br><span class="line">    y = x &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;s = trie[p][y];</span><br><span class="line">    <span class="keyword">if</span> (!s) s = ++idx;</span><br><span class="line">    p = s;</span><br><span class="line">    cnt[p]++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p = <span class="number">0</span>, p1, sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; ~i; i--) &#123;</span><br><span class="line">    <span class="keyword">int</span> y = x &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> z = m &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="number">1</span> &amp;&amp; z == <span class="number">1</span>) &#123;</span><br><span class="line">      p = trie[p][<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y == <span class="number">0</span> &amp;&amp; z == <span class="number">1</span>) &#123;</span><br><span class="line">      p = trie[p][<span class="number">1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y == <span class="number">1</span> &amp;&amp; z == <span class="number">0</span>) &#123;</span><br><span class="line">      p1 = trie[p][<span class="number">0</span>];</span><br><span class="line">      p = trie[p][<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span> (p1) sum += cnt[p1];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y == <span class="number">0</span> &amp;&amp; z == <span class="number">0</span>) &#123;</span><br><span class="line">      p1 = trie[p][<span class="number">1</span>];</span><br><span class="line">      p = trie[p][<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">if</span> (p1) sum += cnt[p1];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    res += query(x);</span><br><span class="line">    insert(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字典树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim配置</title>
      <link href="2020/08/Vim%E9%85%8D%E7%BD%AE.html"/>
      <url>2020/08/Vim%E9%85%8D%E7%BD%AE.html</url>
      
        <content type="html"><![CDATA[<p>写C++还是用vim爽啊，曾经三次尝试vim，寒假的时候终于能得到一份比较不错的配置了。</p><p>配色用的是atom的onedark，个人感觉挺好看的。</p><p><img src="http://img.benboby.top/%E7%95%8C%E9%9D%A2.png" alt></p><p>贴个配置，即开即用。</p><a id="more"></a> <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&quot; Vundle set nocompatible</span></span><br><span class="line"><span class="keyword">filetype</span> off</span><br><span class="line"><span class="keyword">set</span> rtp+=~/.<span class="keyword">vim</span>/bundle/Vundle.<span class="keyword">vim</span></span><br><span class="line"><span class="keyword">call</span> vundle#begin()</span><br><span class="line">Plugin <span class="string">&#x27;VundleVim/Vundle.vim&#x27;</span></span><br><span class="line">Plugin <span class="string">&#x27;gdbmgr&#x27;</span></span><br><span class="line">Plugin <span class="string">&#x27;The-NERD-Tree&#x27;</span> <span class="comment">&quot; 目录树</span></span><br><span class="line">Plugin <span class="string">&#x27;mbbill/undotree&#x27;</span> <span class="comment">&quot; 撤回树</span></span><br><span class="line">Plugin <span class="string">&#x27;majutsushi/tagbar&#x27;</span> <span class="comment">&quot; 函数、变量名</span></span><br><span class="line">Plugin <span class="string">&#x27;vim-airline/vim-airline&#x27;</span> <span class="comment">&quot; 状态栏</span></span><br><span class="line">Plugin <span class="string">&#x27;vim-airline/vim-airline-themes&#x27;</span> <span class="comment">&quot;状态栏</span></span><br><span class="line">Plugin <span class="string">&#x27;arzg/vim-colors-xcode&#x27;</span>  <span class="comment">&quot; xcode 主题</span></span><br><span class="line"><span class="string">&quot;Plugin &#x27;cohlin/vim-colorschemes&#x27; &quot;</span> xcode 主题</span><br><span class="line">Plugin <span class="string">&#x27;tomasr/molokai&#x27;</span> <span class="comment">&quot; molokai 主题</span></span><br><span class="line">Plugin <span class="string">&#x27;ashfinal/vim-colors-violet&#x27;</span> <span class="comment">&quot; violet 主题</span></span><br><span class="line">Plugin <span class="string">&#x27;joshdick/onedark.vim&#x27;</span> <span class="comment">&quot; onedark主题</span></span><br><span class="line">Plugin <span class="string">&#x27;sheerun/vim-polyglot&#x27;</span> <span class="comment">&quot; 语法突出显示</span></span><br><span class="line">Plugin <span class="string">&#x27;jiangmiao/auto-pairs&#x27;</span> <span class="comment">&quot; 括号补全</span></span><br><span class="line">Plugin <span class="string">&#x27;iamcco/mathjax-support-for-mkdp&#x27;</span> <span class="comment">&quot; 数学公式</span></span><br><span class="line">Plugin <span class="string">&#x27;plasticboy/vim-markdown&#x27;</span>  <span class="comment">&quot; markdown预览</span></span><br><span class="line">Plugin <span class="string">&#x27;iamcco/markdown-preview.vim&#x27;</span> <span class="comment">&quot; markdown预览</span></span><br><span class="line">Plugin <span class="string">&#x27;Valloric/YouCompleteMe&#x27;</span> <span class="comment">&quot; 代码补全</span></span><br><span class="line">Plugin <span class="string">&#x27;zxqfl/tabnine-vim&#x27;</span> <span class="comment">&quot;代码补全</span></span><br><span class="line">Plugin <span class="string">&#x27;tpope/vim-commentary&#x27;</span> <span class="comment">&quot; 代码注释</span></span><br><span class="line">Plugin <span class="string">&#x27;sillybun/vim-repl&#x27;</span>   <span class="comment">&quot; 代码调试</span></span><br><span class="line">Plugin <span class="string">&#x27;w0rp/ale&#x27;</span> <span class="comment">&quot; 语法纠错</span></span><br><span class="line"><span class="string">&quot;Plugin &#x27;octol/vim-cpp-enhanced-highlight&#x27; &quot;</span> <span class="keyword">c</span>++语法高亮</span><br><span class="line">Plugin <span class="string">&#x27;TagHighlight&#x27;</span> <span class="comment">&quot; c++语法高亮</span></span><br><span class="line">Plugin <span class="string">&#x27;Shougo/echodoc.vim&#x27;</span> <span class="comment">&quot; c++函数提示</span></span><br><span class="line">Plugin <span class="string">&#x27;rhysd/vim-clang-format&#x27;</span> <span class="comment">&quot; 代码格式化</span></span><br><span class="line">Plugin <span class="string">&#x27;Chiel92/vim-autoformat&#x27;</span> <span class="comment">&quot; c++代码格式化</span></span><br><span class="line">Plugin <span class="string">&#x27;scrooloose/nerdcommenter&#x27;</span> <span class="comment">&quot; c++代码注释</span></span><br><span class="line">Plugin <span class="string">&#x27;artur-shaik/vim-javacomplete2&#x27;</span> <span class="comment">&quot; java代码补全</span></span><br><span class="line">Plugin <span class="string">&#x27;python-mode/python-mode&#x27;</span>  <span class="comment">&quot; python mode</span></span><br><span class="line">Plugin <span class="string">&#x27;fatih/vim-go&#x27;</span>  <span class="comment">&quot; go语言</span></span><br><span class="line">Plugin <span class="string">&#x27;terryma/vim-multiple-cursors&#x27;</span> <span class="comment">&quot; vim 多行编辑</span></span><br><span class="line">Plugin <span class="string">&#x27;mhinz/vim-startify&#x27;</span> <span class="comment">&quot; 欢迎界面</span></span><br><span class="line"><span class="keyword">call</span> vundle#end()</span><br><span class="line"><span class="keyword">filetype</span> plugin <span class="built_in">indent</span> <span class="keyword">on</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> backspace=<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; javacomplete2</span></span><br><span class="line"><span class="comment">&quot; https://github.com/artur-shaik/vim-javacomplete2</span></span><br><span class="line"><span class="keyword">autocmd</span> FileType java <span class="keyword">setlocal</span> omnifunc=javacomplete#Complete</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot;   TagHighlight</span></span><br><span class="line"><span class="comment">&quot; UpdateTypesFile</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; multiple cursors</span></span><br><span class="line"><span class="comment">&quot;start: &lt;C-n&gt; start multicursor and add a virtual cursor + selection on the match</span></span><br><span class="line"><span class="comment">&quot;next: &lt;C-n&gt; add a new virtual cursor + selection on the next match</span></span><br><span class="line"><span class="comment">&quot;skip: &lt;C-x&gt; skip the next match</span></span><br><span class="line"><span class="comment">&quot;prev: &lt;C-p&gt; remove current virtual cursor + selection and go back on previous match</span></span><br><span class="line"><span class="comment">&quot;select all: &lt;A-n&gt; start multicursor and directly select all matches</span></span><br><span class="line"><span class="comment">&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; plugin nerdcommenter</span></span><br><span class="line"><span class="keyword">let</span> mapleader = <span class="string">&quot;,&quot;</span></span><br><span class="line"><span class="keyword">let</span> NERDSpaceDelims=<span class="number">1</span>           <span class="comment">&quot; 让注释符与语句之间留一个空格</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDDefaultAlign</span> = <span class="string">&#x27;left&#x27;</span>  <span class="comment">&quot;将行注释符左对齐</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; auto save</span></span><br><span class="line"><span class="string">&quot; let g:auto_save = 5  &quot;</span> enable AutoSave <span class="keyword">on</span> Vim startup</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; plugin undotree</span></span><br><span class="line"><span class="comment">&quot; :UndotreeToggle</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; plugin NERDTree</span></span><br><span class="line"><span class="comment">&quot; :NERDTreeToggle</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; plugin tarbar</span></span><br><span class="line"><span class="comment">&quot; :TagbarToggle</span></span><br><span class="line"><span class="comment">&quot;</span></span><br><span class="line"><span class="comment">&quot; plugin autoformat</span></span><br><span class="line"><span class="comment">&quot; :Autoformat</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:autoformat_verbosemode</span>=<span class="number">1</span> <span class="comment">&quot;开启详细模式便于查错</span></span><br><span class="line"><span class="comment">&quot; c++</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:formatdef_clangformat_google</span> = <span class="string">&#x27;&quot;clang-format -style google -&quot;&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:formatters_cpp</span> = [<span class="string">&#x27;clangformat_google&#x27;</span>]</span><br><span class="line"><span class="comment">&quot; python</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:formatdef_autopep8</span> = <span class="string">&quot;&#x27;autopep8 - --range &#x27;.a:firstline.&#x27; &#x27;.a:lastline&quot;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:formatters_python</span> = [<span class="string">&#x27;autopep8&#x27;</span>]</span><br><span class="line"><span class="comment">&quot; java</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:formatdef_astyle_java</span> = <span class="string">&#x27;&quot;astyle --mode=java --style=google -pcHs2&quot;&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:formatdef_java</span> = [<span class="string">&#x27;astyle_java&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; plugin echodoc</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:echodoc</span>#type = <span class="string">&quot;echo&quot;</span> <span class="comment">&quot; Default value</span></span><br><span class="line"><span class="keyword">set</span> noshowmode</span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:echodoc_enable_at_startup</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; plugin YCM</span></span><br><span class="line"><span class="comment">&quot;let g:ycm_global_ycm_extra_conf=&#x27;~/.ycm_extra_conf.py&#x27;</span></span><br><span class="line"><span class="comment">&quot;set completeopt=menu</span></span><br><span class="line"><span class="comment">&quot; YouCompleteMe</span></span><br><span class="line"><span class="keyword">set</span> runtimepath+=~/.<span class="keyword">vim</span>/bundle/YouCompleteMe</span><br><span class="line"><span class="keyword">set</span> completeopt=longest,<span class="keyword">menu</span>    <span class="comment">&quot;让Vim的补全菜单行为与一般IDE一致(参考VimTip1228)</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_collect_identifiers_from_tags_files</span> = <span class="number">1</span>           <span class="comment">&quot; 开启 YCM 基于标签引擎</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_collect_identifiers_from_comments_and_strings</span> = <span class="number">1</span> <span class="comment">&quot; 注释与字符串中的内容也用于补全</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:syntastic_ignore_files</span>=[<span class="string">&quot;.*\.py$&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_seed_identifiers_with_syntax</span> = <span class="number">1</span>                  <span class="comment">&quot; 语法关键字补全</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_complete_in_comments</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_confirm_extra_conf</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_key_list_select_completion</span> = [<span class="string">&#x27;&lt;c-n&gt;&#x27;</span>, <span class="string">&#x27;&lt;Down&gt;&#x27;</span>]  <span class="comment">&quot; 映射按键, 没有这个会拦截掉tab, 导致其他插件的tab不能用.</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_key_list_previous_completion</span> = [<span class="string">&#x27;&lt;c-p&gt;&#x27;</span>, <span class="string">&#x27;&lt;Up&gt;&#x27;</span>]</span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_complete_in_comments</span> = <span class="number">1</span>                          <span class="comment">&quot; 在注释输入中也能补全</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_complete_in_strings</span> = <span class="number">1</span>                           <span class="comment">&quot; 在字符串输入中也能补全</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_collect_identifiers_from_comments_and_strings</span> = <span class="number">1</span> <span class="comment">&quot; 注释和字符串中的文字也会被收入补全</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_global_ycm_extra_conf</span>=<span class="string">&#x27;~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_show_diagnostics_ui</span> = <span class="number">0</span>                           <span class="comment">&quot; 禁用语法检查</span></span><br><span class="line"><span class="comment">&quot; 回车即选中当前项</span></span><br><span class="line"><span class="keyword">inoremap</span> <span class="symbol">&lt;expr&gt;</span> <span class="symbol">&lt;CR&gt;</span> <span class="built_in">pumvisible</span>() ? <span class="string">&quot;\&lt;C-y&gt;&quot;</span> : <span class="string">&quot;\&lt;CR&gt;&quot;</span> |</span><br><span class="line"><span class="comment">&quot; 跳转到定义处</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;c-j&gt;</span> :YcmCompleter GoToDefinitionElseDeclaration<span class="symbol">&lt;CR&gt;</span>|</span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_min_num_of_chars_for_completion</span>=<span class="number">2</span>                 <span class="comment">&quot; 从第2个键入字符就开始罗列匹配项</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot;disable ycm 语法检查</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_enable_diagnostic_signs</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_enable_diagnostic_highlighting</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_error_symbol</span> = <span class="string">&#x27;K&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_warning_symbol</span> = <span class="string">&#x27;O&#x27;</span></span><br><span class="line"><span class="comment">&quot; plugin vim-markdown 自动折叠关闭</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:vim_markdown_folding_disabled</span>=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot;auto-format 格式化</span></span><br><span class="line"><span class="comment">&quot;F5自动格式化代码并保存</span></span><br><span class="line"><span class="comment">&quot;自动格式化代码，针对所有支持的文件</span></span><br><span class="line"><span class="comment">&quot;au BufWrite * :Autoformat</span></span><br><span class="line"><span class="comment">&quot;自动格式化python代码</span></span><br><span class="line"><span class="comment">&quot;au BufWrite *.py :Autoformatet g:autoformat_verbosemode=1</span></span><br><span class="line"><span class="comment">&quot;默认情况下是pep8，还可以选择google,facebook和chromium</span></span><br><span class="line"><span class="comment">&quot;let g:formatter_yapf_style = &#x27;google&#x27;</span></span><br><span class="line"><span class="string">&quot;let g:formatdef_my_cpp = &#x27;&quot;</span>astyle --style=webkit<span class="comment">&quot;&#x27;</span></span><br><span class="line"><span class="comment">&quot;let g:formatters_cpp = [&#x27;my_cpp&#x27;]</span></span><br><span class="line"><span class="comment">&quot;au BufWrite * :Autoformat</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; 代码调试快捷键</span></span><br><span class="line"><span class="keyword">autocmd</span> Filetype <span class="keyword">python</span> <span class="keyword">nnoremap</span> <span class="symbol">&lt;F12&gt;</span> <span class="symbol">&lt;Esc&gt;</span>:REPLDebugStopAtCurrentLine<span class="symbol">&lt;Cr&gt;</span></span><br><span class="line"><span class="keyword">autocmd</span> Filetype <span class="keyword">python</span> <span class="keyword">nnoremap</span> <span class="symbol">&lt;F10&gt;</span> <span class="symbol">&lt;Esc&gt;</span>:REPLPDBN<span class="symbol">&lt;Cr&gt;</span></span><br><span class="line"><span class="keyword">autocmd</span> Filetype <span class="keyword">python</span> <span class="keyword">nnoremap</span> <span class="symbol">&lt;F11&gt;</span> <span class="symbol">&lt;Esc&gt;</span>:REPLPDBS<span class="symbol">&lt;Cr&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; Let clangd fully control code completion</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_clangd_uses_ycmd_caching</span> = <span class="number">0</span></span><br><span class="line"><span class="comment">&quot; Use installed clangd, not YCM-bundled clangd which doesn&#x27;t get updates.</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_clangd_binary_path</span> = exepath(<span class="string">&quot;clangd&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot;目录树</span></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;F2&gt;</span> :NERDTreeToggle<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot;Python缩进</span></span><br><span class="line"><span class="keyword">autocmd</span> FileType <span class="keyword">python</span> <span class="keyword">set</span> tabstop=<span class="number">4</span> | <span class="keyword">set</span> expandtab | <span class="keyword">set</span> autoindent</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; plugin airline</span></span><br><span class="line"><span class="keyword">set</span> laststatus=<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; plugin ale</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ale_linters</span> = &#123;</span><br><span class="line">      \   <span class="string">&#x27;cpp&#x27;</span>: [<span class="string">&#x27;gcc&#x27;</span>],</span><br><span class="line">      \&#125;</span><br><span class="line"><span class="comment">&quot;始终开启标志列</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ale_sign_column_always</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ale_set_highlights</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ale_echo_msg_format</span> = <span class="string">&#x27;ale[%linter%] %code: %%s&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ale_cpp_gcc_executable</span> = <span class="string">&#x27;/usr/local/bin/g++-9 -I /usr/local/Cellar/eigen/3.3.7/include/eigen3&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ale_sign_error</span> = <span class="string">&#x27;✗&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ale_sign_warning</span> = <span class="string">&#x27;⚡&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ale_lint_on_text_changed</span> = <span class="string">&#x27;always&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; 语法高亮</span></span><br><span class="line"><span class="keyword">let</span> c_no_curly_error = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:cpp_class_scope_highlight</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:cpp_member_variable_highlight</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:cpp_class_decl_highlight</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:cpp_experimental_simple_template_highlight</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:cpp_experimental_template_highlight</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:cpp_concepts_highlight</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">&quot;let g:cpp_no_function_highlight=1</span></span><br><span class="line"><span class="keyword">syntax</span> <span class="keyword">on</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; 主题</span></span><br><span class="line"><span class="comment">&quot;colorscheme xcode-default</span></span><br><span class="line"><span class="comment">&quot;colorscheme molokai</span></span><br><span class="line"><span class="comment">&quot;colorscheme violet</span></span><br><span class="line"><span class="keyword">colorscheme</span> onedark</span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:rehash256</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">set</span> cursorline    <span class="comment">&quot;or set cul 设置光标所在的行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> et <span class="comment">&quot;tab用空格替换</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> tabstop=<span class="number">2</span></span><br><span class="line"><span class="keyword">set</span> expandtab</span><br><span class="line"><span class="comment">&quot; Tab键的宽度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> softtabstop=<span class="number">2</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">shiftwidth</span>=<span class="number">2</span></span><br><span class="line"><span class="comment">&quot;  统一缩进为2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">number</span></span><br><span class="line"><span class="comment">&quot; 显示行号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">history</span>=<span class="number">10000</span></span><br><span class="line"><span class="comment">&quot; 历史纪录数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> hlsearch</span><br><span class="line"><span class="keyword">set</span> incsearch</span><br><span class="line"><span class="comment">&quot; 搜索逐字符高亮</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> encoding=utf-<span class="number">8</span></span><br><span class="line"><span class="keyword">set</span> fileencodings=utf-<span class="number">8</span>,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936,utf-<span class="number">16</span>,big5,euc-jp,latin1</span><br><span class="line"><span class="comment">&quot; 编码设置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; set mouse=a</span></span><br><span class="line"><span class="comment">&quot; use mouse</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> langmenu=zn_CN.UTF-<span class="number">8</span></span><br><span class="line"><span class="keyword">set</span> helplang=<span class="keyword">cn</span></span><br><span class="line"><span class="comment">&quot; 语言设置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> laststatus=<span class="number">2</span></span><br><span class="line"><span class="comment">&quot; 总是显示状态行 就是那些显示 --insert-- 的怪东西</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> showcmd</span><br><span class="line"><span class="comment">&quot; 在状态行显示目前所执行的命令，未完成的指令片段亦会显示出来</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> scrolloff=<span class="number">3</span></span><br><span class="line"><span class="comment">&quot; 光标移动到buffer的顶部和底部时保持3行距离</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> showmatch</span><br><span class="line"><span class="comment">&quot; 高亮显示对应的括号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> matchtime=<span class="number">1</span></span><br><span class="line"><span class="comment">&quot; 对应括号高亮的时间（单位是十分之一秒）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; 共享剪切板</span></span><br><span class="line"><span class="keyword">set</span> clipboard=unnamed</span><br><span class="line"><span class="keyword">set</span> norelativenumber</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &amp;t_SI.=<span class="string">&quot;\e[5 q&quot;</span> <span class="comment">&quot;SI = INSERT mode</span></span><br><span class="line"><span class="keyword">let</span> &amp;t_SR.=<span class="string">&quot;\e[4 q&quot;</span> <span class="comment">&quot;SR = REPLACE mode</span></span><br><span class="line"><span class="keyword">let</span> &amp;t_EI.=<span class="string">&quot;\e[1 q&quot;</span> <span class="comment">&quot;EI = NORMAL mode (ELSE)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:syntastic_cpp_compiler_options</span> = <span class="string">&#x27; -std=c++11 -stdlib=libc++&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; c++ 路径</span></span><br><span class="line"><span class="keyword">set</span> path=.,/usr/local/bin/g++-<span class="number">9</span>,/usr/local/include/<span class="keyword">c</span>++/<span class="number">9.3</span>.<span class="number">0</span>,/usr/local/Cellar/eigen/<span class="number">3.3</span>.<span class="number">7</span>/include/eigen3,/usr/local/Cellar/boost/<span class="number">1.72</span>.<span class="number">0</span>/include,/usr/local/Cellar/gcc/<span class="number">9.2</span>.<span class="number">0</span>_1/include/<span class="keyword">c</span>++/<span class="number">9.2</span>.<span class="number">0</span>,/usr/local/Cellar/gcc/<span class="number">9.2</span>.<span class="number">0</span>_1/include/<span class="keyword">c</span>++/<span class="number">9.2</span>.<span class="number">0</span>/x86_64-apple-darwin19,/usr/local/Cellar/gcc/<span class="number">9.2</span>.<span class="number">0</span>_1/include/<span class="keyword">c</span>++/<span class="number">9.2</span>.<span class="number">0</span>/backward,/usr/local/Cellar/gcc/<span class="number">9.2</span>.<span class="number">0</span>_1/lib/gcc/<span class="number">9</span>/gcc/x86_64-apple-darwin19/<span class="number">9.2</span>.<span class="number">0</span>/include,/usr/local/Cellar/gcc/<span class="number">9.2</span>.<span class="number">0</span>_1/lib/gcc/<span class="number">9</span>/gcc/x86_64-apple-darwin19/<span class="number">9.2</span>.<span class="number">0</span>/include-fixed,/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include,/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/System/Library/Frameworks,</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：数数</title>
      <link href="2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%95%B0%E6%95%B0.html"/>
      <url>2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%95%B0%E6%95%B0.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="http://img.benboby.top/%E9%A2%98%E7%9B%AE.png" alt></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p><img src="http://img.benboby.top/%E9%A2%98%E8%A7%A3.png" alt><br><a id="more"></a> </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> ll M = <span class="number">1e7</span>;</span><br><span class="line">ll t, n, ans1, ans2, x, p[M + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qp</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            ans = (ans * a) % mod;</span><br><span class="line">        a = (a * a) % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt;= M; i++)</span><br><span class="line">        p[i] = (p[i - <span class="number">1</span>] * i) % mod;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;t))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (t--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">            ans1 = <span class="number">0</span>, ans2 = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                x = (n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                ans1 = (((x * n) % mod) * ((x * n) % mod)) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                x = n / <span class="number">2</span>;</span><br><span class="line">                ans1 = (((x * (n + <span class="number">1</span>)) % mod) * ((x * (n + <span class="number">1</span>)) % mod)) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            ans2 = qp(p[n], <span class="number">2</span> * n);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>, ans1, ans2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode440：字典序的第K小数字</title>
      <link href="2020/08/LeetCode440%EF%BC%9A%E5%AD%97%E5%85%B8%E5%BA%8F%E7%9A%84%E7%AC%ACK%E5%B0%8F%E6%95%B0%E5%AD%97.html"/>
      <url>2020/08/LeetCode440%EF%BC%9A%E5%AD%97%E5%85%B8%E5%BA%8F%E7%9A%84%E7%AC%ACK%E5%B0%8F%E6%95%B0%E5%AD%97.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定整数 n 和 k，找到 1 到 n 中字典序第 k 小的数字。</p><p>注意：1 ≤ k ≤ n ≤ 10^9。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><a id="more"></a> <p>我们可以把每个字符看作是字符串，这样我们只需要考虑前缀即可。显然最小的字符串一定是0，然后是所有以1开头的数。。。</p><p>我们只需要枚举所有首位数字 $1-9$，计算每个前缀在区间 $[0, n]$ 内有多少个数就好了，当累加和超过 $n$ 时，说明答案一定是以这个首位数字开头的，然后向下枚举。比如当以得知答案以3开头时，扣除3本身，然后向下枚举前缀30,31重复上述操作。。。直到 $k$ 为0。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get_Count</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">long</span> x, <span class="keyword">long</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">            sum += Math.min(n + <span class="number">1</span>, y) - x;  <span class="comment">// 如n=15,则sum+=min(16,20)-10</span></span><br><span class="line">            x *= <span class="number">10</span>;</span><br><span class="line">            y *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthNumber</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">1</span>;</span><br><span class="line">        k--; <span class="comment">// 扣除数字0</span></span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> now = get_Count(n, pre, pre + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (k &gt;= now) &#123;  <span class="comment">// 说明不在这个前缀区间里</span></span><br><span class="line">                pre++;  <span class="comment">// 找下一个字典序前缀</span></span><br><span class="line">                k -= now;  <span class="comment">// 扣除这个前缀的所有数</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 说明答案是这个前缀</span></span><br><span class="line">                pre *= <span class="number">10</span>;  <span class="comment">// 往下找</span></span><br><span class="line">                k--; <span class="comment">// 扣除当前这个数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：Functions again</title>
      <link href="2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AFunctions-again.html"/>
      <url>2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AFunctions-again.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p><img src="http://img.benboby.top/fomula.png" alt></p><p>给定数组，求上述式子的最大值。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><a id="more"></a> <p>可以看出，上述式子是交替加减求最大子段和。预处理两项差的绝对值，那么只需要枚举起点是奇数位置还是偶数位置就可以了，根据贪心原则，起点肯定选正数，然后交替正负就好了，这样问题就转化成就求最大子段和了，贪心即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll a[N], b[N], d[N];</span><br><span class="line"> </span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll c[])</span> </span>&#123;</span><br><span class="line">  ll now = <span class="number">0</span>, ma = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (now &lt;= <span class="number">0</span>)</span><br><span class="line">      now = c[i];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      now += c[i];</span><br><span class="line">    ma = max(ma, now);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ma;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; a[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    ll x = llabs(a[i] - a[i - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (i &amp; <span class="number">1</span>)</span><br><span class="line">      b[i] = -x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      b[i] = x;</span><br><span class="line">    d[i] = -b[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; max(solve(b), solve(d)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode424：替换后的最长重复字符</title>
      <link href="2020/08/LeetCode424%EF%BC%9A%E6%9B%BF%E6%8D%A2%E5%90%8E%E7%9A%84%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6.html"/>
      <url>2020/08/LeetCode424%EF%BC%9A%E6%9B%BF%E6%8D%A2%E5%90%8E%E7%9A%84%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。</p><h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><p>枚举重复的字符，然后计算对应字符的能构成的最大长度，取最大值。<br><a id="more"></a> </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characterReplacement</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            List&lt;Integer&gt; l = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            l.add(-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(j) - <span class="string">&#x27;A&#x27;</span> != i) &#123;</span><br><span class="line">                    l.add(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l.size() &lt;= k + <span class="number">1</span>) &#123;</span><br><span class="line">                res = n;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            l.add(n);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = k + <span class="number">1</span>; j &lt; l.size(); j++) &#123;</span><br><span class="line">                res = Math.max(res, l.get(j) - l.get(j - k - <span class="number">1</span>) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><p>滑动窗口，一个区间满足条件的原则是$当前区间的长度&lt;=区间内出现次数最多的字符 + k$，用滑动窗口维护即可。即当满足条件时，滑动窗口拓展，右端点++；不满足时，滑动窗口平移，左右端点++。滑动窗口的长度只会不断增大，遍历结束后滑动窗口的长度即为答案。</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characterReplacement</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), res = <span class="number">0</span>, l = <span class="number">0</span>, r = <span class="number">0</span>, ma = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (r = <span class="number">0</span>; r &lt; n; r++) &#123;</span><br><span class="line">            <span class="keyword">int</span> now = s.charAt(r) - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            b[now]++;</span><br><span class="line">            ma = Math.max(ma, b[now]);</span><br><span class="line">            <span class="keyword">if</span> (ma + k &lt; r - l + <span class="number">1</span>) &#123;</span><br><span class="line">                b[s.charAt(l) - <span class="string">&#x27;A&#x27;</span>]--;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode354：俄罗斯套娃信封问题</title>
      <link href="2020/08/LeetCode354%EF%BC%9A%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98.html"/>
      <url>2020/08/LeetCode354%EF%BC%9A%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>求二维最长上升子序列</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>对第一维进行从小到大排序，然后第二维从大到小排序，对第二维做LIS即可。<br><a id="more"></a> </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="keyword">int</span>[][] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] low = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(a, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt; () &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] c1, <span class="keyword">int</span>[] c2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (c1[<span class="number">0</span>] == c2[<span class="number">0</span>]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> c2[<span class="number">1</span>] - c1[<span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> c1[<span class="number">0</span>] - c2[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (low[res] &lt; a[i][<span class="number">1</span>])</span><br><span class="line">                low[++res] = a[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> pos = Arrays.binarySearch(low, <span class="number">1</span>, res, a[i][<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line">                    pos = -pos - <span class="number">1</span>;</span><br><span class="line">                low[pos] = a[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：找出最长的超赞子字符串</title>
      <link href="2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%89%BE%E5%87%BA%E6%9C%80%E9%95%BF%E7%9A%84%E8%B6%85%E8%B5%9E%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html"/>
      <url>2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%89%BE%E5%87%BA%E6%9C%80%E9%95%BF%E7%9A%84%E8%B6%85%E8%B5%9E%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你一个字符串 s 。请返回 s 中最长的 超赞子字符串 的长度。</p><p>「超赞子字符串」需满足满足下述两个条件：</p><p>该字符串是 s 的一个非空子字符串<br><a id="more"></a><br>进行任意次数的字符交换重新排序后，该字符串可以变成一个回文字符串</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>首先，一个字符串可以重新排序得到一个回文字符串的充要条件是：对字符计数，出现奇数次的字符个数小于等于1。</p><p>由此我们可以发现：我们没有必要知道这个数字到底出现了几次，我们只需要关心它到底是出现了奇数次还是偶数次。我们用 $0,1$ 来表示出现了 $偶数/奇数$ 次，由于需要统计的字符只有 $0-9$ 十个数字，因此我们只需要一个十位的二进制数 $status$ 即可表示当前所有字符出现次数的奇偶状态，即第i位表示数字 $i$ 出现次数的奇偶性。</p><p>假设当前遇到的数字是 i ，那么更新它的状态就是 $status ^= (1 &lt;&lt; i)$ ，因为根据异或的特性，相同为0，不同为1，能够很好的实现我们需要的 $奇+奇(1+1)=偶+偶(0+0)=偶(0),奇+偶(1+0)= 偶+奇(0+1)=奇(1)$，改变对应二进制位的状态。</p><p>我们遍历字符串维护这样一个 $status$，采用数组标记的思想，$pre[status]$ 表示 $status$ 出现的最早位置。</p><p>满足超赞字符串的条件：</p><ol><li><p>再一次遇到之前已经出现过的 $status$ ，说明所有数字都出现了偶数次。（因为每一位二进制位的奇偶性都相同的话，不论都是1还是0，$奇-奇=偶-偶=偶$，都代表这些字符在中间这一段出现了偶数次，长度为 $当前位置i - 最早出现的位置pre[status]$）</p></li><li><p>与之前出现过的 $status$ 只有一个二进制位不同，说明这个不同的二进制位出现了奇数次 $(奇-偶=偶-奇=奇)$，其余的二进制位出现了偶数次，仍然满足回文字符串的条件。针对这种情况，我们只需要从 $0-9$ 枚举二进制位，然后看之前是否出现过即可，同时维护答案。</p></li></ol><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] pre = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span> &lt;&lt; <span class="number">11</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestAwesome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), status = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        Arrays.fill(pre, -<span class="number">2</span>);  <span class="comment">// pre数组初始化为-2，代表都没有出现过</span></span><br><span class="line">        pre[status] = -<span class="number">1</span>;  <span class="comment">// 最初的状态为0，代表都出现了0次（偶数次）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            status ^= <span class="number">1</span> &lt;&lt; (s.charAt(i) - <span class="string">&#x27;0&#x27;</span>);  <span class="comment">// 更新当前状态</span></span><br><span class="line">            <span class="keyword">if</span> (pre[status] != -<span class="number">2</span>) &#123;  <span class="comment">// 之前已经存在过</span></span><br><span class="line">                res = Math.max(res, i - pre[status]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 没有存在过</span></span><br><span class="line">                pre[status] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;  <span class="comment">// 枚举0-9</span></span><br><span class="line">                <span class="keyword">int</span> status1 = status ^ (<span class="number">1</span> &lt;&lt; j);  <span class="comment">// 将对应位置的奇偶性改变</span></span><br><span class="line">                <span class="keyword">if</span> (pre[status1] != -<span class="number">2</span>) &#123;  <span class="comment">// 之前是否出现过</span></span><br><span class="line">                    res = Math.max(res, i - pre[status1]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：最长有效括号</title>
      <link href="2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.html"/>
      <url>2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>栈里面存左括号的位置，当遇到右括号时：<br><a id="more"></a> </p><p>栈为空：记录这个位置，说明下一轮的合法括号可能从这里开始。</p><p>栈不为空：先弹出左括号表示匹配。</p><ul><li>此时栈为空，说明之前可能还有合法括号，用当前下标减去之前记录的那个位置。</li><li>此时栈不为空，减去当前栈顶的位置即可（最接近的没有被匹配的左括号）。</li></ul><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, last = -<span class="number">1</span>;</span><br><span class="line">        Stack&lt;Integer&gt; st = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                st.push(i);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (st.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    st.pop();</span><br><span class="line">                    <span class="keyword">if</span> (st.size() &gt; <span class="number">0</span>)</span><br><span class="line">                        res = Math.max(res, i - st.peek());</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        res = Math.max(res, i - last);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    last = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：最大得分</title>
      <link href="2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86.html"/>
      <url>2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定两个严格递增数组，从任意一个数组出发到任意一个数组结束，当遇到相同元素时可以切换到另一个数组，只能从左到右走且每个数只计算一次，求最大累计得分。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>当遇到两个数组都有的元素时可以切换，那其实从上一次遇到相同到这一次，假设中间这部分元素和是 $sum$，无非是看到底是上面这部分的 $sum$ 更大还是下面的 $sum$ 更大，然后选走罢了，如此循环下去。至于判断相同元素，提前用map记录每个元素的位置就好了。时间复杂度$O(n)$。<br><a id="more"></a> </p><p>比如: </p><p>$nums1: [2, 4, 5, 8, 10]$</p><p>$nums2: [4, 6, 8, 9]$</p><p>首先第一部分（从起点开始，碰到第一次相同）是 $sum1(nums1[2, 4]) = 6$, $sum2(nums2[4]) = 4$，选择 $max(sum1, sum2) = 6$</p><p>第二部分（第二次相同）是 $sum1(nums1[5, 8]) = 13$, $sum2(nums2[6, 8]) = 14$，选择 $max(sum1, sum2) = 14$</p><p>第三部分（一直循环到结尾也没再发现相同元素，换不了路线，故只能一直走到终点）是 $sum1(nums1[10]) = 10$, $sum2(nums2[9]) = 9$，选择 $max(sum1, sum2) = 10$</p><p>故答案为 $6 + 14 + 10 = 20$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSum</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.length, m = b.length;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; mp = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            mp.put(b[i], i);  <span class="comment">// 预处理b[i]数组的位置</span></span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>, sum1 = <span class="number">0</span>, sum2 = <span class="number">0</span>, mod = <span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sum1 += a[i];  <span class="comment">// 计算a数组这部分的和</span></span><br><span class="line">            <span class="keyword">if</span>(mp.get(a[i]) != <span class="keyword">null</span>) &#123;  <span class="comment">// 说明a[i]在b数组中也存在</span></span><br><span class="line">                <span class="keyword">int</span> pos = mp.get(a[i]);</span><br><span class="line">                <span class="keyword">for</span>(; j &lt;= pos; j++) &#123;  <span class="comment">// 开始计算b数组这部分的和</span></span><br><span class="line">                    sum2 += b[j];</span><br><span class="line">                &#125;</span><br><span class="line">                res = (res + Math.max(sum1, sum2)) % mod;  <span class="comment">// 选择更大的那部分加</span></span><br><span class="line">                sum1 = sum2 = <span class="number">0</span>;  <span class="comment">// 归零，开始下一部分的计算</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(; j &lt; m; j++) &#123;  <span class="comment">// b数组可能还没走完</span></span><br><span class="line">            sum2 += b[j];</span><br><span class="line">        &#125;</span><br><span class="line">        res = (res + Math.max(sum1, sum2)) % mod;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(res % <span class="number">1000000007</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：最小区间</title>
      <link href="2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E5%8C%BA%E9%97%B4.html"/>
      <url>2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E5%8C%BA%E9%97%B4.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>你有 k 个升序排列的整数数组。找到一个最小区间，使得 k 个列表中的每个列表至少有一个数包含在其中。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>直接对所有的数排序，然后优先队列维护一个k个数组都有值存在且对当前来说长度最小的滑动窗口，同时维护答案即可。<br><a id="more"></a> </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> val, id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] smallestRange(List&lt;List&lt;Integer&gt;&gt; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        PriorityQueue&lt;Node&gt; q = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Node&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a.val - b.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        PriorityQueue&lt;Node&gt; q1 = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Node&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a.val - b.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            List&lt;Integer&gt; num = nums.get(i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num.size(); j++) &#123;</span><br><span class="line">                Node node = <span class="keyword">new</span> Node(num.get(j), i);</span><br><span class="line">                q.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, dis = <span class="number">1000000000</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">while</span> (q.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Node now = q.poll();</span><br><span class="line">            q1.add(now);</span><br><span class="line">            <span class="keyword">if</span>(map.get(now.id) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                map.put(now.id, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> x = map.get(now.id);</span><br><span class="line">                map.remove(now.id);</span><br><span class="line">                map.put(now.id, x + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(q1.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                Node x = q1.peek();</span><br><span class="line">                <span class="keyword">if</span>(map.get(x.id) == <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    q1.poll();</span><br><span class="line">                    <span class="keyword">int</span> y = map.get(x.id);</span><br><span class="line">                    map.remove(x.id);</span><br><span class="line">                    map.put(x.id, y - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(q1.size() &gt; <span class="number">0</span> &amp;&amp; cnt == n &amp;&amp; dis &gt; now.val - q1.peek().val) &#123;</span><br><span class="line">                dis = now.val - q1.peek().val;</span><br><span class="line">                res[<span class="number">0</span>] = q1.peek().val;</span><br><span class="line">                res[<span class="number">1</span>] = now.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：最多的不重叠子字符串</title>
      <link href="2020/07/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%A4%9A%E7%9A%84%E4%B8%8D%E9%87%8D%E5%8F%A0%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html"/>
      <url>2020/07/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%A4%9A%E7%9A%84%E4%B8%8D%E9%87%8D%E5%8F%A0%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你一个只包含小写字母的字符串 s ，你需要找到 s 中最多数目的非空子字符串，满足如下条件：</p><ol><li>这些字符串之间互不重叠，也就是说对于任意两个子字符串 s[i..j] 和 s[k..l] ，要么 j &lt; k 要么 i &gt; l 。</li><li>如果一个子字符串包含字符 char ，那么 s 中所有 char 字符都应该在这个子字符串中。</li></ol><a id="more"></a> <p>请你找到满足上述条件的最多子字符串数目。如果有多个解法有相同的子字符串数目，请返回这些子字符串总长度最小的一个解。可以证明最小总长度解是唯一的。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>先对每个字母求出合法的最短长度，可以记录每个字母出现的左右端点，但这样不一定是合法的，因为之间会有别的字母，而这些字母没有被完全包含，所以必须枚举这个区间内的所有字母，一直拓展这个区间直到合法位置。</p><p>然后问题就转变为不相交线段数最多且长度和最短的问题，考虑贪心。显然可以看出先对右端点进行排序从小到大排序（保证右边剩余的空间尽量大），然后对左端点从大到小排序（保证长度尽可能小），然后贪心着取，遇到可以加入的线段将其加入答案即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node&amp; node) <span class="keyword">const</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (r == node.r) </span><br><span class="line">        <span class="keyword">return</span> l &gt; node.l;</span><br><span class="line">      <span class="keyword">return</span> r &lt; node.r;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; p[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">maxNumOfSubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) p[i].l = p[i].r = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (p[s[i] - <span class="string">&#x27;a&#x27;</span>].l == <span class="number">-1</span>) p[s[i] - <span class="string">&#x27;a&#x27;</span>].l = i;</span><br><span class="line">      p[s[i] - <span class="string">&#x27;a&#x27;</span>].r = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (p[i].l == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">int</span> le = p[i].l;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = p[i].l; j &lt;= p[i].r; j++) &#123;</span><br><span class="line">        p[i].l = min(p[i].l, p[s[j] - <span class="string">&#x27;a&#x27;</span>].l);</span><br><span class="line">        p[i].r = max(p[i].r, p[s[j] - <span class="string">&#x27;a&#x27;</span>].r);</span><br><span class="line">        <span class="keyword">if</span> (le &gt; p[i].l) &#123;</span><br><span class="line">          le = p[i].l;</span><br><span class="line">          j = le;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(p, p + <span class="number">26</span>);</span><br><span class="line">    <span class="keyword">int</span> ri = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (p[i].r == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (p[i].l &gt; ri) &#123;</span><br><span class="line">        ri = p[i].r;</span><br><span class="line">        res.push_back(s.substr(p[i].l, p[i].r - p[i].l + <span class="number">1</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java自动内存管理机制</title>
      <link href="2020/07/Java%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6.html"/>
      <url>2020/07/Java%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java内存区域与内存溢出异常"><a href="#Java内存区域与内存溢出异常" class="headerlink" title="Java内存区域与内存溢出异常"></a>Java内存区域与内存溢出异常</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>对于Java程序员来说，有虚拟机的自动内存管理机制，不再需要像C++那样为每个new操作去写配对的delete/free代码。但正因如此，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是如何使用内存的，那排查错误将会变得异常困难。</p><h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><p>Java虚拟机在执行Java程序过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。</p><p><img src="http://img.benboby.top/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png" alt><br><a id="more"></a> </p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器是一块较小的内存空间，它的作用可以看做是<strong>当前线程所执行的字节码的行号指示器</strong>。在虚拟机的概念模型里，字节码解释器工作时就是<strong>通过改变这个计数器的值来选取下一条需要执行的字节码指令</strong>， 分支、循环 、跳转、异常 处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>线程私有：由于 Java 虚拟机的多线程是通过<strong>线程轮流切换</strong>并<strong>分配处理器执行时间</strong>的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令，切换时也并不会记录上一个线程执行到那个位置。因此，为了线程<strong>切换后能恢复到正确的执行位控</strong>，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><p>如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是<strong> Native 方法</strong>，这个<strong>计数器值则为空</strong> ( Undefined )。</p><ul><li>Native方法大多是通过C实现并未编译成需要执行的字节码指令，也就不需要去存储字节码文件的行号</li></ul><p>程序计数器的内存区域是<strong>唯一</strong>一个在 Java 虚拟机规范中<strong>没有</strong>规定任何OutOfMemoryError情况的区域，因为<strong>程序计数器存储的是字节码文件的行号，这个范围是可知晓的，在一开始分配内存时就可以分配一个绝对不会溢出的内存</strong>。</p><p>总结：</p><ol><li>线程私有的，每个线程都有一个程序计数器</li><li>是java虚拟机规范里面，唯一一个没有规定任何 OutOfMemoryError 情况的区域 </li><li>生活周期随着线程的创建而创建，随着线程的结束而消亡</li><li>程序计数器是一块较小的内存区域</li></ol><h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>与程序计数器一样，Java虚拟机栈也是线程私有的，它的<strong>生命周期与线程相同</strong>。虚拟机栈描述的是 Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个<strong>栈帧</strong>用于存储局部变量表、操作栈、动态链接、方法出口等信息。<strong>每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从人栈到出栈的过程</strong>。</p><p>虚拟机栈是Java执行方法的内存模型。每个方法被执行的时候，都会创建一个栈帧，把栈帧压入栈，当方法正常返回或者抛出未捕获的异常时，栈帧就会出栈。</p><blockquote><p><strong>栈对应线程，栈帧对应方法</strong></p></blockquote><p>在活动线程中，只有位于栈顶的帧才是有效的，称为当前栈帧。正在执行的方法称为当前方法。在执行引擎运行时，所有指令都只能针对当前栈帧进行操作。而 StackOverflowError 表示请求的栈溢出，导致内存耗尽，通常出现在递归方法中。</p><blockquote><p>一般把Java内存区分为堆内存（Heap）和栈内存（Stack），其中『栈』指的是虚拟机栈，『堆』指的是Java堆。在 Java 虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过 Java 虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出 OutOfMemoryError 异常。</p><ul><li>StackOverflowError：递归过深，递归没有出口</li><li>OutOfMemoryError：JVM空间溢出，创建对象速度高于GC回收速度，可能是申请了较多空间没有及时释放</li></ul></blockquote><p><strong>局部变量表</strong>：存放方法参数和方法内部定义的局部变量的区域。</p><p>局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是<strong>虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务</strong>。在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并<strong>没有强制规定</strong>，因此具体的虚拟机可以自由实现它。与虚拟机栈一样，<strong>本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常</strong>。</p><h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><p>Java堆是披<strong>所有线程共享</strong>的一块内存区域，在<strong>虚拟机启动时创建</strong>。此内存区域的唯一目的就是存放<strong>对象实例</strong>，几乎所有的对象实例以及数组都要在堆上分配。</p><p>是垃圾收集器管理的主要区域，也被称做“GC堆”，也是Java虚拟机所管理的内存中最大的一块。</p><p>根据 Java 虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。在实现时，既可以实现成固定大小的，也可以是可扩展的。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出 OutOfMemoryError 异常。</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>用于<strong>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</strong>。与Java堆一样，是<strong>各个线程共享的内存区域</strong>。</p><p>人们更愿意把这个区域称为“永久代”，本质上两者并不等价，或者说是永久代来实现方法区而已。它还有个别名叫做Non-Heap（非堆）。</p><p>和Java堆一样不需要连续的内存和可以选择固定大小或可扩展外，还可选择不实现GC。相对而言，<strong>垃圾收集行为在这个区域是比较少出现的</strong>，但并非数据进入了方法区就如永久代的名字一样“永久” 存在了。这个区域的内存回收目标主要是<strong>针对常量池的回收和对类型的卸载</strong>，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的，未完全回收可能会导致内存泄漏。</p><p>在Java虚拟机规范中，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是<strong>常量池</strong>，用于<strong>存放编译期生成的各种字面量和符号引用</strong>，这部分内容将在<strong>类加载后进入方法区的运行时常量池中存放</strong>。</p><p>相对于<strong>Class文件常量池</strong>的一个重要特征是具备<strong>动态性</strong>，体现在并非只有预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中。是方法区的一部分，会受到方法区内存的限制。在Java虚拟机规范中，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p><h3 id="对象访问"><a href="#对象访问" class="headerlink" title="对象访问"></a>对象访问</h3><p>由于 reference 类型在 Java 虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访间到 Java 堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：</p><ol><li><p>通过句柄方式访问<br>  如果使用句柄访问的话，那么Java堆中将会划分一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象的实例数据与类型数据各自的具体地址信息。</p><p> <img src="http://img.benboby.top/%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE.png" alt></p><ul><li><p>优点：当对象移动的时候（垃圾回收的时候移动很普遍），这样值需要改变句柄中的指针，但是栈中的指针不需要变化，因为栈中存储的是句柄的地址</p></li><li><p>缺点：需要进行二次定位，寻找两次指针，开销相对更大一些</p></li></ul></li><li><p>使用指针访问<br>  如果使用直接指针访问方式，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象的地址。</p><p> <img src="http://img.benboby.top/%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE.png" alt></p><ul><li>优点：速度快，不需要和句柄一样指针定位的开销</li></ul></li></ol><h2 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>当需要排查各种内存溢出、内存泄涌问题时，当垃圾收集成为系统达到<strong>更高并发</strong>的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。</p><p>程序计数器、虚拟机栈、本地方法栈三个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行若出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具备确定性，在这几个区域内不需要过多考虑回收的问题，因为方法结束或线程结束时，内存自然就跟随着回收了。</p><p>而 Java 堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存，</p><h3 id="对象已死？"><a href="#对象已死？" class="headerlink" title="对象已死？"></a>对象已死？</h3><p>堆中几乎存放着 Java 中所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象有哪些还“存活”着，哪些已经“死去”（即不可能再披任何途径使用的对象）。</p><h4 id="引用计数器法"><a href="#引用计数器法" class="headerlink" title="引用计数器法"></a>引用计数器法</h4><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加 1; 当引用失效时，计数器值就减 1; 任何时刻计数器都为 0 的对象就是不可能再被使用的。</p><p>Java语言中没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间的相互循环引用的问题。</p><h4 id="根搜索算法"><a href="#根搜索算法" class="headerlink" title="根搜索算法"></a>根搜索算法</h4><p>通过一系列的名为 “GCRoots” 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链 (ReferenceChain) , 当一个对象到 GCRoots 没有任何引用链相连（用图论的话来说就是从 GCRoots 到这个对象不可达）时，则证明此对象是不可用的。</p><p>在 Java 语言里，可作为 GCRoots 的对象包括下面几种 ：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中的引用的对象。</li><li>方法区中的类静态属性引用的对象。</li><li>方法区中的常扯引用的对象。</li><li>本地方法栈中 JNI (即一般说的 Native 方法）的引用的对象</li></ul><h4 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h4><p>在 JDK 1.2 之前，Java中的引用的定义很传统 ：如果 reference 类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。</p><p>在 JDK 1.2 之后，Java 对引用的概念进行了扩充，将引用分为<strong>强引用、软引用、弱引用、虚引用</strong>四种，这四种引用强度依次逐渐减弱。</p><ul><li>强引用就是指在程序代码之中普遍存在的，类似 “Object obj = new Object()” 这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</li><li>软引用用来描述一些还有用，但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中并进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。在 JDK1.2 之后，提供了 SoftReference 类来实现软引用。</li><li>弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在 JDK 1.2 之后，提供了 WeakReference 类来实现弱引用。</li><li>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知。在 JDK 1.2 之后，提供了 PhantomReference 类来实现虚引用。</li></ul><h4 id="生存还是死亡？"><a href="#生存还是死亡？" class="headerlink" title="生存还是死亡？"></a>生存还是死亡？</h4><p>要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行根搜索后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法。当对象没有覆盖 finalize()方法，或者 finalize () 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</p><p>如果这个对象被判定为有必要执行 finalize() 方法，那么这个对象将会被放置在一个名为 F-Queue 的队列之中，并在稍后由一条由虚拟机自动建立的、低优先级的 Finalizer 线程去执行。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象在 finalize() 方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致 F-Queue 队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。finalize() 方法是对象逃脱死亡命运的最后一次机会，稍后 GC 将对 F-Queue 中的对象进行第二次小规模的标记，如果对象要在 finalize() 中成功拯救自己 —— 只要重新与引用链上的任何一个对象建立关联即可，譬如把自己 (this 关键字）赋值给某个类变址或对象的成员变量，那在第二次标记时它将被移除出 “即将回收” 的集合；如果对象这时候还没有逃脱，那它就真的离死不远了。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程</title>
      <link href="2020/07/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B.html"/>
      <url>2020/07/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B.html</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>程序：是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念。</p><p>进程：执行程序的一次执行过程，它是一个动态的概念，是系统资源分配的单位。</p><p>线程：通常在一个进程中可以包含若干个进程，当然一个进程中至少有一个线程，不然没有存在的意义。线程是CPU调度和执行的单位。</p><p>多线程：多条执行路径，主线程和子线程并行交替执行。很多多线程是模拟出来的，真正的多线程是指有多个CPU，即多核，如服务器。如果是模拟出来的多线程，即在一个CPU的情况下，在同一个时间点，CPU只能执行一个代码，因为切换的很快，所以就有同时执行的错觉。 </p><a id="more"></a> <ul><li>线程就是独立的执行路径</li><li>在程序运行时，即使没有自己创建线程，后台也会有多个线程，如主线程，gc线程（负责垃圾回收）</li><li>main()称之为主线程，为系统的入口，用于执行整个程序</li><li>在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器是与操作系统密切相关的，先后顺序是不能人为干预的</li><li>对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制（如抢票问题，需要让线程排队）</li><li>线程会带来额外的开销，如CPU调度时间，并发控制开销</li><li>每个线程在自己的工作内存交互，内存控制不会造成数据不一致</li></ul><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><p>方法一： Thread class -&gt; 继承Thread类</p><ul><li>自定义线程类继承Thread类</li><li>重写run()方法，编写线程执行体</li><li><p>创建线程对象，调用start()方法启动线程</p><p><strong>不建议使用：避免OOP单继承局限性</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程的创建方式一：继承Thread类，重写run()方法，调用start开启线程</span></span><br><span class="line"><span class="comment">// 总结：线程开启不一定立即执行，由CPU调度器执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test15</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;看书&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个线程对象</span></span><br><span class="line">        Test15 test15 = <span class="keyword">new</span> Test15();</span><br><span class="line">        test15.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;刷剧&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二： Runnable接口 -&gt; 实现Runnable接口</p><ul><li>定义MyRunnable类实现Runnable接口</li><li>实现run()方法，编写线程执行体</li><li><p>创建线程对象，调用start()方法启动线程</p><p>  <strong>推荐使用：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线程方式2：实现Runnable接口，重写run()方法，执行线程需要丢入runnable接口实现类，调用start()方法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test16</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;看书&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Runnable接口的实现类对象</span></span><br><span class="line">        Test16 test16 = <span class="keyword">new</span> Test16();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程对象，通过线程对象来开启线程，代理</span></span><br><span class="line">        <span class="comment">//Thread t = new Thread(test16);</span></span><br><span class="line">        <span class="comment">//t.start();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等价于上一种写法</span></span><br><span class="line">        <span class="keyword">new</span> Thread(test16).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;追剧&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法三： Callable接口 -&gt; 实现Callable接口</p><ul><li>实现Callable接口，需要返回值类型</li><li>重写call方法，需要抛出异常</li><li>创建目标对象</li><li>创建执行服务：ExecutorService ser = Executors.newFixedThreadPool(1);</li><li>提交执行：Future<Boolean>result1 = ser.submit(t1);</Boolean></li><li>获取结果：boolean r1 = result1.get();</li><li>关闭服务：ser.shutdownNow();</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程创建方式三：实现Callable接口</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    callable的好处：</span></span><br><span class="line"><span class="comment">    1. 可以定义返回值</span></span><br><span class="line"><span class="comment">    2. 可以抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test17</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test17</span><span class="params">(String url, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        WebDownloader webDownloader = <span class="keyword">new</span> WebDownloader();</span><br><span class="line">        webDownloader.downloader(url, name);</span><br><span class="line">        System.out.println(<span class="string">&quot;下载图片名为：&quot;</span> + name);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        Test17 t1 = <span class="keyword">new</span> Test17(<span class="string">&quot;http://kmlerc.coding-pages.com/images/head.JPG&quot;</span>, <span class="string">&quot;1.jpg&quot;</span>);</span><br><span class="line">        Test17 t2 = <span class="keyword">new</span> Test17(<span class="string">&quot;https://www5.jiumodiary.com/images/front/eleps.png&quot;</span>, <span class="string">&quot;2.png&quot;</span>);</span><br><span class="line">        Test17 t3 = <span class="keyword">new</span> Test17(<span class="string">&quot;https://pic.cnblogs.com/avatar/1569506/20190731001716.png&quot;</span>, <span class="string">&quot;3.png&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建执行服务</span></span><br><span class="line">        ExecutorService ser = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交执行</span></span><br><span class="line">        Future&lt;Boolean&gt; result1 = ser.submit(t1);</span><br><span class="line">        Future&lt;Boolean&gt; result2 = ser.submit(t2);</span><br><span class="line">        Future&lt;Boolean&gt; result3 = ser.submit(t3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取结果</span></span><br><span class="line">        <span class="keyword">boolean</span> r1 = result1.get();</span><br><span class="line">        <span class="keyword">boolean</span> r2 = result2.get();</span><br><span class="line">        <span class="keyword">boolean</span> r3 = result3.get();</span><br><span class="line"></span><br><span class="line">        System.out.println(r1 + <span class="string">&quot; &quot;</span> + r2 + <span class="string">&quot; &quot;</span> + r3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭服务</span></span><br><span class="line">        ser.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下载器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebDownloader</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下载方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">downloader</span><span class="params">(String url, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileUtils.copyURLToFile(<span class="keyword">new</span> URL(url), <span class="keyword">new</span> File(name));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;IO异常，downloader方法出现问题&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程状态分析"><a href="#线程状态分析" class="headerlink" title="线程状态分析"></a>线程状态分析</h3><ol><li>Thread t = new Thread() 线程对象一旦创建就进入到新生状态</li><li>当调用start()方法，线程立即进入就绪状态，但不意味着立即调度执行</li><li>进入运行状态，线程才真正执行线程体的代码块</li><li>当调用sleep,wait或同步锁定时，线程进入阻塞状态，就是代码不往下执行，阻塞事件解除后，重新进入就绪状态，等待cpu调度执行</li><li>线程中断或者结束，一旦进入死亡状态，就不能再次启动</li></ol><h3 id="线程方法"><a href="#线程方法" class="headerlink" title="线程方法"></a>线程方法</h3><div class="table-container"><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>setPriority(int newPriority)</td><td>更改线程的优先级</td></tr><tr><td>static void sleep(long millis)</td><td>在指定毫秒数内让当前正在执行的线程休眠</td></tr><tr><td>void join()</td><td>等待该线程终止</td></tr><tr><td>static void yield()</td><td>暂停当前正在执行的线程对象，并执行线程其他线程</td></tr><tr><td>void interrupt()</td><td>中断线程，别用这个方式</td></tr><tr><td>boolean isAlive()</td><td>测试线程是否处于活动状态</td></tr></tbody></table></div><h3 id="线程停止"><a href="#线程停止" class="headerlink" title="线程停止"></a>线程停止</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程停止</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 建议让线程正常停止</span></span><br><span class="line"><span class="comment">    2. 建议使用标志</span></span><br><span class="line"><span class="comment">    3. 不要使用stop或destroy等过时的不推荐使用的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test20</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;run...Thread&quot;</span> + ++i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test20 test20 = <span class="keyword">new</span> Test20();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(test20).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;main&quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">999</span>)&#123;</span><br><span class="line">                <span class="comment">// 修改标志位，让线程停止</span></span><br><span class="line">                test20.stop();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程停止了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h3><ul><li>sleep(时间)指定当前线程阻塞的毫秒数</li><li>sleep存在异常InterruptedException</li><li>sleep时间达到后线程进入就绪状态</li><li>sleep可以模拟网络延时，倒计时等</li><li>每一个对象都有一个锁，slepp不会释放锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程睡眠：打印时间</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test21</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getTime</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;HH:mm:ss&quot;</span>).format(date));</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            date = <span class="keyword">new</span> Date(System.currentTimeMillis());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        getTime();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程礼让"><a href="#线程礼让" class="headerlink" title="线程礼让"></a>线程礼让</h3><ul><li>让当前正在执行的线程暂停，但不阻塞</li><li>将线程从运行状态转为就绪状态</li><li>让cpu重新调度，礼让不一定成功！看cpu心情</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程礼让</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test22</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyYield myYield = <span class="keyword">new</span> MyYield();</span><br><span class="line">        <span class="keyword">new</span> Thread(myYield, <span class="string">&quot;a&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(myYield, <span class="string">&quot;b&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyYield</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始运行&quot;</span>);</span><br><span class="line">        Thread.yield(); <span class="comment">// 礼让</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;停止运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程强制执行（插队）"><a href="#线程强制执行（插队）" class="headerlink" title="线程强制执行（插队）"></a>线程强制执行（插队）</h3><ul><li>Join合并线程，待此线程完成后，再执行其他线程，其他线程阻塞</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程强制执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test23</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;vip线程&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Test23 test23 = <span class="keyword">new</span> Test23();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(test23);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">200</span>) &#123;</span><br><span class="line">                thread.join();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;main&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程状态观测"><a href="#线程状态观测" class="headerlink" title="线程状态观测"></a>线程状态观测</h3><p><strong>Thread.State</strong>: 线程状态</p><ul><li>NEW 尚未启动的线程处于此状态</li><li>RUNNABLE 在Java虚拟机中执行的线程处于此状态</li><li>BLOCKED 被阻塞等待监视器锁定的处于此状态</li><li>WAITING 正在等待另一个线程执行特定动作的线程处于此状态</li><li>TIMED_WAITING 正在等待另一个线程执行达到指定等待时间的线程处于此状态</li><li>TERMINATED 已退出的线程处于此状态</li></ul><p>一个线程可以在给定时间点处于一个状态。这些状态是不反应任何操作系统线程状态的虚拟机状态。</p><h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><ul><li>Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度那个线程来执行</li><li>线程的优先级用数字表示，范围从1-10<ul><li>Thread.MIN_PRIORITY = 1</li><li>Thread.MAX_PRIORITY = 10</li><li>Thread.NORM_PRIORITY = 5</li></ul></li><li>使用 getPriority() 获取优先级</li><li>使用 setPriority(int x) 改变优先级</li></ul><h3 id="守护-daemon-线程"><a href="#守护-daemon-线程" class="headerlink" title="守护(daemon)线程"></a>守护(daemon)线程</h3><ul><li>线程分为用户线程和守护线程</li><li>虚拟机必须确保用户线程执行完毕</li><li>虚拟机不必等待守护线程执行完毕</li><li>如：后台记录操作日志，监控内存，垃圾回收等等… </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 守护线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test24</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        God god = <span class="keyword">new</span> God();</span><br><span class="line">        People people = <span class="keyword">new</span> People();</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(god);</span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>); <span class="comment">// 设置为守护线程</span></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(people).start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当people结束，守护线程也就自动结束了。。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上帝线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">God</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;上帝保佑人类&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 人类线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;人类开心的活着&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Goodbye, world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程同步-多个线程操作同一个资源"><a href="#线程同步-多个线程操作同一个资源" class="headerlink" title="线程同步(多个线程操作同一个资源)"></a>线程同步(多个线程操作同一个资源)</h3><blockquote><p>处理多线程问题时，多个线程访问同一个对象(并发问题)，并且某些线程还想修改这个对象，这时候就需要线程同步。线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个对象的等待池形成队列，等待前面线程使用完毕，下一个线程再使用。</p><p>由于同一进程的多个线程共享同一块存储空间，在带来方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问时的正确性，在访问时加入锁机制synchronized，当一个线程获得对象的排它锁，独占资源，其他线程必须等待，使用后释放锁即可，存在以下问题：</p><ul><li>一个线程持有锁会导致其他所有需要此锁的线程挂起</li><li>在多线程竞争下，加锁，释放锁会导致比较多的上下文切换和调度延时，引起性能问题</li><li>如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，引起性能问题</li></ul></blockquote><h3 id="同步方法及同步块"><a href="#同步方法及同步块" class="headerlink" title="同步方法及同步块"></a>同步方法及同步块</h3><blockquote><p>由于我们可以通过private关键字来保证数据对象只能被方法访问，所以我们只需要针对方法提出一套机制，这套机制就是synchronized关键字，它包括两种用法：synchronized方法和synchronized块。</p><ul><li>同步方法：public synchronized void method(int args){}</li></ul><p>synchronized方法控制对”对象”的访问，每个对象对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞。方法一旦执行，就独占该锁，直到方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行。</p><ul><li>缺陷：若将一个大的方法声明为synchronized将会影响效率</li></ul><p>同步块：synchronized(Obj) {}<br>Obj称之为同步监视器</p><ul><li>Obj可以是任何对象，但是推荐使用共享资源作为同步监视器</li><li>同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是这个对象本身，或者是class</li></ul><p>同步监视器的执行过程</p><ol><li>第一个线程访问，锁定同步监视器，执行其中代码</li><li>第二个线程访问，发现同步监视器被锁定，无法访问</li><li>第一个线程访问完毕，解锁同步监视器</li><li>第二个线程访问，发现同步监视器没有锁，然后锁定并访问</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 买票测试synchronized方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test25</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BuyTicket buyTicket = <span class="keyword">new</span> BuyTicket();</span><br><span class="line">        <span class="keyword">new</span> Thread(buyTicket, <span class="string">&quot;小米&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(buyTicket, <span class="string">&quot;小明&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(buyTicket, <span class="string">&quot;小红&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuyTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticketNums = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                buy();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ticketNums &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Thread.sleep(10);</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;抢到&quot;</span> + ticketNums--);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 同步块</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuyTicket1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticketNums = <span class="number">100000</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (flag)</span><br><span class="line">            buy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;     <span class="comment">// 同步块，可以锁任何对象，默认为this</span></span><br><span class="line">            <span class="keyword">if</span>(ticketNums &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//Thread.sleep(10);</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;抢到&quot;</span> + ticketNums--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><blockquote><p>多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形。某一个同步块同时拥有“两个以上对象的锁”时，就可能会发生”死锁“的问题。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 死锁：多个线程互相抱着对方需要的线程，形成僵持</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test26</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Makeup q1 = <span class="keyword">new</span> Makeup(<span class="number">0</span>, <span class="string">&quot;小明&quot;</span>);</span><br><span class="line">        Makeup q2 = <span class="keyword">new</span> Makeup(<span class="number">1</span>, <span class="string">&quot;小红&quot;</span>);</span><br><span class="line">        q1.start();</span><br><span class="line">        q2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gun</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Makeup</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 需要的资源只有一份，用static来保证只有一份</span></span><br><span class="line">    <span class="keyword">static</span> Gun gun = <span class="keyword">new</span> Gun();</span><br><span class="line">    <span class="keyword">static</span> Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> choice;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    Makeup(<span class="keyword">int</span> choice, String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.choice = choice;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            makeup();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">makeup</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (choice == <span class="number">0</span>) &#123;   <span class="comment">// 小明想要枪，他本来有狗</span></span><br><span class="line">            <span class="keyword">synchronized</span>(gun) &#123;</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;获得枪的锁&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="comment">/*   发生死锁</span></span><br><span class="line"><span class="comment">                synchronized(dog) &#123;</span></span><br><span class="line"><span class="comment">                    System.out.println(this.name + &quot;获得狗的锁&quot;);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span>(dog) &#123;  <span class="comment">// 放到外面即可解决死锁问题</span></span><br><span class="line">                System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;获得狗的锁&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (choice == <span class="number">1</span>) &#123;  <span class="comment">// 小红想要狗，她本来有枪</span></span><br><span class="line">            <span class="keyword">synchronized</span>(dog) &#123;</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;获得狗的锁&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                <span class="comment">/*  发生死锁</span></span><br><span class="line"><span class="comment">                synchronized(gun) &#123;</span></span><br><span class="line"><span class="comment">                    System.out.println(this.name + &quot;获得枪的锁&quot;);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span>(gun) &#123;  <span class="comment">// 放到外面即可解决死锁问题</span></span><br><span class="line">                System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;获得枪的锁&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>死锁产生的四个必要条件(只需要破解其中一个即可解决死锁问题)：</p><ol><li>互斥条件：一个资源每次只能被一个进程使用</li><li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放</li><li>不剥夺条件：进程以获得的资源，在未使用完之前，不能强行剥夺</li><li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系</li></ol><h3 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h3><ul><li>Lock是显式锁（手动开启和关闭锁），synchronized是隐式锁，出了作用域自动释放</li><li>Lock只有代码块锁，synchronized有代码块锁和方法锁</li><li>使用Lock锁，JVM将花费较少时间来调度线程，性能更好，并且具有更好的拓展性（提供更多子类）</li><li>优先使用顺序：Lock &gt; 同步代码块 &gt; 同步方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lock锁</span></span><br><span class="line"><span class="comment">/*  格式：</span></span><br><span class="line"><span class="comment">    class A &#123;</span></span><br><span class="line"><span class="comment">            private final ReentrantLock lock = new ReentrantLock();</span></span><br><span class="line"><span class="comment">            public void m() &#123;</span></span><br><span class="line"><span class="comment">                lock.lock();</span></span><br><span class="line"><span class="comment">                try &#123;</span></span><br><span class="line"><span class="comment">                    // 保证线程安全的代码</span></span><br><span class="line"><span class="comment">                &#125; finally &#123;</span></span><br><span class="line"><span class="comment">                    lock.unlock();</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test27</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BuyTicket1 buyTicket1 = <span class="keyword">new</span> BuyTicket1();</span><br><span class="line">        <span class="keyword">new</span> Thread(buyTicket1).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(buyTicket1).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(buyTicket1).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuyTicket1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> TicketNums = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义lock锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();  <span class="comment">// 加锁</span></span><br><span class="line">                <span class="keyword">if</span>(TicketNums &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(TicketNums--);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();  <span class="comment">// 解锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态代理模式"><a href="#静态代理模式" class="headerlink" title="静态代理模式"></a>静态代理模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态代理方法</span></span><br><span class="line"><span class="comment">/*  总结：</span></span><br><span class="line"><span class="comment">    真实对象和代理对象都要实现同一个接口</span></span><br><span class="line"><span class="comment">    代理对象要代理真实角色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*  优点：</span></span><br><span class="line"><span class="comment">    代理对象可以做很多真实对象做不了的事情</span></span><br><span class="line"><span class="comment">    真实对象可以专心做自己的事情</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test18</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*  举例模拟结婚：</span></span><br><span class="line"><span class="comment">        你只需要负责结婚，其他的事情都由婚庆公司（代理）帮你包办即可。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread( () -&gt; System.out.println(<span class="string">&quot;我爱你&quot;</span>) ).start();</span><br><span class="line">        <span class="keyword">new</span> Company(<span class="keyword">new</span> You()).HappyMarry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Marry</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">HappyMarry</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真实角色，即你自己</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">You</span> <span class="keyword">implements</span> <span class="title">Marry</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HappyMarry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;新郎结婚中。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理角色，即婚庆公司</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Company</span> <span class="keyword">implements</span> <span class="title">Marry</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 要结婚的对象</span></span><br><span class="line">    <span class="keyword">private</span> Marry target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Company</span><span class="params">(Marry target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HappyMarry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        <span class="keyword">this</span>.target.HappyMarry();</span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;布置场地&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收拾场地&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h2><blockquote><p>应用场景：生产者和消费者问题</p><ul><li>假设仓库只能存放一件商品，生产者将生产出来的产品放入仓库，消费者将仓库中产品消费取走。</li><li>如果仓库没有商品，则生产者将产品放入仓库，否则停止生产并等待，直到仓库中的产品被消费者取走为止</li><li>如果仓库中放有产品，则消费者可以将产品取走消费，否则停止消费并等待，直到仓库中再次放入产品为止</li></ul><p>这是一个线程同步问题，生产者和消费者共享一个资源，并且生产者和消费者之间相互依赖，互为条件。</p><ul><li>对于生产者，没有生产产品之前，要通知消费者等待。而生产之后，又需要通知消费者消费</li><li>对于消费者，在消费之后，要通知生产者已经结束消费，需要生产新的产品以供消费</li><li>在生产者消费者问题中，仅有synchronized是不够的<ul><li>synchronized可以阻止并发更新同一个共享资源，实现了同步</li><li>synchronized不能用来实现不同线程之间的消息传递（通信） </li></ul></li></ul><p>Java提供了几个方法解决线程通信问题</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">方法名</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">wait()</td><td style="text-align:center">表示线程一直等待，直到其他线程通知，与sleep不同，会释放锁</td></tr><tr><td style="text-align:center">wait(long timeout)</td><td style="text-align:center">指定等待的毫秒数</td></tr><tr><td style="text-align:center">notify()</td><td style="text-align:center">唤醒一个处于等待状态的线程</td></tr><tr><td style="text-align:center">notifyAll()</td><td style="text-align:center">唤醒同一个对象上所有调用wait()方法的线程，优先级别高的线程优先调度</td></tr></tbody></table></div><p>注意：均是Object类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常IllegalMonitorStateException</p><h3 id="管程法"><a href="#管程法" class="headerlink" title="管程法"></a>管程法</h3><blockquote><p>消费者不能直接使用生产者的数据，他们之间有个“缓冲区”<br>生产者将生产好的数据放入缓冲区，消费者从缓冲区拿出数据</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试：生产者消费者模型 --&gt; 利用缓冲区解决：管程法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test28</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynContainer container = <span class="keyword">new</span> SynContainer();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Productor(container).start();</span><br><span class="line">        <span class="keyword">new</span> Consumer(container).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Productor</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    SynContainer container;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Productor</span><span class="params">(SynContainer container)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.container = container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;生产了&quot;</span> + i + <span class="string">&quot;个产品&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                container.push(<span class="keyword">new</span> Product(i));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    SynContainer container;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span> <span class="params">(SynContainer container)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.container = container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消费了--&gt;&quot;</span> + container.pop().id + <span class="string">&quot;产品&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 产品</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Product</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓冲区</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynContainer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 需要一个容器大小</span></span><br><span class="line">    Product[] products = <span class="keyword">new</span> Product[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">// 容器计数器</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产者放入产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Product product)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 如果容器满了，就需要等待消费者消费</span></span><br><span class="line">        <span class="keyword">if</span>(count == products.length) &#123;</span><br><span class="line">            <span class="comment">// 通知消费者消费，等待生产</span></span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有满，我们就需要丢入产品</span></span><br><span class="line">        products[count] = product;</span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知生产者消费</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费者消费商品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Product <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 判断能否消费</span></span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 等待生产者生产，消费者等待</span></span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果可以消费</span></span><br><span class="line">        count--;</span><br><span class="line">        Product product = products[count];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费空了，通知生产者生产</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><blockquote><p>背景：经常创建和销毁，使用量特别大的资源，比如并发情况下的线程，对性能影响很大。<br>思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。<br>可以避免频繁创建销毁，实现重复利用。类似生活中的公共交通工具。</p><ul><li>提高响应速度（减少了创建新线程的时间）</li><li>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</li><li>便于线程管理<ul><li>corePoolSize：核心池的大小</li><li>maximumPoolSize：最大线程数</li><li>keepAliveTime：线程没有任务时最多保持多长时间后会终止</li></ul></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test29</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建服务，创建线程池</span></span><br><span class="line">        <span class="comment">// newFixedThreadPool参数为线程池大小</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭链接</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>为什么要使用lambda表达式：</p><ul><li>避免匿名内部类定义过多</li><li>让代码更加简洁</li><li>去掉了没有意义的代码，只留下核心逻辑</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lambda表达式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test19</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Like2</span> <span class="keyword">implements</span> <span class="title">ILike</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I like lambda2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现类</span></span><br><span class="line">        ILike like = <span class="keyword">new</span> Like1();</span><br><span class="line">        like.lambda();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 静态内部类</span></span><br><span class="line">        like = <span class="keyword">new</span> Like2();</span><br><span class="line">        like.lambda();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 局部内部类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Like3</span> <span class="keyword">implements</span> <span class="title">ILike</span> </span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;I like lambda3&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        like = <span class="keyword">new</span> Like3();</span><br><span class="line">        like.lambda();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匿名内部类，没有类的名称，必须借助父类或接口</span></span><br><span class="line">        like = <span class="keyword">new</span> ILike() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;I like lambda4&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        like.lambda();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// lambda表达式</span></span><br><span class="line">        like = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I like lambda5&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        like.lambda();</span><br><span class="line"></span><br><span class="line">        ILove love = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// lambda表达式2</span></span><br><span class="line">        love = (a, b) -&gt; System.out.println(<span class="string">&quot;I like lambda &quot;</span> + a + <span class="string">&quot; &quot;</span>+ b);</span><br><span class="line">        love.lambda(<span class="number">20</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  总结：</span></span><br><span class="line"><span class="comment">            1. lambda表达式只能在一行代码的情况下简化成一行，否则必须用代码块包装。</span></span><br><span class="line"><span class="comment">            2. 使用的前提是接口必须为函数式接口且只有一个函数。</span></span><br><span class="line"><span class="comment">            3. 可以都去掉参数类型，且只有一个参数时可以不加括号。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数式接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ILike</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Like1</span> <span class="keyword">implements</span> <span class="title">ILike</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I like lambda1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ILove</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lambda</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：矩阵中最长递增路径（记忆化搜索）</title>
      <link href="2020/07/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84%EF%BC%88%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%EF%BC%89.html"/>
      <url>2020/07/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84%EF%BC%88%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个整数矩阵，找出最长递增路径的长度。</p><p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><a id="more"></a> <p>记忆化搜索模板题。$dp[i][j]$记录之前已经计算得到的结果，之后直接读取即可。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution329</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">           [7,8,9]</span></span><br><span class="line"><span class="comment">           [9,7,6]</span></span><br><span class="line"><span class="comment">           [7,2,3]</span></span><br><span class="line"><span class="comment">           输出：6</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] dirs = &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] a, <span class="keyword">int</span>[][] dp, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[x][y] != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> dp[x][y];</span><br><span class="line">        dp[x][y] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] dir : dirs) &#123;</span><br><span class="line">            <span class="keyword">int</span> fx = x + dir[<span class="number">0</span>], fy = y + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(fx &gt;= <span class="number">0</span> &amp;&amp; fx &lt; n &amp;&amp; fy &gt;= <span class="number">0</span> &amp;&amp; fy &lt; m &amp;&amp; a[fx][fy] &gt; a[x][y])</span><br><span class="line">                dp[x][y] = Math.max(dp[x][y], dfs(a, dp, fx, fy) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[x][y];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] a)</span> </span>&#123;</span><br><span class="line">        n = a.length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        m = a[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                res = Math.max(res, dfs(a, dp, i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记忆化搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 注解与反射</title>
      <link href="2020/07/Java-%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84.html"/>
      <url>2020/07/Java-%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84.html</url>
      
        <content type="html"><![CDATA[<h2 id="注解-Annotation"><a href="#注解-Annotation" class="headerlink" title="注解 Annotation"></a>注解 Annotation</h2><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li>对程序作出解释（类似于注释）</li><li>可以被其他程序读取（如：编译器等）</li></ul><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><ul><li>注解以 “@注释名” 形式存在，如 “@Override”，有些可以添加一些参数值，如 “@SuppressWarnings(value=”unchecked”)”<a id="more"></a> </li><li>附加在package，class，method，field等上方，等于给他们添加额外辅助信息，我们可以通过反射机制编程实现对这些元数据的访问</li></ul><h3 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h3><ul><li>@Override: 此注释只适用于修饰方法，表示一个方法声明打算重写超类中的另一个方法声明</li><li>@SuppressWarnings: 用于抑制编译时的警告信息(Warning)，需要添加参数才能使用，如：(“all”),(“unchecked”),(value={“unchecked”,”deprecation”})等等</li></ul><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>元注解作用就是负责注解其他注解，Java定义了4个标准的meta-annotation类型，他们被用来提供对其他annotation类型作说明</p><ul><li><strong>@Target</strong>: 用于描述注解的使用范围（被描述的注解可以用在什么地方）</li><li><strong>@Retention</strong>: 表示需要在什么级别保存该注释信息，用于描述注解的生命周期(SOURCE &lt; CLASS &lt; RUNTIME)</li><li>@Document: 说明该注解将被包含在javadoc中</li><li>@Inherited: 说明子类可以<strong>继承</strong>父类中的该注解</li></ul><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>使用@interface自定义注解时，自动继承java.lang.annotation.Annotation接口</p><ul><li>@interface用来声明一个注释，格式：@interface 注解名 { 定义内容 }</li><li>其中的每一个方法实际上是声明了一个配置参数</li><li>方法的名称就是参数的名称</li><li>返回值类型就是参数的类型，返回值只能是基本类型(Class, String, enum)</li><li>可以通过default来声明参数的默认值</li><li>如果只有一个参数成员，一般参数名为value</li><li>注解必须要有值，我们定义注解元素时，经常使用空字符串或者0来作为默认值(default)</li></ul><h2 id><a href="#" class="headerlink" title></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注解可以显示赋值，没有先后顺序之分，如果没有默认值，就必须给注解赋值</span></span><br><span class="line">    <span class="meta">@MyAnnotation01(id = 1, age = 18, name = &quot;Benboby&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当注解只有一个参数时，默认定义为 value() , 则可以省略 &quot;value = &quot;</span></span><br><span class="line">    <span class="meta">@MyAnnotation02(&quot;Benboby&quot;)</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span> <span class="comment">// 作用域可以在类上或者方法上</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">// 在运行时有效</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation01 &#123;</span><br><span class="line">    <span class="comment">// 注解的参数：参数类型 + 参数名() (+ 默认值);</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    String[] schools() <span class="keyword">default</span> &#123;<span class="string">&quot;本科&quot;</span>,<span class="string">&quot;带专&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span> <span class="comment">// 作用域可以在类上或者方法上</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">// 在运行时有效</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation02 &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h2 id="反射（Java-Reflection）"><a href="#反射（Java-Reflection）" class="headerlink" title="反射（Java Reflection）"></a>反射（Java Reflection）</h2><h3 id="动态-VS-静态语言"><a href="#动态-VS-静态语言" class="headerlink" title="动态 VS 静态语言"></a>动态 VS 静态语言</h3><p>动态语言：运行时代码可以根据某些条件改变自身结构。如：C#, JavaScript, PHP, Python等。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// var 是万能类型</span></span><br><span class="line">    <span class="keyword">var</span> x = <span class="string">&quot;var a=1; var b=2; alert(a+b)&quot;</span>; <span class="comment">// 可以认为目前是字符串类型</span></span><br><span class="line">    <span class="built_in">eval</span>(x) <span class="comment">// 执行 x ，x 变为 a+b 的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>静态语言：运行时结构不可改变的语言就是静态语言。如：Java, C, C++。</p><ul><li>Java不是动态语言，但Java有一定的动态性，我们可以利用反射机制获得类似动态语言的特性，使得Java在编程的时候变得更灵活。</li></ul><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Reflection是Java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。</p><p>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构，这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射。</p><p>正常方式： 引入需要的“包类”名称 -&gt; 通过new实例化 -&gt; 取得实例化对象<br>反射方式： 实例化对象 -&gt; getClass()方法 -&gt; 得到完整的“包类”名称</p><p>优点：可以实现创建对象和编译，体现出很大的灵活性<br>缺点：对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于直接执行相同的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 通过反射获取对象类的Class对象</span></span><br><span class="line">        Class c1 = Class.forName(<span class="string">&quot;pers.Shuke.reflection.User&quot;</span>);</span><br><span class="line">        System.out.println(c1); <span class="comment">// 输出：class pers.Shuke.reflection.User</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><p>在Object类中定义了以下的方法，此方法将所有子类继承：<strong>public final Class getClass()</strong></p><p>以上方法的返回值类型是一个Class类，此类是Java反射的源头，即：可以通过对象反射求出类名称。</p><h3 id="获取Class类型的几种方式"><a href="#获取Class类型的几种方式" class="headerlink" title="获取Class类型的几种方式"></a>获取Class类型的几种方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Student();</span><br><span class="line">        <span class="comment">// 方式1：通过对象获得</span></span><br><span class="line">        Class c1 = person.getClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式2：forname获得</span></span><br><span class="line">        Class c2 = Class.forName(<span class="string">&quot;pers.Shuke.reflection.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式3：通过类名.class获得</span></span><br><span class="line">        Class c3 = Student.class;</span><br><span class="line">        System.out.println(c3);</span><br><span class="line">        <span class="comment">// c1 = c2 = c3 = &quot;class pers.Shuke.reflection.Student&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式4：基本内置类型的包装类都有一个Type属性</span></span><br><span class="line">        Class c4 = Integer.TYPE;   <span class="comment">// c4 = int</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式5：</span></span><br><span class="line">        Class c5 = c1.getSuperclass();  <span class="comment">// c5 = &quot;class pers.Shuke.reflection.Person&quot;</span></span><br><span class="line">        System.out.println(c5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><h3 id="所有类型的Class对象"><a href="#所有类型的Class对象" class="headerlink" title="所有类型的Class对象"></a>所有类型的Class对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class c1 = Object.class; <span class="comment">// 类 c1 = &quot;class java.lang.Object&quot;</span></span><br><span class="line">        Class c2 = Comparable.class; <span class="comment">// 接口 c2 = &quot;interface java.lang.Comparable&quot;</span></span><br><span class="line">        Class c3 = String[].class; <span class="comment">// 一维数组 c3 = &quot;class [Ljava.lang.String;&quot;</span></span><br><span class="line">        Class c4 = <span class="keyword">int</span>[][].class; <span class="comment">// 二维数组 c4 = &quot;class [[I&quot;</span></span><br><span class="line">        Class c5 = Override.class; <span class="comment">// 注解 c5 = &quot;interface java.lang.Override&quot;</span></span><br><span class="line">        Class c6 = ElementType.class; <span class="comment">// 枚举 c6 = &quot;class java.lang.annotation.ElementType&quot;</span></span><br><span class="line">        Class c7 = Integer.class; <span class="comment">// 基本数据类型 c7 = &quot;class java.lang.Integer&quot;</span></span><br><span class="line">        Class c8 = <span class="keyword">void</span>.class; <span class="comment">// void c8 = &quot;void&quot;</span></span><br><span class="line">        Class c9 = Class.class; <span class="comment">// Class c9 = &quot;class java.lang.Class&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        Class c10 = a.getClass();</span><br><span class="line">        Class c11 = b.getClass();</span><br><span class="line">        <span class="comment">// c10 = c11</span></span><br><span class="line">        <span class="comment">// 只有元素类型与维度一样，就是同一个Class</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java内存分析"><a href="#Java内存分析" class="headerlink" title="Java内存分析"></a>Java内存分析</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>堆：存放new的对象和数组，可以被所有的线程共享，不会存放别的对象引用<br>栈：存放基本变量类型（包含具体数值），引用对象的变量（会存放这个引用在堆里面的具体地址）<br>方法区：可以被所有的线程共享，包含所有的class和static变量</p><h4 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h4><p>当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过以下三个步骤来对该类进行初始化。</p><ol><li>类的加载(Load)：将类的class文件读入内存，并为之创建一个java.lang.Class对象。此过程由类加载器完成。</li><li>类的连接(Link)：将类的二进制数据合并到JRE中。</li><li>类的初始化(Initialize)：JVM负责对类进行初始化。</li></ol><h4 id="类的初始化"><a href="#类的初始化" class="headerlink" title="类的初始化"></a>类的初始化</h4><ol><li>类的主动引用（一定会发生类的初始化）</li></ol><ul><li>当虚拟机启动，先初始化main方法所在的类</li><li>new一个类的对象</li><li>调用类的静态成员（除了final常量）和静态方法</li><li>使用java.lang.reflect包的方法对类进行反射调用</li><li>当初始化一个类，如果其父类没有被初始化，则会先初始化他的父类</li></ul><ol><li>类的被动引用</li></ol><ul><li>当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类初始化</li><li>通过数组定义类引用，不会触发此类的初始化</li><li>引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试类什么时候会被初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test08</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main类被加载&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 主动调用</span></span><br><span class="line">        <span class="comment">//Son son = new Son();</span></span><br><span class="line">        <span class="comment">/* main类被加载</span></span><br><span class="line"><span class="comment">           父类被加载</span></span><br><span class="line"><span class="comment">           子类被加载</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射</span></span><br><span class="line">        <span class="comment">//Class.forName(&quot;pers.Shuke.Initialization.Son&quot;);</span></span><br><span class="line">        <span class="comment">/*  main类被加载</span></span><br><span class="line"><span class="comment">            父类被加载</span></span><br><span class="line"><span class="comment">            子类被加载</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 引用父类常量</span></span><br><span class="line">        <span class="comment">//System.out.println(Son.b);</span></span><br><span class="line">        <span class="comment">/*  main类被加载</span></span><br><span class="line"><span class="comment">            父类被加载</span></span><br><span class="line"><span class="comment">            2</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 引用自身常量</span></span><br><span class="line">        <span class="comment">//System.out.println(Son.m);</span></span><br><span class="line">        <span class="comment">/*  main类被加载</span></span><br><span class="line"><span class="comment">            父类被加载</span></span><br><span class="line"><span class="comment">            子类被加载</span></span><br><span class="line"><span class="comment">            100</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义数组</span></span><br><span class="line">        <span class="comment">//Son[] array = new Son[5];</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            main类被加载</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 引用final常量</span></span><br><span class="line">        <span class="comment">//System.out.println(Son.f);</span></span><br><span class="line">        <span class="comment">/*  main类被加载</span></span><br><span class="line"><span class="comment">            10</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类被加载&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类被加载&quot;</span>);</span><br><span class="line">        m = <span class="number">300</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> f = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类加载器的作用"><a href="#类加载器的作用" class="headerlink" title="类加载器的作用"></a>类加载器的作用</h4><p>类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据转化成方法区的运行时数据结构，然后在堆中生成一个代表这个类的Class对象，作为方法区中类数据的访问入口。</p><p>类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，他将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象。</p><p>源程序(.java文件) -&gt; Java编译器 -&gt; 字节码(.class文件) -&gt; 类装载器 -&gt; 字节码校验器 -&gt; 解释器 -&gt; 操作系统平台</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test09</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取系统类加载器</span></span><br><span class="line">        ClassLoader classLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(classLoader); <span class="comment">// 输出：jdk.internal.loader.ClassLoaders$AppClassLoader@3d4eac69</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取系统类父类的加载器 -&gt; 拓展类加载器</span></span><br><span class="line">        ClassLoader parent = classLoader.getParent();</span><br><span class="line">        System.out.println(parent); <span class="comment">// 输出：jdk.internal.loader.ClassLoaders$PlatformClassLoader@77459877</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取拓展类加载器的父类加载器 -&gt; 引导类加载器/根加载器（C/C++）</span></span><br><span class="line">        ClassLoader root = parent.getParent();</span><br><span class="line">        System.out.println(root); <span class="comment">// 输出：null （无法直接获取）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试当前类是哪个加载器加载的</span></span><br><span class="line">        ClassLoader classLoader1 = Class.forName(<span class="string">&quot;pers.Shuke.Initialization.Test09&quot;</span>).getClassLoader();</span><br><span class="line">        System.out.println(classLoader1); <span class="comment">// 输出：jdk.internal.loader.ClassLoaders$AppClassLoader@3d4eac69</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试jdk内置的类是哪个加载器加载的</span></span><br><span class="line">        ClassLoader classLoader2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getClassLoader();</span><br><span class="line">        System.out.println(classLoader2); <span class="comment">// 输出：null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如何获得系统类加载器可以加载的路径</span></span><br><span class="line">        System.out.println(System.getProperty(<span class="string">&quot;java.class.path&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取类的运行时结构"><a href="#获取类的运行时结构" class="headerlink" title="获取类的运行时结构"></a>获取类的运行时结构</h3><p>通过反射获取类运行时的完整结构：</p><ul><li>实现的全部接口（Interface）</li><li>所继承的父类（Superclass）</li><li>全部的构造器（Constructor）</li><li>全部的方法（Method）</li><li>全部的Field</li><li>注解</li><li>…</li></ul><p>PS：public/private/protected区别（默认为friendly）</p><div class="table-container"><table><thead><tr><th style="text-align:center">作用域</th><th style="text-align:center">当前类</th><th style="text-align:center">同一public</th><th style="text-align:center">子孙类</th><th style="text-align:center">其他package</th></tr></thead><tbody><tr><td style="text-align:center">public</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">protected</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">friendly</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">private</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test05</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, NoSuchMethodException </span>&#123;</span><br><span class="line">        Class c1 = Class.forName(<span class="string">&quot;pers.Shuke.reflection.User&quot;</span>);</span><br><span class="line">        System.out.println(c1.getName()); <span class="comment">// 输出：pers.Shuke.reflection.User</span></span><br><span class="line">        System.out.println(c1.getSimpleName()); <span class="comment">// 输出：User</span></span><br><span class="line"></span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        c1 = user.getClass();</span><br><span class="line">        System.out.println(c1.getName()); <span class="comment">// 输出：pers.Shuke.reflection.User</span></span><br><span class="line">        System.out.println(c1.getSimpleName()); <span class="comment">// 输出：User</span></span><br><span class="line"></span><br><span class="line">        Field[] fields = c1.getFields(); <span class="comment">// 输出：null  解释：只能找到public属性</span></span><br><span class="line">        fields = c1.getDeclaredFields();</span><br><span class="line">        <span class="comment">/*  private java.lang.String pers.Shuke.reflection.User.name</span></span><br><span class="line"><span class="comment">            private int pers.Shuke.reflection.User.age</span></span><br><span class="line"><span class="comment">            private int pers.Shuke.reflection.User.id</span></span><br><span class="line"><span class="comment">            解释：可以找到全部属性</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span>(Field field : fields) &#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得指定属性的值</span></span><br><span class="line">        <span class="comment">//Field name = c1.getField(&quot;name&quot;); // 报错：只能获取public对象</span></span><br><span class="line">        Field name = c1.getDeclaredField(<span class="string">&quot;name&quot;</span>); <span class="comment">// 输出：private java.lang.String pers.Shuke.reflection.User.name</span></span><br><span class="line">        System.out.println(name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取类的方法</span></span><br><span class="line">        Method[] methods = c1.getMethods(); <span class="comment">// 获取本类和父类所有public方法</span></span><br><span class="line">        methods = c1.getDeclaredMethods(); <span class="comment">// 获取本类所有方法</span></span><br><span class="line">        <span class="keyword">for</span>(Method method : methods) &#123;</span><br><span class="line">            System.out.println(method);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取类的指定方法(需要传参)</span></span><br><span class="line">        Method getname = c1.getMethod(<span class="string">&quot;getName&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        Method setname = c1.getMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">        System.out.println(getname); <span class="comment">// 输出：public java.lang.String pers.Shuke.reflection.User.getName()</span></span><br><span class="line">        System.out.println(setname); <span class="comment">// 输出：public void pers.Shuke.reflection.User.setName(java.lang.String)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得指定的构造器</span></span><br><span class="line">        Constructor[] constructors = c1.getConstructors(); <span class="comment">// 获取public构造器</span></span><br><span class="line">        constructors = c1.getDeclaredConstructors(); <span class="comment">// 获取指定构造器</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得指定构造器</span></span><br><span class="line">        Constructor constructor = c1.getDeclaredConstructor(String.class, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class);</span><br><span class="line">        System.out.println(constructor); <span class="comment">// 输出：public pers.Shuke.reflection.User(java.lang.String,int,int)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态创建对象执行方法"><a href="#动态创建对象执行方法" class="headerlink" title="动态创建对象执行方法"></a>动态创建对象执行方法</h3><p>创建类的对象：<br>有无参构造器：调用Class对象的newInstance()方法</p><ul><li>类必须有一个无参数构造器</li><li>类的构造器的访问权限要足够</li></ul><p>没有无参构造器：</p><ol><li>通过Class类的getDeclaredConstructor()取得本类的指定形参类型的构造器</li><li>向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的哥哥参数</li><li>通过Constructor</li></ol><p>调用指定的方法：<br>通过反射，调用类中的方法，通过Method完成。</p><ol><li>通过Class类的getMethod()方法取得一个Method对象，并设置此方法操作时所需要的参数类型。</li><li>之后使用Object invoke()进行调用，并向方法中传递需要设置的obj对象的参数信息。</li></ol><p>setAccessible：</p><ul><li>Method，Field和Constructor对象都有setAccessible()方法</li><li>作用为启动和禁用访问安全检查的开关</li><li>参数值为true则指示反射的对象在使用时应该取消Java语言访问检测，这样可以提高反射的效率，使得原本无法访问的私有成员也可以访问</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test11</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取class对象</span></span><br><span class="line">        Class c1 = Class.forName(<span class="string">&quot;pers.Shuke.reflection.User&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造一个对象</span></span><br><span class="line">        User user = (User)c1.newInstance(); <span class="comment">// 本质上调用类的无参构造器</span></span><br><span class="line">        System.out.println(user); <span class="comment">// pers.Shuke.reflection.User@5b2133b1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过构造器创建对象</span></span><br><span class="line">        Constructor constructor = c1.getDeclaredConstructor(String.class, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class);</span><br><span class="line">        User user2 = (User)constructor.newInstance(<span class="string">&quot;舒克&quot;</span>, <span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">        System.out.println(user2); <span class="comment">// pers.Shuke.reflection.User@72ea2f77</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射调用普通方法</span></span><br><span class="line">        User user3 = (User)c1.newInstance();</span><br><span class="line">        <span class="comment">// 通过反射获取一个方法</span></span><br><span class="line">        Method setName = c1.getDeclaredMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// invoke : 激活的意思</span></span><br><span class="line">        <span class="comment">// &#123;对象，方法的值&#125;</span></span><br><span class="line">        setName.invoke(user3, <span class="string">&quot;舒克&quot;</span>);</span><br><span class="line">        System.out.println(user3.getName()); <span class="comment">// 舒克</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射操作属性</span></span><br><span class="line">        User user4 = (User)c1.newInstance();</span><br><span class="line">        Field name = c1.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">        name.setAccessible(<span class="keyword">false</span>); <span class="comment">// 关闭权限检测，否则无法直接修改private变量</span></span><br><span class="line">        name.set(user4, <span class="string">&quot;舒克2&quot;</span>);</span><br><span class="line">        System.out.println(user4.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="性能对比分析"><a href="#性能对比分析" class="headerlink" title="性能对比分析"></a>性能对比分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分析性能问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test12</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 普通方式调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Test12_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++) &#123;</span><br><span class="line">            user.getName();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;普通方法执行10亿次：&quot;</span> + (endTime - startTime) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反射方式调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Test12_2</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        Class c1 = user.getClass();</span><br><span class="line">        Method getName = c1.getDeclaredMethod(<span class="string">&quot;getName&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++) &#123;</span><br><span class="line">            getName.invoke(user, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;反射调用不关检测执行10亿次：&quot;</span> + (endTime - startTime) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反射反射调用（关闭检测）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Test12_3</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        Class c1 = user.getClass();</span><br><span class="line">        Method getName = c1.getDeclaredMethod(<span class="string">&quot;getName&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        getName.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++) &#123;</span><br><span class="line">            getName.invoke(user, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;反射调用不关检测执行10亿次：&quot;</span> + (endTime - startTime) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException </span>&#123;</span><br><span class="line">        Test12_1(); <span class="comment">// 6ms</span></span><br><span class="line">        Test12_2(); <span class="comment">// 2686ms</span></span><br><span class="line">        Test12_3(); <span class="comment">// 1065ms</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据结果可知：<strong>普通调用效率 &gt;&gt; 关闭检测反射调用效率 &gt; 不关闭检测反射调用效率</strong></p><h3 id="获取泛型信息"><a href="#获取泛型信息" class="headerlink" title="获取泛型信息"></a>获取泛型信息</h3><p>Java采用泛型擦除机制来引入泛型，Java中的泛型仅仅是给编译器javac使用的，确保数据的安全性和免去强制类型转换问题，但是，一旦编译完成，所有和泛型相关的类型全部擦除</p><p>为了通过反射操作这些类型，Java新增了ParameterizedType，GenericArrayType，TypeVariable和WildcardType这几种类型来代表不能被归一到Class类中的类型但是又和原始类型齐名的类型</p><ul><li>ParameterizedType: 表示一种参数化类型，比如Collection<String></String></li><li>GenericArrayType: 表示一种元素类型是参数化类型或者类型变量的数组类型</li><li>TypeVariable: 是各种类型变量的公共父接口</li><li>WildcardType: 代表一种通配符类型表达式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过反射获取泛型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test13</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Test13_1</span><span class="params">(Map&lt;String, User&gt; map, List&lt;User&gt; list)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test13_1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, User&gt; <span class="title">Test13_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test13_2&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取方法</span></span><br><span class="line">        Method method = Test13.class.getMethod(<span class="string">&quot;Test13_1&quot;</span>, Map.class, List.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取泛型参数类型</span></span><br><span class="line">        Type[] genericParameterTypes = method.getGenericParameterTypes();</span><br><span class="line">        <span class="keyword">for</span>(Type genericParameterType : genericParameterTypes) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;#&quot;</span> + genericParameterType);</span><br><span class="line">            <span class="comment">/*  #java.util.Map&lt;java.lang.String, pers.Shuke.reflection.User&gt;</span></span><br><span class="line"><span class="comment">                ------------</span></span><br><span class="line"><span class="comment">                #java.util.List&lt;pers.Shuke.reflection.User&gt;</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">// 是否属于参数化类型</span></span><br><span class="line">            <span class="keyword">if</span>(genericParameterType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">                <span class="comment">// 强制转化，获得真实的参数类型</span></span><br><span class="line">                Type[] actualTypeArguments = ((ParameterizedType) genericParameterType).getActualTypeArguments();</span><br><span class="line">                <span class="keyword">for</span>(Type actualTypeArgument : actualTypeArguments) &#123;</span><br><span class="line">                    System.out.println(actualTypeArgument);</span><br><span class="line">                    <span class="comment">/*  class java.lang.String</span></span><br><span class="line"><span class="comment">                        class pers.Shuke.reflection.User</span></span><br><span class="line"><span class="comment">                        ------------</span></span><br><span class="line"><span class="comment">                        class pers.Shuke.reflection.User</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        method = Test13.class.getMethod(<span class="string">&quot;Test13_2&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 获取返回值类型</span></span><br><span class="line">        Type genericParameterType = method.getGenericReturnType();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否为泛型</span></span><br><span class="line">        <span class="keyword">if</span>(genericParameterType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">            <span class="comment">// 强制转化为具体泛型</span></span><br><span class="line">            Type[] actualTypeArguments = ((ParameterizedType) genericParameterType).getActualTypeArguments();</span><br><span class="line">            <span class="keyword">for</span>(Type actualTypeArgument : actualTypeArguments) &#123;</span><br><span class="line">                System.out.println(actualTypeArgument);</span><br><span class="line">                <span class="comment">/*  class java.lang.String</span></span><br><span class="line"><span class="comment">                    class pers.Shuke.reflection.User</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取注解信息"><a href="#获取注解信息" class="headerlink" title="获取注解信息"></a>获取注解信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反射操作注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test14</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException </span>&#123;</span><br><span class="line">        Class c1 = Class.forName(<span class="string">&quot;pers.Shuke.reflection.People&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射获得注解</span></span><br><span class="line">        Annotation[] annotations = c1.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span>(Annotation annotation : annotations) &#123;</span><br><span class="line">            System.out.println(annotation); <span class="comment">// @pers.Shuke.reflection.TableShuke(&quot;db_people&quot;)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得注解的value的值</span></span><br><span class="line">        TableShuke tableShuke = (TableShuke)c1.getAnnotation(TableShuke.class);</span><br><span class="line">        String value = tableShuke.value();</span><br><span class="line">        System.out.println(value); <span class="comment">// db_people</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得类的指定注解</span></span><br><span class="line">        Field field = c1.getDeclaredField(<span class="string">&quot;name&quot;</span>); <span class="comment">// 获得name属性的注解</span></span><br><span class="line">        FieldShuke annotation = field.getAnnotation(FieldShuke.class);</span><br><span class="line">        System.out.println(annotation.columnName() + <span class="string">&quot; &quot;</span> + annotation.type() + <span class="string">&quot; &quot;</span> + annotation.length()); <span class="comment">// db_name varchar 8</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@TableShuke(&quot;db_people&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="meta">@FieldShuke(columnName = &quot;db_name&quot;, type = &quot;varchar&quot;, length = 8)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@FieldShuke(columnName = &quot;db_age&quot;, type = &quot;int&quot;, length = 4)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="meta">@FieldShuke(columnName = &quot;db_id&quot;, type = &quot;int&quot;, length = 12)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类名的注解</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> TableShuke &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性的注解</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> FieldShuke &#123;</span><br><span class="line">    <span class="function">String <span class="title">columnName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">type</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静态代码块，构造代码块，构造函数及其执行顺序和逻辑</title>
      <link href="2020/07/%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%8C%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E5%92%8C%E9%80%BB%E8%BE%91.html"/>
      <url>2020/07/%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%8C%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E5%92%8C%E9%80%BB%E8%BE%91.html</url>
      
        <content type="html"><![CDATA[<h2 id="静态代码块："><a href="#静态代码块：" class="headerlink" title="静态代码块："></a>静态代码块：</h2><ol><li>随着类的加载而执行，只执行一次，并优先于主函数。具体说，静态代码块是由类调用的。类调用时，先执行静态代码块，然后才执行主函数的。</li><li>静态代码块其实就是给类初始化的，而构造代码块是给对象初始化的。</li><li>静态代码块中的变量是局部变量，与普通函数中的局部变量性质没有区别。</li><li>一个类中可以有多个静态代码块（顺序由上至下）。</li></ol><h2 id="构造代码块"><a href="#构造代码块" class="headerlink" title="构造代码块"></a>构造代码块</h2><ol><li>构造代码块的作用是给对象进行初始化。<a id="more"></a> </li><li>对象一建立就运行构造代码块了，而且优先于构造函数执行。这里要强调一下，有对象建立，才会运行构造代码块，类不能调用构造代码块的，而且构造代码块与构造函数的执行顺序是前者先于后者执行。</li><li>构造代码块与构造函数的区别是：构造代码块是给所有对象进行统一初始化，而构造函数是给对应的对象初始化，因为构造函数是可以多个的，运行哪个构造函数就会建立什么样的对象，但无论建立哪个对象，都会先执行相同的构造代码块。也就是说，构造代码块中定义的是不同对象共性的初始化内容。</li></ol><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ol><li>对象一建立，就会调用与之相应的构造函数，也就是说，不建立对象，构造函数是不会运行的。</li><li>构造函数的作用是用于给对象进行初始化。</li><li>一个对象建立，构造函数只运行一次，而一般方法可以被该对象调用多次。</li></ol><h2 id="Java类初始化顺序"><a href="#Java类初始化顺序" class="headerlink" title="Java类初始化顺序"></a>Java类初始化顺序</h2><ol><li>单一类：静态变量，静态代码块 &gt; 变量，构造代码块 &gt; 构造函数<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test06</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String x = <span class="string">&quot;静态变量&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> String y = <span class="string">&quot;变量&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test06</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(y);</span><br><span class="line">        System.out.println(<span class="string">&quot;构造代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 输出：静态变量</span></span><br><span class="line"><span class="comment">                静态代码块</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        Test06 test06 = <span class="keyword">new</span> Test06();</span><br><span class="line">        <span class="comment">/* 输出：变量</span></span><br><span class="line"><span class="comment">                构造代码块</span></span><br><span class="line"><span class="comment">                构造函数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>继承情况：父类静态 &gt; 子类静态 &gt; 父类构造代码块 &gt; 父类构造函数 &gt; 子类构造代码块 &gt; 子类构造函数</li></ol><p><strong>静态变量是属于类的，和继承无关！！！</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test06</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test06</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类构造代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test06_1</span> <span class="keyword">extends</span> <span class="title">Test06</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test06_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类构造代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 输出：父类静态代码块</span></span><br><span class="line"><span class="comment">                子类静态代码块</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        Test06_1 test06_1 = <span class="keyword">new</span> Test06_1();</span><br><span class="line">        <span class="comment">/* 输出：父类构造代码块</span></span><br><span class="line"><span class="comment">                父类构造函数</span></span><br><span class="line"><span class="comment">                子类构造代码块</span></span><br><span class="line"><span class="comment">                子类构造函数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        staticFunction();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态变量（有实例化的过程,这就是本题的重点）</span></span><br><span class="line">    <span class="keyword">static</span> StaticTest st = <span class="keyword">new</span> StaticTest();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//System.out.println(b); // 编译报错：因为b在构造代码块后边，此处不能引用。因此Java代码是从上到下的顺序</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    StaticTest() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;a=&quot;</span> + a + <span class="string">&quot;,b=&quot;</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这两个变量写在最后面</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">110</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">112</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出：2</span></span><br><span class="line"><span class="comment">        3</span></span><br><span class="line"><span class="comment">        a=110,b=0</span></span><br><span class="line"><span class="comment">        1</span></span><br><span class="line"><span class="comment">        4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ol><li>先初始化静态变量，也就是执行new StaticTest()，先执行构造代码块，输出 2</li><li>再执行构造函数，输出 3 和 a=110,b=0<ul><li>在执行构造函数前，必须初始化实例属性，故 a = 110</li><li>静态变量从上到下初始化，还没有轮到，因此 b = 0</li></ul></li><li>执行静态代码块，输出 1</li><li>最后进入main函数，执行静态方法staticFunction，输出 4</li></ol><p>可以发现：<strong>static变量并不一定在实例化变量前被初始化</strong>。</p><h3 id="父类和子类有同名属性时"><a href="#父类和子类有同名属性时" class="headerlink" title="父类和子类有同名属性时"></a>父类和子类有同名属性时</h3><pre><code class="lang-Java">public class Test07 &#123;    public static void main(String[] args) &#123;        // 使用多态        Parent chidParent = new Child();        System.out.println(&quot;Parent:&quot; + chidParent.getAge()); //40        System.out.println(&quot;Parent:&quot; + chidParent.age); //18        System.out.println(&quot;Parent:&quot; + chidParent.id); //08        // 直接使用原本类型        Child child = new Child();        System.out.println(&quot;Child:&quot; + child.getAge()); //40        System.out.println(&quot;Child:&quot; + child.age); //40        System.out.println(&quot;Child:&quot; + child.id); //8    &#125;&#125;class Child extends Parent &#123;    public Integer age = 40;    public Integer id = 8;    public int getAge() &#123;        return age;    &#125;&#125;class Parent &#123;    public Integer age = 18;    public String id = &quot;08&quot;;    public int getAge() &#123;        return age;    &#125;&#125;</code></pre><p>对于输出 18 的解释（Java的继承机制）：</p><ol><li>属性属于实例自己的，所以Parent的age属性值是18</li><li>属性不存在覆盖（即使同名），而方法是实实在在的覆盖（复写）</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客多校2020第二场补题</title>
      <link href="2020/07/%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A12020%E7%AC%AC%E4%BA%8C%E5%9C%BA%E8%A1%A5%E9%A2%98.html"/>
      <url>2020/07/%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A12020%E7%AC%AC%E4%BA%8C%E5%9C%BA%E8%A1%A5%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<h2 id="F-Fake-Maxpooling"><a href="#F-Fake-Maxpooling" class="headerlink" title="F Fake Maxpooling"></a>F Fake Maxpooling</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>规定矩阵对应的值为其下标的 $lcm$ ，求所有 $k * k$ 子矩阵最大值之和。 $( n,m,k = 5000 )$</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><a id="more"></a> <p>线性求 $lcm$ + 二维单调队列</p><p>线性求 $lcm$ ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!g[i][j]) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">1</span>; h * i &lt;= n &amp;&amp; h * j &lt;= m; h++) &#123;</span><br><span class="line">          g[h * i][h * j] = h;</span><br><span class="line">          a[h * i][h * j] = i * j * h;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>先对每一行进行单调队列（滑动窗口）维护出最大值矩阵 $g$ ，再对列进行单调队列维护矩阵 $g$ 的最大值即可。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5005</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k, a[N][N], g[N][N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> res;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!g[i][j]) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">1</span>; h * i &lt;= n &amp;&amp; h * j &lt;= m; h++) &#123;</span><br><span class="line">          g[h * i][h * j] = h;</span><br><span class="line">          a[h * i][h * j] = i * j * h;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">      <span class="keyword">while</span> (!q.empty() &amp;&amp; a[i][q.back()] &lt; a[i][j]) q.pop_back();</span><br><span class="line">      <span class="keyword">while</span> (!q.empty() &amp;&amp; j - q.front() &gt;= k) q.pop_front();</span><br><span class="line">      q.push_back(j);</span><br><span class="line">      <span class="keyword">if</span> (j &gt;= k) g[i][j] = a[i][q.front()];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">      <span class="keyword">while</span> (!q.empty() &amp;&amp; g[q.back()][i] &lt; g[j][i]) q.pop_back();</span><br><span class="line">      <span class="keyword">while</span> (!q.empty() &amp;&amp; j - q.front() &gt;= k) q.pop_front();</span><br><span class="line">      q.push_back(j);</span><br><span class="line">      <span class="keyword">if</span> (j &gt;= k) &#123;</span><br><span class="line">        a[j][i] = g[q.front()][i];</span><br><span class="line">        res += a[j][i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Cover-the-Tree"><a href="#C-Cover-the-Tree" class="headerlink" title="C Cover the Tree"></a>C Cover the Tree</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给定无根树，用最少的链覆盖树的所有点。 $( n = 2e5 )$</p><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>思维 + dfs序</p><p>首先不难想到所取的链两个端点都在叶子上才会是最优的，因此答案应为 $(叶子结点数 + 1)/2$ 。</p><p>经过一番玄学证明，得到结论为按 dfs序 构造链会是最优的，任取非叶子结点为根，由 dfs序 得到叶子结点 $l<em>1, l_2 ….l_x$ ，然后将 $l_1$ 与 $l</em>{x/2+1}$ 构成链以此类推，若多出一个点，则与根结点连起来即可。</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, u, v, root, de[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[N], res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (de[u] == <span class="number">1</span>) res.push_back(u);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> v : g[u]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">    dfs(v, u);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">    g[u].push_back(v);</span><br><span class="line">    g[v].push_back(u);</span><br><span class="line">    de[u]++;</span><br><span class="line">    de[v]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (de[i] &gt; <span class="number">1</span>) root = i;</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(root, <span class="number">-1</span>);</span><br><span class="line">  n = res.size();</span><br><span class="line">  <span class="keyword">if</span> (n &amp; <span class="number">1</span>) res.push_back(root), n++;</span><br><span class="line">  n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, res[i], res[i + n]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Boundary"><a href="#B-Boundary" class="headerlink" title="B Boundary"></a>B Boundary</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>已知一个圆必过点 $(0,0)$ ，需要构造该圆使得尽可能多的给定点在该圆的边界上，问最多能有几个点。 $( n = 2000, |x,y| = 100000 )$</p><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>三个点可以确定一个圆，因此不妨枚举两个点，求出圆心，圆心重合次数最多的即为答案。</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, res;</span><br><span class="line"><span class="keyword">double</span> X, Y, R;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">  <span class="keyword">double</span> x, y;</span><br><span class="line">&#125; p[N];</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt;, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">(Point a, Point b, Point c)</span>  <span class="comment">//三点共圆圆心公式</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">2</span> * (a.y - c.y) * (a.x - b.x) - <span class="number">2</span> * (a.y - b.y) * (a.x - c.x) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">      <span class="number">2</span> * (a.y - b.y) * (a.x - c.x) - <span class="number">2</span> * (a.y - c.y) * (a.x - b.x) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  X = ((a.x * a.x - b.x * b.x + a.y * a.y - b.y * b.y) * (a.y - c.y) -</span><br><span class="line">       (a.x * a.x - c.x * c.x + a.y * a.y - c.y * c.y) * (a.y - b.y)) /</span><br><span class="line">      (<span class="number">2</span> * (a.y - c.y) * (a.x - b.x) - <span class="number">2</span> * (a.y - b.y) * (a.x - c.x));</span><br><span class="line">  Y = ((a.x * a.x - b.x * b.x + a.y * a.y - b.y * b.y) * (a.x - c.x) -</span><br><span class="line">       (a.x * a.x - c.x * c.x + a.y * a.y - c.y * c.y) * (a.x - b.x)) /</span><br><span class="line">      (<span class="number">2</span> * (a.y - b.y) * (a.x - c.x) - <span class="number">2</span> * (a.y - c.y) * (a.x - b.x));</span><br><span class="line">  R = <span class="built_in">sqrt</span>((X - a.x) * (X - a.x) + (Y - a.y) * (Y - a.y));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>, &amp;p[i].x, &amp;p[i].y);</span><br><span class="line">  Point o = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    mp.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (solve(o, p[i], p[j])) &#123;</span><br><span class="line">        <span class="keyword">auto</span> now = <span class="built_in">make_pair</span>(X, Y);</span><br><span class="line">        res = max(res, ++mp[now]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ++res);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="J-Just-Shuffle"><a href="#J-Just-Shuffle" class="headerlink" title="J Just Shuffle"></a>J Just Shuffle</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>一个排列经过质数次置换后得到排列 A ，求原排列。 ( n = 1e5 )</p><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>直接拍个置换开根板子就过了。。。</p><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, i, j, k, o, x, l, d, a[N], g[N], nxt[N], t, q[N], b[N], ans[N];</span><br><span class="line"><span class="keyword">bool</span> v[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, k = m, t = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">2</span>; i * i &lt;= x; i++)</span><br><span class="line">    <span class="keyword">if</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i, t *= i;</span><br><span class="line">      <span class="keyword">while</span> (k % i == <span class="number">0</span>) k /= i, t *= i;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (t *= x; k % x == <span class="number">0</span>; k /= x, t *= x)</span><br><span class="line">      ;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">if</span> (!v[i]) &#123;</span><br><span class="line">      t = v[i] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (j = a[i]; j != i; j = a[j]) v[j] = <span class="number">1</span>, t++;</span><br><span class="line">      nxt[i] = g[t], g[t] = i;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">if</span> (g[i]) &#123;</span><br><span class="line">      <span class="keyword">for</span> (t = <span class="number">0</span>, j = g[i]; j; j = nxt[j]) q[++t] = j;</span><br><span class="line">      d = __gcd(l = cal(i), m);</span><br><span class="line">      <span class="keyword">if</span> (t % d) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>), <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (x = <span class="number">1</span>; x &lt;= t; x += d) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; d; j++)</span><br><span class="line">          <span class="keyword">for</span> (k = <span class="number">0</span>, o = q[x + j]; k &lt; i; k++, o = a[o])</span><br><span class="line">            b[(j + <span class="number">1L</span>L * k * m) % l] = o;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; l; j++) ans[b[j]] = b[(j + <span class="number">1</span>) % l];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 多校训练 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多校训练 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：地下城游戏 （dp）</title>
      <link href="2020/07/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F-%EF%BC%88dp%EF%BC%89.html"/>
      <url>2020/07/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F-%EF%BC%88dp%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定权值矩阵，需要从左上角走到右下角，只能往右或往下走且权值会累加，问至少需要提前准备多少权值才能保证过程中不出现权值被耗尽的情况。</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>正着不太好写，可以尝试倒过来dp，$dp[i][j]$ 表示当前位置到终点至少需要准备多少权值，这样每个点要么从下边转移，要么从右边转移，选择最小的那个点转移即可，过程中需要保证权值至少为1，得到转移方程：$dp[i][j] = max(min(dp[i+1][j],dp[i][j+1])-mp[i][j],1)$。<br><a id="more"></a> </p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="keyword">int</span>[][] mp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = mp.length, m = mp[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            Arrays.fill(dp[i], Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[n][m - <span class="number">1</span>] = dp[n - <span class="number">1</span>][m] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                dp[i][j] = Math.max(Math.min(dp[i + <span class="number">1</span>][j], dp[i][j + <span class="number">1</span>]) - mp[i][j], <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：Contest （树状数组）</title>
      <link href="2020/06/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AContest-%EF%BC%88%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%EF%BC%89.html"/>
      <url>2020/06/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AContest-%EF%BC%88%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p> $n$ 支队伍一共参加了三场比赛。<br>一支队伍 $x$ 认为自己比另一支队伍 $y$ 强当且仅当 $x$ 在至少一场比赛中比 $y$ 的排名高。<br>求有多少组 $(x,y)$，使得 $x$ 自己觉得比 $y$ 强，$y$ 自己也觉得比 $x$ 强，$(x, y)$, $(y, x)$算一组。</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><a id="more"></a> <p>若 $x$ 和 $y$ 都互相认为更强，那么必定存在两场，一场 $x$ 强于 $y$，一场 $y$ 强于 $x$，那么就是对于任意两场求逆序数，最后的答案需要除以2，因为如果两队互认为更强，必定存在 $x$ 有两场更强，或者 $y$ 有两场更强，那么计算逆序数时就多计算了一次。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const ll N = <span class="number">2</span>e5 + <span class="number">5</span>;</span><br><span class="line">ll n, res, t[N];</span><br><span class="line"></span><br><span class="line">struct Node &#123;</span><br><span class="line">  ll a, b, c;</span><br><span class="line">&#125; <span class="string">q[N]</span>;</span><br><span class="line"></span><br><span class="line">bool cmpa(Node <span class="keyword">x</span>, Node <span class="keyword">y</span>) &#123; <span class="keyword">return</span> x.a &lt; y.a; &#125;</span><br><span class="line">bool cmpb(Node <span class="keyword">x</span>, Node <span class="keyword">y</span>) &#123; <span class="keyword">return</span> x.b &lt; y.b; &#125;</span><br><span class="line"></span><br><span class="line">void add(ll <span class="keyword">x</span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">x</span> &lt;= n) &#123;</span><br><span class="line">    t[<span class="keyword">x</span>]++;</span><br><span class="line">    <span class="keyword">x</span> += <span class="keyword">x</span> &amp; -<span class="keyword">x</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll query(ll <span class="keyword">x</span>) &#123;</span><br><span class="line">  ll sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">x</span>) &#123;</span><br><span class="line">    sum += t[<span class="keyword">x</span>];</span><br><span class="line">    <span class="keyword">x</span> -= <span class="keyword">x</span> &amp; -<span class="keyword">x</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main() &#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; <span class="string">q[i]</span>.a &gt;&gt; <span class="string">q[i]</span>.b &gt;&gt; <span class="string">q[i]</span>.c;</span><br><span class="line">  <span class="keyword">sort</span>(<span class="keyword">q</span> + <span class="number">1</span>, <span class="keyword">q</span> + n + <span class="number">1</span>, cmpa);</span><br><span class="line">  <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    add(<span class="string">q[i]</span>.b);</span><br><span class="line">    res += i - query(<span class="string">q[i]</span>.b);</span><br><span class="line">  &#125;</span><br><span class="line">  memset(t, <span class="number">0</span>, sizeof(t));</span><br><span class="line">  <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    add(<span class="string">q[i]</span>.c);</span><br><span class="line">    res += i - query(<span class="string">q[i]</span>.c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">sort</span>(<span class="keyword">q</span> + <span class="number">1</span>, <span class="keyword">q</span> + n + <span class="number">1</span>, cmpb);</span><br><span class="line">  memset(t, <span class="number">0</span>, sizeof(t));</span><br><span class="line">  <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    add(<span class="string">q[i]</span>.c);</span><br><span class="line">    res += i - query(<span class="string">q[i]</span>.c);</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; res / <span class="number">2</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：Protecting the Flower （贪心）</title>
      <link href="2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AProtecting-the-Flower-%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%89.html"/>
      <url>2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AProtecting-the-Flower-%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>一共有 $n$ 只牛在花坛旁边，第 $i$ 头牛每分钟破坏 $d_i$ 朵花，把第i头牛带回牛棚需要 $2 \times ti$ 这么多时间，每次只能带回一头牛，请问怎样能使得被破坏的花最少。</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>以小化大，先考虑两头牛，先领 $a$ ，损失为：$2\times{t_a}\times{d_b}$，先领 $b$，损失为 $2\times{t_b}\times{d_a}$，故得到排序条件 ${a_t \times {b_d} &lt; b_t \times {a_d}}$，最后模拟得出答案。<br><a id="more"></a> </p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">ll n, sum, res;</span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; p[i].x &gt;&gt; p[i].y;</span><br><span class="line">  sort(p + <span class="number">1</span>, p + n + <span class="number">1</span>, [](PI a, PI b) &#123; <span class="keyword">return</span> a.x * b.y &lt; b.x * a.y; &#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    res += sum * p[i].y;</span><br><span class="line">    sum += p[i].x * <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：货币系统 （背包dp）</title>
      <link href="2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%B4%A7%E5%B8%81%E7%B3%BB%E7%BB%9F-%EF%BC%88%E8%83%8C%E5%8C%85dp%EF%BC%89.html"/>
      <url>2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%B4%A7%E5%B8%81%E7%B3%BB%E7%BB%9F-%EF%BC%88%E8%83%8C%E5%8C%85dp%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>$n$ 种面额货币，数量无限，问最多保留几种，使得原来可以组成的仍然可以组成。（$t&lt;=20,n&lt;=100,a[i]&lt;=25000$）</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>由于大的只会被小的组成，所以先排序，对于存在性问题就显然是完全背包了，dp[i] 表示是否能表示出 $i$ 价值，得到状态转移方程：$dp[i]|=dp[i-a[i]]$，对于已经可以表示出来对 $a[i]$，已经可以由小的组成，因此不需要在枚举。<br><a id="more"></a> </p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, n, res, a[<span class="number">105</span>], dp[<span class="number">300005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">  <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    res = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!dp[a[i]]) &#123;</span><br><span class="line">        res++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = a[i]; j &lt;= a[n]; j++) dp[j] |= dp[j - a[i]];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 背包dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：建筑抢修 （贪心）</title>
      <link href="2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%BB%BA%E7%AD%91%E6%8A%A2%E4%BF%AE-%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%89.html"/>
      <url>2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%BB%BA%E7%AD%91%E6%8A%A2%E4%BF%AE-%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>$n$ 栋建筑，第 $i$ 栋建筑需要 $s_i$ 时间修，截止到 $t_i$ 时间，问最多可以修多少建筑。</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>我们可以类比成写作业，先截止的我们会先做，这是大体的贪心策略。但他并不是最优的，因为可能那一科会花你非常多的时间，够你做更多的科目，得不偿失。因此我们用优先队列维护做过的作业中花费时间最大的那份，当目前要做的作业时间不够的时候，与这个最大值比较看是否花的时间更少，可行的话就把这个塞进去，那个丢出来，这样做了同样多的作业却花了更少的时间，同时维护答案。<br><a id="more"></a> </p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, sum, res;</span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p[N];</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; p[i].y &gt;&gt; p[i].x;</span><br><span class="line">  sort(p, p + n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sum + p[i].y &lt;= p[i].x) &#123;</span><br><span class="line">      sum += p[i].y;</span><br><span class="line">      res++;</span><br><span class="line">      q.push(p[i].y);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p[i].y &lt; q.top()) &#123;</span><br><span class="line">      sum -= q.top();</span><br><span class="line">      q.pop();</span><br><span class="line">      q.push(p[i].y);</span><br><span class="line">      sum += p[i].y;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：中位数图</title>
      <link href="2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E4%B8%AD%E4%BD%8D%E6%95%B0%E5%9B%BE.html"/>
      <url>2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E4%B8%AD%E4%BD%8D%E6%95%B0%E5%9B%BE.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个 $1-n$ 排列，求长度为奇数子串以 $b$ 为中位数的子串个数。</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>由于求的是中位数，所以我们只需要关心这个数和 $b$ 的大小关系就好了，大于 $b$ 看作 1，小于 $b$ 看作 -1，等于 $b$ 看作 0，问题转化为求包含 0 且和为 0 的子串有多少个。<br><a id="more"></a> </p><p>从 $b$ 的位置开始遍历，map 统计右边累加的和，然后从左边累加的和中查找对应的相反数个数，累加即可。同时，如果遍历过程中任何一边已经存在和为 0 的情况，也为可行解。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="keyword">int</span> n, b, sum, pos, res, a[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; b;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">if</span> (a[i] &gt; b)</span><br><span class="line">      a[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a[i] &lt; b)</span><br><span class="line">      a[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a[i] == b) &#123;</span><br><span class="line">      a[i] = <span class="number">0</span>;</span><br><span class="line">      pos = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = pos + <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    sum += a[i];</span><br><span class="line">    mp[sum]++;</span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">0</span>) res++;</span><br><span class="line">  &#125;</span><br><span class="line">  sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = pos - <span class="number">1</span>; i; i--) &#123;</span><br><span class="line">    sum += a[i];</span><br><span class="line">    res += mp[-sum];</span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">0</span>) res++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res + <span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：简单瞎搞题 （STL）</title>
      <link href="2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%AE%80%E5%8D%95%E7%9E%8E%E6%90%9E%E9%A2%98-%EF%BC%88STL%EF%BC%89.html"/>
      <url>2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%AE%80%E5%8D%95%E7%9E%8E%E6%90%9E%E9%A2%98-%EF%BC%88STL%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>一共有 $n$ 个数，第 $i$ 个数是 $x_i$ 可以取 $[l_i , r_i]$ 中任意的一个值。设 $S = \sum{ {x_i}^2}$，求 $S$ 种类数。（0 ~ n,l,r ~ 100）</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>$dp[i][j]$ 表示前 $i$ 个数能不能组成 $j$，可以得到转移方程：$dp[i][j]=dp[i-1][j-x^2]$，最后统计 $dp[n]$ 层组成的 $j$ 的数量即可。因为 dp 的值只有 0 和 1 ，因此使用 bitset 优化，把第二维看成二进制位，这样就可以用位移的形式来表示加法运算，得到转移方程：dp[i]=dp[i-1] &lt;&lt; (j*j)，复杂度 $10^{10}/64$。<br><a id="more"></a> </p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">bitset</span>&lt;1000005&gt; dp[<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, l, r;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = l; j &lt;= r; j++) dp[i] |= dp[i - <span class="number">1</span>] &lt;&lt; (j * j);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>, dp[n].count());</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：图的遍历</title>
      <link href="2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86.html"/>
      <url>2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>无向图 $n$ 个点，每次必须跳两个，至少需要加多少条边可以遍历所有点。</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>首先，如果图不联通，那么需要加联通分量 - 1 条边使图联通，然后发现一点，只要这个图存在奇数环，就一定能全部走完，不存在的话，随便加一条边生成奇数环即可。<br><a id="more"></a> </p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, odd, x, y, res, vis[N], color[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> v : g[u]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">      vis[v] = <span class="number">1</span>;</span><br><span class="line">      color[v] = !color[u];</span><br><span class="line">      dfs(v);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (color[u] == color[v])</span><br><span class="line">      odd = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    g[x].push_back(y);</span><br><span class="line">    g[y].push_back(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">      res++;</span><br><span class="line">      vis[i] = color[i] = <span class="number">1</span>;</span><br><span class="line">      dfs(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res - odd &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：比赛</title>
      <link href="2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%AF%94%E8%B5%9B.html"/>
      <url>2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%AF%94%E8%B5%9B.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>一共12道题，你有 $a_i$ 的概率做对第 $i$ 题，有 $b_i$ 的概率抄到左边的，有 $c_i$ 的概率抄到右边的，问做对 $0-12$ 题的概率是多少。</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>做对的概率不太好求，可以反过来求做错的概率，即 $(1-a[i])\times(1-b[i])\times(1-c[i])$，然后 $dp[i][j]$ 表示前 $i$ 道题做对 $j$ 道的概率，设 $dp[0][0] =1$，得到状态转移方程：$dp[i][j]=dp[i-1][j-1]\times(ac=(1-wa))+dp[i-1][j]*wa$ 。<br><a id="more"></a> </p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">double a[<span class="number">15</span>], b[<span class="number">15</span>], c[<span class="number">15</span>], dp[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line">int main() &#123;</span><br><span class="line">  for (int i = <span class="number">1</span>; i &lt;= <span class="number">12</span>; i++) cin &gt;&gt; a[i];</span><br><span class="line">  for (int i = <span class="number">1</span>; i &lt;= <span class="number">12</span>; i++) cin &gt;&gt; b[i];</span><br><span class="line">  for (int i = <span class="number">1</span>; i &lt;= <span class="number">12</span>; i++) cin &gt;&gt; c[i];</span><br><span class="line">  dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  for (int i = <span class="number">1</span>; i &lt;= <span class="number">12</span>; i++) &#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] * (<span class="number">1</span> - a[i]) * (<span class="number">1</span> - b[i]) * (<span class="number">1</span> - c[i]);</span><br><span class="line">    for (int j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">      double wa = (<span class="number">1</span> - a[i]) * (<span class="number">1</span> - b[i]) * (<span class="number">1</span> - c[i]);</span><br><span class="line">      dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] * (<span class="number">1</span> - wa) + dp[i - <span class="number">1</span>][j] * wa;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i = <span class="number">0</span>; i &lt;= <span class="number">12</span>; i++) printf(<span class="string">&quot;%f\n&quot;</span>, dp[<span class="number">12</span>][i]);</span><br><span class="line">  return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：加分二叉树 （树形dp/区间dp）</title>
      <link href="2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%8A%A0%E5%88%86%E4%BA%8C%E5%8F%89%E6%A0%91-%EF%BC%88%E6%A0%91%E5%BD%A2dp-%E5%8C%BA%E9%97%B4dp%EF%BC%89.html"/>
      <url>2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%8A%A0%E5%88%86%E4%BA%8C%E5%8F%89%E6%A0%91-%EF%BC%88%E6%A0%91%E5%BD%A2dp-%E5%8C%BA%E9%97%B4dp%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有一颗二叉树，树的每一个节点都有一个值，设他的中序遍历为（l,2,3,…,n），其中数字1,2,3,…,n为节点编号。</p><p>任一棵子树subtree（也包含tree本身）的加分计算方法如下：<br><a id="more"></a> </p><p>subtree的左子树的加分× subtree的右子树的加分＋subtree的根的分数<br>若某个子树为主，规定其加分为1，叶子的加分就是叶节点本身的分数。不考虑它的空子树。 试求一棵符合中序遍历为（1,2,3,…,n）且加分最高的二叉树tree。</p><p>要求输出：（1）tree的最高加分（2）tree的前序遍历</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>符合条件的二叉树是加分最高的二叉树，它的总分依题意得 总分 = 左子树分数 * 右子树分数 + 根节点分数 ，想要总分最高，左右子树的分数应当也分别取最高。 </p><p>题目中给出的节点序号根据二叉树的中序遍历排列，$dp[l][r]$ （l&lt;r） 表示从节点 $l$ 到节点 $r$ 所构成的子树的最高加分。设$k(l \le k \le r)$为该子树的根节点，通过枚举当前 $[l,r]$ 某点为根来取得不同的左右子树和根节点分数，维护最大值。</p><p>状态转移方程：</p><p>$dp[i][j]=max(dp[i][j],dp[i][k-1]*dp[k+1][r]+dp[k][k])$</p><p>最后维护一个 $root$ 数组表示节点 $l-r$ 最高分子树的根即可。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int <span class="symbol">N</span> = <span class="number">35</span>;</span><br><span class="line"></span><br><span class="line">int n, root[<span class="symbol">N</span>][<span class="symbol">N</span>];</span><br><span class="line">ll dp[<span class="symbol">N</span>][<span class="symbol">N</span>];</span><br><span class="line"></span><br><span class="line">void dfs(int l, int r) &#123;</span><br><span class="line">  if (l &gt; r) return;</span><br><span class="line">  cout &lt;&lt; root[l][r] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  dfs(l, root[l][r] - <span class="number">1</span>);</span><br><span class="line">  dfs(root[l][r] + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  for (int i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    cin &gt;&gt; dp[i][i];</span><br><span class="line">    dp[i][i - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[i + <span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">    root[i][i] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    for (int l = <span class="number">1</span>; l + i &lt;= n; l++) &#123;</span><br><span class="line">      int r = l + i;</span><br><span class="line">      for (int k = l; k &lt;= r; k++) &#123;</span><br><span class="line">        int tmp = dp[l][k - <span class="number">1</span>] * dp[k + <span class="number">1</span>][r] + dp[k][k];</span><br><span class="line">        if (dp[l][r] &lt; tmp) &#123;</span><br><span class="line">          dp[l][r] = tmp;</span><br><span class="line">          root[l][r] = k;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; dp[<span class="number">1</span>][n] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  dfs(<span class="number">1</span>, n);</span><br><span class="line">  return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区间dp </tag>
            
            <tag> 树形dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：储物点的距离</title>
      <link href="2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%82%A8%E7%89%A9%E7%82%B9%E7%9A%84%E8%B7%9D%E7%A6%BB.html"/>
      <url>2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%82%A8%E7%89%A9%E7%82%B9%E7%9A%84%E8%B7%9D%E7%A6%BB.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定 $i$ 和 $i+1$两点的距离和 $i$ 点的货物数量，$m$ 次询问将 $[l,r]$ 所有物品搬到 $x$ 点的总费用（区间内每个物品各自离 $x$ 点距离和）。（$n,m &lt;= 200000 , 0 &lt;= ai,bi &lt;= 2000000000$）</p><h3 id="soltuion"><a href="#soltuion" class="headerlink" title="soltuion"></a>soltuion</h3><p>前缀和维护：$sum1$ 表示每个储物点离原点0的距离，$sum2$ 表示前 $i$ 个储物点共有多少货物，$sum3$ 表示前 $i$ 个储物点的所有物品到原点0的和。<br><a id="more"></a> </p><ul><li>$x&lt;=l$，即 $[l,r]$ 所有物品到原点的距离 - 到 $x$ 点的距离。</li><li>$x&gt;=r$，即 $[l,r]$ 所有物品从 $x$ 点到原点的距离 - 从原位置到原点的距离。</li><li>处于中间的情况，就是拆解成 $[l,x],[x+1,r]$ 两种情况，然后分别带入上面情况即可。</li></ul><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const ll <span class="keyword">mod</span> = <span class="number">1000000007</span>;</span><br><span class="line">const int N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">int n, m, l, r;</span><br><span class="line">ll <span class="symbol">x</span>, res, sum1[N], sum2[N], sum3[N];</span><br><span class="line">int main() &#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (int i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    cin &gt;&gt; <span class="symbol">x</span>;</span><br><span class="line">    sum1[i] = (sum1[i - <span class="number">1</span>] + <span class="symbol">x</span>) % <span class="keyword">mod</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    cin &gt;&gt; <span class="symbol">x</span>;</span><br><span class="line">    sum2[i] = (sum2[i - <span class="number">1</span>] + <span class="symbol">x</span>) % <span class="keyword">mod</span>;</span><br><span class="line">    sum3[i] = (sum3[i - <span class="number">1</span>] + sum1[i] * <span class="symbol">x</span>) % <span class="keyword">mod</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    cin &gt;&gt; <span class="symbol">x</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    <span class="keyword">if</span> (<span class="symbol">x</span> &lt;= l)</span><br><span class="line">      res = ((sum3[r] - sum3[l - <span class="number">1</span>] + <span class="keyword">mod</span>) % <span class="keyword">mod</span> -</span><br><span class="line">             (sum2[r] - sum2[l - <span class="number">1</span>] + <span class="keyword">mod</span>) % <span class="keyword">mod</span> * sum1[<span class="symbol">x</span>] % <span class="keyword">mod</span> + <span class="keyword">mod</span>) %</span><br><span class="line">            <span class="keyword">mod</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="symbol">x</span> &gt;= r)</span><br><span class="line">      res = ((sum1[<span class="symbol">x</span>] * ((sum2[r] - sum2[l - <span class="number">1</span>] + <span class="keyword">mod</span>) % <span class="keyword">mod</span>)) % <span class="keyword">mod</span> - sum3[r] +</span><br><span class="line">             sum3[l - <span class="number">1</span>] + <span class="keyword">mod</span>) %</span><br><span class="line">            <span class="keyword">mod</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      res = (((sum3[r] - sum3[<span class="symbol">x</span>] + <span class="keyword">mod</span>) % <span class="keyword">mod</span> -</span><br><span class="line">              (sum2[r] - sum2[<span class="symbol">x</span>] + <span class="keyword">mod</span>) % <span class="keyword">mod</span> * sum1[<span class="symbol">x</span>] + <span class="keyword">mod</span>) %</span><br><span class="line">                 <span class="keyword">mod</span> +</span><br><span class="line">             ((sum1[<span class="symbol">x</span>] * ((sum2[<span class="symbol">x</span>] - sum2[l - <span class="number">1</span>] + <span class="keyword">mod</span>) % <span class="keyword">mod</span>)) % <span class="keyword">mod</span> -</span><br><span class="line">              sum3[<span class="symbol">x</span>] + sum3[l - <span class="number">1</span>] + <span class="keyword">mod</span>) %</span><br><span class="line">                 <span class="keyword">mod</span>) %</span><br><span class="line">            <span class="keyword">mod</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (res + <span class="keyword">mod</span>) % <span class="keyword">mod</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：Moovie Mooving （状压dp）</title>
      <link href="2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AMoovie-Mooving-%EF%BC%88%E7%8A%B6%E5%8E%8Bdp%EF%BC%89.html"/>
      <url>2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AMoovie-Mooving-%EF%BC%88%E7%8A%B6%E5%8E%8Bdp%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有 N 部电影，每部电影有不同的放映时常，和若干个放映起始时间。<br>Bessie 可以在一部电影播放过程中的任何时间进入或退出放映厅。每部电影她最多看1次且她不能在看一部电影的过程中，换到另一个正在播放相同电影的放映厅。</p><p>Bessie 能不能从0到L分钟连续不断地观看电影？如果能，计算她最少看几部电影。</p><a id="more"></a> <p>$(1 \leq L \leq 100,000,000，1\leq N\leq 201≤L≤100,000,000，1≤N≤20)$</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>$n$ 只有20考虑状压dp，$dp[i]$ 表示完成 $i$ 集合需要的最长时间，假设 $i$ 集合最后看的一部电影为 $j$，那么 $dp[i]$ 由 dp[i ^ (2^j)] 转移过来，并二分选取小于转移前集合的电影 $j$ 的最晚放映时间来更新 $p[i]$，同时维护 $dp[i] &gt;=l $ 的最小集合为答案。时间复杂度 $O(2^n*log(1000))$</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">int</span> n, l, t[N], dp[<span class="number">1</span> &lt;&lt; N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; l;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> c, x;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t[i] &gt;&gt; c;</span><br><span class="line">    <span class="keyword">while</span> (c--) &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">      g[i].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    g[i].push_back(l);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> res = n + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((i &gt;&gt; j) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> now = i ^ (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">        <span class="keyword">int</span> pos =</span><br><span class="line">            upper_bound(g[j].<span class="built_in">begin</span>(), g[j].<span class="built_in">end</span>(), dp[now]) - g[j].<span class="built_in">begin</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (pos &gt;= <span class="number">0</span> &amp;&amp; g[j][pos] + t[j] &gt; dp[now])</span><br><span class="line">          dp[i] = <span class="built_in">max</span>(dp[i], g[j][pos] + t[j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dp[i] &gt;= l) res = <span class="built_in">min</span>(res, __builtin_popcount(i));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (res == n + <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状压dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：过河 离散化+dp</title>
      <link href="2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%BF%87%E6%B2%B3-%E7%A6%BB%E6%95%A3%E5%8C%96-dp.html"/>
      <url>2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%BF%87%E6%B2%B3-%E7%A6%BB%E6%95%A3%E5%8C%96-dp.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>桥长度为$L$ ，分布有$n$ 个石子，青蛙每次可以跳 $[S,T]$ 的距离,问青蛙过桥至少要踩多少个石子。</p><p>$(1&lt;=S,T&lt;=10,m&lt;=100,a_i&lt;=10^9, a_i 表示第i个石子的位置)$</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><a id="more"></a> <p>这是个很显然的dp题，难点在于他的 $a_i$ 达到了 $10^9$ ，所以我们需要压缩一下。</p><ol><li>当 $s==t$ 时，答案就是位置能被 $s$ 整除的石子个数。</li><li>当 $s!=t$ 时，我们可以发现：假设当前位置为 $x$ ，那么 $x+s*t$ 之后的所有位置是一定可以被走到的。（可以看做是 $s$ 个 $t$ 步相加或 $t$ 个 $s$ 步相加，然后调整某些步的长度即可。）</li></ol><p>然后，石子之间的距离就被压缩了，只要相邻的两个石子距离 $&gt;=s<em>t$ 的变成 $s</em>t$ 即可。</p><p>但是这样一压缩，最后的落点就不能确定了，但是起点是已知的，所以干脆倒过来dp。</p><p>状态转移方程：</p><ul><li>i 点有石子：$dp[i] = min(dp[i], dp[i+j]+1)$</li><li>i 点无石子：$dp[i] = min(dp[i], dp[i+j])$</li></ul><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const <span class="built_in">int</span> <span class="built_in">N</span> = <span class="number">2</span>e5 + <span class="number">5</span>;</span><br><span class="line"><span class="built_in">int</span> l, s, <span class="built_in">t</span>, <span class="built_in">n</span>, dis, res, a[<span class="built_in">N</span>], dp[<span class="built_in">N</span>], vis[<span class="built_in">N</span>];</span><br><span class="line"><span class="built_in">int</span> main() &#123;</span><br><span class="line">  cin &gt;&gt; l &gt;&gt; s &gt;&gt; <span class="built_in">t</span> &gt;&gt; <span class="built_in">n</span>;</span><br><span class="line">  for (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">n</span>; i++) cin &gt;&gt; a[i];</span><br><span class="line">  <span class="built_in">if</span> (s == <span class="built_in">t</span>) &#123;</span><br><span class="line">    for (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">n</span>; i++) &#123;</span><br><span class="line">      <span class="built_in">if</span> (a[i] % s == <span class="number">0</span>) res++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  sort(a + <span class="number">1</span>, a + <span class="built_in">n</span> + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">int</span> <span class="built_in">len</span> = s * <span class="built_in">t</span>;</span><br><span class="line">  for (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">n</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">int</span> d = a[i] - a[i - <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">if</span> (d &gt; <span class="built_in">len</span>) d = <span class="built_in">len</span>;</span><br><span class="line">    dis += d;</span><br><span class="line">    vis[dis] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  for (<span class="built_in">int</span> i = dis; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    dp[i] = <span class="number">100</span>;</span><br><span class="line">    for (<span class="built_in">int</span> j = s; j &lt;= <span class="built_in">t</span>; j++) &#123;</span><br><span class="line">      dp[i] = <span class="built_in">min</span>(dp[i], dp[i + j] + vis[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; dp[<span class="number">0</span>] &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">  return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆，栈与内存管理</title>
      <link href="2020/05/%E5%A0%86%EF%BC%8C%E6%A0%88%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"/>
      <url>2020/05/%E5%A0%86%EF%BC%8C%E6%A0%88%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html</url>
      
        <content type="html"><![CDATA[<h2 id="stack-amp-amp-heap"><a href="#stack-amp-amp-heap" class="headerlink" title="stack &amp;&amp; heap"></a>stack &amp;&amp; heap</h2><p><strong>stack</strong>，由操作系统自动分配释放，是存在于某作用域的一块内存空间。例如当你调用函数，函数本身即会形成一个stack用来放置它所接收的参数，以及返回地址。函数本体中声明的任何变量，所使用的内存块都取自上述stack。</p><p><strong>heap</strong>，是指由操作系统提供的一块 global 内存空间，程序可动态分配从中获得的若干区块，由开发人员分配和释放，若开发人员不释放，程序结束时由 OS 回收，分配方式类似于链表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">c3</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>; <span class="comment">// 全局对象，其生命周期在整个程序结束之后才结束。（可视为 static 对象，作用域是整个程序）</span></span><br><span class="line"></span><br><span class="line">&lt;!--more--&gt; </span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;         <span class="comment">// 栈中创建对象</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> Complex <span class="title">c2</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;   <span class="comment">// static 静态对象，其生命在作用域结束之后仍然存在，直到整个程序结束</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 堆中创建对象</span></span><br><span class="line">  Complex* p = <span class="keyword">new</span> Complex(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">delete</span> p;    <span class="comment">// 否则会发生内存泄漏，因为当作用域结束，p 所指的对象仍然存在，但指针 p 的生命结束了，也就不可能再有机会 delete p; </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="new-关键字"><a href="#new-关键字" class="headerlink" title="new 关键字"></a>new 关键字</h2><p><strong>new</strong>：先分配内存，再调用构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Complex* pc = <span class="keyword">new</span> Complex(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  编译器转换为：</span></span><br><span class="line"><span class="comment">    void* mem = operator new ( sizeof(Complex) );  // 分配内存，operator new 只是一个函数名，内部调用 malloc(n) </span></span><br><span class="line"><span class="comment">    pc = static_cast&lt;Complex*&gt;(mem);   // 转型</span></span><br><span class="line"><span class="comment">    pc-&gt;Complex::Complex(1, 2);   // 构造函数</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="delete-关键字"><a href="#delete-关键字" class="headerlink" title="delete 关键字"></a>delete 关键字</h2><p> <strong>delete</strong>：先调用析构函数，再释放内存。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String* ps = <span class="keyword">new</span> String(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span>(ps);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 编译器转化为</span></span><br><span class="line"><span class="comment">   String::~String(ps);  // 析构函数</span></span><br><span class="line"><span class="comment">   operator delete(ps);  // 释放内存，内部调用 free(ps)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">String* p = <span class="keyword">new</span> String[<span class="number">3</span>];</span><br><span class="line">...</span><br><span class="line"><span class="comment">// delete[] p;  // 调用三次析构函数</span></span><br><span class="line"><span class="comment">// delete p;    // 调用一次析构，导致只回收了对象p[0]对应的内存，但p[1]和p[2]对应的内存没有被清空，这两块发生了内存泄漏。 </span></span><br></pre></td></tr></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    String(<span class="keyword">const</span> <span class="keyword">char</span>* cstr = <span class="number">0</span>);   <span class="comment">// 构造函数</span></span><br><span class="line">    String(<span class="keyword">const</span> String&amp; str);      <span class="comment">// 拷贝构造</span></span><br><span class="line">    String&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> String&amp; str);   <span class="comment">// 拷贝赋值</span></span><br><span class="line">    ~String();   <span class="comment">// 析构函数</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span>* <span class="title">get_c_str</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_data; &#125;   <span class="comment">// 获得字符串</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* m_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line">String::String(<span class="keyword">const</span> <span class="keyword">char</span>* cstr) &#123;</span><br><span class="line">  <span class="keyword">if</span> (cstr) &#123;</span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(cstr) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_data, cstr);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">    *m_data = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line">String::String(<span class="keyword">const</span> String&amp; str) &#123;</span><br><span class="line">  m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span>];</span><br><span class="line">  <span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> </span><br><span class="line">String&amp; String::<span class="keyword">operator</span>=(<span class="keyword">const</span> String&amp; str) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">delete</span>[] m_data;</span><br><span class="line">  m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span>];</span><br><span class="line">  <span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line">String::~String() &#123; <span class="keyword">delete</span>[] m_data; &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：codeJan与旅行（贪心）</title>
      <link href="2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AcodeJan%E4%B8%8E%E6%97%85%E8%A1%8C%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%89.html"/>
      <url>2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AcodeJan%E4%B8%8E%E6%97%85%E8%A1%8C%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定n个城市坐标，每个城市可以多次到达，问一共到m次，最短花费。给出起始位置，并且起始位置不在城市上。</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>不难猜到要么就是一条路走到黑要么就是在路上找的两个城市然后一直往返。因此我们从原来的位置，往左右两边一直走下去，顺便枚举路上每两座城市之间横跳的花费，维护最小花费，同时注意边界情况。<br><a id="more"></a> </p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line">LL ans, a[N];</span><br><span class="line"><span class="keyword">int</span> _, n, m, p;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> res)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; m - (i - k) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      LL tmp = res + (a[i] - a[k]) + (a[i] - a[i - <span class="number">1</span>]) * (m - (i - k));</span><br><span class="line">      ans = <span class="built_in">min</span>(ans, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = k - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; n &amp;&amp; m - (k - i) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      LL tmp = res + (a[k] - a[i]) + (a[i + <span class="number">1</span>] - a[i]) * (m - (k - i));</span><br><span class="line">      ans = <span class="built_in">min</span>(ans, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;_); _; _--) &#123;</span><br><span class="line">    ans = <span class="number">1e18</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;p);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">    m--;</span><br><span class="line">    <span class="keyword">int</span> k = upper_bound(a + <span class="number">1</span>, a + <span class="number">1</span> + n, p) - a;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= n) solve(k, a[k] - p);</span><br><span class="line">    <span class="keyword">if</span> (k &gt; <span class="number">1</span>) solve(k - <span class="number">1</span>, p - a[k - <span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拷贝构造，拷贝复制，析构</title>
      <link href="2020/05/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%EF%BC%8C%E6%8B%B7%E8%B4%9D%E5%A4%8D%E5%88%B6%EF%BC%8C%E6%9E%90%E6%9E%84.html"/>
      <url>2020/05/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%EF%BC%8C%E6%8B%B7%E8%B4%9D%E5%A4%8D%E5%88%B6%EF%BC%8C%E6%9E%90%E6%9E%84.html</url>
      
        <content type="html"><![CDATA[<h3 id="Big-Three（拷贝构造，拷贝复制，析构）"><a href="#Big-Three（拷贝构造，拷贝复制，析构）" class="headerlink" title="Big Three（拷贝构造，拷贝复制，析构）"></a>Big Three（拷贝构造，拷贝复制，析构）</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">String</span> (<span class="keyword">const</span> <span class="keyword">char</span>* cstr = <span class="number">0</span>);    <span class="comment">// 构造函数，默认初值为0</span></span><br><span class="line">&lt;!--more--&gt; </span><br><span class="line">    <span class="keyword">String</span> (<span class="keyword">const</span> <span class="keyword">String</span>&amp; str);       <span class="comment">// 接受的值为类本身，因此为拷贝构造函数</span></span><br><span class="line">    <span class="keyword">String</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">String</span>&amp; str);  <span class="comment">// = 号重载，拷贝赋值函数</span></span><br><span class="line">    ~<span class="keyword">String</span>();        <span class="comment">// 析构函数，类死亡时自动调用</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span>* <span class="title">get_c_str</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_data; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* m_data; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">String</span> <span class="title">s1</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">String</span> <span class="title">s2</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">String</span> <span class="title">s3</span><span class="params">(s1)</span></span>;      <span class="comment">// 拷贝构造，类还未存在</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; s3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  s3 = s2;            <span class="comment">// 拷贝赋值，类已经存在</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; s3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="keyword">String</span>::<span class="keyword">String</span>(<span class="keyword">const</span> <span class="keyword">char</span>* cstr = <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (cstr) &#123;               <span class="comment">// 指定初值</span></span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(cstr) + <span class="number">1</span>];    <span class="comment">// 分配传进来的长度+ &#x27;\0&#x27; 的空间</span></span><br><span class="line">    <span class="built_in">strcpy</span>(m_data, cstr);   <span class="comment">// 复制  </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;                    <span class="comment">// 未指定初值</span></span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">    *m_data = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="keyword">String</span>::~<span class="keyword">String</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">delete</span>[] m_data;      <span class="comment">// 将原来分配的内存释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="function"><span class="keyword">String</span> <span class="title">p1</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;                   <span class="comment">//栈中分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> <span class="keyword">String</span> p2 = <span class="keyword">String</span>(<span class="string">&quot;hello&quot;</span>);　　　　　　　<span class="comment">//栈中分配内存，跟方法1相同，是方法1的完整模式</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> <span class="keyword">String</span> *p3 = <span class="keyword">new</span> <span class="keyword">String</span>(<span class="string">&quot;hello&quot;</span>);　　　 <span class="comment">//堆中分配内存</span></span><br></pre></td></tr></table></figure><p><strong><br>方法1、2中都是在栈中分配内存，在栈中内存由系统自动的去分配和释放，释放的顺序也和栈一样，后定义的先释放。</strong></p><p><strong><br>而使用new创建的指针对象是在堆中分配内存，当不需要该对象时，需要我们手动的去释放，否则会造成内存泄漏。</strong></p><h3 id="深拷贝，浅拷贝"><a href="#深拷贝，浅拷贝" class="headerlink" title="深拷贝，浅拷贝"></a>深拷贝，浅拷贝</h3><p>如果类中有指针成员，则必须写拷贝构造和拷贝赋值函数。</p><p>假设 指针a -&gt; “hello”, 指针b -&gt; “world”，当执行 b = a 时，则变成 b 指向 a，造成 “world” 无人指向，发生了内存泄漏，而”hello” 被 a 和 b 同时指向的情况，那么将来一旦改变 a ，b 也会发生改变。那么，这种拷贝称之为 <strong>“浅拷贝”</strong>。</p><p><strong>深拷贝</strong>即为我们自己写的拷贝函数：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="keyword">String</span>::<span class="keyword">String</span>(<span class="keyword">const</span> <span class="keyword">String</span>&amp; str)    <span class="comment">// 拷贝构造</span></span><br><span class="line">&#123;</span><br><span class="line">  m_data = <span class="keyword">new</span> <span class="keyword">char</span>[ <span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span> ];</span><br><span class="line">  <span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="keyword">String</span>&amp; <span class="keyword">String</span>::<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">String</span>&amp; str)  <span class="comment">// 拷贝赋值</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;str)    <span class="comment">// 有可能是自己赋值给自己（比如引用），如果不写这句，那么delete就是它自己，下面全错</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span>[] m_data;    <span class="comment">// 先将自己删除</span></span><br><span class="line">  m_data = <span class="keyword">new</span> <span class="keyword">char</span>[ <span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span> ];  <span class="comment">// 重新创建和右边一样大的空间</span></span><br><span class="line">  <span class="built_in">strcpy</span>(m_data, str.m_data);     <span class="comment">// 重新赋值</span></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杜教BM模板</title>
      <link href="2020/05/%E6%9D%9C%E6%95%99BM%E6%A8%A1%E6%9D%BF.html"/>
      <url>2020/05/%E6%9D%9C%E6%95%99BM%E6%A8%A1%E6%9D%BF.html</url>
      
        <content type="html"><![CDATA[<p><strong>用于求线性递推式第n项，扔进前k+x项即可</strong></p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstring&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cmath&gt;</span></span><br><span class="line"><span class="comment">#include &lt;algorithm&gt;</span></span><br><span class="line"><span class="comment">#include &lt;vector&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string&gt;</span></span><br><span class="line"><span class="comment">#include &lt;map&gt;</span></span><br><span class="line"><span class="comment">#include &lt;set&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cassert&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long <span class="keyword">ll;</span></span><br><span class="line"><span class="keyword">#define </span>rep(i, a, n) for (int i = a<span class="comment">; i &lt; n; i++)</span></span><br><span class="line"><span class="comment">#define per(i, a, n) for (int i = n - 1; i &gt;= a; i--)</span></span><br><span class="line"><span class="comment">#define pb push_back</span></span><br><span class="line"><span class="comment">#define mp make_pair</span></span><br><span class="line"><span class="comment">#define all(x) (x).begin(), (x).end()</span></span><br><span class="line"><span class="comment">#define fi first</span></span><br><span class="line"><span class="comment">#define se second</span></span><br><span class="line"><span class="comment">#define SZ(x) ((int)(x).size())</span></span><br><span class="line">typedef vector&lt;<span class="keyword">ll&gt; </span>VI;</span><br><span class="line">typedef pair&lt;<span class="keyword">ll, </span><span class="keyword">ll&gt; </span>PII;</span><br><span class="line">const <span class="keyword">ll </span>mod = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">ll </span>powmod(<span class="keyword">ll </span>a, <span class="keyword">ll </span><span class="keyword">b) </span>&#123;</span><br><span class="line">  <span class="keyword">ll </span>res = <span class="number">1</span>;</span><br><span class="line">  a %= mod;</span><br><span class="line">  assert(<span class="keyword">b </span>&gt;= <span class="number">0</span>);</span><br><span class="line">  for (<span class="comment">; b; b &gt;&gt;= 1) &#123;</span></span><br><span class="line">    if (<span class="keyword">b </span>&amp; <span class="number">1</span>) res = res * a % mod;</span><br><span class="line">    a = a * a % mod;</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">ll </span>_, n;</span><br><span class="line">namespace linear_seq &#123;</span><br><span class="line">const <span class="keyword">ll </span>N = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">ll </span>res[N], <span class="keyword">base[N], </span>_c[N], _md[N];</span><br><span class="line">vector&lt;<span class="keyword">ll&gt; </span>Md;</span><br><span class="line">void <span class="keyword">mul(ll </span>*a, <span class="keyword">ll </span>*<span class="keyword">b, </span>int k) &#123;</span><br><span class="line">  rep(i, <span class="number">0</span>, k + k) _c[i] = <span class="number">0</span>;</span><br><span class="line">  rep(i, <span class="number">0</span>, k) if (a[i]) rep(<span class="keyword">j, </span><span class="number">0</span>, k) _c[i + <span class="keyword">j] </span>=</span><br><span class="line">      (_c[i + <span class="keyword">j] </span>+ a[i] * <span class="keyword">b[j]) </span>% mod;</span><br><span class="line">  for (<span class="keyword">ll </span>i = k + k - <span class="number">1</span><span class="comment">; i &gt;= k; i--)</span></span><br><span class="line">    if (_c[i])</span><br><span class="line">      rep(<span class="keyword">j, </span><span class="number">0</span>, SZ(Md)) _c[i - k + Md[<span class="keyword">j]] </span>=</span><br><span class="line">          (_c[i - k + Md[<span class="keyword">j]] </span>- _c[i] * _md[Md[<span class="keyword">j]]) </span>% mod;</span><br><span class="line">  rep(i, <span class="number">0</span>, k) a[i] = _c[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">ll </span>solve(<span class="keyword">ll </span>n, VI a, VI <span class="keyword">b) </span>&#123;</span><br><span class="line">  <span class="keyword">ll </span>ans = <span class="number">0</span>, pnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">ll </span>k = SZ(a);</span><br><span class="line">  assert(SZ(a) == SZ(<span class="keyword">b));</span></span><br><span class="line"><span class="keyword"> </span> rep(i, <span class="number">0</span>, k) _md[k - <span class="number">1</span> - i] = -a[i];</span><br><span class="line">  _md[k] = <span class="number">1</span>;</span><br><span class="line">  Md.clear();</span><br><span class="line">  rep(i, <span class="number">0</span>, k) if (_md[i] != <span class="number">0</span>) Md.push_back(i);</span><br><span class="line">  rep(i, <span class="number">0</span>, k) res[i] = <span class="keyword">base[i] </span>= <span class="number">0</span>;</span><br><span class="line">  res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  while ((<span class="number">1</span>ll &lt;&lt; pnt) &lt;= n) pnt++;</span><br><span class="line">  for (<span class="keyword">ll </span>p = pnt<span class="comment">; p &gt;= 0; p--) &#123;</span></span><br><span class="line">    <span class="keyword">mul(res, </span>res, k);</span><br><span class="line">    if ((n &gt;&gt; p) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">      for (<span class="keyword">ll </span>i = k - <span class="number">1</span><span class="comment">; i &gt;= 0; i--) res[i + 1] = res[i];</span></span><br><span class="line">      res[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">      rep(<span class="keyword">j, </span><span class="number">0</span>, SZ(Md)) res[Md[<span class="keyword">j]] </span>= (res[Md[<span class="keyword">j]] </span>- res[k] * _md[Md[<span class="keyword">j]]) </span>% mod;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  rep(i, <span class="number">0</span>, k) ans = (ans + res[i] * <span class="keyword">b[i]) </span>% mod;</span><br><span class="line">  if (ans &lt; <span class="number">0</span>) ans += mod;</span><br><span class="line">  return ans;</span><br><span class="line">&#125;</span><br><span class="line">VI <span class="keyword">BM(VI </span>s) &#123;</span><br><span class="line">  VI C(<span class="number">1</span>, <span class="number">1</span>), <span class="keyword">B(1, </span><span class="number">1</span>);</span><br><span class="line">  <span class="keyword">ll </span>L = <span class="number">0</span>, m = <span class="number">1</span>, <span class="keyword">b </span>= <span class="number">1</span>;</span><br><span class="line">  rep(n, <span class="number">0</span>, SZ(s)) &#123;</span><br><span class="line">    <span class="keyword">ll </span>d = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">0</span>, L + <span class="number">1</span>) d = (d + (<span class="keyword">ll)C[i] </span>* s[n - i]) % mod;</span><br><span class="line">    if (d == <span class="number">0</span>)</span><br><span class="line">      ++m;</span><br><span class="line">    else if (<span class="number">2</span> * L &lt;= n) &#123;</span><br><span class="line">      VI T = C;</span><br><span class="line">      <span class="keyword">ll </span>c = mod - d * powmod(<span class="keyword">b, </span>mod - <span class="number">2</span>) % mod;</span><br><span class="line">      while (SZ(C) &lt; SZ(<span class="keyword">B) </span>+ m) C.pb(<span class="number">0</span>);</span><br><span class="line">      rep(i, <span class="number">0</span>, SZ(<span class="keyword">B)) </span>C[i + m] = (C[i + m] + c * <span class="keyword">B[i]) </span>% mod;</span><br><span class="line">      L = n + <span class="number">1</span> - L;</span><br><span class="line">      <span class="keyword">B </span>= T;</span><br><span class="line">      <span class="keyword">b </span>= d;</span><br><span class="line">      m = <span class="number">1</span>;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      <span class="keyword">ll </span>c = mod - d * powmod(<span class="keyword">b, </span>mod - <span class="number">2</span>) % mod;</span><br><span class="line">      while (SZ(C) &lt; SZ(<span class="keyword">B) </span>+ m) C.pb(<span class="number">0</span>);</span><br><span class="line">      rep(i, <span class="number">0</span>, SZ(<span class="keyword">B)) </span>C[i + m] = (C[i + m] + c * <span class="keyword">B[i]) </span>% mod;</span><br><span class="line">      ++m;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">ll </span>gao(VI a, <span class="keyword">ll </span>n) &#123;</span><br><span class="line">  VI c = <span class="keyword">BM(a);</span></span><br><span class="line"><span class="keyword"> </span> c.erase(c.<span class="keyword">begin());</span></span><br><span class="line"><span class="keyword"> </span> rep(i, <span class="number">0</span>, SZ(c)) c[i] = (mod - c[i]) % mod;</span><br><span class="line">  return solve(n, c, VI(a.<span class="keyword">begin(), </span>a.<span class="keyword">begin() </span>+ SZ(c)));</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">;  // namespace linear_seq</span></span><br><span class="line">int main() &#123;</span><br><span class="line">  while (~<span class="keyword">scanf(&quot;%lld&quot;, </span>&amp;n) &amp;&amp; n != -<span class="number">1</span>) &#123;</span><br><span class="line">    vector&lt;<span class="keyword">ll&gt;v;</span></span><br><span class="line"><span class="keyword"> </span>      v.push_back(<span class="number">0</span>);</span><br><span class="line">       v.push_back(<span class="number">1</span>);</span><br><span class="line">        v.push_back(<span class="number">1</span>);</span><br><span class="line">        v.push_back(<span class="number">2</span>);</span><br><span class="line">        v.push_back(<span class="number">3</span>);</span><br><span class="line">        v.push_back(<span class="number">5</span>);</span><br><span class="line">        v.push_back(<span class="number">8</span>);</span><br><span class="line">        v.push_back(<span class="number">13</span>);</span><br><span class="line">        v.push_back(<span class="number">21</span>);</span><br><span class="line">        v.push_back(<span class="number">34</span>);</span><br><span class="line">      printf(<span class="string">&quot;%lld\n&quot;</span>, linear_seq::gao(v, n));</span><br><span class="line">  &#125;</span><br><span class="line">  return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：皇家烈焰（线性dp）</title>
      <link href="2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%9A%87%E5%AE%B6%E7%83%88%E7%84%B0%EF%BC%88%E7%BA%BF%E6%80%A7dp%EF%BC%89.html"/>
      <url>2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%9A%87%E5%AE%B6%E7%83%88%E7%84%B0%EF%BC%88%E7%BA%BF%E6%80%A7dp%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>现在帕秋莉告诉你一部分烈焰的分布情况，请你告诉她可能的情况有多少种</p><p>对于一个格子，里面会有以下几种字符：</p><p>0：这个格子没有烈焰，且其左右两个格子均没有烈焰</p><a id="more"></a> <p>1：这个格子没有烈焰，且其左右两个格子中只有一个烈焰</p><p>2：这个格子没有烈焰，且其左右两个格子中均有烈焰</p><p>$*$：这个格子有烈焰</p><p>?：未告诉你本格情况</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>$f[i][0/1][0/1]$表示前i位，当前位和下一位是（1）不是（0）烈焰的方案数</p><p>转移方程分情况讨论：</p><p>当$s[i]=’*’$时：</p><p>$f[i][1][0]=(f[i-1][0][1]+f[i-1][1][1])$</p><p>$f[i][1][1]=(f[i-1][0][1]+f[i-1][1][1])$</p><p>当$s[i]=’0’$时，上一位、当前位和下一位都得是0：</p><p>$f[i][0][0]=f[i-1][0][0]$</p><p>当s[i]=’1’时，上一位或下一位有一个是1：</p><p>$f[i][0][1]=f[i-1][0][0]$</p><p>$f[i][0][0]=f[i-1][1][0]$</p><p>当s[i]=’2’时，上一位和下一位都是1当前位是0：</p><p>$f[i][0][1]=f[i-1][1][0]$</p><p>当s[i]=’?’时：</p><p>$f[i][1][0]=(f[i-1][0][1]+f[i-1][1][1])$</p><p>$f[i][1][1]=(f[i-1][0][1]+f[i-1][1][1])$</p><p>$f[i][0][0]=(f[i-1][0][0]+f[i-1][1][0])$</p><p>$f[i][0][1]=(f[i-1][0][0]+f[i-1][1][0])$</p><p>初值$f[0][0][0] =1,f[0][0][1] = 1$</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int <span class="symbol">N</span> = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line">const int mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">int dp[<span class="symbol">N</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">char s[<span class="symbol">N</span>];</span><br><span class="line">int main() &#123;</span><br><span class="line">  cin &gt;&gt; s + <span class="number">1</span>;</span><br><span class="line">  dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  int len = strlen(s + <span class="number">1</span>);</span><br><span class="line">  for (int i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">    if (s[i] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">      dp[i][<span class="number">0</span>][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    else if (s[i] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">      dp[i][<span class="number">0</span>][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">      dp[i][<span class="number">0</span>][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125; else if (s[i] == <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">      dp[i][<span class="number">0</span>][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    else if (s[i] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">      dp[i][<span class="number">1</span>][<span class="number">0</span>] = (dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] + dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>]) <span class="comment">% mod;</span></span><br><span class="line">      dp[i][<span class="number">1</span>][<span class="number">1</span>] = dp[i][<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      dp[i][<span class="number">0</span>][<span class="number">0</span>] = (dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>] + dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]) <span class="comment">% mod;</span></span><br><span class="line">      dp[i][<span class="number">0</span>][<span class="number">1</span>] = dp[i][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">      dp[i][<span class="number">1</span>][<span class="number">0</span>] = (dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>] + dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]) <span class="comment">% mod;</span></span><br><span class="line">      dp[i][<span class="number">1</span>][<span class="number">1</span>] = dp[i][<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; (dp[len][<span class="number">1</span>][<span class="number">0</span>] + dp[len][<span class="number">0</span>][<span class="number">0</span>]) <span class="comment">% mod &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">  return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：Two Graphs（暴力）</title>
      <link href="2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9ATwo-Graphs%EF%BC%88%E6%9A%B4%E5%8A%9B%EF%BC%89.html"/>
      <url>2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9ATwo-Graphs%EF%BC%88%E6%9A%B4%E5%8A%9B%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给一个小图和一个大图，问大图有多少个子图形状和小图一样。</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>最多只有8个点，因为每个点标号可能不一样，因此可以全排列枚举所有点的位置，然后判断小图有的边大图是否也有（因为原来边的属性还在），并通过hash进行去重。</p><a id="more"></a> <h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m1, m2, res, pre[<span class="number">10</span>], mp1[<span class="number">10</span>][<span class="number">10</span>], mp2[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">int</span>&gt; p;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m1, &amp;m2)) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(mp1, <span class="number">0</span>, <span class="keyword">sizeof</span>(mp1));</span><br><span class="line">    <span class="built_in">memset</span>(mp2, <span class="number">0</span>, <span class="keyword">sizeof</span>(mp2));</span><br><span class="line">    p.<span class="built_in">clear</span>();</span><br><span class="line">    res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m1; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> x, y;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">      mp1[x][y] = mp1[y][x] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m2; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> x, y;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">      mp2[x][y] = mp2[y][x] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) pre[i] = i;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">long</span> <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n &amp;&amp; flag; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n &amp;&amp; flag; j++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (mp1[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mp2[pre[i]][pre[j]]) flag = <span class="number">0</span>;</span><br><span class="line">            now |= <span class="number">1L</span>L &lt;&lt; (mp2[pre[i]][pre[j]]);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (flag &amp;&amp; p[now] == <span class="number">0</span>) &#123;</span><br><span class="line">        res++;</span><br><span class="line">        p[now] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (next_permutation(pre + <span class="number">1</span>, pre + n + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：Different Integers（树状数组/莫队）</title>
      <link href="2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9ADifferent-Integers%EF%BC%88%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-%E8%8E%AB%E9%98%9F%EF%BC%89.html"/>
      <url>2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9ADifferent-Integers%EF%BC%88%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-%E8%8E%AB%E9%98%9F%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定长度为 $n$ 的数组，$q$ 次询问 $[1,l]+[r,n]$ 组成的新数组中不相同的元素个数。$(1&lt;=n,q&lt;=1e5)$</p><h3 id="solution1"><a href="#solution1" class="headerlink" title="solution1"></a>solution1</h3><p>一眼莫队题，主要是要想怎么样把它变成一个连续的区间。其实只要把整个数组再复制一遍接上就可以了，则原来查询的 $r$ 变为 $l$，$l$ 变为 $l+n$，区间连续。<br><a id="more"></a> </p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1812 ms</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> l, r, id;</span><br><span class="line">&#125; node[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q, blocks, a[N], b[N], ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a.l / blocks == b.l / blocks) <span class="keyword">return</span> a.r &lt; b.r;</span><br><span class="line">  <span class="keyword">return</span> a.l &lt; b.l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">      a[i + n] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="keyword">sizeof</span>(b));</span><br><span class="line">    blocks = <span class="built_in">sqrt</span>(<span class="number">2</span> * n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;node[i].r, &amp;node[i].l);</span><br><span class="line">      node[i].r += n;</span><br><span class="line">      node[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(node + <span class="number">1</span>, node + q + <span class="number">1</span>, cmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>, num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">      <span class="keyword">while</span> (l &lt; node[i].l) num -= !--b[a[l++]];</span><br><span class="line">      <span class="keyword">while</span> (l &gt; node[i].l) num += !b[a[--l]]++;</span><br><span class="line">      <span class="keyword">while</span> (r &lt; node[i].r) num += !b[a[++r]]++;</span><br><span class="line">      <span class="keyword">while</span> (r &gt; node[i].r) num -= !--b[a[r--]];</span><br><span class="line">      ans[node[i].id] = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution2"><a href="#solution2" class="headerlink" title="solution2"></a>solution2</h3><p>同样是复制一遍，然后考虑树状数组+离线处理。我们需要保证之前的更新不会对当前的查询构成干扰，可以对查询按照右端点从小到大排序，然后把当前的数更新到当前位置，删除之前的位置，这样保证数是跟排序后的查询一样是从左往右流动的。</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 702 ms</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q, a[N], b[N], c[N], ans[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> l, r, id;</span><br><span class="line">&#125; node[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node x, Node y)</span> </span>&#123; <span class="keyword">return</span> x.r &lt; y.r; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (; x &lt;= n; x += x &amp; (-x)) c[x] += y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (; x &gt;= <span class="number">1</span>; x -= x &amp; (-x)) sum += c[x];</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">      a[i + n] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="keyword">sizeof</span>(b));</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;node[i].r, &amp;node[i].l);</span><br><span class="line">      node[i].r += n;</span><br><span class="line">      node[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(node + <span class="number">1</span>, node + q + <span class="number">1</span>, cmp);</span><br><span class="line">    n &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> pre = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = pre; j &lt;= node[i].r; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b[a[j]]) update(b[a[j]], <span class="number">-1</span>);</span><br><span class="line">        b[a[j]] = j;</span><br><span class="line">        update(b[a[j]], <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      pre = node[i].r + <span class="number">1</span>;</span><br><span class="line">      ans[node[i].id] = query(node[i].r) - query(node[i].l - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：合并回文子串（区间DP）</title>
      <link href="2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%90%88%E5%B9%B6%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%EF%BC%88DP%EF%BC%89.html"/>
      <url>2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%90%88%E5%B9%B6%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%EF%BC%88DP%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定两个字符串，各取出一个子串接在一起，求最长回文子串的长度。</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>先考虑普通的求最长回文子串的dp做法:<br><a id="more"></a> </p><p>$dp[i][j] = 0/1 $ 表示子串 $i~j$ 是否为回文串。</p><p>那么，容易得到：$dp[i][j] = (dp[i+1][j-1]$ &amp;&amp; $s[i]==s[j])$。</p><p>由于 $i$ 是由 $i+1$ 转移过来的，所以我们需要倒着遍历：</p><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (int i = s.size() - <span class="number">1</span><span class="comment">; i &gt;= 0; i--)</span></span><br><span class="line">  for (int <span class="keyword">j </span>= i<span class="comment">; j &lt; s.size(); j++) &#123;</span></span><br><span class="line">    if (s[i] == s[<span class="keyword">j] </span>&amp;&amp; (<span class="keyword">j </span>- i &lt; <span class="number">2</span> <span class="title">||</span> dp[i + <span class="number">1</span>][<span class="keyword">j </span>- <span class="number">1</span>])) &#123;</span><br><span class="line">      dp[i][<span class="keyword">j] </span>= true;</span><br><span class="line">      res = max(res, <span class="keyword">j </span>- i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>那么这题其实可以类比：</p><p>$dp[i][j][k][l]$ 表示a串第i个字符到第j个字符和b串第k个字符到第l个字符是否组成回文串：</p><p>往 $a[i+1]$ 到 $a[j−1]$ 和 $b[k]$ 到 $b[l]$ 构成的串的两端加上 $a[i]$ 和 $a[j]$ 两个字符：</p><p>$dp[i][j][k][l] = dp[i+1][j-1][k][l] and (a[i]==a[j])$</p><p>往 $a[i+1]$ 到 $a[j]$ 和 $b[k]$ 到 $b[l-1]$ 构成的串的两端加上 $a[i]$ 和 $b[l]$ 两个字符：</p><p>$dp[i][j][k][l] = dp[i+1][j][k][l-1] and (a[i]==b[l])$</p><p>往 $a[i]$ 到 $a[j-1]$ 和 $b[k+1]$ 到 $b[l]$ 构成的串的两端加上 $b[k]$ 和 $a[j]$ 两个字符：</p><p>$dp[i][j][k][l] = dp[i][j-1][k+1][l] and (b[k]==a[j])$</p><p>往 $a[i]$ 到 $a[j]$ 和 $b[k+1]$ 到 $b[l-1]$ 构成的串的两端加上 $b[k]$ 和 $b[l]$ 两个字符：</p><p>$dp[i][j][k][l] = dp[i][j][k+1][l-1] and (b[k]==b[l])$</p><p><strong>实际上就是取法由原来的一种变为了四种，注意若组成的字符串长度小于2时需要直接赋值为1</strong></p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int <span class="symbol">N</span> = <span class="number">105</span>;</span><br><span class="line">char a[<span class="symbol">N</span>], b[<span class="symbol">N</span>];</span><br><span class="line">bool f[<span class="symbol">N</span>][<span class="symbol">N</span>][<span class="symbol">N</span>][<span class="symbol">N</span>];</span><br><span class="line">int t, n, m;</span><br><span class="line">int main() &#123;</span><br><span class="line">  scanf(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">  while (t--) &#123;</span><br><span class="line">    int res = <span class="number">0</span>;</span><br><span class="line">    scanf(<span class="string">&quot;%s&quot;</span>, a + <span class="number">1</span>);</span><br><span class="line">    scanf(<span class="string">&quot;%s&quot;</span>, b + <span class="number">1</span>);</span><br><span class="line">    n = strlen(a + <span class="number">1</span>);</span><br><span class="line">    m = strlen(b + <span class="number">1</span>);</span><br><span class="line">    for (int len1 = <span class="number">0</span>; len1 &lt;= n; len1++)    //枚举a串的长度</span><br><span class="line">      for (int len2 = <span class="number">0</span>; len2 &lt;= m; len2++)  //枚举b串的长度</span><br><span class="line">        for (int i = <span class="number">1</span>; i + len1 - <span class="number">1</span> &lt;= n; i++)</span><br><span class="line">          for (int k = <span class="number">1</span>; k + len2 - <span class="number">1</span> &lt;= m; k++) &#123;</span><br><span class="line">            int j = i + len1 - <span class="number">1</span>,</span><br><span class="line">                l = k + len2 - <span class="number">1</span>;  //根据左端点和长度计算右端点</span><br><span class="line">            if (len1 + len2 &lt;= <span class="number">1</span>)</span><br><span class="line">              f[i][j][k][l] = <span class="number">1</span>;</span><br><span class="line">            else &#123;</span><br><span class="line">              f[i][j][k][l] = <span class="number">0</span>;</span><br><span class="line">              if (len1 &gt; <span class="number">1</span>)</span><br><span class="line">                f[i][j][k][l] |= (f[i + <span class="number">1</span>][j - <span class="number">1</span>][k][l] &amp;&amp; (a[i] == a[j]));</span><br><span class="line">              if (len1 &amp;&amp; len2)</span><br><span class="line">                f[i][j][k][l] |= (f[i + <span class="number">1</span>][j][k][l - <span class="number">1</span>] &amp;&amp; (a[i] == b[l]));</span><br><span class="line">              if (len1 &amp;&amp; len2)</span><br><span class="line">                f[i][j][k][l] |= (f[i][j - <span class="number">1</span>][k + <span class="number">1</span>][l] &amp;&amp; (a[j] == b[k]));</span><br><span class="line">              if (len2 &gt; <span class="number">1</span>)</span><br><span class="line">                f[i][j][k][l] |= (f[i][j][k + <span class="number">1</span>][l - <span class="number">1</span>] &amp;&amp; (b[k] == b[l]));</span><br><span class="line">            &#125;</span><br><span class="line">            if (f[i][j][k][l]) res = max(res, len1 + len2);</span><br><span class="line">          &#125;</span><br><span class="line">    printf(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">  &#125;</span><br><span class="line">  return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区间dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>课程安排（状压dp）</title>
      <link href="2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%AF%BE%E7%A8%8B%E5%AE%89%E6%8E%92%EF%BC%88%E7%8A%B6%E5%8E%8Bdp%EF%BC%89.html"/>
      <url>2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%AF%BE%E7%A8%8B%E5%AE%89%E6%8E%92%EF%BC%88%E7%8A%B6%E5%8E%8Bdp%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<p>题意：让你安排课程，保证每学期的课不能冲突，问最少需要几个学期。</p><p>solution：</p><p>因为 n 只有15，可以考虑状压dp。用二进制每位的1/0表示当前是否学习该课程，可以得到 n 个二进制位，那么所有的可能性有 1&lt;&lt;n 种，预处理 g[s] 表示 s 所代表课程的是否可以在一个学期内学完（对于当前要学的所有课程的学时进行标记，若有重复标记则不可能在一学期学完），f[s] 维护学完当前课程所花费的最少学期，枚举子集进行转移。<br>答案的状态应该是所有课全部修完，即 $f[(1&lt;&lt;n)-1]$。时间复杂度 $O(2^n <em> m </em> n)$。</p><a id="more"></a> <h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1</span> &lt;&lt; <span class="number">15</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, sum, f[N], g[N], b[<span class="number">20</span>], a[<span class="number">20</span>][<span class="number">105</span>], vis[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;&gt; i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= b[i]; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[a[i][j]]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        vis[a[i][j]] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= b[i]; j++) <span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f));    <span class="comment">// 因为要维护最小值，因此初值赋为最大值</span></span><br><span class="line">  f[<span class="number">0</span>] = <span class="number">0</span>;                  <span class="comment">//  学完 0 门课需要 0 个学期</span></span><br><span class="line">  sum = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;        <span class="comment">//  每门课代表一个二进制位，枚举所有可能共有 1&lt;&lt;n 种</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt;= sum; ++s) &#123;       </span><br><span class="line">    g[s] = check(s);         <span class="comment">// 验证 s 是否能在一个学期内学完</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = s; t; t = (t - <span class="number">1</span>) &amp; s)         <span class="comment">// 从之前的状态（子集）进行转移</span></span><br><span class="line">      <span class="keyword">if</span> (g[t]) f[s] = <span class="built_in">min</span>(f[s], f[s ^ t] + <span class="number">1</span>);      <span class="comment">// 可以在一个学期学完，则维护最小值</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; f[sum] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状压dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11新特性</title>
      <link href="2020/05/C++11%E6%96%B0%E7%89%B9%E6%80%A7.html"/>
      <url>2020/05/C++11%E6%96%B0%E7%89%B9%E6%80%A7.html</url>
      
        <content type="html"><![CDATA[<h2 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h2><p><strong>nullptr</strong> 出现的目的是为了替代 NULL。传统 C++ 会把 <strong>NULL, 0</strong> 视为同一种东西，有些编译器会将 NULL 定义为 <strong>((void*)0)</strong>，有些则会直接将其定义为 0。C++ 不允许直接将 void <em> 隐式转换到其他类型，但如果 NULL 被定义为 **((void</em>)0)<strong>，那么当编译 </strong>char <em>ch = NULL;*</em> 时，NULL 只好被定义为 0。而这依然会产生问题，将导致了 C++ 中重载特性会发生混乱，考虑：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><br>对于这两个函数来说，如果 NULL 又被定义为了 0 那么 foo(NULL); 这个语句将会去调用 foo(int)，从而导致代码违反直观。为了解决这个问题，C++11 引入了 nullptr 关键字，专门用来区分空指针、0。nullptr 的类型为 nullptr_t，能够隐式的转换为任何指针或成员指针的类型，也能和他们进行相等或者不等的比较。</p><a id="more"></a><h2 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h2><p>C++11 引入了 auto 和 decltype 这两个关键字实现了类型推导。</p><ol><li><p>auto: 使用 auto 进行类型推导的一个最为常见而且显著的例子就是迭代器，可以使代码变得十分简洁。但需要注意的是 auto 不能用于函数传参，不能用于推导数组类型。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator itr = v.cbegin(); itr != v.cend(); ++itr)</span><br><span class="line"><span class="comment">// auto 类型推导</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> itr = v.cbegin(); itr != v.cend(); ++itr)</span><br><span class="line"><span class="comment">// 不能用于函数传参</span></span><br><span class="line"><span class="comment">//! int add(auto x, auto y);</span></span><br><span class="line"><span class="comment">// auto 不能用于推导数组</span></span><br><span class="line"><span class="comment">//! int a = &#123;1, 2, 3&#125;;</span></span><br><span class="line"><span class="comment">//! auto b = a;</span></span><br></pre></td></tr></table></figure></li><li><p>decltype: decltype 关键字是为了解决 auto 关键字只能对变量进行类型推导的缺陷。它的用法和 sizeof 很相似： <strong>decltype(表达式)</strong> 在此过程中，<strong>编译器分析表达式并得到它的类型，却不实际计算表达式的值</strong>。 </p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x + y) z;</span><br></pre></td></tr></table></figure></li><li>拖尾返回类型 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function">R <span class="title">add</span><span class="params">(T x, U y)</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;</span><br></pre></td></tr></table></figure> 很多时候我们并不知道 add() 这个函数会做什么样的操作，获得一个什么样的返回类型。如果用 decltype(x + y) add(T x, U y); 来进行类型推导的话，并不能通过编译。<br> 这是因为在编译器读到 decltype(x + y) 时， x 和 y 尚未被定义。为了解决这个问题，C++11 还引入了一个叫做 <strong>拖尾返回类型</strong>，利用 auto 关键字将返回类型后置： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line">auto add(T x, U y) -&gt; decltype(x + y) &#123; </span><br><span class="line">    <span class="keyword">return</span> x + y; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 而从 C++14 开始，普通函数具备返回值推导的能力： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T x, U y)</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="模板增强"><a href="#模板增强" class="headerlink" title="模板增强"></a>模板增强</h2><ol><li><p>外部模板：传统 C++ 中，模板只有在使用时才会被编译器实例化。只要在每个编译单元（文件）中编译的代码中遇到了被完整定义的模板，都会实例化。这就产生了重复实例化而导致的编译时间的增加。并且，我们没有办法通知编译器不要触发模板实例化。C++11 引入了外部模板，扩充了原来的强制编译器在特定位置实例化模板的语法，使得能够显式的告诉编译器何时进行模板的实例化：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">std</span>:</span>:<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;;   <span class="comment">// 强行实例化</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">std</span>:</span>:<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;;   <span class="comment">// 不在该编译文件中实例化模板</span></span><br><span class="line">    ```    </span><br><span class="line"><span class="number">2.</span> 尖括号 <span class="string">&#x27;&gt;&#x27;</span>：在传统 C++ 的编译器中，&gt;&gt; 一律被当做右移运算符来进行处理。因此对于嵌套模板来说是不能够被编译的，而 C++<span class="number">11</span> 开始，连续的右尖括号将变得合法，并且能够顺利通过编译。</span><br><span class="line"></span><br><span class="line">    ```cpp</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v;</span><br></pre></td></tr></table></figure></li><li><p>类型别名模板：在传统 C++中，typedef 可以为类型定义一个新的名称，但却没有办法为模板定义一个新的名称，因为 <strong>模板不是类型</strong>。于是 C++11 引入了 <strong>using</strong>，并且同时支持对传统 typedef 相同的作用。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U, <span class="keyword">int</span> value&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuckType</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T a;</span><br><span class="line">    U b;</span><br><span class="line">    SuckType(): a(value), b(value)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 不合法</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">typedef</span> SuckType&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, U, <span class="number">1</span>&gt; NewType; </span><br><span class="line"><span class="comment">// 合法</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> NewType = SuckType&lt;<span class="keyword">int</span>, T, <span class="number">1</span>&gt;; </span><br></pre></td></tr></table></figure></li><li><p>默认模板参数：在 C++11 中提供了一种便利，可以指定模板的默认参数。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="keyword">int</span>, <span class="keyword">typename</span> U = <span class="keyword">int</span>&gt;</span><br><span class="line"><span class="keyword">auto</span> add(T x, U y) -&gt; <span class="keyword">decltype</span>(x + y) &#123; </span><br><span class="line">    <span class="keyword">return</span> x + y; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>变长参数模板：在 C++11 之前，无论是类模板还是函数模板，都只能按其指定的样子，接受一组固定数量的模板参数；而 C++11 加入了新的表示方法，允许任意个数、任意类别的模板参数，同时也不需要在定义时将参数的个数固定。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt; <span class="class"><span class="keyword">class</span> <span class="title">Magic</span>;</span></span><br><span class="line"><span class="comment">// 可以指定模板参数以要求模板参数的个数至少为1</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Require, <span class="keyword">typename</span>... Args&gt; <span class="class"><span class="keyword">class</span> <span class="title">Magic</span>;</span></span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2></li><li><p>委托构造：C++11 引入了委托构造的概念，这使得构造函数可以在同一个类中一个构造函数调用另一个构造函数，从而达到简化代码的目的。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> v1;</span><br><span class="line">    <span class="keyword">int</span> v2;</span><br><span class="line">    Base() &#123; v1 = <span class="number">1</span>; &#125;</span><br><span class="line">    Base(<span class="keyword">int</span> v) : Base() &#123; v2 = <span class="number">2</span>; &#125;   <span class="comment">// 委托 Base() 构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>继承构造：在继承体系中，如果派生类想要使用基类的构造函数，需要在构造函数中显式声明。假若基类拥有为数众多的不同版本的构造函数，这样，在派生类中得写很多对应的“透传”构造函数。在 C++11 中，只要一句话搞定。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>:</span>A&#123;</span><br><span class="line">    <span class="comment">// 太麻烦</span></span><br><span class="line">    B(<span class="keyword">int</span> i):A(i)&#123;&#125;</span><br><span class="line">    B(<span class="keyword">double</span> d, <span class="keyword">int</span> i)&#123;&#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>:</span>A &#123;</span><br><span class="line">    <span class="comment">// 一句话搞定</span></span><br><span class="line">    <span class="keyword">using</span> A::A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 如果一个继承构造函数不被相关的代码使用，编译器就不会为之产生真正的函数代码，这样比透传基类各种构造函数更加节省目标代码空间。</p></li></ol><h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><h2 id="新增容器"><a href="#新增容器" class="headerlink" title="新增容器"></a>新增容器</h2><ol><li><p>std::array：保存在栈内存中，相比堆内存中的 std::vector，性能更高。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> len = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 4&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, len&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;  <span class="comment">// 非法，数组大小必为常量表达式</span></span><br></pre></td></tr></table></figure></li><li>std::forward_list 是一个列表容器，使用方法和 std::list 基本类似。和 std::list 的双向链表的实现不同，std::forward_list 使用单向链表进 行实现，提供了 O(1) 复杂度的元素插入，不支持快速随机访问（这也是链表的 特点），也是标准库容器中唯一一个不提供 size() 方法的容器。当不需要双向 迭代时，具有比 std::list 更高的空间利用率。</li><li>无序容器：C++11 引入了两组无序容器： std::unordered_map/std::unordered_multimap 和 std::unordered_set/std::unordered_multiset。无序容器中的元素是不进行排序的，内部通过 Hash 表实现，插入和搜索元素的 平均复杂度为 O(constant)。</li><li>元组：std::tuple 元组的使用有三个核心的函数： <ul><li>std::make_tuple: 构造元组 </li><li>std::get: 获得元组某个位置的值 </li><li>std::tie: 元组拆包</li></ul></li></ol><h2 id="explicit-关键字"><a href="#explicit-关键字" class="headerlink" title="explicit 关键字"></a>explicit 关键字</h2><p>explicit主要是用来修饰类的构造函数，从而使被构造的类只能发生显示转换，而不能进行隐式转化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Test1(<span class="keyword">int</span> n)&#123;  <span class="comment">// 隐式构造函数</span></span><br><span class="line">            num = n;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">Test2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;   <span class="comment">//explicit(显式)构造函数</span></span><br><span class="line">            num = n;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Test1 t1 = <span class="number">10</span>;  <span class="comment">// 隐式转化</span></span><br><span class="line">    <span class="comment">//等同于 Test1 temp(10);  Test1 t1 = temp;</span></span><br><span class="line"></span><br><span class="line">    Test1 t2 = <span class="string">&#x27;c&#x27;</span>;  <span class="comment">// &#x27;c&#x27;被转化为ascii码，然后同上</span></span><br><span class="line"></span><br><span class="line">    Test2 t3 = <span class="number">12</span>;  <span class="comment">// 编译错误,不能隐式调用其构造函数</span></span><br><span class="line"></span><br><span class="line"> Test2 t4 = <span class="string">&#x27;c&#x27;</span>;  <span class="comment">// 编译错误,不能隐式调用其构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Test2 <span class="title">t5</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">//  正常的显式转化</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>explicit关键字只用于类的单参数构造函数，对于无参数和多参数的构造函数总是显示调用，因此使用explicit没有意义。通常情况下，我们约定对于单参数构造函数必须使用explicit关键字，避免产生意外的类型转化，拷贝构造函数除外。</strong></p><h2 id="constexpr关键字"><a href="#constexpr关键字" class="headerlink" title="constexpr关键字"></a>constexpr关键字</h2><p>constexpr 关键字是 C++11 新增的关键字，其语义是“常量表达式”，也就是在编译期可求值的表达式。</p><p>对于constexpr修饰的函数：</p><ol><li>函数体一般只包含一个return语句；</li><li>函数体可以包含其他语句，但是不能是运行期语句，只能是编译期语句；</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">Inc</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> a = Inc(<span class="number">1</span>); <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> b = Inc(<span class="built_in">cin</span>.get()); <span class="comment">// !error</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> c = a * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>constexpr还能用于修饰类的构造函数，即保证如果提供给该构造函数的参数都是constexpr，那么产生的对象中的所有成员都会是constexpr，该对象也就是constexpr对象了，可用于各种只能使用constexpr的场合。注意，constexpr构造函数必须有一个空的函数体，即所有成员变量的初始化都放到初始化列表中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    constexpr A(int xx, int yy): x(xx), y(yy) &#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> A <span class="title">a</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span>SIZE_X = a.x, SIZE_Y = a.y&#125;;</span><br></pre></td></tr></table></figure><p>好处：</p><ol><li>是一种很强的约束，更好地保证程序的正确语义不被破坏。</li><li>编译器可以在编译期对constexpr的代码进行非常大的优化，比如将用到的constexpr表达式都直接替换成最终结果等。</li><li>相比宏来说，没有额外的开销，但更安全可靠。</li></ol><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>const 和 constexpr 变量之间的主要区别在于：const 变量的初始化可以延迟到运行时，而 constexpr 变量必须在编译时进行初始化。所有 constexpr 变量均为常量，因此必须使用常量表达式初始化。</p><h3 id="修饰指针"><a href="#修饰指针" class="headerlink" title="修饰指针"></a>修饰指针</h3><p>在使用const时，如果关键字const出现在星号左边，表示被指物是常量；如果出现在星号右边，表示指针本身是常量；如果出现在星号两边，表示被指物和指针两者都是常量。</p><p>与const不同，在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指对象无关。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> g_tempA = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> g_conTempA = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> g_conexprTempA = <span class="number">4</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tempA = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> conTempA = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> conexprTempA = <span class="number">4</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*1.正常运行,编译通过*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *conptrA = &amp;tempA;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *conptrB = &amp;conTempA;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *conptrC = &amp;conexprTempA;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*2.局部变量的地址要运行时才能确认，故不能在编译期决定，编译不过*/</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *conexprPtrA = &amp;tempA;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *conexprPtrB = &amp;conTempA;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *conexprPtrC = &amp;conexprTempA;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*3.第一个通过，后面两个不过,因为constexpr int *所限定的是指针是常量，故不能将常量的地址赋给顶层const*/</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *conexprPtrD = &amp;g_tempA;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *conexprPtrE = &amp;g_conTempA;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *conexprPtrF = &amp;g_conexprTempA;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*4.局部变量的地址要运行时才能确认，故不能在编译期决定，编译不过*/</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">int</span> *conexprConPtrA = &amp;tempA;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">int</span> *conexprConPtrB = &amp;conTempA;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">int</span> *conexprConPtrC = &amp;conexprTempA;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*5.正常运行，编译通过*/</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">int</span> *conexprConPtrD = &amp;g_tempA;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">int</span> *conexprConPtrE = &amp;g_conTempA;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">int</span> *conexprConPtrF = &amp;g_conexprTempA;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修饰引用"><a href="#修饰引用" class="headerlink" title="修饰引用"></a>修饰引用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> g_tempA = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> g_conTempA = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> g_conexprTempA = <span class="number">4</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tempA = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> conTempA = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> conexprTempA = <span class="number">4</span>;</span><br><span class="line"><span class="comment">/*1.正常运行，编译通过*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;conptrA = tempA;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;conptrB = conTempA;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;conptrC = conexprTempA;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*2.有两个问题：一是引用到局部变量，不能在编译器确定；二是conexprPtrB和conexprPtrC应该为constexpr const类型，编译不过*/</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> &amp;conexprPtrA = tempA;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> &amp;conexprPtrB = conTempA;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> &amp;conexprPtrC = conexprTempA;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*3.第一个编译通过，后两个不通过，原因是因为conexprPtrE和conexprPtrF应该为constexpr const类型*/</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> &amp;conexprPtrD = g_tempA;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> &amp;conexprPtrE = g_conTempA;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> &amp;conexprPtrF = g_conexprTempA;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*4.正常运行，编译通过*/</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">int</span> &amp;conexprConPtrD = g_tempA;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">int</span> &amp;conexprConPtrE = g_conTempA;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">int</span> &amp;conexprConPtrF = g_conexprTempA;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的说 constexpr 所引用的对象必须在编译期就决定地址。可以通过上例 conexprPtrD 来修改 g_tempA 的值，也就是说 constexpr 修饰的引用不是常量，如果要确保常量引用需要 constexpr const 来修饰。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：粉刷匠（背包dp）</title>
      <link href="2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%B2%89%E5%88%B7%E5%8C%A0%EF%BC%88%E8%83%8C%E5%8C%85dp%EF%BC%89.html"/>
      <url>2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%B2%89%E5%88%B7%E5%8C%A0%EF%BC%88%E8%83%8C%E5%8C%85dp%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>n 条木板，每条木板都被分成 m 段且每一段都有要涂的颜色，有 t 次机会涂色，每次可以选择一条木板的连续一段涂成同一种颜色，问最多可以涂对多少段。</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>考虑四维dp的做法。$dp[i][j][k][0/1]$ 代表到第 $i$ 条第 $j$ 段时涂 $k$ 次，当前段涂红或蓝$(0/1)$的最大正确数，可以得到转移方程：<br><a id="more"></a> </p><p>当 $j=1$ (属于当前木板第一段) 时，由上一个木板转移过来：</p><p>$dp[i][j][k][0] = max(dp[i-1][m][k-1][0],dp[i-1][m][k-1][1]) + (s[i][j] == ‘0’)$</p><p>$dp[i][j][k][1] = max(dp[i-1][m][k-1][0],dp[i-1][m][k-1][1]) + (s[i][j] == ‘1’)$</p><p>否则，由当前木板的上一段转移过来：</p><p>$dp[i][j][k][0] = max(dp[i][j-1][k][0],dp[i][j-1][k-1][1]) + (s[i][j] == ‘0’)$</p><p>$dp[i][j][k][1] = max(dp[i][j-1][k-1][0],dp[i][j-1][k][1]) + (s[i][j] == ‘1’)$</p><p>最后结果显然为 $max(dp[n][m][t][0], dp[n][m][t][1])$ 。</p><p>时间复杂度 $O(nmt)$，空间上可以使用滚动数组压维，空间复杂度为 $O(4mt)$。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int <span class="symbol">N</span> = <span class="number">55</span>;</span><br><span class="line">char s[<span class="symbol">N</span>][<span class="symbol">N</span>];</span><br><span class="line">int n, m, t, dp[<span class="number">2</span>][<span class="symbol">N</span>][<span class="symbol">N</span> * <span class="symbol">N</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  scanf(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;t);</span><br><span class="line">  for (int i = <span class="number">1</span>; i &lt;= n; i++) scanf(<span class="string">&quot;%s&quot;</span>, s[i] + <span class="number">1</span>);</span><br><span class="line">  for (int i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    for (int j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">      for (int k = <span class="number">1</span>; k &lt;= t; k++)</span><br><span class="line">        for (int l = <span class="number">0</span>; l &lt;= <span class="number">1</span>; l++) &#123;</span><br><span class="line">          if (j == <span class="number">1</span>)</span><br><span class="line">            dp[i &amp; <span class="number">1</span>][j][k][l] = max(dp[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][m][k - <span class="number">1</span>][<span class="number">0</span>], dp[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][m][k - <span class="number">1</span>][<span class="number">1</span>]) + (s[i][j] == l + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">          else</span><br><span class="line">            dp[i &amp; <span class="number">1</span>][j][k][l] = max(dp[i &amp; <span class="number">1</span>][j - <span class="number">1</span>][k][l], dp[i &amp; <span class="number">1</span>][j - <span class="number">1</span>][k - <span class="number">1</span>][l ^ <span class="number">1</span>]) + (s[i][j] == l + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">  printf(<span class="string">&quot;%d\n&quot;</span>, max(dp[n &amp; <span class="number">1</span>][m][t][<span class="number">0</span>], dp[n &amp; <span class="number">1</span>][m][t][<span class="number">1</span>]));</span><br><span class="line">  return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 背包dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：滑雪与时间胶囊（最小生成树）</title>
      <link href="2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%BB%91%E9%9B%AA%E4%B8%8E%E6%97%B6%E9%97%B4%E8%83%B6%E5%9B%8A%EF%BC%88%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89.html"/>
      <url>2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%BB%91%E9%9B%AA%E4%B8%8E%E6%97%B6%E9%97%B4%E8%83%B6%E5%9B%8A%EF%BC%88%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个 $n$ 个点 $m$ 条边图，只能从点权高的点走到低的，且可以不计路程的瞬移至之前走过的某个点，求经过最多点的最短路径。</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>求经过最多点显然直接bfs，建图的时候建高到低的单向边即可，（值得注意的是，若点权相同，则为相互可达的，需要建双向边）。然后根据bfs遍历可以走到的点，将走过的边加入边集，建一个新图出来。为了使路径最短，考虑最小生成树，但需要满足题目的条件，因此我们对新的图进行排序，以高度为第一关键字从大到小排，再以路径长度为第二关键字从小到大排，这样可以保证点最多的同时路径最短。<br><a id="more"></a> </p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, tot, cnt, hi[N], h[N], pre[N], vis[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> from, to, v, next;</span><br><span class="line">&#125; g[N], E[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">  g[tot].from = x, g[tot].to = y, g[tot].v = z, g[tot].next = h[x],</span><br><span class="line">  h[x] = tot++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">  cnt++, E[cnt].from = x, E[cnt].to = y, E[cnt].v = z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node x, Node y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (hi[x.to] == hi[y.to]) <span class="keyword">return</span> x.v &lt; y.v;</span><br><span class="line">  <span class="keyword">return</span> hi[x.to] &gt; hi[y.to];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xfind</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = x, j = x, temp;</span><br><span class="line">  <span class="keyword">while</span> (i != pre[i]) i = pre[i];</span><br><span class="line">  <span class="keyword">while</span> (i != j) &#123;</span><br><span class="line">    temp = pre[j];</span><br><span class="line">    pre[j] = i;</span><br><span class="line">    j = temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> res1 = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">  vis[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">  q.push(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = q.front();</span><br><span class="line">    q.pop();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i; i = g[i].next) &#123;</span><br><span class="line">      <span class="keyword">int</span> v = g[i].to;</span><br><span class="line">      add2(u, v, g[i].v);</span><br><span class="line">      <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">        vis[v] = <span class="literal">true</span>;</span><br><span class="line">        res1++;</span><br><span class="line">        q.push(v);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, res1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kruscal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> res2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = E[i].from, y = E[i].to;</span><br><span class="line">    <span class="keyword">int</span> fx = xfind(x), fy = xfind(y);</span><br><span class="line">    <span class="keyword">if</span> (fx != fy) &#123;</span><br><span class="line">      pre[fx] = fy;</span><br><span class="line">      res2 += E[i].v;</span><br><span class="line">      num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;hi[i]);</span><br><span class="line">    pre[i] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, z;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">    <span class="keyword">if</span> (hi[x] &gt;= hi[y]) add1(x, y, z);</span><br><span class="line">    <span class="keyword">if</span> (hi[x] &lt;= hi[y]) add1(y, x, z);</span><br><span class="line">  &#125;</span><br><span class="line">  bfs();</span><br><span class="line">  sort(E + <span class="number">1</span>, E + cnt + <span class="number">1</span>, cmp);</span><br><span class="line">  Kruscal();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：换个角度思考（树状数组）</title>
      <link href="2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%8D%A2%E4%B8%AA%E8%A7%92%E5%BA%A6%E6%80%9D%E8%80%83%EF%BC%88%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%EF%BC%89.html"/>
      <url>2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%8D%A2%E4%B8%AA%E8%A7%92%E5%BA%A6%E6%80%9D%E8%80%83%EF%BC%88%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个长度为 $(1&lt;=n&lt;=1e5)$ 的数组，$(1&lt;=q&lt;=1e5)$ 次询问查询区间 $[l,r]$ 内 $&lt;=k$ 的元素个数。</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>考虑树状数组。我们在查询区间 $&lt;=k$ 的个数时，为了更好计数，这个区间应该不包含 $&gt;k$ 的元素才行。因此我们不妨离线，将询问的 $k$ 从小到大排序，将数组也从小到大排序，这样从小到大处理询问，每次处理时只将 $&lt;=k$ 的数挂到树的对应下标上（因为询问的 $k$ 是从小到大的，因此之前树上的数一定比当前询问的 $k$ 要小），维护答案为 $query(r) - query(l-1)$。<br><a id="more"></a> </p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#define x first</span></span><br><span class="line"><span class="comment">#define y second</span></span><br><span class="line">using namespace std;</span><br><span class="line">const <span class="keyword">int</span> N = <span class="number">2</span>e5 + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">struct Node &#123;</span><br><span class="line">  <span class="keyword">int</span> l, r, v, id;</span><br><span class="line">&#125; <span class="string">q[N]</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, <span class="keyword">m</span>, c[N], res[N];</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p[N];</span><br><span class="line"></span><br><span class="line">bool cmp(Node <span class="keyword">x</span>, Node <span class="keyword">y</span>) &#123; <span class="keyword">return</span> x.v &lt; y.v; &#125;</span><br><span class="line"></span><br><span class="line">void update(<span class="keyword">int</span> <span class="keyword">x</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (; <span class="keyword">x</span> &lt;= n; <span class="keyword">x</span> += <span class="keyword">x</span> &amp; (-<span class="keyword">x</span>)) c[<span class="keyword">x</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> query(<span class="keyword">int</span> <span class="keyword">x</span>) &#123;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (; <span class="keyword">x</span> &gt;= <span class="number">1</span>; <span class="keyword">x</span> -= <span class="keyword">x</span> &amp; (-<span class="keyword">x</span>)) sum += c[<span class="keyword">x</span>];</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main() &#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; <span class="keyword">m</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    cin &gt;&gt; p[i].x;</span><br><span class="line">    p[i].y = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">sort</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="keyword">m</span>; i++) &#123;</span><br><span class="line">    cin &gt;&gt; <span class="string">q[i]</span>.l &gt;&gt; <span class="string">q[i]</span>.r &gt;&gt; <span class="string">q[i]</span>.v;</span><br><span class="line">    <span class="string">q[i]</span>.id = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">sort</span>(<span class="keyword">q</span> + <span class="number">1</span>, <span class="keyword">q</span> + <span class="keyword">m</span> + <span class="number">1</span>, cmp);</span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">pos</span> = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="keyword">m</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="string">q[i]</span>.v &gt;= p[<span class="keyword">pos</span>].x &amp;&amp; <span class="keyword">pos</span> &lt;= n) &#123;</span><br><span class="line">      update(p[<span class="keyword">pos</span>].y);</span><br><span class="line">      <span class="keyword">pos</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">    res[<span class="string">q[i]</span>.id] = query(<span class="string">q[i]</span>.r) - query(<span class="string">q[i]</span>.l - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="keyword">m</span>; i++) cout &lt;&lt; res[i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题: Best Cow Fences(二分)</title>
      <link href="2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9ABest-Cow-Fences%EF%BC%88%E4%BA%8C%E5%88%86%EF%BC%89.html"/>
      <url>2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9ABest-Cow-Fences%EF%BC%88%E4%BA%8C%E5%88%86%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个正整数数列A，求一个平均数最大的、长度不小于L的子段。</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>考虑check问题，正着枚举起点，我们需要知道每个起点所能枚举的最大值。当一个数大于当前二分的平均数时，它一定是对答案有贡献的，因此倒过来预处理每个起点能枚举到的最大值即可。时间复杂度 $O(nlogn)$。<br><a id="more"></a> </p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">ll n, k;</span><br><span class="line"><span class="keyword">double</span> a[N], sum[N], pre[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> avg)</span> </span>&#123;</span><br><span class="line">  pre[n + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (ll i = n; i &gt;= <span class="number">1</span>; i--) pre[i] = <span class="built_in">max</span>(a[i] - avg, pre[i + <span class="number">1</span>] + a[i] - avg);</span><br><span class="line">  <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt;= n - k; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sum[i + k] - sum[i] &gt;= k * avg) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (sum[i + k] - sum[i] + pre[i + k + <span class="number">1</span>] &gt;= k * avg) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;k)) &#123;</span><br><span class="line">    <span class="keyword">double</span> l = <span class="number">1e18</span> + <span class="number">7</span>, r = <span class="number">0</span>, mid;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;a[i]);</span><br><span class="line">      l = <span class="built_in">min</span>(l, a[i]);</span><br><span class="line">      r = <span class="built_in">max</span>(r, a[i]);</span><br><span class="line">      sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; <span class="number">0.0001</span>) &#123;</span><br><span class="line">      mid = (l + r) / <span class="number">2.0</span>;</span><br><span class="line">      <span class="keyword">if</span> (check(mid))</span><br><span class="line">        l = mid;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (ll)(l + <span class="number">0.5</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：Yet Another Counting Problem</title>
      <link href="2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AYet-Another-Counting-Problem.html"/>
      <url>2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AYet-Another-Counting-Problem.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给你两个数 $a$ 和 $b$，$q$ 次询问 $[l,r]$ 内满足 (($x$ mod $a$) mod $b$) != (($x$ mod $b$) mod $a$) 的 $x$ 个数。（$q&lt;=500,1&lt;=a,b&lt;=200,1&lt;=l&lt;=r&lt;=1e18$）</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>若 x % a % b != x % b % a，则(x + a $\times$ b ) % a % b != (x + $a \times b$ ) % b % a. 可以得到规律一定是以 a $\times$ b 为循环的，因此预处理前 a $\times$ b个即可。<br><a id="more"></a> </p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll t, a, b, q, l, r, sl, sr, sum[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">  <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; q;</span><br><span class="line">    <span class="keyword">int</span> p = a * b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; p; i++) sum[i] = sum[i - <span class="number">1</span>] + (i % a % b != i % b % a);</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">      l--;</span><br><span class="line">      sl = l / p * sum[p - <span class="number">1</span>] + sum[l % p];</span><br><span class="line">      sr = r / p * sum[p - <span class="number">1</span>] + sum[r % p];</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; sr - sl &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：美味菜肴</title>
      <link href="2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%BE%8E%E5%91%B3%E8%8F%9C%E8%82%B4.html"/>
      <url>2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%BE%8E%E5%91%B3%E8%8F%9C%E8%82%B4.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>$n$ 件食材（每种食材的数量可以视为无限），小明连续工作 $T$ 时间。每道菜肴的制作需要特定的一种食材以及一段时间，但是食材一旦放久就不新鲜了，菜的美味值会降低。第 $i$ 道菜肴有三个属性 $ai$，$bi$，$ci$，$ai$ 是该菜肴的美味值，$bi$ 是该菜肴所选食材不新鲜的速率，如果在第t时刻完成第i道菜则美味值为：$ai-t*bi$，完成这道菜需要 $ci$ 的时间。求在这 $T$ 时间内能做出菜肴使得总美味值的最大值。</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>首先需要贪心确定顺序，考虑只有两道菜，可以得到：$a_i−b_i∗c_i+(a_j−b_j∗(c_i+c_j))&gt;=a_j−b_j∗c_j+(a_i−b_i∗(c_i+c_j))$，化简后得到：$b_i∗c_i&gt;=b_j∗c_i$。排序后背包即可（需要降维）。</p><a id="more"></a> <h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const ll INF = <span class="number">0x3ffffffffffff</span>;</span><br><span class="line">const <span class="keyword">int</span> N = <span class="number">2</span>e5 + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">struct Node &#123;</span><br><span class="line">  ll a, b, c;</span><br><span class="line">&#125; <span class="string">q[N]</span>;</span><br><span class="line"></span><br><span class="line">ll res = -INF, <span class="keyword">s</span>[N], dp[N];</span><br><span class="line"></span><br><span class="line">bool cmp(Node <span class="keyword">x</span>, Node <span class="keyword">y</span>) &#123; <span class="keyword">return</span> x.c * <span class="keyword">s</span>[y.a] &lt; y.c * <span class="keyword">s</span>[x.a]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main() &#123;</span><br><span class="line">  <span class="keyword">int</span> n, <span class="keyword">m</span>, t;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; <span class="keyword">m</span> &gt;&gt; t;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; <span class="keyword">s</span>[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="keyword">m</span>; i++) cin &gt;&gt; <span class="string">q[i]</span>.a &gt;&gt; <span class="string">q[i]</span>.b &gt;&gt; <span class="string">q[i]</span>.c;</span><br><span class="line">  <span class="keyword">sort</span>(<span class="keyword">q</span> + <span class="number">1</span>, <span class="keyword">q</span> + <span class="keyword">m</span> + <span class="number">1</span>, cmp);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++) dp[i] = -INF;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="keyword">m</span>; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = t; j &gt;= <span class="string">q[i]</span>.c; j--)</span><br><span class="line">      dp[j] = max(dp[j], dp[j - <span class="string">q[i]</span>.c] + <span class="string">q[i]</span>.b - j * <span class="keyword">s</span>[<span class="string">q[i]</span>.a]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++) res = max(res, dp[i]);</span><br><span class="line">  cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：Game Strategy</title>
      <link href="2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AGame-Strategy.html"/>
      <url>2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AGame-Strategy.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>三个人玩游戏，每个人最开始都有 $n$ 个数，开始轮流删数，直到最后每个人只剩下一个数。第一个人想让这三个数的和（$x+y+z$）加起来尽量大，第二个想尽量小，第三个想尽量接近0。每个人都以自己的想法为策略，问最后得到的三个数的和是多少（$n&lt;=100$）。</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>不要想复杂了，其实就是直接模拟。暴力枚举三个数，因为第三个人想尽量接近 0，因此枚举 $z$ 时维护最接近 0 的解 $m1$，因为第二个人想要最小值，因此取枚举所有 $z$ 得到的解（$m1$）的最小值$m2$，然后第一个人想要最大值，所以取枚举所有 $y$ （$m2$）的最大值 $m3$。</p><a id="more"></a> <h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, a[<span class="number">105</span>], b[<span class="number">105</span>], c[<span class="number">105</span>], d[<span class="number">105</span>];</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; c[i];</span><br><span class="line">  <span class="keyword">int</span> m1 = -INF, m2, m3;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    m2 = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) d[k] = a[i] + b[j] + c[k];</span><br><span class="line">      sort(d, d + n);</span><br><span class="line">      <span class="keyword">int</span> pos = lower_bound(d, d + n, <span class="number">0</span>) - d;</span><br><span class="line">      <span class="keyword">if</span> (pos == n)</span><br><span class="line">        m3 = d[pos - <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (pos == <span class="number">0</span>)</span><br><span class="line">        m3 = d[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (d[pos] &gt; -d[pos - <span class="number">1</span>])</span><br><span class="line">          m3 = d[pos - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          m3 = d[pos];</span><br><span class="line">      &#125;</span><br><span class="line">      m2 = <span class="built_in">min</span>(m2, m3);</span><br><span class="line">    &#125;</span><br><span class="line">    m1 = <span class="built_in">max</span>(m1, m2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; m1 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博弈论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回文相关算法总结及简单变形</title>
      <link href="2020/04/%E5%9B%9E%E6%96%87%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E5%8F%8A%E7%AE%80%E5%8D%95%E5%8F%98%E5%BD%A2.html"/>
      <url>2020/04/%E5%9B%9E%E6%96%87%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E5%8F%8A%E7%AE%80%E5%8D%95%E5%8F%98%E5%BD%A2.html</url>
      
        <content type="html"><![CDATA[<h2 id="求最长回文串"><a href="#求最长回文串" class="headerlink" title="求最长回文串"></a><strong>求最长回文串</strong></h2><h3 id="解法一：中心扩散法"><a href="#解法一：中心扩散法" class="headerlink" title="解法一：中心扩散法"></a>解法一：中心扩散法</h3><p>过于傻逼，就是枚举中心点向两边拓展长度直到不相等。（时间复杂度 $O(n^2)$，空间复杂度 $O(1)$）</p><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><a id="more"></a> <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> now, x, y;</span><br><span class="line">  <span class="keyword">if</span> (type)</span><br><span class="line">    now = <span class="number">0</span>, x = pos, y = pos + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    now = <span class="number">1</span>, x = pos - <span class="number">1</span>, y = pos + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; y &lt; s.<span class="built_in">size</span>() &amp;&amp; s[x] == s[y])</span><br><span class="line">      now += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    x--, y++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s) &#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">      res = <span class="built_in">max</span>(res, <span class="built_in">max</span>(check(i, <span class="number">0</span>), check(i, <span class="number">1</span>)));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="解法二：动态规划"><a href="#解法二：动态规划" class="headerlink" title="解法二：动态规划"></a>解法二：动态规划</h3><p>$dp[i][j] = 0/1 $ 表示子串 $i~j$ 是否为回文串。</p><p>那么，容易得到：$dp[i][j] = (dp[i+1][j-1]$ &amp;&amp; $s[i]==s[j])$。</p><p>由于 $i$ 是由 $i+1$ 转移过来的，所以我们需要倒着遍历：</p><h4 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (int i = s.size() - <span class="number">1</span><span class="comment">; i &gt;= 0; i--)</span></span><br><span class="line">  for (int <span class="keyword">j </span>= i<span class="comment">; j &lt; s.size(); j++) &#123;</span></span><br><span class="line">    if (s[i] == s[<span class="keyword">j] </span>&amp;&amp; (<span class="keyword">j </span>- i &lt; <span class="number">2</span> <span class="title">||</span> dp[i + <span class="number">1</span>][<span class="keyword">j </span>- <span class="number">1</span>])) &#123;</span><br><span class="line">      dp[i][<span class="keyword">j] </span>= true;</span><br><span class="line">      res = max(res, <span class="keyword">j </span>- i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>时间复杂度 $O(n^2)$，空间复杂度 $O(n^2)$</p><h3 id="解法三：manacher"><a href="#解法三：manacher" class="headerlink" title="解法三：manacher"></a>解法三：manacher</h3><h4 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="keyword">char</span> s[N], t[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">manacher</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    t[l++] = <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line">    t[l++] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t[l++] = s[i];</span><br><span class="line">        t[l++] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t[l++] = <span class="string">&#x27;@&#x27;</span>;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>, mx = <span class="number">0</span>, index = <span class="number">0</span>, maxlength = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; l; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = mx &gt; i ? <span class="built_in">min</span>(p[<span class="number">2</span> * id - i], mx - i) : <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/// 向左右两边延伸，扩展右边界</span></span><br><span class="line">        <span class="keyword">while</span> (t[i + p[i]] == t[i - p[i]])</span><br><span class="line">            p[i]++;</span><br><span class="line">        <span class="comment">/// 如果回文子串的右边界超过了mx，则需要更新mx和id的值</span></span><br><span class="line">        <span class="keyword">if</span> (i + p[i] &gt; mx)</span><br><span class="line">        &#123;</span><br><span class="line">            mx = i + p[i];</span><br><span class="line">            id = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/// 如果回文子串的长度大于maxLength，则更新maxLength和index的值</span></span><br><span class="line">        <span class="keyword">if</span> (maxlength &lt; p[i] - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            maxlength = p[i] - <span class="number">1</span>;</span><br><span class="line">            index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start = (index - maxlength) / <span class="number">2</span>; <span class="comment">/// 记录起始位置</span></span><br><span class="line">    <span class="keyword">return</span> maxlength;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, manacher());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变形1"><a href="#变形1" class="headerlink" title="变形1"></a>变形1</h2><h3 id="求最长回文子序列"><a href="#求最长回文子序列" class="headerlink" title="求最长回文子序列"></a>求最长回文子序列</h3><h4 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h4><ul><li><p>状态</p><p>$f[i][j]$ 表示 $s$ 的第 $i$ 个字符到第 $j$ 个字符组成的子串中，最长的回文序列长度是多少。</p></li><li><p>转移方程</p><p>如果 $s$ 的第 $i$ 个字符和第 $j$ 个字符相同的话</p></li><li><p>$f[i][j] = f[i + 1][j - 1] + 2$</p><p>如果 $s$ 的第 $i$ 个字符和第 $j$ 个字符不同的话</p></li><li><p>$f[i][j] = max(f[i + 1][j], f[i][j - 1])$</p><p>然后注意遍历顺序，$i$ 从最后一个字符开始往前遍历，$j$ 从 $i + 1$ 开始往后遍历，这样可以保证每个子问题都已经算好了。</p></li><li><p>初始化<br>$f[i][i] = 1$ 单个字符的最长回文序列是 $1$</p></li><li><p>结果<br>$f[0][n - 1]$</p></li></ul><h4 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h4><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for(int i = n - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">  dp<span class="comment">[i]</span><span class="comment">[i]</span> = 1;</span><br><span class="line">  for(int j = i + 1; j &lt; n; j++) &#123;</span><br><span class="line">    if(s<span class="comment">[i]</span> == s<span class="comment">[j]</span>)</span><br><span class="line">      dp<span class="comment">[i]</span><span class="comment">[j]</span> = dp<span class="comment">[i + 1]</span><span class="comment">[j - 1]</span> + 2;</span><br><span class="line">    else</span><br><span class="line">      dp<span class="comment">[i]</span><span class="comment">[j]</span> = max(dp<span class="comment">[i + 1]</span><span class="comment">[j]</span>, dp<span class="comment">[i]</span><span class="comment">[j - 1]</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">return dp<span class="comment">[0]</span><span class="comment">[n - 1]</span>;</span><br></pre></td></tr></table></figure><h2 id="变形2"><a href="#变形2" class="headerlink" title="变形2"></a>变形2</h2><h3 id="插入最少的字符，使得字符串变成回文串。"><a href="#插入最少的字符，使得字符串变成回文串。" class="headerlink" title="插入最少的字符，使得字符串变成回文串。"></a>插入最少的字符，使得字符串变成回文串。</h3><h4 id="solution-1"><a href="#solution-1" class="headerlink" title="solution"></a>solution</h4><p>很直观的，答案就是原长度-最长回文子序列。考虑另一种区间dp的做法：</p><p>既然是区间dp，那么就是由小区间得到大区间，故最外层从小到大枚举长度，然后枚举左右端点。</p><ul><li>$dp[i][j] = min(dp[i + 1][j] + 1, dp[i][j - 1] + 1)$                     $s[i] != s[j]$</li><li>$dp[i][j] = min(dp[i + 1][j] + 1, dp[i][j - 1] + 1, dp[i + 1][j - 1])$   $s[i] == s[j]$</li></ul><h4 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h4><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for (int len = 2; len &lt;= n; len++) &#123;</span><br><span class="line">    for (int l = 0; l &lt;= n - len; l++) &#123;</span><br><span class="line">      int r = l + len - 1;</span><br><span class="line">      dp<span class="comment">[l]</span><span class="comment">[r]</span> = min(dp<span class="comment">[l + 1]</span><span class="comment">[r]</span>, dp<span class="comment">[l]</span><span class="comment">[r - 1]</span>) + 1;</span><br><span class="line">      if (s<span class="comment">[l]</span> == s<span class="comment">[r]</span>)</span><br><span class="line">        dp<span class="comment">[l]</span><span class="comment">[r]</span> = min(dp<span class="comment">[l]</span><span class="comment">[r]</span>, dp<span class="comment">[l + 1]</span><span class="comment">[r - 1]</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return dp<span class="comment">[0]</span><span class="comment">[n - 1]</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：不同子序列个数(升级版)</title>
      <link href="2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E4%B8%8D%E5%90%8C%E5%AD%90%E5%BA%8F%E5%88%97%E4%B8%AA%E6%95%B0-%E5%8D%87%E7%BA%A7%E7%89%88.html"/>
      <url>2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E4%B8%8D%E5%90%8C%E5%AD%90%E5%BA%8F%E5%88%97%E4%B8%AA%E6%95%B0-%E5%8D%87%E7%BA%A7%E7%89%88.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个长度为 $n$ 的数组，求长度为 $n-m$ 的不同子序列个数。（$1&lt;=n&lt;=1e5, m&lt;=10$）</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>$dp[i][j]$ 表示长度为 $i$，删除 $j$ 个元素的子序列个数，不考虑重复的话，有 $dp[i][j] = dp[i-1][j] + dp[i-1][j-1]$（即已经删除了 $j$  个和已经删除了 $j-1$ 个再删除这一个的情况）。<br><a id="more"></a> </p><p>考虑去重。如果是单纯求不限长度的不同子序列的去重，容易得到：$dp[i] -= dp[pre[a[i]] - 1]$  （$pre[a[i]]$ 为上一次 $a[i]$ 出现的位置），在此题中也是同理，我们需要剔除 $[pre[a[i]], i]$ 之间的元素，假设我们当前需要剔除 $j$ 个元素，那么在$pre[a[i]]-1$之前我们先需要剔除 $j-(i-pre[a[i]])$ 个元素， $dp[i][j] -= dp[pre[a[i]]-1][j-(i-pre[a[i]])]$，初始化为所有的 $dp[i][0] = 1$。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k, pre[N], dp[N][<span class="number">12</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">memset</span>(pre, <span class="number">0</span>, <span class="keyword">sizeof</span>(pre));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> x;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="built_in">min</span>(i, m); j++) &#123;</span><br><span class="line">        dp[i][j] = (dp[i - <span class="number">1</span>][j] + dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br><span class="line">        <span class="keyword">if</span> (pre[x] &amp;&amp; j - (i - pre[x]) &gt;= <span class="number">0</span>)</span><br><span class="line">          dp[i][j] = (dp[i][j] - dp[pre[x] - <span class="number">1</span>][j - (i - pre[x])] + mod) % mod;</span><br><span class="line">      &#125;</span><br><span class="line">      pre[x] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[n][m] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计数dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：子序列</title>
      <link href="2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%AD%90%E5%BA%8F%E5%88%97.html"/>
      <url>2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%AD%90%E5%BA%8F%E5%88%97.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个由n个元素组成的序列 { a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>,…, a<sub>n</sub> } ，她想知道其中有多少个子序列 { a<sub>p1</sub>, a<sub>p2</sub>, …, a<sub>pm</sub> } $(1 ≤ m ≤ n, 1 ≤ p1 &lt; p2 ,…, &lt; pm ≤ n)$，满足对于所有的 $i, j$ $(1 ≤ i &lt; j ≤ m)$, a<sub>pi</sub><sup>pj</sup> &lt; a<sub>pj</sub><sup>pi</sup>成立。</p><h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h3><p>py + dp直接冲。<br><a id="more"></a> </p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">n, <span class="keyword">mod</span> = <span class="keyword">int</span>(<span class="built_in">input</span>()), <span class="keyword">int</span>(<span class="number">1000000007</span>)</span><br><span class="line"><span class="keyword">a</span> = <span class="keyword">list</span>(<span class="keyword">map</span>(<span class="keyword">int</span>, <span class="built_in">input</span>().<span class="keyword">split</span>()))</span><br><span class="line"><span class="keyword">dp</span> = [ <span class="number">1</span> <span class="keyword">for</span> i in <span class="built_in">range</span>(n) ]</span><br><span class="line"><span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="number">0</span>, n):</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">j</span> in <span class="built_in">range</span>(i):</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">a</span>[<span class="keyword">j</span>] ** (i + <span class="number">1</span>) &lt; <span class="keyword">a</span>[i] ** (<span class="keyword">j</span> + <span class="number">1</span>)):</span><br><span class="line">            <span class="keyword">dp</span>[i] += <span class="keyword">dp</span>[<span class="keyword">j</span>]</span><br><span class="line"><span class="keyword">print</span>(sum(<span class="keyword">dp</span>) % <span class="keyword">mod</span>)</span><br></pre></td></tr></table></figure><h3 id="solution2"><a href="#solution2" class="headerlink" title="solution2"></a>solution2</h3><p>变形公式。a[ i ]<sup>j</sup> &lt; a[ j ]<sup>i</sup> $\Leftrightarrow$ j $\times$ $log(a[i]) &lt; i * log(a[j])$，即原题等价于求上升子序列的数量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">ll res, dp[<span class="number">105</span>], a[<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    dp[i] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">      <span class="keyword">if</span> (j * <span class="built_in">log</span>(a[i]) &gt; i * <span class="built_in">log</span>(a[j])) dp[i] = (dp[i] + dp[j]) % mod;</span><br><span class="line">    res = (res + dp[i]) % mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计数dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：不同子序列个数</title>
      <link href="2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E4%B8%8D%E5%90%8C%E5%AD%90%E5%BA%8F%E5%88%97%E4%B8%AA%E6%95%B0.html"/>
      <url>2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E4%B8%8D%E5%90%8C%E5%AD%90%E5%BA%8F%E5%88%97%E4%B8%AA%E6%95%B0.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个长度为 $n$ 的字符串，求不同的子序列个数。</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>很经典的一道计数dp。我们用 $dp[i]$ 表示以前 $i$ 个字符中的不同子序列个数：<br><a id="more"></a> </p><p><strong>当 $s[i]$ 之前没有出现过：$dp[i] = dp[i - 1] * 2 + 1$ ，即前 $i - 1$ 个不同子序列个数 + 前 $i - 1$ 个不同子序列与当前的 $s[i]$ 结合 + 单独一个 $s[i]$ 成为字符串。</strong></p><p><strong>当 $s[i]$ 之前出现过：$dp[i] = dp[i - 1] * 2 - dp[上一次出现的位置 - 1]$ ，因为以该字符结尾的情况我们之前已经计算过一次，因此要减去上一次计算的结果，否则会产生重复计算。</strong></p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> n, vis[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; s + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[s[i]])</span><br><span class="line">      dp[i] = (dp[i - <span class="number">1</span>] * <span class="number">2</span> - dp[vis[s[i]] - <span class="number">1</span>] + mod) % mod;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      dp[i] = (dp[i - <span class="number">1</span>] * <span class="number">2</span> + <span class="number">1</span>) % mod;</span><br><span class="line">    vis[s[i]] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; dp[n] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计数dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：K-th Number</title>
      <link href="2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AK-th-Number.html"/>
      <url>2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AK-th-Number.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个长度为 $n$ 的数组 A ，把所有长度 &gt;= $k$ 的区间中的第 $k$ 大值插入 B 数组中，求 B 数组的第 $m$ 大数。</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>这种显然二分答案题我们主要关心 $check$ 问题。<br><a id="more"></a> </p><p>如何计算第 $k$ 大数 $&gt;= mid$ 的区间个数？</p><p>假设区间 $[l, r]$ 中刚好有 $k$ 个数 $&gt;= mid$，则 $[l, r…n]$ 区间全部满足第 $k$ 大数 $&gt;= mid$。</p><p>因此考虑尺取，若当前区间满足 $k$ 个数 $=mid$，则计数 $cnt += n - r + 1$，同时移动左边界；否则移动右边界直至。。。当 $cnt &gt;= m$ 时，说明 $mid$ 过小，调整左边界，否则调整右边界。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, n, k, a[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (r &lt;= n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt == k) &#123;</span><br><span class="line">      sum += (n - r + <span class="number">1L</span>L);</span><br><span class="line">      cnt -= (a[l++] &gt;= x);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      cnt += (a[++r] &gt;= x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum &gt;= m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">  <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">1e9</span> + <span class="number">7</span>, mid;</span><br><span class="line">    <span class="keyword">while</span> (l + <span class="number">1</span> &lt; r) &#123;</span><br><span class="line">      <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (check(mid))</span><br><span class="line">        l = mid;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：逆序对</title>
      <link href="2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E9%80%86%E5%BA%8F%E5%AF%B9.html"/>
      <url>2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E9%80%86%E5%BA%8F%E5%AF%B9.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>题意很简单，求长度为n的01串逆序对数量和。( n &lt;= 1e18 )</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>任意选两个位置 $i, j$ $(i &lt; j)$，令 $a[i] = 1, a[j] = 0$，这样一定能产生逆序对，这样有 $C_n^2$ 种选法。剩下的位置随便放，有$2^{n-2}$种选法，总方案数即为答案。( 注意 1 需要特判 )<br><a id="more"></a> </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qp</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (b == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  ll ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (b) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">    a = a * a % mod;</span><br><span class="line">    b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll n, res;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  res = (((n % mod) * ((n - <span class="number">1</span>) % mod) / <span class="number">2</span> % mod) * qp(<span class="number">2</span>, n - <span class="number">2</span>) % mod);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数间参数的传递方式</title>
      <link href="2020/04/%E5%87%BD%E6%95%B0%E9%97%B4%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F.html"/>
      <url>2020/04/%E5%87%BD%E6%95%B0%E9%97%B4%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F.html</url>
      
        <content type="html"><![CDATA[<h4 id="1-值传递：将主调函数的实参值传递给被调函数的形参，形参单独分配内存。"><a href="#1-值传递：将主调函数的实参值传递给被调函数的形参，形参单独分配内存。" class="headerlink" title="1. 值传递：将主调函数的实参值传递给被调函数的形参，形参单独分配内存。"></a>1. <strong>值传递</strong>：将主调函数的实参值传递给被调函数的形参，形参单独分配内存。</h4><p>  <strong>单向数据传递机制</strong>：传递的只是实参的值，形参的改变不影响实参。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="comment">//实现形参a、b的交换</span></span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    c = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">2</span>, y = <span class="number">3</span>;</span><br><span class="line">    swap(x, y);<span class="comment">//实参x,y的值并没有交换。值传递的单向数据传递机制</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x&lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt;y&lt;&lt; <span class="built_in">endl</span>;<span class="comment">//2 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-引用传递：被调用的形参引用主调函数的实参，实现间接访问。"><a href="#2-引用传递：被调用的形参引用主调函数的实参，实现间接访问。" class="headerlink" title="2. 引用传递：被调用的形参引用主调函数的实参，实现间接访问。"></a>2. <strong>引用传递</strong>：被调用的形参引用主调函数的实参，实现间接访问。</h4><p>  <strong>双向数据传递机制</strong>：通过引用&amp;，指向同一内存，其一改变，二者都改变。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span> <span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;<span class="comment">//引用变量a、b，等效int &amp;a=x;int &amp;b=y;</span></span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    c = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">2</span>, y = <span class="number">3</span>;</span><br><span class="line">    swap(x, y);<span class="comment">//实参x,y的值被交换。a与x，b与y指向同一内存，其一改变，两者都变</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x&lt;&lt; <span class="string">&quot;和&quot;</span>&lt;&lt;y&lt;&lt; <span class="built_in">endl</span>;<span class="comment">//3和2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：关于直接和间接访问：</p><p>按照C语言的方式，定义一个变量，系统会自动为该变量分配内存，变量有两个属性：变量值和变量地址。变量地址指示该变量在内存中的存储位置，变量值为该内存中的存储内容。</p><p><strong>直接访问</strong>：直接使用变量名访问内存空间上的内容。</p><p><strong>间接访问</strong>：先从其它内存空间获得要访问的内存地址（指针），根据地址访问对应内存中的数据。</p><h4 id="3-指针传递：被调函数的形参接收主调函数实参的内存地址，间接访问。"><a href="#3-指针传递：被调函数的形参接收主调函数实参的内存地址，间接访问。" class="headerlink" title="3. 指针传递：被调函数的形参接收主调函数实参的内存地址，间接访问。"></a>3. <strong>指针传递</strong>：被调函数的形参接收主调函数实参的内存地址，间接访问。</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span> <span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span> </span>&#123;<span class="comment">//引用变量a、b，等效int *a=&amp;x;int *b=&amp;y;</span></span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    c = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">2</span>, y = <span class="number">3</span>;</span><br><span class="line">    swap(&amp;x, &amp;y);<span class="comment">//实参x,y的值被交换。实参地址传递给指针类型的形参</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x&lt;&lt; <span class="string">&quot;和&quot;</span>&lt;&lt;y&lt;&lt; <span class="built_in">endl</span>;<span class="comment">//3和2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：Treepath</title>
      <link href="2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9ATreepath.html"/>
      <url>2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9ATreepath.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给定一棵n个节点的树，求偶数长度路径的数量。</p><h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1:"></a>Solution1:</h3><p>考虑树的深度对距离的影响，可以发现，深度奇偶性相同的点之间的距离总是偶数。<br><a id="more"></a> </p><p>证明：我们先将深度更大的点走到和另一个点深度相同，显然需要偶数步，然后两个点同时移动到最近公共节点，可知所用的步数是相同的，加起来也是偶数。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, idx, h[N], dep[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; E[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; E[idx].to = b, E[idx].next = h[a], h[a] = idx++; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">  dep[u] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i; i = E[i].next) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = E[i].to;</span><br><span class="line">    <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">    dfs(v, u);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    add(x, y);</span><br><span class="line">    add(y, x);</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> odd = <span class="number">0</span>, even = <span class="number">0</span>, res;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[i] &amp; <span class="number">1</span>)</span><br><span class="line">      odd++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      even++;</span><br><span class="line">  &#125;</span><br><span class="line">  res = odd * (odd - <span class="number">1</span>) / <span class="number">2</span> + even * (even - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="solution2"><a href="#solution2" class="headerlink" title="solution2:"></a>solution2:</h3><p>考虑树形dp。$dp[i][0/1]$ 表示从 i 出发，长度为偶数/奇数的路径数。</p><p>从子节点到父节点状态转移：</p><p>$dp[u][1] += dp[v][0]$</p><p>$dp[u][0] += dp[v][1]$</p><p>对于 $u$ 的每一个儿子 $v$，贡献即为 $dp[u][0] \times dp[v][1] + dp[u][1] \times dp[v][0]$, dfs回溯时进行合并更新即可。</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, idx, h[N];</span><br><span class="line">ll res, dp[N][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; E[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; E[idx].to = b, E[idx].next = h[a], h[a] = idx++; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">  dp[u][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i; i = E[i].next) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = E[i].to;</span><br><span class="line">    <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">    dfs(v, u);</span><br><span class="line">    res += dp[v][<span class="number">0</span>] * dp[u][<span class="number">1</span>];</span><br><span class="line">    res += dp[v][<span class="number">1</span>] * dp[u][<span class="number">0</span>];</span><br><span class="line">    dp[u][<span class="number">0</span>] += dp[v][<span class="number">1</span>];</span><br><span class="line">    dp[u][<span class="number">1</span>] += dp[v][<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    add(x, y);</span><br><span class="line">    add(y, x);</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>关于树上统计问题一直是个人较怕的题目（虽然经常出现但几乎每次都不会做 T_T），树上问题往往离不开dfs，需要考虑父子节点的转移，必要时可以考虑树形dp。</p>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：Accumulation Degree</title>
      <link href="2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AAccumulation-Degree.html"/>
      <url>2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AAccumulation-Degree.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一棵n个节点的树，边权值视作流量，找到一个源点使得从该点出发到所有叶子节点流量和最大。</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>我们先考虑这样一道题：指定一点使得到树上其他点的深度之和最小。<br><a id="more"></a> </p><h4 id="这显然是树的重心的性质：树中所有点到某个点的距离和中，到重心的距离和是最小的，如果有两个重心，他们的距离和一样。"><a href="#这显然是树的重心的性质：树中所有点到某个点的距离和中，到重心的距离和是最小的，如果有两个重心，他们的距离和一样。" class="headerlink" title="这显然是树的重心的性质：树中所有点到某个点的距离和中，到重心的距离和是最小的，如果有两个重心，他们的距离和一样。"></a>这显然是树的重心的性质：树中所有点到某个点的距离和中，到重心的距离和是最小的，如果有两个重心，他们的距离和一样。</h4><p>我们先假设这棵树的根为1，进行一次dfs，可以求出每个点的深度 $dep[i]$ 和子树大小 $size[i]$ ，设某点作为根深度之和为 $f$( i )，显然：$f(1)$ = $\sum_{i=1}^{n}{dep[i]}$。</p><p>当根从 $u$ 转移到子节点 $v$ 时，以 $v$ 为根的子树内所有节点 $dep$ 都减1，其余节点加1。从而得到状态转移方程：$f[v] = f[u] - size[v] + (n - size[v]) = f[u] + n - 2 * size[v]$，答案取最小值即可，时间复杂度 $O (n)$ 。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, res, idx, h[N], dep[N], <span class="built_in">size</span>[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; E[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; E[idx].to = b, E[idx].next = h[a], h[a] = idx++; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">size</span>[u] = <span class="number">1</span>;</span><br><span class="line">  dep[u] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i; i = E[i].next) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = E[i].to;</span><br><span class="line">    <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">    dfs1(v, u);</span><br><span class="line">    <span class="built_in">size</span>[u] += <span class="built_in">size</span>[v];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i; i = E[i].next) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = E[i].to;</span><br><span class="line">    <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">    f[v] = f[u] + n - <span class="number">2L</span>L * <span class="built_in">size</span>[v];</span><br><span class="line">    dfs2(v, u);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    add(x, y);</span><br><span class="line">    add(y, x);</span><br><span class="line">  &#125;</span><br><span class="line">  dep[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">  dfs1(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[<span class="number">1</span>] += dep[i];</span><br><span class="line">  dfs2(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0x3ffffffffffff</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; f[i]) &#123;</span><br><span class="line">      sum = f[i];</span><br><span class="line">      res = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在我们回过头来看这道题，可以发现思路都大同小异，只是转移方程发生了变化。</p><p>定义 $flow[i]表示以 i 为根的子树中流量的最大值$，那么，当节点从 $u$ 转移到 $v$ 时，我们可以得到：</p><ol><li>当 $v$ 为叶子结点，则 $flow[u] += flow[v]$ ；</li><li>当 $u$ 为非叶子结点，则 $flow[u] = min(flow[v], fl(u, v))$  $(fl(u, v) 即u, v两点间的流量限制)$ 。</li></ol><p>这样，根为1时的 $flow[1]$ 就求出来了。</p><p>接下来考虑根节点的转移：从以 $u$ 为根节点转移为以 $v$ 为根节点，对于根节点 $v$ 而言，唯一会产生影响的就是 $v$ 流向 $u$ 的路径，也就是对于换根后所有用到这条边的路径，都要加上这条流量的限制，则状态转移方程为：</p><ol><li>当 $u$ 为叶子节点时，$f[v] += fl(u, v)$ ;</li><li>当 $v$ 为非叶子结点时，$f[v] += min(fl(u, v), flow[u] - min(flow[v], fl(u, v)))$ 。</li></ol><p>进行两次dfs即可，时间复杂度 $O(n)$。</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, n, res, idx, h[N], d[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> to, w, next;</span><br><span class="line">&#125; E[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">  E[idx].to = b, E[idx].w = c, E[idx].next = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i; i = E[i].next) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = E[i].to, w = E[i].w;</span><br><span class="line">    <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">    dfs1(v, u);</span><br><span class="line">    <span class="keyword">if</span> (d[v] == <span class="number">1</span>)</span><br><span class="line">      f[u] += w;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      f[u] += <span class="built_in">min</span>(f[v], w);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i; i = E[i].next) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = E[i].to, w = E[i].w;</span><br><span class="line">    <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (d[u] == <span class="number">1</span>)</span><br><span class="line">      f[v] += w;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      f[v] += <span class="built_in">min</span>(w, f[u] - <span class="built_in">min</span>(f[v], w));</span><br><span class="line">    dfs2(v, u);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">  <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> x, y, z;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">      add(x, y, z);</span><br><span class="line">      add(y, x, z);</span><br><span class="line">      d[x]++;</span><br><span class="line">      d[y]++;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs1(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    dfs2(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于换根dp，一般有两个步骤：</p><ol><li>默认1为根进行dfs预处理；</li><li>从1开始，进行根的转移，计算贡献变化。</li></ol><p>对于dp而言，状态转移方程是最重要的，需要多思考，多刷题，才能累积经验，掌握要点。</p>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
