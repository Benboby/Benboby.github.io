<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>STL的两级空间配置器</title>
      <link href="2021/03/STL%E7%9A%84%E4%B8%A4%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8.html"/>
      <url>2021/03/STL%E7%9A%84%E4%B8%A4%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8.html</url>
      
        <content type="html"><![CDATA[<p>首先抛出一个问题：为什么需要二级配置器？<br>因为当我们动态分配内存的时候，分配的内存往往不仅仅是我们需要的那些，还会产生一些额外的开销，比如首尾的cookies，debug模式下产生的额外开销，和内存对齐所产生的pad。这些附加信息，降低了空间的利用率。</p><p>于是就设置了二级空间配置器，当开辟小等于128bytes内存时，就视为开辟小块内存，调用二级空间配置器。否则调用一级空间配置器。</p><h3 id="一级空间配置器"><a href="#一级空间配置器" class="headerlink" title="一级空间配置器"></a>一级空间配置器</h3><p>在一级空间配置器中，最重要的函数有：</p><ul><li>allocate：用于分配空间，申请失败，调用oom_alloc尝试重新申请</li><li>deallocate：用于释放空间</li><li>reallocate：调整已经存在的空间大小，如果调整失败，调用oom_alloc尝试重新申请</li></ul><p>其实对应的标准库函数就是malloc，free和realloc。</p><h3 id="二级空间配置器"><a href="#二级空间配置器" class="headerlink" title="二级空间配置器"></a>二级空间配置器</h3><ol><li>维护了16条单向链表，最小8字节，以8字节逐步递增到128字节。系统会自动根据你要分配的内存大小来向上对齐到符合的第一个链表。若不为空，则直接从对应链表中拔出，并且指针向后一位。</li><li>对应的free_list为空，先看其内存池是不是空时，如果内存池不为空：<ul><li>先检验它剩余空间是否够20个节点大小（即所需内存大小(提升后) * 20），若足够则直接从内存池中拿出20个节点大小空间，将其中一个分配给用户使用，另外19个当作自由链表中的区块挂在相应的free_list下，这样下次再有相同大小的内存需求时，可直接拨出。</li><li>如果不够20个节点大小，则看它是否能满足1个节点大小，如果够的话则直接拿出一个分配给用户，然后从剩余的空间中分配尽可能多的节点挂在相应的free_list中。</li><li>如果连一个节点内存都不能满足的话，则将内存池中剩余的空间挂在相应的free_list中（找到相应的free_list），然后再给内存池申请内存，转到3。</li></ul></li><li>内存池为空，申请内存<br> 此时二级空间配置器会使用malloc()从heap上申请内存，（一次所申请的内存大小为2 <em> 所需节点内存大小（提升后）</em> 20 + 一段额外空间），申请40块，一半拿来用，一半放内存池中。</li><li>malloc没有成功<br> 在第三种情况下，如果malloc()失败了，说明heap上没有足够空间分配给我们了，这时，二级空间配置器会从比所需节点空间大的free_list中一一搜索，从比它所需节点空间大的free_list中拔除一个节点来使用。如果这也没找到，说明比其大的free_list中都没有自由区块了，那就要调用一级适配器了。</li></ol><p>释放时调用deallocate()函数，若释放的n&gt;128，则调用一级空间配置器，否则就直接将内存块挂上自由链表的合适位置。</p><p>STL二级空间配置器虽然解决了外部碎片与提高了效率，但它同时增加了一些缺点：</p><ol><li><p>因为自由链表的管理问题，它会把我们需求的内存块自动提升为8的倍数，这时若你需要1个字节，它会给你8个字节，即浪费了7个字节，所以它又引入了内部碎片的问题，若相似情况出现很多次，就会造成很多内部碎片；</p></li><li><p>二级空间配置器是在堆上申请大块的狭义内存池，然后用自由链表管理，供现在使用，在程序执行过程中，它将申请的内存一块一块都挂在自由链表上，即不会还给操作系统，并且它的实现中所有成员全是静态的，所以它申请的所有内存只有在进程结束才会释放内存，还给操作系统，由此带来的问题有：1.即我不断的开辟小块内存，最后整个堆上的空间都被挂在自由链表上，若我想开辟大块内存就会失败；2.若自由链表上挂很多内存块没有被使用，当前进程又占着内存不释放，这时别的进程在堆上申请不到空间，也不可以使用当前进程的空闲内存，由此就会引发多种问题。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继承，虚函数和多态</title>
      <link href="2021/02/%E7%BB%A7%E6%89%BF-%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81.html"/>
      <url>2021/02/%E7%BB%A7%E6%89%BF-%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81.html</url>
      
        <content type="html"><![CDATA[<h2 id="继承-with-virtual-function"><a href="#继承-with-virtual-function" class="headerlink" title="继承 with virtual function"></a>继承 with virtual function</h2><p><strong>构造由内而外</strong>：首先调用父类的构造函数，然后再调用自己。<br><strong>析构由外而内</strong>：首先执行自己的析构函数，然后调用父类的析构函数。</p><p>non-virtual: 你不希望重新定义（重写）它。<br>virtual: 你希望子类重新定义它，且它有默认定义。<br>pure virtual: 你希望子类一定要重新定义它，你对它没有默认定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;   <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; msg)</span></span>;   <span class="comment">// 虚函数 </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">objectID</span><span class="params">()</span> <span class="keyword">const</span></span>;   <span class="comment">// 一般成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape &#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ellipse</span>:</span> <span class="keyword">public</span> Shape &#123;...&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a> <h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据所指对象的实际类型来调用相应的函数，如果对象类型是派生类，就调用派生类的函数，如果对象类型是基类，就调用基类的函数。</p><p>虚表：虚函数表的缩写，类中含有virtual关键字修饰的方法时，编译器会自动生成虚表</p><p>虚表指针：在含有虚函数的类实例化对象时，对象地址的前四个字节存储的指向虚表的指针</p><ul><li>编译器在发现基类中有虚函数时，会自动为每个含有虚函数的类生成一份虚表，该表是一个一维数组，虚表里保存了虚函数的入口地址</li><li>编译器会在每个对象的前四个字节中保存一个虚表指针，即vptr，指向对象所属类的虚表。在构造时，根据对象的类型去初始化虚指针vptr，从而让vptr指向正确的虚表，从而在调用虚函数时，能找到正确的函数</li><li>在派生类定义对象时，程序运行会自动调用构造函数，在构造函数中创建虚表并对虚表初始化。在构造子类对象时，会先调用父类的构造函数，此时，编译器只“看到了”父类，并为父类对象初始化虚表指针，令它指向父类的虚表；当调用子类的构造函数时，为子类对象初始化虚表指针，令它指向子类的虚表</li><li>当派生类对基类的虚函数没有重写时，派生类的虚表指针指向的是基类的虚表；当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表；当派生类中有自己的虚函数时，在自己的虚表中将此虚函数地址添加在后面</li></ul><h3 id="基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间"><a href="#基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间" class="headerlink" title="基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间"></a>基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间</h3><p>首先整理一下虚函数表的特征：</p><ul><li>虚函数表是全局共享的元素，即全局仅有一个，在编译时就构造完成</li><li>虚函数表类似一个数组，类对象中存储vptr指针，指向虚函数表，即虚函数表不是函数，不是程序代码，不可能存储在代码段</li><li>虚函数表存储虚函数的地址,即虚函数表的元素是指向类成员函数的指针,而类中虚函数的个数在编译时期可以确定，即虚函数表的大小可以确定,即大小是在编译时期确定的，不必动态分配内存空间存储虚函数表，所以不在堆中</li></ul><p>根据以上特征，虚函数表类似于类中静态成员变量。静态成员变量也是全局共享，大小确定，因此最有可能存在全局数据区。</p><p>由于虚表指针vptr跟虚函数密不可分，对于有虚函数或者继承于拥有虚函数的基类，对该类进行实例化时，在构造函数执行时会对虚表指针进行初始化，当一个构造函数被调用时，它做的首要的事情之中的一个是初始化它的VPTR，并且存在对象内存布局的最前面。</p><h3 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h3><p><a href="https://blog.csdn.net/qq_17368865/article/details/79108084">单继承与多重继承下的虚函数表</a></p><p>总结来说：</p><ul><li>一般继承无虚函数覆盖：父类虚函数在前，子类在后。</li><li>一般继承有虚函数覆盖：子类虚函数直接覆盖父类虚函数被重写的虚函数，其余不变。</li><li>多重继承无虚函数覆盖：每个父类都有自己的虚表，子类虚函数被放到第一个父类的虚函数表中。</li><li>多重继承无虚函数覆盖：子类虚函数覆盖所有父类虚函数表被重写的函数，其余不变。</li></ul><h3 id="补充：inline内联函数"><a href="#补充：inline内联函数" class="headerlink" title="补充：inline内联函数"></a>补充：inline内联函数</h3><p>内联函数和普通函数的区别在于：当编译器处理调用内联函数的语句时，不会将该语句编译成函数调用的指令，而是直接将整个函数体的代码插人调用语句处，就像整个函数体在调用处被重写了一遍一样。相比之下，普通函数能够避免将相同代码重写多次的麻烦，还能减少可执行程序的体积，但也会带来程序运行时间上的开销；而内联函数省去了调用函数的时间开销。</p><p><strong>在函数调用执行过程中，首先要为在栈中的形参和局部变量分配存储空间，然后再将实参的值复制给形参，然后还要将函数的返回地址放入栈中，最后才跳转到函数内部执行。return语句返回时，还要从栈中回收形参和局部变量占有的存储空间，然后从栈中取出返回地址，跳转到该地址继续执行。</strong></p><p>如果内联函数执行的时间很长，那函数调用的时间相比起来就微不足道，使用内联函数也就没有意义了。从另一方面来说，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。因此，内联函数中的代码应该是很简单，执行起来很快的一些语句。</p><p>Google C++编码规范对于inline的使用说明：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">内联函数：</span><br><span class="line">Tip： 只有当函数只有 <span class="number">10</span> 行甚至更少时才将其定义为内联函数.</span><br><span class="line"></span><br><span class="line">定义: 当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用.</span><br><span class="line"></span><br><span class="line">优点: 当函数体比较小的时候, 内联该函数可以令目标代码更加高效. 对于存取函数以及其它函数体比较短, 性能关键的函数, 鼓励使用内联.</span><br><span class="line"></span><br><span class="line">缺点: 滥用内联将导致程序变慢. 内联可能使目标代码量或增或减, 这取决于内联函数的大小. 内联非常短小的存取函数通常会减少代码大小, 但内联一个相当大的函数将戏剧性的增加代码大小. 现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快。</span><br><span class="line"></span><br><span class="line">结论: 一个较为合理的经验准则是, 不要内联超过 <span class="number">10</span> 行的函数. 谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!</span><br><span class="line"></span><br><span class="line">另一个实用的经验准则: 内联那些包含循环或 <span class="keyword">switch</span> 语句的函数常常是得不偿失 (除非在大多数情况下, 这些循环或 <span class="keyword">switch</span> 语句从不被执行).</span><br><span class="line"></span><br><span class="line">有些函数即使声明为内联的也不一定会被编译器内联, 这点很重要; 比如虚函数和递归函数就不会被正常内联. 通常, 递归函数不应该声明成内联函数.(递归调用堆栈的展开并不像循环那么简单, 比如递归层数在编译时可能是未知的, 大多数编译器都不支持内联递归函数). 虚函数内联的主要原因则是想把它的函数体放在类定义内, 为了图个方便, 抑或是当作文档描述其行为, 比如精短的存取函数.</span><br></pre></td></tr></table></figure><br>PS：内联函数和宏定义的区别：</p><ul><li><strong>内联函数在编译时展开，宏在预编译时展开</strong></li><li>内联函数直接嵌入到目标代码中，宏是简单的做文本替换</li><li><strong>内联函数有类型检测、语法判断等功能，而宏没有</strong></li><li>内联函数是函数，宏不是</li><li>宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义</li><li>内联函数代码是被放到符号表中，使用时像宏一样展开，没有调用的开销，效率很高</li></ul><h3 id="构造函数、析构函数、虚函数可否声明为内联函数"><a href="#构造函数、析构函数、虚函数可否声明为内联函数" class="headerlink" title="构造函数、析构函数、虚函数可否声明为内联函数"></a>构造函数、析构函数、虚函数可否声明为内联函数</h3><p>将这些函数声明为内联函数，在语法上没有错误。因为inline同register一样，只是个建议，编译器并不一定真正的内联。</p><ul><li>register关键字：这个关键字请求编译器尽可能的将变量存在CPU内部寄存器中，而不是通过内存寻址访问，以提高效率</li></ul><p>首先在《Effective C++》中明确阐述：<strong>将构造函数和析构函数声明为inline是没有什么意义的</strong>，即编译器并不真正对声明为inline的构造和析构函数进行内联操作，因为<strong>编译器会在构造和析构函数中添加额外的操作（申请/释放内存，构造/析构对象等）</strong>，致使构造函数/析构函数并不像看上去的那么精简。其次，class中的函数默认是inline型的，编译器也只是有选择性的inline，将构造函数和析构函数声明为内联函数是没有什么意义的。</p><p>虚函数是通过指针或引用调用函数时，通过虚函数表来确定调用的函数，在运行时确定。内联函数是在编译时，将调用函数处插入内联函数的代码，省去了函数调用时的开销。</p><h3 id="构造函数与虚函数"><a href="#构造函数与虚函数" class="headerlink" title="构造函数与虚函数"></a>构造函数与虚函数</h3><p>构造函数不可以是虚函数。</p><ol><li>从vptr角度解释：虚函数对应一个vtable，可是这个vtable其实是存储在对象的内存空间的。 那么问题来了，如果构造函数是虚函数，就要通过vtable来调用，可是对象空间还没有实例化，也就是内存空间还没有，无法找到vtable，所以构造函数不能是虚函数。</li><li>从使用角度：虚函数主要用于在信息不全的情况下，能够使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义。 </li></ol><h3 id="析构函数与虚函数"><a href="#析构函数与虚函数" class="headerlink" title="析构函数与虚函数"></a>析构函数与虚函数</h3><p>在派生类中的析构函数常常为虚析构函数，是为了避免内存泄露。</p><p>如果不考虑虚函数的状况，给出一个基类和派生类，如果调用派生类的析构函数时，肯定会引发调用基类的析构函数，这和析构函数是不是虚函数没关系。如：[ Derive* p = new Derive(); ]</p><p>现在考虑虚函数的问题，由于使用虚函数使我们可以定义一个基类指针或引用可以直接对派生类进行操作，如：[ Base* p = new Derive(); ]，这就存在两种情况：</p><p>如果，不把基类的析构函数设置为虚函数，则在删除对象时，如果直接删除基类指针，系统就只能调用基类析构函数，而不会调用派生类构造函数。这就会导致内存泄露。</p><p>如果，把基类的析构函数设置为虚函数，则在删除对象时，直接删除基类指针，系统会调用派生类析构函数，之后此派生类析构函数会引发系统自动调用自己的基类，这就不会导致内存泄露。</p><p>所以，在写一个类时，尽量将其析构函数设置为虚函数，但析构函数默认不是虚函数。</p><p>[问] 应该把所有的类的析构函数都设置为虚函数吗？<br>[答] 不一定。使用虚函数后的类对象要比不使用虚函数的类对象占的空间多，而且在查找具体使用哪一个虚函数时，还会有时间代价。即当一个类不打算作为基类时，不用将其中的函数设置为虚函数。</p><h3 id="在构造函数和析构函数中调用虚函数"><a href="#在构造函数和析构函数中调用虚函数" class="headerlink" title="在构造函数和析构函数中调用虚函数"></a>在构造函数和析构函数中调用虚函数</h3><p>语法上没有问题，但是体现不出多态性。<br>当实例化一个子类对象时，会先调用父类构造函数，此时子类对象还没有被完全创建，被当成一个父类对象，调用的是父类的虚函数。<br>同理，析构是先析构子类，然后析构父类，若父类调用析构函数，子类已经被析构了，只能调用父类自己的虚函数。</p><h3 id="构造函数和析构函数可以调用虚函数吗，为什么"><a href="#构造函数和析构函数可以调用虚函数吗，为什么" class="headerlink" title="构造函数和析构函数可以调用虚函数吗，为什么"></a>构造函数和析构函数可以调用虚函数吗，为什么</h3><p>不提倡在构造函数和析构函数中调用虚函数。</p><ul><li>因为父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全的，故而C++不会进行动态联编</li><li>析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义。</li></ul><h3 id="动态绑定和静态绑定"><a href="#动态绑定和静态绑定" class="headerlink" title="动态绑定和静态绑定"></a>动态绑定和静态绑定</h3><p>为了支持c++的多态性，才用了动态绑定和静态绑定。</p><ul><li>对象的静态类型：<strong>对象在声明时采用的类型。是在编译期确定的。</strong></li><li>对象的动态类型：<strong>目前所指对象的类型，是在运行期决定的。</strong>对象的动态类型可以更改，但是静态类型无法更改。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span>&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B &#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B &#123;&#125;</span><br><span class="line">D* pD = <span class="keyword">new</span> D();<span class="comment">//pD的静态类型是它声明的类型D*，动态类型也是D*</span></span><br><span class="line">B* pB = pD;<span class="comment">//pB的静态类型是它声明的类型B*，动态类型是pB所指向的对象pD的类型D*</span></span><br><span class="line">C* pC = <span class="keyword">new</span> C();</span><br><span class="line">pB = pC;<span class="comment">//pB的动态类型是可以更改的，现在它的动态类型是C*</span></span><br></pre></td></tr></table></figure><ul><li>静态绑定：绑定的是对象的静态类型，某特性（比如函数）依赖于对象的静态类型，发生在编译期。</li><li>动态绑定：绑定的是对象的动态类型，某特性（比如函数）依赖于对象的动态类型，发生在运行期。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfun</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">()</span></span>;<span class="comment">//首先说明一下，这个子类重新定义了父类的no-virtual函数，这是一个不好的设计，会导致名称遮掩；这里只是为了说明动态绑定和静态绑定才这样使用。</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfun</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfun</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">D* pD = <span class="keyword">new</span> D();</span><br><span class="line">B* pB = pD;</span><br></pre></td></tr></table></figure><p>pD-&gt;DoSomething() 和 pB-&gt;DoSomething() 是no-virtual函数，它是静态绑定的，也就是编译器会在编译期根据对象的静态类型来选择函数。</p><p>pD-&gt;vfun()和pB-&gt;vfun() 是一个虚函数，它动态绑定的，也就是说它绑定的是对象的动态类型，pB和pD虽然静态类型不同，但是他们同时指向一个对象，他们的动态类型是相同的，都是D*，所以，他们的调用的是同一个函数：D::vfun()。</p><p>需要特别注意：虚函数的缺省参数是静态绑定的！！！</p><p>总结：可以认为只有虚函数才使用的是动态绑定，其他的全部是静态绑定。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：最多可以参加的会议数目II</title>
      <link href="2021/02/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%A4%9A%E5%8F%AF%E4%BB%A5%E5%8F%82%E5%8A%A0%E7%9A%84%E4%BC%9A%E8%AE%AE%E6%95%B0%E7%9B%AEII.html"/>
      <url>2021/02/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%A4%9A%E5%8F%AF%E4%BB%A5%E5%8F%82%E5%8A%A0%E7%9A%84%E4%BC%9A%E8%AE%AE%E6%95%B0%E7%9B%AEII.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你一个 $a$ 数组，其中 $a[i] = [startDay_i, endDay_i, value_i]$ ，表示第 $i$ 个会议在 $startDay_i$ 天开始，第 $endDay_i$ 天结束，如果你参加这个会议，你能得到价值 $value_i$ 。同时给你一个整数 $k$ 表示你能参加的最多会议数目。</p><p>你同一时间只能参加一个会议。如果你选择参加某个会议，那么你必须 <strong>完整</strong> 地参加完这个会议。会议结束日期是包含在会议内的，也就是说你不能同时参加一个开始日期与另一个结束日期相同的两个会议。</p><p>请你返回能得到的会议价值 <strong>最大和</strong>。$(k \in [1, n], k * n \in [1, 1e6], startDay_i, endDay_i \in [1, 1e9], value_i \in[1, 1e6])$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><a id="more"></a><p>考虑动态规划。$dp[i][j]$ 表示前 $i$ 个会议刚好选 $j$ 个时，能获得的最大价值。</p><p>那么对于每个 $dp[i][j]$ 有两种情况：</p><ul><li>不参加第 $i$ 个会议，有 $dp[i][j] = dp[i - 1][j]$</li><li>参加第 $i$ 个会议，设第 $i$ 个会议开始时间为 $l$，那么我们应该是从 <strong>所有结束时间小于 $l$ 且刚好选 $j - 1$ 个会议</strong> 的那个状态转移过来。那么最好的方式就是一开始就将 $a$ 按结束时间排序，这样我们就能很快二分出来结束时间刚好（最后一个）小于 $l$ 的那个会议 $p$，有 $dp[i][j] = max(dp[i][j], dp[p][j - 1] + a[i].value)$。</li></ul><p>时间复杂度 $O(nklog_n)$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> l, r, w;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Node&amp; a) <span class="keyword">const</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> r &lt; a.r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; a, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;Node&gt; <span class="title">q</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (k + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) q[i + <span class="number">1</span>] = &#123;a[i][<span class="number">0</span>], a[i][<span class="number">1</span>], a[i][<span class="number">2</span>]&#125;;</span><br><span class="line">        sort(q + <span class="number">1</span>, q + n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>, r = i, mid;</span><br><span class="line">            <span class="keyword">while</span> (l + <span class="number">1</span> &lt; r) &#123;</span><br><span class="line">                mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (q[mid].r &lt; q[i].l) l = mid;</span><br><span class="line">                <span class="keyword">else</span> r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++) </span><br><span class="line">                dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[l][j - <span class="number">1</span>] + q[i].w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：滑动窗口中位数</title>
      <link href="2021/02/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%AD%E4%BD%8D%E6%95%B0.html"/>
      <url>2021/02/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%AD%E4%BD%8D%E6%95%B0.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你一个数组 nums，有一个长度为 k 的窗口从最左端滑动到最右端。窗口中有 k 个数，每次窗口向右移动 1 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。$(n, k \in [1, 100000])$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>用优先队列+延迟删除有点麻烦，可以考虑直接用 <strong>multiset</strong> 做，本质都是一样的，维护两个大小相同或差一的集合（自动排序）$l 和 r$，$l$ 维护小于等于中位数的值，$r$ 维护大于等于中位数的值，$multiset$ 的优秀特性可以在 $log$ 时间复杂度内进行增删操作。具体细节较多，时间复杂度 $O(nlog(k))$。</p><a id="more"></a><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">medianSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">double</span>&gt; l, r;</span><br><span class="line">        <span class="keyword">int</span> n = a.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k) &#123;           <span class="comment">// 需要移除之前已经加入滑动窗口的元素</span></span><br><span class="line">                <span class="keyword">if</span> (l.count(a[i - k])) l.erase(l.find(a[i - k]));</span><br><span class="line">                <span class="keyword">else</span> r.erase(r.find(a[i - k]));</span><br><span class="line">            &#125;</span><br><span class="line">            l.insert((<span class="keyword">double</span>)a[i]);</span><br><span class="line">            <span class="keyword">while</span> (l.size() &amp;&amp; r.size() &amp;&amp; *(--l.end()) &gt; *r.begin()) &#123;   <span class="comment">// 左集合的元素不可能大于右集合</span></span><br><span class="line">                l.insert(*r.begin());</span><br><span class="line">                r.insert(*(--l.end()));</span><br><span class="line">                l.erase(*(--l.end()));</span><br><span class="line">                r.erase(*r.begin());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (l.size() - <span class="number">1</span> &gt; r.size()) &#123;            <span class="comment">// 左集合元素最多只会比右集合多一（窗口大小为奇数）</span></span><br><span class="line">                r.insert(*(--l.end()));</span><br><span class="line">                l.erase(--l.end());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;         </span><br><span class="line">                <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res.push_back(*(--l.end()));</span><br><span class="line">                <span class="keyword">else</span> res.push_back((*(--l.end()) + *r.begin()) / <span class="number">2.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LinuxC++网络编程学习笔记</title>
      <link href="2021/02/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
      <url>2021/02/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
      
        <content type="html"><![CDATA[<h2 id="主机字节序和网络字节序"><a href="#主机字节序和网络字节序" class="headerlink" title="主机字节序和网络字节序"></a>主机字节序和网络字节序</h2><p>字节在内存中的排列影响它实际的值，字节序分为<strong>大端序</strong>和<strong>小端序</strong>。大端序指一个整数的高位存储在内存的低地址处，小端序指一个整数的高位存储在内存的高地址处。</p><p>现代PC大多采用小端序，因此小端序又被称为<strong>主机字节序</strong>。</p><p>由于数据在两台使用不同字节序的主机之间进行传递是，接收到必然错误的解释了数据。解决的方法是：发送端总是把要发送的数据转化成大端序然后再发送，接受端明白对方传过来的数据总是采用大端序，所以接受端可以根据自身使用的字节序来决定是否对该数据进行转化。因此大端序也称为<strong>网络字节序</strong>。</p><a id="more"></a><p>Linux提供了四个函数来完成主机字节序和网络字节序之间的转化：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="comment">// 一般用于转换ip地址</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">htonl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> hostlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">ntonl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> netlong)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般用于转换端口</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">htons</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> hostshort)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> netshort)</span></span>;</span><br></pre></td></tr></table></figure><br>判断大小端：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">w</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">&#125;c;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   c.a = <span class="number">0x1234567</span>;</span><br><span class="line">   <span class="keyword">return</span> c.b == <span class="number">1</span>; <span class="comment">// 是否小端</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>解释一下原理：union联合体是共享内存的，c.a = 1 即最低位为1，其它都为0，小端模式低字节放在低地址中，所以b会被赋值为1。</p><h2 id="socket套接字"><a href="#socket套接字" class="headerlink" title="socket套接字"></a>socket套接字</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, ubt protocol)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>domain: PF_INET -&gt; IPv4, PF_INET6 -&gt; IPv6, PF_UNIX -&gt; UNIX本地协议族</li><li>type: SOCK_STREAM -&gt; TCP协议，SOCK_DGRAM -&gt; UDP协议</li><li>protocol: 一般都置位0，表示使用默认协议</li></ul><p>调用成功返回一个socket文件描述符，其实就是一个数字，这个数字具有唯一性，并且一直有效直到你close()这个数字为止；失败返回-1并设置errno。</p><p>文件描述符：unix哲学——一切皆文件，我们把socket也看成是文件描述符，用它来收发数据。send(), recv()。</p><p>一旦连接成功建立，双方的通讯就只需要通过该文件描述符即可。</p><h2 id="命名socket"><a href="#命名socket" class="headerlink" title="命名socket"></a>命名socket</h2><p>创建socket时，指定了地址族，却并未指定该地址族中的哪个具体socket地址。我们称socket与socket地址绑定称为给socket命名。服务端只有命名后，客户端才知道如何连接它。客户端通常不需要命名，采用匿名，操作系统会自动分配给它socket地址。使用的函数为bind()：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct* my_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>sockfd: socket文件描述符</li><li>my_addr: 这个地址将分配给未命名的sockfd文件描述符</li><li>addrlen: 该socket地址的长度</li></ul><p>相同的ip地址的相同端口只能被 bind() 一次，bind成功返回0，失败返回-1并设置errno。</p><p>关于bind绑定失败的情况，还需要详谈。。。</p><h2 id="监听socket"><a href="#监听socket" class="headerlink" title="监听socket"></a>监听socket</h2><p>socket被命名后，还不能被马上接受客户连接，我们需要创建一个监听队列用以存放待处理的客户连接：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure><br>listen 用于监听端口，作用于TCP连接中的服务端。</p><p>对于一个调用listen()进行监听的套接字，操作系统会给这个套接字维护两个队列：</p><ul><li>未完成队列：当服务端收到客户端第一次握手发送的SYN包时（SYN_SENT状态），就会在未完成队列中创建一个跟该 SYN 包对应的一项新的套接字（通常由(服务器ip + port, 客户端ip +port)组成）</li><li>已完成队列：三次握手完成后，连接变为ESTABISHED状态，从未完成队列进入已完成队列</li></ul><p>backlog的含义：已完成队列和未完成队列条目之和不能超过backlog。<br>RTT：未完成队列中任意一项在未完成队列中停留的时间，这个时间取决于客户端和服务器。对于客户端，RTT为前两次握手时间；对于服务端，RTT为后两次握手时间。</p><p>客户端的Connect()其实在第二次握手结束后已经返回了。</p><p>细节：</p><ol><li>如果两个队列之和已经达到最大上限，再有客户发送syn请求的话，这个请求会被服务器忽略；而客户端发现syn没有被回应，会重发请求包。</li><li>已完成队列中有客户端发来数据，但该套接字还未被accept函数取出，那么这个数据就会被保存在已连接的套接字的接收缓冲区中，接收的数据量取决于缓冲区有多大。</li></ol><h2 id="接受连接"><a href="#接受连接" class="headerlink" title="接受连接"></a>接受连接</h2><p>accept() 函数，从已完成连接队列中的队首取出一项（已经完成三次握手连接的客户端socket值），返回给进程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>sockfd 是执行过 listen 系统监听调用的 <strong>监听socket</strong>，只要服务端还在运行，那么它就应该一直存在（我们称已经处于ESTABISHED状态的客户端连接为 <strong>连接socket</strong>）</li><li>addr 被用于接收远端 socket 地址，该地址的长度由addrlen指出</li></ul><p>如果已完成队列为空，那么则会一直处于休眠等待状态，直到有内容时才唤醒。<br>accept返回的是对应TCP连接的套接字connfd。</p><p>如果建立连接后用户掉线，accept依然返回成功，因为它只负责从已完成队列中取出内容。</p><h2 id="发起连接"><a href="#发起连接" class="headerlink" title="发起连接"></a>发起连接</h2><p>客户端需要使用connect函数主动与服务器建立连接：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *serv_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><br>sockfd参数由socket系统调用返回一个socket，serv_addr参数是服务器监听的socket地址，addrlen则指定这个地址的长度。</p><p>connect成功时返回0。一旦成功建立连接，sockfd就唯一标识这个连接，客户端就可以通过读写sockfd来与服务器通信。失败返回-1并设置errno，常见的错误有：目的端口不存在，连接超时。</p><h2 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h2><p>关闭连接实际上就是关闭该连接对应的socket：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure><br>fd是待关闭的socket，close并非总是立即关闭一个连接，而是将fd的引用计数减一。当引用计数为0时，才最终关闭连接。<br>在多进程中，一次fork会使父进程中打开的socket引用计数加一，因此必须在父进程和子进程中都对该socket执行close才能将连接关闭。</p><h2 id="IO操作"><a href="#IO操作" class="headerlink" title="IO操作"></a>IO操作</h2><p>分为两个阶段：数据准备阶段，内核空间复制会用户进程缓冲区阶段。</p><p>在Unix中，一切皆文件，文件即是一串二进制流，不论是socket，FIFO，管道，终端，都是文件，对这些流进行数据收发操作即是IO操作。系统调用 read 读入数据，调用 write 写入数据。我们如何知道操作哪个流？文件描述符，即fd，而fd就是一个整数，对这个整数操作即是对文件操作。创建一个socket，返回一个文件描述符，对socket操作即是对这个描述符操作。</p><h2 id="阻塞-非阻塞"><a href="#阻塞-非阻塞" class="headerlink" title="阻塞/非阻塞"></a>阻塞/非阻塞</h2><p>阻塞IO：调用某个函数，该函数卡在这里（进入休眠状态）等待一个事情发生，然后才继续执行，这种函数一般称为阻塞函数。<br>非阻塞IO：充分利用时间片，效率更高。不断的调用accept，recvfrom函数检查有没有数据到来。</p><h2 id="同步-异步"><a href="#同步-异步" class="headerlink" title="同步/异步"></a>同步/异步</h2><p><strong>异步IO：</strong>调用一个异步I/O函数，我们要给这个函数指定一个接收缓冲区和一个回调函数。调用后，该函数会立即返回。其余判断交给操作系统，判断数据是否到来，如果到来，操作系统会把数据拷贝到你所指定的缓冲区里，然后调用回调函数通知你。</p><p><strong>异步和非阻塞的区别：</strong></p><ul><li>非阻塞I/O需要不停调用I/O函数来检查数据是否到来，一旦数据到来，就必须卡在I/O函数里把内核缓冲区复制到用户缓冲区，然后才执行结束</li><li>异步I/O只需要调用一次，然后你就可以去做别的事了，内核去帮你判断数据是否到来，最后通知你</li></ul><p><strong>同步I/O：</strong><br>select，poll，epoll都可以认为属于同步IO。</p><ul><li>首先调用select函数判断有无数据到来，没有则卡在那里</li><li>select返回之后，调用recvfrom去取数据，取数据时也会卡一下</li></ul><p>同步I/O看起来更麻烦一点，因为要调用两个函数才可以得到数据。但与阻塞式相比，优势在于I/O复用。</p><p><strong>I/O复用：</strong><br>又称为I/O多路复用，将多个socket（TCP连接）弄成一堆，select/poll/epoll等待这一堆的任何一个TCP连接有数据到来，再用具体的recvfrom去收。</p><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, struct timeval* timeout)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>nfds 指定被监听文件描述符总数，通常设置为select监听的所有文件描述符中的最大值加1，因为文件描述符是从0开始计数的。</li></ul><ol><li>创建所关注的事件描述符集合。分为三大类事件描述符集合（读事件、写事件、异常发生事件）</li><li>等待事件发生，轮询这三个事件描述符集合里的每一个事件描述符，检查是否有相应的事件发生，如果有就执行。</li></ol><h2 id="epoll技术"><a href="#epoll技术" class="headerlink" title="epoll技术"></a>epoll技术</h2><p>从Linux内核2.6开始引入，是一种典型的I/O多路复用技术，最大的特点就是支持高并发，完全没有会随着并发量提高而出现性能明显下降的情况，但是会造成一定内存消耗。</p><p>与select，poll不同的是，它使用一组函数来完成任务。epoll 把用户关心的文件描述符上的事件放在内核的一个事件表中，无需每次调用都要重复传入描述符，因此epoll需要一个额外的文件描述符，来唯一标示内核中的这个事件表，<strong>使用 epoll_create 来创建该文件描述符：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span>: </span></span><br></pre></td></tr></table></figure><br>size参数只是告诉内核事件表需要多大，还并不起作用。返回的文件描述符讲称为其它所有epoll系统调用函数的第一个参数，以指定要访问的内核事件表。</p><p>具体：创建一个eventpoll结构体对象，创建了一棵红黑树和一个双向链表，其中rbr指向该红黑树的根，rdlist指向该双向链表的头节点</p><p><strong>使用 epoll_ctl 来操作内核事件表：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br></pre></td></tr></table></figure><br>event 指定事件信息，fd为要操作的文件描述符(accept得到)，op指定操作类型：</p><ul><li>ADD，往事件表中注册fd上的事件，相当于向红黑树添加一个节点，key值为客户端连接产生的fd，如果已经存在该节点，则直接报错</li><li>MOD，修改fd上的注册事件，修改某个节点</li><li>DEL，删除fd上的注册事件，删除某个节点</li></ul><p>因此，红黑树上的节点来自于 epoll_ctl 操作。</p><p><strong>当事件发生时，我们需要通过 epoll_wait 函数来得到操作系统的通知。</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event* events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><br>双向链表中存放的是所有有事件/数据的请求，epoll_wait 遍历双向链表，把双向链表里面的数据拷贝出去，然后移除。</p><p>需要注意的是，在红黑树中的节点并不会被删除。实际上用的是一个结构体同时维护了红黑树和双向链表的节点内容：红黑树拥有指向父节点，子节点的指针，双向链表拥有指向上一个和下一个结点的指针。这种优秀的设计使得在删除双向链表的结点时并不会对红黑树产生影响，而是相互独立的，但维护的时候又可以一起维护，使得一个节点既可以作为红黑树节点，也可以作为双向链表节点，从而大大减少了内存浪费。</p><ul><li>epfd 为 epoll_create 返回的对象描述符</li><li>events指向一个数组，最大长度为 maxevents，表示此次 epoll_wait 调用最多可以收集到 maxevents 个（双向链表中）已经准备好的读写事件。</li></ul><p>什么时候内核会向双向链表中增加节点呢？</p><ul><li>客户端完成三次握手 ——&gt;  服务器需要accept()</li><li>当客户端关闭连接  ——&gt;  服务器也要调用close()关闭</li><li>客户端发送数据来  ——&gt;  服务器需要调用read(),recv()函数来收数据</li><li>当可以发送数据时  ——&gt;  服务器调用send(),write()</li></ul><h2 id="LT-和-ET-模式"><a href="#LT-和-ET-模式" class="headerlink" title="LT 和 ET 模式"></a>LT 和 ET 模式</h2><p>epoll对文件描述符的操作有两种模式：<br>LT：水平触发，低速效率较低，默认模式，如果这个事件没有被处理完，就会被一直触发<br>ET：边沿触发，高速模式，效率高，只会被触发一次，但代价是编码难度加大</p><p>为什么ET模式事件只触发一次：ET模式事件只会被扔到双向链表一次，被 epoll_wait 取出后销毁。</p><p>为什么LT模式事件会触发多次：如果事件没有处理完，就会被多次扔进双向链表。</p><p>如果收发数据包没有具体格式，可以考虑用ET模式。</p><h2 id="TCP粘包"><a href="#TCP粘包" class="headerlink" title="TCP粘包"></a>TCP粘包</h2><p>客户端粘包：短时间内多次send，客户端有 Nagle 优化算法，直接合并成一个数据包发送出去，导致粘包。因此只要关闭 Nagle 算法，就能解决客户端粘包问题。</p><p>服务端粘包：无论客户端是否粘包，都避免不了服务端都会粘包。两次recv之间需要时间，但如果这个时间内多个包来了，则这多个包可能就被第二次recv全部收走，导致一次recv就收走了所有的包。</p><p><strong>解决粘包：</strong>把几个包一个一个拆出来，能拆一个是一个。<br>如何拆包？每一个收发的数据包都遵循包头+包体的格式，包头固定【10个字节】，其中有一个变量记录整个包【包头+包体】的长度。这样就知道了包体的长度，然后只收包体长度一样多的字节即可。这样就收到一个完整的数据包。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++语言基础</title>
      <link href="2021/01/C-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80.html"/>
      <url>2021/01/C-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="8355609795abf1e7b3a9dccea69391a80fa0928102df26e9c72c90758c19ab1f">88bfb973b5cd9a98289a5356073cb3e5594eb6ba137f50990b97deaa4f5157d63b171c88bd8e655090bc624df133b36ad9ad15e6810d106478bb206225a36c29bfffb124dc929dd0ca845e6ea57c1b6fe3b0cdf008f493989f4e85f69039b4a76c813ea12d04da9083127b52d23b3934aeeb03916df2878df84aa2480192523104803e4233b227fd3daa2ca063aeeace21258fa2e88c5cc1ed87a70450efdb07fdbea4026761ff928b132912e683e916dcc48fe77ead40e3e2c6eb37177e4a43a3739cb119e0dbb167744a7e029f30b7660ed893d14d032591d784e3e9af44201d45e3a430b4bc18f645cceacef51bf1288cfc02527af7e0f6bb304a669b31e5043834ea7f01a0abf0aba54da55c1861a66a1d2bd94776adbb463ead133ffe0acc243e9864158980692f22bd2b9baad06cc26b764e676286dd248669a109affec45b7614eb1cd74e324e0cc488557a9264a1e852a9c9fcd6b1a88f574a7e1ea506176abfd35bb5287bd459a5fec6ee879cfd9c93e0e24182717e650262f5d5fb7b756ff9c9da524b2a6b4958f696a6036793becd7c20fa0b939704f74daa9c549516654070aff8de7c90a7f0b0aa960ad4646c88766a76bb782cf88737a424fb6068dc2143840b2883616783bc37ed43c940a95293837451b056a430de3837e2e74358f11be7c667b7dfad55e53210b6246a079dbead8910e7b00030303ab2d8169defcd26db1e42e023724f83c2e59661a22c990953a0cf584db750cc7567263e75f2f70d6191da865a3c4330a73c3a0bda0de33ddf95da19bf30cd4d0b8934209fdca90552cb28a971e12953abf220b2ffd7f4f6afceb1ca8e0c6fd8e7428dbb8956a64921d3526d1f02385746f1b0b11eb1c87c7e9c0bab9df1f8a0fed43e93e7774c65c895c3696ac24d99d513eba682c8d415efff81f8ed34d28a02c8f138c757aed1dacf91ebcded4fcc16432d0ac334dadfe7186d053db7f69491d50317c914a2b0b3c246c163aec99f82941cc177d68b4dd1bfb73af3f8fd7e398ef83b278a3390dd97d3b199a3b10e377ea2d349b8117b5967be5d2f4b6401875c3368d7e0d9c26357c95722cd676f48a73f663384259c7ce61a1bd1d81fd270693297b3b2ab0664116d8e62f07ad858c8a7bf91449ae24b824baf2f9989bce9f826d0d84e10a8f037116b8ba835c1fa03890ab2d140d363da76e495d60828caebfc4cfdaae2aa182de448129eea1b79237a8b4478f85ad805d905d1ccfef0e4c0bbfe2f620af65d12b043cb77d9d7d0ab902bbd24f3d0ee9b1303f10af5fb3078e74f45d5fc2d206b43f5f93b9473c4f3c15e81034136d88ff68eb9ab93ebd9b49ebc5d3f1cea46afbd703934eb099b3d8efbd8bf756afed8ed4ea9fa1b3577c5550a6147534d2ccee9a5cc006b43372cbcc9ca96dd3ab60f3e35dd805984f3faf271124c10a1b8292f39895906a4671d812a3a62b3350dcfd8ece2e18df0f48d0edd39a02d3efe9cf0119423b7dee1e5cff8fdd9e5611fe8948e1cd6694c8c6765676f0a2f620c6e613eff9b703f2a744b16d41bbde675fd5ca70137b8d5a5526027b0e31308536c51ae780d3fa6a984ade92f9c96be7c85fba6e0221ad407a00be41bea25efb5354c63ed04db2871925be26925dfd275c79740e6815f6b1729dc0e236c59cab30e4e0a189dbe3446b708c1effdfc163157a2a2af62ff672e55720ff1cf239339c1d7f676a149c1f4643fefc733d8921b4afd680f9a75dd4cd65f85dda22444dc1525fe0ea7aa384ed6d3326f9be6000c3fd1c7124511e6d422569bcbf04daf6855aeff5f9b690ca87ce122eb914fb5c87f15a69d3236755aa740c07f91e1fded141d4afbfb2f5c0bc1db5a2ed2f23c03562a39f94a9cfe6c9dcb1cb0a9fdd93377f489ad26b730d96bff7319796ad172151f909c0e1465206161d535105a2266d1f23512ece5a4ac9c903e0982158bc37b0586c2a317d6e905f312fec64cad0ec6176f8dc6bc5e1f23cf4406bc949b35db4f6e1fa7659e993444db166a73250932a1a2fd4fa45e28c493244c77da3c4dca42a289d808f845f9b6981a5b9b9570aeb6639a78d4f70dcfd348056ae789b4a6175f015716a89aceb4c4ef9001f4bbb382f1ddb9f4c0ecb0a7e2dc6bef63fd4637e8cdf516ab79895dfcc487074fa0ef06e9be7cfc2165d857646abee544c96f9351aa228577219166bbb7b7ed989c1f0e5b1957e37120e8e4329f10c718a08ab710e7e30274dee0f3715cff43c0a1b743ff5d97d7313dfddac51a01a8f33c3432090899759d0f59cf6993eba8fbd3ffd9b191c7192c562918b9d935d2f558889333dbddd80961b2ef2fa39fe68e306ec8ec0ed14ed377d280299c4e521402c474dd1f02ec05d681fcb8de63b703bcb52d3718ffb8f5cd717b210488d51cb9ebe28b9ca878773e353bc0a7178d150b3be1ba3f73e5f55fbedf13357288b1e104e35f024b604098ea3b4a7434e6ced58487b35964828b900022d178bf1886055c581e2dd2a425dd6cf5fac2c30a03ab70fdc1e95901db6969f77e94799665a7951b56c18151f46c00041800f78a2dd9ad7e2f39bf8fd617d7e1f11c9175a42ddc3a4a1fdae889c27e795d536fd0cbd9c44725a391b5d2e163a0bfc86e114b89b72cbbc6ac201d28e960831a3c7c4c67c7c00d0c7534466dd862000a8f39130bb38420f2d2be18a894becfcb2048ccb60aadc76ff532101d4a1d4559dbbf59822311d228da16aa340896baf718078e01f72f7321250046ebf2e2f8451e8b3bf67315679cc624a45cfcdbedcd4c22493986f50370641ffb1e37b7e427ffe443b373a39787d6bc60df40f1c466f8fb0479effd5047246bdc5a008e3be18fd0a1a81e618530189f93a103b6b5330cee8de899209b7c670d7f0734cd407f44959be3dddb4b5868cc8bc435ecd58a4fb5b223e29185f0af25a4e0a723387065a06ad9e212e58a838948566df1b4f4266c262be805d97fb777daa52144d152eaccfe89e41eaea228ae35e2cf00ea5a7ab97488b45158ceaebd9dadd8a756626ca0548cde733dd3e83c2dff73f9ec56222e3bf7ed3915b22c827c7f7511be3bd1afe26c6b69347be090d99b79c67ba3a2232a7479ca98a8cd4c7db9036154652279c37c19f67a1ee70f944f381ea7ee5985dbbd8fda1e02bab4c4749ab400cfc496071b1667c38c7ef6b5e964188069a13fbfc6643725c5d0a010678addb49b9b542cf3397a72a8d8c334bc47c084abb675c614fbaa73e7eeb679d618a641ef8cf0d589edac887ee011fb64f7e6af6855d931c09f667dd61b3aa68d80c43c5c0d62a27aec7b4b06faf82b0304c8634148c95a68891da58e3fcabc7985777137487fa21e3ad7aef57a2cf8518d3e076ffe94b23bdd558c5314e1641713b95a4788a7b50ae7310a9b94292c2aa22b0c6318dee9c170995d5cd96896a28606b58c1c8b6273261ee3d1f0d9c5e28d12ffa1cb3f22981c827dcacaf94edc32553c8d488466ea7d0f0287d927bb8c40eb8599b7c11fd04955dce8adc1226e933672fcd6f7369c5704303feee8089c7bf56e2ce8675889da3c8375914475ce5411b6c7dad0f1cd2b6d7f76754c0de3041a13d754ee160de62e0b621b782e81677f740a7c133d0e17059e6818a8a006c18d689a28a615487e9c6a0d864e59f6a43ecba0f949940e02ab548fd4f6755f4ccdc2a2124c1c1925db50c7acc186449a1ef56de771330c32f9df61cfe01008e8a296e509f9db1befdc2339d78f30a5b03d299449be60d900c57acba695c303d6a6a3bca041218387fcdfddce3209f7528dce4d43e8b201dda1b7cb4003a0f2403fe035303e82d37b65414c2ebb0250bd2b7a22dad1785a114ebae39e6d14f7b8105ad33b59f7b3cbc2061ea54535c67d7d60db15fd38ed46f9233c913e1d2d41457e9994c21975bdfabc36e6e73897a8b53d24c38372f4faf564ed1c09d4ab67e703809fc4842c09a9f30a84cbeaf6e884b4ba22d8af611734aaea2f887ba0c97f5cb116fd685a60a6df522a6c58ba46079aff4c751a4b80ff8e7ee1248b23571ec838ebca028f67c129a1938a12f05b825252a9e95b796007308555135c6428eab5a081b24410495f7b30d86ad962795939e152bf84e37cb6de0ba64de3a39e2364ed8b134715c175c261250115d361ba9dd2a70f9f544aa7a7d1ae6dc00fac9d86e2bbe36106c2f805cc553e58ef597172b21c01ce19dc650fc954d5d6e7225695efdd4a074d7bf3ba1f58998a70d765d71373691bb5e76d2b392f0e446b205f521315f2e163c63c3d93e489f556bb0b3976feb06649b3364420bbb0d5fcaf5ed564e6fb809f382ab9d9c6af3bc9519c9ef0bd8a360c208f44c13cda0a9d21234b74735b732bea12839b04eb23e787cc1dce7c4e0f5d0eb98d17f77ffbf13bbdaa1a684d43b823edc4c0831106f0257ef193be804e72bc01474c866c9ab1da1b833689a8fdb378ac61c6d2c132f8c4155657faaea5ec2e6dcdca6a5a687f1294367bde6ed79862accd97464a1dbe4273d7a0eb229f1c98e42ace9e99ee6dfb6c39021c8c0216960aa5ea73e39be4765d338eba8b0e09c129a80b8251f8e3797276480d842df36ccf413d92cb32450d2667856699131755a222b5a34e6966c28a5a48a6f4d05e27240e04257f8e42eee59cf4c836ef446a0c0df9556f70758fd89c63f7af7ff68918939fd2ed07c8375ab24c9403b692787a2e961a6cc98520eb7123f5f154b620ca9258c0bdb5322257ef19a3706713d655410bd32469ad55fc12d5ae109d804bf957de4e4227464f034e0706cd76169c03e3b5aaec8ddfd5b7f1ceaf55f0896a165e22bf65e23044dee82bb0268ca292ce345a75e1405f8724a3c8203bec1ab5a94c0359ca15ab89ce752f99c08e8c019558815436d410c5c570742be317494d058247797b15615839935e5970147dd0d401959f3c4948e3e4677c1e0dcd06a3bf7bd1102020645e750604b4057d0802af370c1a29fd568653de102a912eb597b12fa127bd85ab3569b788c5a6ab8bcfeb82adc475bbd97af02c0e6f45218c8ddffcecd416c7699e182d161e13190d24b72f8b07e63db1b8c394c3c876896607dee3c26e677930f43875f597ba4e2ec61c90a71a13ade06f5c09d407ca3069b861625e555145b4679435ef89b0d5783ce00a1e28b44ee2008d6ba3b4ab106dff4320a0071d977cd6a59c6e23e4b53415557a2b9da6101affd018eec2502ded5f44de2aae66e8d4b4a735dffbd63b1ec62c3c872f9ca953bcfa9550bdc57976dcf1979a4a3853f9bf379511d9105552b90781b55345f8393af776d552fb8bd05f15194cc8368adf03a0d1fa8dfef07b848833f937c66514d949ffaa0beac3d8e906351b5e4f1ea5f78a69f0ab3a8479fb99ef3bb8d7fc843d5577f786fa9326cff31a8b8c04e2ba62542776c7f6965501d7eb9daa393bca1b7529c6296f24d203508e3b6c85ec37ac2bc3a34f1786e49538b2e29c74fe91cd77ef891a08e45a48a5de328693e950b01d4aa9389769c0a78bf96a64aa570687446e8eb437ae62412476eacd1f1c721b560993b7e570dee841b3207881fd40bfa19e947b3c2130f6aa19aacffa0fd0aa2f3e7cabee433e11e7f40ecbd0a68d7ccf7aac39d2768ff26895d8675027dc0325f08e0aebcd4fe9937c344233d819e9264b4733d3517f0863062bb5f27f22f545554a7d615798ce3e2dc7a25c6c54b18b90ad92e9c87fe40c05038f313c0ab2dba89ec7963d9f7274ce9f4c2f90ab86ac374c3803fdabe3d4c8f696511ecc7b160bdf0761d4e0876e0ea92d693d8377be1881c4734c9edde025e90a9861985c96c5b66eb070af5560bf595bc87b3d43ef13c0bcb653d37c324f40163248af89812280a7681866699c04e469249033a06353e6fd68027521e8220bae0b48eeeeb1646a7c874bd80d18f8542ad3b60ffccaa5d8e7a92868cfa7fc46fc0494d037f5f2b5c6c4943a80c94f7bcf51e94ffd2995f18a34ddcd0534023107639c6f95d47c8af94f7ce585eb87c85c97de3941f713f312718db0a7e53096b801e50206307f32d848cd93cc788f49303531eae28cfe03c679324d078d5987ade045657aff7a89b97d49c1d5b82c76cddde3f9c2f970b02f9a88ac6f3448c03e06e28171e7efad30f582458526304d83416f1e61ca055a518238df94cb51051ee473d2941f4fea5d1d365e3ecd6be8cf38c1e02ffe33bd818051244086b8ea413851aab14dd2981c1e04c721f6b9f174700273f9447f88d39b2f41ead066007637a62dcf16c6343206463d48acb45e64ad3ef854b5c9043f74554f032a13aae8d4e9b09e13d95135089e50c4afa6bedb71bd7b1bed76470671965e16ec93c75e3894bc7191fcab8a94d114b211dc571c3080d22ffab316c7c2b35e5f0250b72ed4b5c0abb2c843b15350f186364962a9baa514bd23474fe43c425133463585fa5ce1439d9572b813c69dcb680ff4605b03433f26e446db0988a9940b437fa9e2358f7a893dc0a421b371e65f6e98e1633cf4acd6fdef6707164ecefac6657b35f1eed81a2d9c672d87bcd4a4f6e307d75f4a1eaa2adf9c6e7057a5ba3e16674378555b00b60dea40a9e5a65710b36186f0ba4355f0425f9bbf515a77ac39fe4cadae0fcdf4cb698df1bb5a1e22ebba066f9d0ef006c184444b3d1f5ba02c44c8313378aa6865385f9b67ba91ee090ea18c105e467fbff763b176ff4ecafa5f753d306ff6c6c42c652b64d5fd7de22c0400c53bc65e1b06a1ac40a1aff0eda56f3e2338bab402ea9b00b6a2390321db9d305ea437adc9cd5c0dbbe950d93ac9c2facba722037efd7d0d80d1d9fed5c9aabb528d1386db93d767d9bf902d7075bd553efe6440dcb1696dbce95129365cbfe99edbaabb8cb35449caaa587bb1c2ea32aab55bb447aed6123ae8354685f3bc9c17dec6bbd218fa07ae073007e0ead041c784b644722ae59b1101dcb06ab9b5fa3e3dc88fbedcc72364de2802a1424d22070909805925419df962e3903c0eb3ee3fa8565ba565ecd756ce99f72ecb84b7031072f2493c41a29afa1c5d7488212732c88c6498624836ff208224c76321e9fd69f376befce892b0cddf4f4bca476faba77096786aa0690f1039973f416ccafe721023920080666e557b6c06e5513898f5d9867018efb42454aaad084b52afc3918b112ec14d5208985a633b8f2dfacba113bc8bf86f936929c1f72a82664861e2dcce6222a3d74ecce319d74dba4e8313bdd57b4a00762338c0e636f2c1d88b3290cd4fd715aea467a3930df6bf20ec4fbc788bb51b211294998551603b4e41585623563d4db4e0a5dedd668981e88b291d492adba59f48337d6d83651dab4f672ea2c4de0f34eb9ff77dc1ddadcd58734fd1d770923cfd6cdea4ef5da43164b4cf41f15e31aabc47db649528b45281206d6a7e70626cfa634bf737dc4551140c08f253e6ab20ce605e8eaf75499098d33f60a39cff92aef21225fb9857c4a0f4ec14717247e1ebc759773add04223d67256e39ec629c395571c2e062c53dbae63f0e34508f6c387c3c86157e077dce95a8c68769d048b289d027bcfc46d9c49d851e1e399b659c11a92cb2bb22a1a4438e29c2bdb88856873eaa93930bf39cf621ef9c4d7b37e5067d3738e18c2a73a54b92aac03a0cfd2395a86a2bbe0c549e9f9795bc40401e8a7df74a035c8188f9f1395188cc920f541587ded4a71f90c0c5b6f807308991aedd9043ceaea2f8a1883bae77c20de5f331e219612739e37434580bf086d13a34ec893b18d29fbd4fda3b3c075868354f4c53b740864c59725ff808b0db2b9283483bb3f66bd8f7e739a117839b12448c1da4d6aa9fd7ab78e199e40159e7238064db3b98445e045aa7e20822fae6c6624e192abc25ca27855bdf70500caf665c0296e18e7f82477d87f9739653bf8ce448e59ce203a3dfea8143d6c2b09f4ef2aa2385d2ad8d89ca9628594a668e3132320ad72abcdb3dc06f2cf1646852bba2f24e26aff45d6416c337af1324943c83addf09dded02107e5dd0a753e9d26217b48db56bffeaf0db75886f52d1bccb8790c267291ba0dfa74588b578e8521d249fbca610aa7af11f8cd6eb9f61947972990a1df3afa58482cf408f9d7794df1ea2ac8aedd97010601610e3771a12954fde88a51b3d1c2a92882ed60888f5ff81521317c071c020b1d9332dc6f9dcf7c898693663702d4416f8cea3a713d2a12055189434a9f07ba86a2d23409dfc36e8f54f72fe2e8c82c03e01ba8ac6505c7418417af7f569bd85fdb3b9bab22c33fcf6aa4f96d7b08e3ecf7f0fad9d6fd183d2f17f371d047ee547945ec5eb9516d89d6e6186199b0199ca310732a7251e8e4092054bf6f1eef5e71fd7b5c7458456fb38ed565a3a8490c70972dad552b5de839d58106344573bbd0edb6d80699cff91d316f941a3dc20a6ae3a92a0aa5d3831bfd7eb335dc56bf7a3a21503e67a0e3ef04f5d7c4afce38ef44b9a411475eb553443330ada947588b5d5da7b24b16ddc479569fb9f12f2a7b390f9b5b26c2da9860bfdcf8ce693daebc2ed7fcc1008804735834fb12ad3575737224400a6f663ed91fabc917a613463b041bd6c6fcf8ac36d4e691c832ba0d25fd42cfae65829d573c43adc576e78a49b28a14ef52f881658eddca4d741f96bcc1a949c0acdf10831694ae453abe57a55ffa8ce0824d06d16dd1e5504e835d8c464afe09b68c032dbff2623a1d4f9986913f0b73addb2dbba427a6f89204a3d9df4b9ba9f6a349efdb9b0aae955545a88ad79e1b816a6f9dbf179f02e90bfbf8bbfe0fef5112352fff37c72b20027b6940c69642c9754248281f35acfd8cedf5f255e354d47f703925ebbbbefad5cd9d0d43a7cd1436d102cb7fcc234e9e6c86369bdfa5e494ec4771b63b4a656ee53c8b8f90a20d9a0a50efe9c7a760bcc2925b5609e74cfc376b617bf817a38ca3154a946947dd5fd20429032e2a20d9f8b7831e7806352694a8a3ed0a66efae735cc5579c60b71b0e538d9d2dbce16880b6ac6fad0b2dc96c992e53b726720f284fd7e6b5fdcfdb71c12d658752dd3777548361cc29b47fc3d5e38d2d899a6330a4b4faabc01208d17ce7df22d634a752ca5fd415e3257292525949250c03df88fbdd8d69856853466c6bc9a0d0125b77560da970ba15fb5bba9054b4c25a7f84e2647f4050b32c0a50ef6087beab9d5b2e7f3378beed1f2c2b10fdacbb90bf5bf2a33cf4a38ca5610309aed407ed7f5b67c02b2b62dde717a20fa21c0c778862bfd8861339a7bcd6b7d40f8a4044ee3b3f91e9b833c3485703a416d2d0e39d6ae8425eb1d8b751e1c5f19904644db5d57b68bc4259afc82f6966b6285eff40993227da8ae7bec0b3a1a8c334c2fa7fb59608450a6600d96568a0baf5061c2830dfb50dff9032e79037bde887056b67f697ab7f67d10370009a64d214622dee0c71d6683a80774959a3ca5e1156df492b64f93c5253006eb24593162a02dfb45733573e7887915f914172eaa6711e9d22785f27aecd050d3e23a3f31c4d01e990628d5ec56d8f30335eed8ad31261afa2b74df01ead15e91d56a79f5a8403cd45f86619325c3b0a8b2bc658375f91373a508a76b606815055519518b6ce62f68f6f04985a445d39099e0009d7d483afba475cf757b8ca4fbb5c6173be4b9c2b6f1b7a032822f7edbe86d7ac2887b53cb4b8d782cefa932870e1a07bf37fc8e91679f5fb0a41c3104f12eb0878eea1b3fea2d9df3cf0dbde7b6a866be00b29e052c1b60299113a694127c94c3abbabe42dfccd22f9f5fe1863fa95665ef7a0b0a47be6064436767b8da2008c761bac270da986c0944bfedad41a437d7988144b81a5ac6a6453f151b77b62014a5fe725041a838ffbc01819d388408b2606325ba044179f3eca147b0b53e009b2cee2eb61a264e0111e89d1ac3630cf4653b598c668d1e89ff551cb255bb2d0a3a497e8c902bfbdd5556519d926749c9f8e297f1d480fc872f5287363d3eb6b1b85e8f194f2d1b5c3afac98be065c7e8b3f380448f3cb2759628910822fa4027059ab378e91662c6b098eb8e4d36398941e153c3e98d058a51d9d738fd079018fe1054895b4f9d04efc497dcfa496f82e4bc969d90ded2431d086f9a04e075845b3857efa86bcb305e92422d0c89e4b1ea596ab42bd9dbeb3e97ea5dd032a4ffe2dc738e6be71070c265a31459e4cc783897c9d62f8a8e250fd8fe7b564c965962b3139dde7fcabbc38407c45fad1ebba90d98f50c74c2b0ff2f5c7ba9a8f87ef2b72b55279bff96c6be1ee1e6093329371373ff7b17b8c8d346b5c962ba442e95a29770730d3c39f40dd857172fde0cfbdb561c37cb1accceadd116c59ec43a9590fc8f46535b232edba1fc36e7608fe641b0a9f83b6aaddbf1dc8b52e59e82a53e81a88ce0f06908eb069bea99a62326bfaba271f73e89c5b39acb9a8c64efff601616cc107c5c2a15a9070cf0b4cab8a3f3d4ec77588a1835678c616161ffea3cb9bb8a08796447ceaf570462fa760136a9b20688730d909933a344a174eb3f463caa99ca4b72f427b0ac06ae7b9ff79f713edf268650b31218e2b8f16cbf6f2548ddce78144aaaa4e12abc0768bd299c7e8ba98755c904f3ac04a964da38dc2b37ec84c59a8042dbafeb7f8280bd1242fb2e9eb151b9ce9ea7ae0ece22e76c04c4c6e8c02db07a8a7a9fe975bb3e895f4003f0e5e1948caecb88b80ec0fd291f9da7be63259ea8f7cacc870d3b405466b2a45d1f254f4d072c67df8f0d041d679bbce3a1efe0251cd882e0abafdcb1c24fc7d905e79ae819a25369a9b7f51144e5e3bea6cd61e91d470808c171c1c9f9b66a0e418b94ae0b573a70933d73a566e0e8ec7488d897fb71c52bd069a14fb00dc5e7fdc3d89941f4c9dc1d33d9c0c37d7363e02cc9c0bc970ec097acc92573872a39e99eec582c3b41500c82d8b09c49e65035ecfbf48a60015b4c7f9efdea442182eb797740c21ce57f25e2d54f82089a48881b6dc818ee30712aa4a5f5dc80d4efe47d6429c5a312a62e3fa84e7683aeb4e3c7f25073ed98093fa891f92d8bc60107b92adf59d0dfadb750f3775b9d96901ca97f6dd2e4f7b152c9d7278f0b87adff9bd83b35ca8f7627cfa3b187383157f3b0e8b233ecddef8d7ae5344743b95a2f36fef4b4a461ccca7ebe7476a61e56d8d35fcfe255ee3f4be4be97d6c7ff4ed7846d2265bc71ad7272416eb3b8baeea60ee02f08811e58b0fdc00ade9839e8de17188aaf20d3bdabb166836ef76a37fefd5967905e3592a3f4fac4d0b64f556ff613a3048f9ddb136a28f3eacb513f5f9bc49862de544267206c6bccb085d920c18fa15fae715f6e76ebd4b1d0c58df56aa6699f79098d48b751b439a5e392f9d03f8db6de07274ab1de5fca3a92ad5e12a693777182d86206714f7329d495dcb38d191a9bf0a3e25c36c692c051a76f1bafcfbe9302b1a8ca92a0025287ca0ff75bbe6f3fffe84e8608795133af284a425ccbdbc1ad519017d75fe63ba3ef1513dd7a3732658a4d7be392c4c84714ed36221f60042015fa5c9879965f6c84650fd2a8ad1f7e9bc3aae295d51bb54aaad84bd8adc374b72389176321a6670df55c1e38050e087c04b5490f4f256eb40267756469208c050f965c73fa46c84160d87bc63c7fa5227001a90aeb0b234924a632ebe520842531663d045951204dbc5a15eb170a5609b044eaf556fef0a68ec04b1a4db5502e559ff22e087e640cd6b30e459aa5f2bbbaaaf93332d3237fe8b70b71611b9230870e7902556faa23ea2346ac2d514095092ff311a649c5a113a3654030af1bbe30dbfb0f17003f1205b0e128f2cb71afde72b9e569c1574fc5e2819ee1fb03b60df3a93f80986961f7da6e2c18f4432bdeee470893eedf49ba81bde6b1d6be9bb2d00d12011b1c1d548a9d8850a2f6705bd177bed51e9486710630039be0eddeb81daf999fca23b7334974bbe5c1220d27de0357e68b2cdbcba6b044f6b88a65bf8d7e53c6f55684488c06fcba8ff9c972a0ab0891b881841bf70a266edab2e7f1c502f3466559a307872fc6ba6d73f99620a047c443e284ed987d0440a993882f9d29f7fdb062c7c64aee5eb4fde68aac6f90750c959dde3800a447991c3aaf8d71e5b87e63fb2e747d6f19260389d1cfc50635ecc4a0948cf8885c160a6e1ec5e38a9de3c954a9d8f349cdff5ac4b8ace4b9cb2d1f76a5be4ca586ea8375bead19af9e058981e3a53196b697d268df2a48d141d1cf3b1e87773905a58890720d9fdba6c3fa5562f507d2de74749c5d38ee5edb0213b433fae245e89e5199c519c5651e38698f981357e921d57a2b43c6f9f9db63f5437403cf8f5ccfb265f85e0112991d759a2d15ca47972bb5d040944107b61f7a84323c514fa5a2d0eeda9917c35fb1ae324da4e02a7e8838c53ffb85961d351e8f6473cdb78eabf2d686c9e54c23b4c1260ec13786203d56a7c4b797033925e05c910c05b92a35a728e62e55e1c9db9a0022e7598d17b1934b65630c4497cf49c4bea398059cb19f1a2d5b53fad731f46589edc52aabc4573a68ccfd439d727de015ecd7ba58882dd96b058f93b38115b11c98f27cd1499e20d5be6bf82f0e967e1c93e122dee7fe4db922ebe34246c9735243ab96ca435058334d510d53329c222196b0c0864c32d0c7c048ceeae5e180716bb5267716822088bac56c9f2096d6c0a58c3a0b0c92c2f9dadcb9d0a222be36bf1d3bb66184df80e3a276e18112e991e27d8319b5916fbda2c41ccc391006250961b673af7ffffcbd63bf3085e9863289b33685e554294dc5b29c2a746dc3a49fd23786c2466c7ec54e5a568af3ddbbbd88331047c1ef041699809b4ffbed32dac9e004409497ca2b11da9ef2ef52f8de53bfd2c76a0b45e3bf05832257e2b17d6fe77daffc83c1c10ba92acf6e56ba1caf0040900f4585654bfb67542ef486b22bbef0226df4cdc783dfb79cc79a08187f223fa3d5d8b96451d35f629bd549b593b549b29201708d048338e2f4391b74b4b3e2ea5fe15650101b9a8981910130eac1cd16966aef26c4c5e4faa1eb1df6cbd7de95de7fe5f86cf66760b85d9323f9c1c84ba6e78fc5e36b92c8dc508d012e3deadbdd363d85fac8b0f83e582c460c968469082b9edb9a3b546640ea090d82ccf55abcd1dd6b09ea3568fc812e93344fece123ae4000a39b853ad3e6b5b22c9e4f85b67bff3cbf48cbe1e722d43b1cd9db411159493db533b3d3c1ac286367a06424a0e9905ae2501e00b83e69a11b45ff8668968d06e1b63e224dea5e289cb5a49fd7015db9a21bb4f73e3cfe96cc31cddeda41e8a75db732fff369bad5d7489e5f686a21060073e1af86966ffa364656a15597e1d70001d43a6502a503b95a48b1d433238e57dddb8b7da036e2c4c6b6128f841b5733dbc159ac34ea0aea3d316c634e4655c92b97b21db09370792727f5c73d773f7e8e3ca225aafa29a3cb4a478196f572be9859107b3d05b71862c0b8ddb7a052043d77674d043fc50d48ae6c7d6383dab61d9fd5bef2b86925d7dcc84628c9ca453e79d376a25ef34e266861b2cc06989ed7cf8fd5694b26ebaf24482240c71ba68dd9258d8c4677c2b7920a6fb798511428dd1daa650a4505d448888cd5586403d87c4c3f09da9e870f433b2d992261def36be3ea215f44ca68f6e8fa4fb8cd63057ebe39b4eb03d2e243f76fc0ca76f213d16b00a75397b2b66e53e7e755f2c33216f60fc28318dbca6e6f0142dc40e253da1e58a77abf51d122c7d01672344d98fe0c815d72ae1407e375b1ee8e21bf094d38207ed4a0db4bc9c5855322d76ccc76b12838b2db3c7dfae4323960e3498b4bc10c620f9a7ed0a68eba5b546ad2483b1ab6f1fa806a94f36e81aff1d202419a928cbf40c5784356023a4e00ee5457226192188b04c371930b60370760bc87bc0e38da5cc698fea648c375f3fbe36c6678cdb6be176e671b33f2460901a91035abc13320b7ed2f79baf6908df389dba60a725727bafcd716de317bbc46bc220418b503aa7f0024bbddac76b1f7e9753fbfa5fdb8689ba3112051858021f34963efb30ae7cbc304acc030a94d07196d2316081d5a6e0366eb69130d95cecc3905e825cae3c1eb99afb865cc8ec6427552b3c42027c06c429e2d62ad553190d38f914e105c758564e88ede4090997d9de402a94643</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：最小体力消耗路径</title>
      <link href="2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.html"/>
      <url>2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个 $nm$ 的权值矩阵，求从左上角走到右下角。$(n, m \in [1, 100], w \in [1, 1e6])$</p><p>一条路径耗费的体力值是路径上相邻格子之间 <strong>高度差绝对值的最大值</strong> 决定的。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ol><li>二分答案：由于答案具有单调性，所以可以二分答案，然后通过 $bfs$ 进行验证。</li><li>并查集：类似于最小生成树，将所有的边都建出来，然后贪心的将当前权值最小的边加入集合，判断起点和终点是否联通即可。</li><li>最短路：将所有的边建出来，做一次起点到终点的最短路径即可。</li></ol><a id="more"></a><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仅给出第二种做法的代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 并查集模板</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; size;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="comment">// 当前连通分量数目</span></span><br><span class="line">        <span class="keyword">int</span> setCount;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        UnionFind(<span class="keyword">int</span> _n): n(_n), setCount(_n), parent(_n), size(_n, <span class="number">1</span>) &#123;</span><br><span class="line">            iota(parent.begin(), parent.end(), <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">findset</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> parent[x] == x ? x : parent[x] = findset(parent[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            x = findset(x);</span><br><span class="line">            y = findset(y);</span><br><span class="line">            <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (size[x] &lt; size[y]) &#123;</span><br><span class="line">                swap(x, y);</span><br><span class="line">            &#125;</span><br><span class="line">            parent[y] = x;</span><br><span class="line">            size[x] += size[y];</span><br><span class="line">            --setCount;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            x = findset(x);</span><br><span class="line">            y = findset(y);</span><br><span class="line">            <span class="keyword">return</span> x == y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> x, y, w;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumEffortPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = h.size(), m = h[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;Node&gt; g;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>) g.push_back(Node&#123;i * m + j, i * m + j - m, <span class="built_in">abs</span>(h[i][j] - h[i - <span class="number">1</span>][j])&#125;);</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) g.push_back(Node&#123;i * m + j, i * m + j - <span class="number">1</span>, <span class="built_in">abs</span>(h[i][j] - h[i][j - <span class="number">1</span>])&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(g.begin(), g.end(), [](Node&amp; a, Node&amp; b) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="function">UnionFind <span class="title">uf</span><span class="params">(n * m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : g) &#123;</span><br><span class="line">            uf.unite(p.x, p.y);</span><br><span class="line">            <span class="keyword">if</span> (uf.connected(<span class="number">0</span>, n * m - <span class="number">1</span>)) <span class="keyword">return</span> p.w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：解码异或后的排列</title>
      <link href="2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%A7%A3%E7%A0%81%E5%BC%82%E6%88%96%E5%90%8E%E7%9A%84%E6%8E%92%E5%88%97.html"/>
      <url>2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%A7%A3%E7%A0%81%E5%BC%82%E6%88%96%E5%90%8E%E7%9A%84%E6%8E%92%E5%88%97.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你一个整数数组 $g$，它是前 $n$ 个正整数的排列，且 $n$ 是个 <strong>奇数</strong> 。</p><p>它被加密成另一个长度为 $n - 1$ 的整数数组 $a$ ，满足 $a[i] = g[i]$ ^ $g[i + 1]$。比方说，如果 $g = [1,3,2]$，那么 $a = [2,1]$。</p><p>给你 $a$ 数组，请你返回原始数组 $g$。题目保证答案存在且唯一。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><a id="more"></a><p>可以发现如果对 $a$ 数组做前缀异或和得到 $sum$ 数组，那么 $sum[i]$ 就表示 $g[0]$ ^ $g[i + 1]$ 的值。$n$ 恰好为奇数，因此如果将数组 $sum$ 全部异或起来，$g[0]$ 刚好为被异或偶数次而抵消，得到的结果为 $g[1]$ ^ $g[2]$ ^ … ^ $g[n]$，恰好只有 $g[0]$ 没有出现。然后将这个结果与 $1-n$ 的所有数异或，得到的就是 $g[0]$ 的值，然后递推即可。时间复杂度 $O(n)$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">decode</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.size(), sum = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">g</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) g[<span class="number">0</span>] ^= (sum ^= a[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++) g[<span class="number">0</span>] ^= i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) g[i + <span class="number">1</span>] = g[i] ^ a[i];</span><br><span class="line">        <span class="keyword">return</span> g;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：最小高度树</title>
      <link href="2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91.html"/>
      <url>2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一颗树，求当树的高度最小时根的编号为多少。$(n \in [1, 2e4])$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：交换字符串中的元素</title>
      <link href="2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E4%BA%A4%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0.html"/>
      <url>2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E4%BA%A4%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你一个字符串 $s$，以及该字符串中的一些「索引对」数组 $pairs$，其中 $pairs[i] = [a, b]$ 表示字符串中的两个索引（编号从 $0$ 开始）。</p><p>你可以 任意多次交换 在 $pairs$ 中任意一对索引处的字符。</p><p>返回在经过若干次交换后，$s$ 可以变成的按字典序最小的字符串。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><a id="more"></a><p>假设 $i$ 可以和 $j$ 交换，$j$ 可以和 $k$ 交换，那么 $i$ 就可以和 $k$ 交换，因此是具有传递关系的。因此将互相具有传递关系的索引看作一个集合，用并查集维护。然后对于每个集合，将字母从小到大排序放置即可。时间复杂度 $O(nlog(n))$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> fa[<span class="number">100005</span>], v[<span class="number">100005</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fa[x] == x ? x : fa[x] = find(fa[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">smallestStringWithSwaps</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) fa[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : pairs) &#123;</span><br><span class="line">            <span class="keyword">int</span> fx = find(p[<span class="number">0</span>]), fy = find(p[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (fx != fy) fa[fx] = fy;</span><br><span class="line">            v[p[<span class="number">0</span>]] = v[p[<span class="number">1</span>]] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; id[<span class="number">100005</span>];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; ch[<span class="number">100005</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!v[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> fx = find(i);</span><br><span class="line">            <span class="keyword">if</span> (!mp[fx]) mp[fx] = ++cnt;</span><br><span class="line">            id[mp[fx]].push_back(i);</span><br><span class="line">            ch[mp[fx]].push_back(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">            sort(ch[i].begin(), ch[i].end());</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ch[i].size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="keyword">int</span>)id[i].size(); j++) </span><br><span class="line">                s[id[i][j]] = ch[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络知识点</title>
      <link href="2021/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9.html"/>
      <url>2021/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9.html</url>
      
        <content type="html"><![CDATA[<h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><p><img src="http://img.benboby.top/%E6%A8%A1%E5%9E%8B%E5%B1%82%E6%AC%A11.png" alt><br>ISO七层：物理层，数据链路层，网络层，传输层，会话层，表示层，应用层。<br>TCP/IP分层模型：</p><ul><li>网络接口层，ARP地址解析协议，提供硬件间接口。</li><li>网间层，IP协议，负责数据的包装，寻址，和路由。</li><li>传输层，TCP协议提供可靠数据流传输服务，UDP协议提供不可靠的用户数据报服务。</li><li>应用层，FTP（文件传输协议），HTTP（超文本传输协议），Telent（远程终端协议）。</li></ul><h2 id="TCP首部"><a href="#TCP首部" class="headerlink" title="TCP首部"></a>TCP首部</h2><ul><li>源端口和目的端口，各2字节</li><li>序号，4字节，面向字节流传输，标识当前报文段发送数据的起始编号，接受方根据起始编号和数据大小，就可以推算出下一个应该接受报文的起始编号</li><li>确认号，4字节，下一个希望收到报文的起始编号，即表示：N之前编号的数据已经成功收到</li><li>数据偏移，4字节，数据部分离报文段起始位置有多远</li><li>保留位，6字节，暂时没用，留着以后使用</li><li>URG：说明有紧急数据，应尽快发送</li><li>ACK：建立连接后所有ACK报文必须置为1</li><li>PSH：。。。</li><li>RST：出现了严重错误，必须重新建立连接</li><li>SYN：请求连接</li><li>FIN：释放连接</li><li>窗口：发送本报文段的一方的接受窗口</li><li>检验和：检验报文的首部和数据是否发送改变</li><li>MSS：规定的最大报文长度</li></ul><a id="more"></a>    <h2 id="三次握手与四次挥手"><a href="#三次握手与四次挥手" class="headerlink" title="三次握手与四次挥手"></a>三次握手与四次挥手</h2><p><img src="http://img.benboby.top/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B1.png" alt></p><ul><li>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 SYN_Send 状态。</li><li>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。 同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。</li><li>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 establised 状态。</li><li>服务器收到 ACK 报文之后，也处于 establised 状态，此时，双方已建立起了链接。</li></ul><p><img src="http://img.benboby.top/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B1.png" alt></p><ul><li>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。</li><li>第二次握手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。</li><li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。</li><li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。 需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态</li><li>服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</li></ul><p>第2次握手传回了ACK，为什么还要传回SYN？<br>答：接收端传回发送端所发送的ACK是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。而回传SYN则是为了建立并确认从服务端到客户端的通信。</p><p>为什么连接的时候是三次握手，关闭的时候却是四次握手？<br>答：连接时，当服务端收到客户端的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文，其中 ACK 报文是用来应答的，SYN 是用来同步的。但关闭连接时，服务端收到 FIN 报文后，可能不会立即发送 FIN 报文，因为服务端可能该发送的报文还没有发完，因此只能先回复一个 ACK 报文表示确认收到了。等服务端所有报文都发送完了，才回复 FIN 信号关闭连接。故需要四次握手。</p><p>为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？<br>答：一个是当服务端没有收到ACK时，有时间重发ACK；二是经过2MSL就可以使本次连接所产生的所有报文都从网络中消失，下次连接就不会出现旧的连接请求报文。</p><p>MSL是最大报文生存时间，2MSL就是发送+回复的最大时间。如果ACK丢包了，那么一定会在2MSL之内收到服务端重发的FIN包。</p><p>为什么不能用两次握手进行连接？<br>答：客户端发出连接请求，未收到确认，于是重发，接收到确认，建立连接。但之前的连接请求却又到了服务端，服务端发送确认报文段，又建立了一次连接。</p><p>如果已经建立了连接，但是客户端突然出现故障了怎么办？<br>答：TCP还设有一个保活计时器，服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><h3 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h3><p>将数据段都当做16位整数，将这些加起来，最后取反，得到校验和。</p><p>发送方发送之前计算校验和并填充，接收方以同样的方式计算，进行比对。</p><h3 id="确认应答与序列号"><a href="#确认应答与序列号" class="headerlink" title="确认应答与序列号"></a>确认应答与序列号</h3><p>TCP对每个字节的数据都进行编号，就是序列号。接收方每次收到数据后，都会发送ACK报文以确认，报文中有相应的确认序列号，告诉发送方，下一次的数据应该从哪里开始发。</p><p>另一个作用是排序，因为数据包不一定是按序到达的，因此可以按序列号对数据包排序。</p><h3 id="TCP超时重传"><a href="#TCP超时重传" class="headerlink" title="TCP超时重传"></a>TCP超时重传</h3><p>超时重传指的是发送数据包到接收确认包之间的时间，如果超过了这个时间就会被认为丢包。（可能是数据丢包，也可能是确认报文丢包）</p><p>TCP每发送一个报文段，就会设置一次计时器。计时器设置的重传时间到了，还没有收到确认，就要重传这一报文段。</p><p>RTO：重传超时时间，<strong>发送端发送数据到重传数据</strong>的这一段等待时间<br>RTT：连接往返时间，<strong>发送端从发送TCP包接受到对应的立即响应</strong>所耗费的时间</p><p><img src="http://img.benboby.top/%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0.png" alt="RTO 和 RTT 比较示意图"></p><h2 id="ARQ协议"><a href="#ARQ协议" class="headerlink" title="ARQ协议"></a>ARQ协议</h2><p>停止等待ARQ：发完一个分组就停止，等待确认，超时就重发，确认收到再发送下一个分组。缺点是信道利用率低。</p><p>连续ARQ：维护一个发送窗口，分组内可用连续发送出去，接受方采用累计确认，对按序到达的最后一个发组发送确认，表明之前的已经全部收到了。<br>缺点： 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</p><h2 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h2><p>接受端缓冲区大小有限，发送的太快太多接受端来不及处理。</p><p>如果一个一个发数据段，等确认了再发下一个，效率就比较低。</p><p>滑动窗口是流量控制和核心，存在与TCP首部，TCP首部有个window字段，用于接受端告诉发送端自己还有多少缓冲区可以接收数据。</p><p>当window字段为0，就会停止发送数据。那什么时候可以继续发送数据？</p><p>一种可能是接收方去发一个报文去通知发送端可以继续发，但要是这个报文丢了，就会再次陷入僵局。</p><p>因此采取的策略当收到win=0的报文后，就开启一个计时器，每隔一段时间就发个测试报文测试一下，打听一下是否可以发数据了。</p><h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p>防止发送方发的太快，使得网络来不及处理，从而导致网络拥塞。</p><ol><li>慢开始：设置拥塞窗口cwnd为1，然后以指数增长（乘2），逐步发送数据。</li><li>拥塞避免：为了防止cwnd增加过快而导致网络拥塞，所以需要设置一个慢开始门限ssthresh状态变量，窗口大小增长到门限值，就改为执行拥塞避免算法，每经历过一次往返时间就使cwnd增加1。</li><li>快速重传：累计收到三个同样的确认报文，说明下一个报文还没有到达，认为拥塞发生了，立即重传该报文。</li><li>快速恢复：将当前窗口大小和门限值调整为当前窗口的一半，开始执行拥塞避免算法。</li></ol><p>流量控制和拥塞控制的区别：</p><ul><li>一个是丢包在接受端上，一个是丢包在路由器上。</li><li>一个是怕接受端来不及处理，一个怕网络拥塞，网络来不及处理</li></ul><h2 id="TCP和UDP区别"><a href="#TCP和UDP区别" class="headerlink" title="TCP和UDP区别"></a>TCP和UDP区别</h2><p>用户数据报协议 UDP（User Datagram Protocol）<br>传输控制协议 TCP（Transmission Control Protocol）</p><ul><li>TCP面向连接，UDP不需要建立连接，随时想发就发，也不会对数据报进行任何拆分，也就说明UDP是不可靠传输</li><li>UDP并不只是一对一的，有单播，多播，广播的功能</li><li>UDP面向报文，TCP面向字节流</li><li>UDP头部更小（源端口，目的端口，数据长度，校验和），只有8个字节，传输效率更高</li><li>TCP有流量控制，拥塞控制来保证安全性，UDP没有</li><li>UDP适用于事实通信（电话，直播），TCP适用于可靠传输（文件传输）</li></ul><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>HTTP（超文本传输协议），基于TCP/IP通信协议来传递数据，属于应用层的面向对象的协议。<br>特点：</p><ul><li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。</li><li>灵活：HTTP允许传输任意类型的数据对象。</li><li>无连接：无连接的含义是限制每次连接只处理一个请求。</li><li>无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传。</li><li>支持B/S及C/S模式。</li></ul><h2 id="从输入URL到页面加载发生了什么？"><a href="#从输入URL到页面加载发生了什么？" class="headerlink" title="从输入URL到页面加载发生了什么？"></a>从输入URL到页面加载发生了什么？</h2><ol><li>DNS 域名解析<br> 当你输入了 www.google.com 并按下回车后，浏览器检查输入框，发现不是 ip 地址，于是去 <strong>浏览器缓存</strong> 里面找有没有相关记录，发现没有，那就继续去 <strong>系统缓存</strong> 找，也就是系统中的 hosts 文件，还是没有，又继续去 <strong>路由器缓存</strong> 里面找，查看的是路由器映射表。接着，计算机将域名发送给 <strong>本地DNS服务器</strong>，也就是 <strong>提供本地连接的服务商</strong>，本地DNS服务器找不到的话，会将域名发送到 <strong>根域名服务器</strong>，也就是 <strong>‘.’</strong>，找不到就返回 <strong>顶级域名服务器 —— .com 的IP地址</strong>，再请求 <strong>顶级域名服务器IP</strong> 返回 <strong>二级域名服务器 —— google.com 的IP地址</strong>…直到找到对应的IP地址，然后返回给浏览器。</li><li>发起 TCP 连接（三次握手）<br> 知道IP地址后，<strong>传输层的TCP协议</strong>就可以向远端服务器发起连接请求了。</li><li>发送 HTTP 请求，接受 HTTP 响应<br> 连接上了，可以传输了。计算机需要将用户输入的地址封装成 <strong>HTTP Request 请求报文</strong>，发送到服务器，服务器收到请求后会发出应答，即响应数据。<br> HTTP请求报文格式：请求行+请求头+空行+消息体，请求行包括请求方式（GET/POST/DELETE/PUT）、请求资源路径（URL）、HTTP版本号。<br> HTTP响应报文格式：状态行+响应头+空行+消息体，状态行包括HTTP版本号、状态码、状态说明。</li><li>断开 TCP 连接（四次挥手）<br> 完成一次 HTTP 请求后，服务器并不是马上断开与客户端的连接。默认启用 <strong>持久连接</strong>，以便处理不久后到来的新请求，无需重新建立连接而增加慢启动开销，提高网络的吞吐能力。在反向代理软件 Nginx 中，持久连接超时时间默认值为 75 秒，如果 75 秒内没有新到达的请求，则断开与客户端的连接。同时，浏览器每隔 45 秒会向服务器发送 TCP keep-alive 探测包，来判断 TCP 连接状况，如果没有收到 ACK 应答，则主动断开与服务器的连接。</li><li>浏览器解析 HTML 代码，请求js，css等资源，最后进行页面渲染，显示出来。</li></ol><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>浏览器输入地址，浏览器去调用gethostbyname库函数，这个函数通过网卡给DNS服务器发送UDP请求，接收结果，然后将结果返回浏览器。</p><p>为什么是UDP？因为UDP快啊！UDP协议传输内容不能超过512字节，查询域名一般返回的内容都不会超过这么多。</p><p>但DNS还是有用到TCP的，DNS有两种类型服务器，主DNS服务器和辅助DNS服务器。当一个辅助DNS服务器启动时，需要与主DNS服务器通信，并加重数据信息，称为区域传送。</p><p>为什么是TCP？因为TCP可靠，而且传送的数据可能大于512字节。</p><h3 id="常见的状态码："><a href="#常见的状态码：" class="headerlink" title="常见的状态码："></a>常见的状态码：</h3><ul><li>1xx，表示成功发出请求正在处理</li><li>2xx，表示成功处理请求</li><li>3xx，表示需要完成请求，需要进行重定向</li><li>4xx，表示请求错误，妨碍了服务器的处理</li><li><p>5xx，表示服务器错误</p></li><li><p>200 请求被正确处理</p></li><li>301 资源被永久转移到另一个URL</li><li>302 资源被暂时转移到另一个URL</li><li>400 客户端请求有语法错误，不能被服务端识别</li><li>403 服务器收到请求，但拒绝提供服务（认证失败）</li><li>404 请求资源不存在</li><li>500 服务器执行请求发生错误</li></ul><h2 id="GET和POST区别"><a href="#GET和POST区别" class="headerlink" title="GET和POST区别"></a>GET和POST区别</h2><p>HTTP请求方法，POST和GET都是向服务器提交数据，并且都会从服务器获取数据。</p><ul><li>get通过地址栏传输，安全性较低，post通过报文传输，安全性更高一些，但也没多高，毕竟http本身就是不安全的</li><li>get长度受限于url长度，传输数据量小，post理论上没有限制</li><li>大部分情况下，get产生一个数据包，post产生两个数据包，也意味着get效率更高</li></ul><p>对于get请求，浏览器会把http head和 data 一起发送出去，服务器响应200，返回数据。<br>对于post请求，浏览器会先传http head，然后服务器响应100 continue，浏览器再发送data，服务器响应200，返回数据。</p><p>一般来说，做数据查询用get，做增删改用post（网站登陆，文件传输）。</p><p>HEAD类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头。</p><p>报文组成：</p><ul><li>对于Request：请求行，说明请求类型，要访问的资源以及HTTP版本；</li><li>对于Response：状态行，状态码，状态消息。</li><li>请求头，一些附加信息</li><li>空行，必须有</li><li>数据部分，是主体</li></ul><h2 id="浅谈HTTP中Get、Post、Put与Delete的区别"><a href="#浅谈HTTP中Get、Post、Put与Delete的区别" class="headerlink" title="浅谈HTTP中Get、Post、Put与Delete的区别"></a>浅谈HTTP中Get、Post、Put与Delete的区别</h2><p>1、GET请求会向数据库发索取数据的请求，从而来获取信息，该请求就像数据库的select操作一样，只是用来查询一下数据，不会修改、增加数据，不会影响资源的内容，即该请求不会产生副作用。无论进行多少次操作，结果都是一样的。</p><p>2、与GET不同的是，PUT请求是向服务器端发送数据的，从而改变信息，该请求就像数据库的update操作一样，用来修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。</p><p>3、POST请求同PUT请求类似，都是向服务器端发送数据的，但是该请求会改变数据的种类等资源，就像数据库的insert操作一样，会创建新的内容。几乎目前所有的提交操作都是用POST请求的。</p><p>4、DELETE请求顾名思义，就是用来删除某一个资源的，该请求就像数据库的delete操作。</p><p>就像前面所讲的一样，既然PUT和POST操作都是向服务器端发送数据的，那么两者有什么区别呢。。。POST主要作用在一个集合资源之上的（url），而PUT主要作用在一个具体资源之上的（url/xxx），通俗一下讲就是，如URL可以在客户端确定，那么可使用PUT，否则用POST。</p><h2 id="HTTP1-0、HTTP-1-1主要区别"><a href="#HTTP1-0、HTTP-1-1主要区别" class="headerlink" title="HTTP1.0、HTTP 1.1主要区别"></a>HTTP1.0、HTTP 1.1主要区别</h2><ol><li>HTTP1.1默认支持长连接，HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接。HTTP是基于TCP/IP协议的，创建一个TCP连接是需要经过三次握手的，有一定的开销，如果每次通讯都要重新建立连接的话，对性能有影响。因此最好能维持一个长连接，可以用一个长连接来发多个请求。</li><li>节约带宽，同post</li></ol><h2 id="cookie和session的作用和区别"><a href="#cookie和session的作用和区别" class="headerlink" title="cookie和session的作用和区别"></a>cookie和session的作用和区别</h2><p>Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端会把Cookie保存起来。</p><p>  当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。</p><p>Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。</p><p>  每个用户访问服务器都会建立一个session，那服务器是怎么标识用户的唯一身份呢？事实上，用户与服务器建立连接的同时，服务器会自动为其分配一个SessionId。</p><p>区别：</p><ul><li>cookie数据存放在客户的浏览器上，session数据放在服务器上。</li><li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用COOKIE</li><li>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗</li><li>将登陆信息等重要信息存放为SESSION，其他信息如果需要保留，可以放在COOKIE中</li></ul><h2 id="HTTP重定向过程"><a href="#HTTP重定向过程" class="headerlink" title="HTTP重定向过程"></a>HTTP重定向过程</h2><p>301:永久性转移<br>302:暂时性转移<br>重定向过程：客户浏览器发送http请求 ——&gt; web服务器接受后发送302状态码响应及对应新的location给客户浏览器 ——&gt; 客户浏览器发现是302响应，则自动再发送一个新的http请求，请求url是新的location地址 -&gt; 服务器根据此请求寻找资源并发送给客户。</p><h2 id="HTTP和HTTPS区别"><a href="#HTTP和HTTPS区别" class="headerlink" title="HTTP和HTTPS区别"></a>HTTP和HTTPS区别</h2><ul><li>HTTP通信使用明文,内容可能被窃听；HTTPS是具有安全性的SSL加密传输协议</li><li>HTTP不验证通信方身份，因此有可能遭遇伪装；HTTPS有验证机制</li><li>HTTP无法验证报文的完整性，所以有可能被篡改；HTTPS有完整性保护</li><li>HTTP使用80端口，HTTPS使用443端口</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：货仓选址</title>
      <link href="2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%B4%A7%E4%BB%93%E9%80%89%E5%9D%80.html"/>
      <url>2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%B4%A7%E4%BB%93%E9%80%89%E5%9D%80.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>在数轴上找到一个点，使得到其余 $n$ 个点距离之和最小。$(n \in [1, 1e5])$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>考虑绝对值不等式：<br><a id="more"></a> </p><p>当只有两个点 $a, b$ 时，有 $|a - x| + |b - x| &gt;= |a - b|$，为了满足 $|a - x| + |b - x| = |a - b|$ 关系，$x$ 必须选在 $a,b$ 两点之间。</p><p>拓展为 $n$ 个点，距离为 $|a[1] - x| + |a[2] - x| + … + |a[n - 1] - x| + |a[n] - x|$，收尾两两分组有 $(|a[1] - x| + |a[n] - x|) + (|a[2] - x| - |a[n - 2] - x| + …)$，两两应用绝对值不等式，$x$ 的位置必须满足在各个对应区间里。</p><p>得出结论：当 $n$ 为奇数时，$x$ 位置为中间那个点（因为刚好分组多出单独一个，满足最小性则必须将 $x$ 的位置选择为那个点，距离刚好为 $0$）；当 $n$ 为偶数时，$x$ 位置为中间两个点之间的任意位置都可。 </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, res, a[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    sort(a, a + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) res += <span class="built_in">abs</span>(a[i] - a[n &gt;&gt; <span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统知识点</title>
      <link href="2021/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9.html"/>
      <url>2021/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9.html</url>
      
        <content type="html"><![CDATA[<h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><p>并发：宏观上两个程序在同时运行，实际上是交织运行的，单个周期只运行了一个指令，用于提高效率。<br>并行：物理意义上的同时运行，如多核cpu，运行在不同的核上，互不影响。</p><h3 id="进程和线程的概念，区别，使用场景"><a href="#进程和线程的概念，区别，使用场景" class="headerlink" title="进程和线程的概念，区别，使用场景"></a>进程和线程的概念，区别，使用场景</h3><p>进程：<strong>资源分配的基本单位</strong>，实现了操作系统的并发。<br>线程：线程是进程的子任务，是<strong>CPU调度的基本单位</strong>，不拥有资源，但可以使用进程所属的资源。每个进程都有一个主线程，实际上是主线程来执行main函数中的代码。</p><p>进程在创建，撤销，切换时的开销都显著大于线程，系统要为之分配，回收，切换资源。</p><p>一个线程只属于一个进程，进程间不会相互影响，一个线程挂掉将影响整个进程挂掉。</p><p>线程并不是越多越好，每个线程都需要一个独立的堆栈空间，线程之间的切换需要保存很多中间状态，耗费程序运行时间。多线程开销远远小于多进程。</p><p>进程在同一时间只能干一件事，进程在执行过程中如果阻塞，整个进程就会挂起，然后其中有些工作并不依赖阻塞的资源，却还是卡在那里。因此引入线程，减少程序在并发时付出的时空开销。</p><a id="more"></a><h3 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a>进程间通信方式</h3><ol><li>管道<ul><li>普通管道PIPE：半双工，数据单向流动，一般申请两个，一个用于读一个用于写。只能用于有父子进程和兄弟进程之间，只存在于内存中。</li><li>命名管道FIFO：有具体的路径名，存在于文件系统中，因此可以在无关进程中交换数据。</li></ul></li><li>套接字socket：可以用于不同主机间进行通讯</li><li><p>系统IPC<br> 消息队列：消息的链接表，存放在内核中。具有写权限的进程可以向队列中添加消息，有读权限的进程可以从队列中读取信息。</p><ul><li>消息具有特定的格式和优先级，克服了信号传递信息少，管道只能承载无格式字节流已经缓冲区大小受限等特点</li><li>独立于发送和接收进程，进程终止是，消息队列及其内容不会被删除</li><li><p>可以实现消息的随机查询，不一定要先进先出地读取  </p><p>信号量：计数器，控制多进程对共享资源的访问。用于实现进程间的互斥和同步，不用于存储进程间的通信数据。一般需要结合共享内存和PV操作使用。</p><p>信号：用于通知接收进程某个事件已经发生</p><p>共享内存：使得多个进程可以访问同一块内存，不同进程可以及时看到对方进程中对共享内存的数据更新。</p></li><li>最快的IPC，进程直接对内存进行存取</li><li>多个进程可以同时操作，需要进行同步</li><li>需要同步操作，和互斥锁和信号量一起结合使用</li></ul></li></ol><h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><p>进程通信：进程间传送（大量）数据<br>进程同步：进程合作，进程间共同完成一项任务时之间的直接制约关系。<br>进程互斥：它主要源于资源共享，是进程之间的间接制约关系。每次只允许一个进程访问的资源称为<strong>临界资源</strong>，进程互斥就是保证每次只有一个进程使用临界资源。</p><h3 id="线程间通信方式"><a href="#线程间通信方式" class="headerlink" title="线程间通信方式"></a>线程间通信方式</h3><p>线程同步和进程同步的本质区别在于锁放在哪，放在私有的进程空间还是放在多进程共享的空间，并且看锁是否具备进程共享的属性。</p><ol><li>临界区：多个线程访问一个独占共享资源时，可以使用临界区对象，其它线程想访问，会被挂起，直到拥有临界区的线程放弃位置。</li><li>事件：允许一个线程在处理完之后，主动唤醒另外一个线程执行任务。</li><li>互斥量：互斥对象机制，拥有互斥对象的线程才有访问公共资源的权限。</li><li>信号量：允许多个线程在同一时刻访问同一个资源，但一般需要限制数目。</li></ol><h3 id="fork和vfork"><a href="#fork和vfork" class="headerlink" title="fork和vfork"></a>fork和vfork</h3><p>fork()创建一个子进程，返回2次，一次在子进程中返回0，一次在父进程中返回子进程的pid，<br>子进程和父进程共享内存空间，采用写时复制，即父子可以同时读取内存，但如果需要对内存进行修改的话，就会复制一份该进程单独使用。毕竟一开始就进行内存复制是很浪费效率的。</p><p>vfork创建的子进程先于父进程运行，父子进程共用数据段，但若子进程依赖父进程操作，就会产生死锁。</p><h3 id="进程状态切换"><a href="#进程状态切换" class="headerlink" title="进程状态切换"></a>进程状态切换</h3><p>就绪态通过调度算法获得CPU时间，进入运行态；时间片用完进入就绪态，等待下一次调度。<br>运行态因确实资源（函数迟迟不返回），进入阻塞态，缺少CPU时间会使其进入就绪态。</p><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><ol><li>传统计算机，进程都是直接访问物理内存的，这就导致恶意程序可以随意访问修改别的进程内存数据，非常的不安全。</li><li>如果出现内存不够用的情况，操作系统必须选择一个程序先将它的数据拷贝到硬盘上，腾出空间给C用，这就导致有大量数据装入装出，效率低。</li><li>内存是随机分配地址的，因此程序的运行地址是不确定的。</li></ol><p>于是出现了虚拟地址，作为中间层的存在，间接的访问物理内存。程序访问的内存地址是虚拟地址，然后由操作系统将其映射到物理内存地址上。只要处理好映射关系（MMU虚拟内存管理），就可以使不同的程序处于不同的区域，达到内存隔离效果。</p><p>操作系统将内存抽象成地址空间，每个程序都有自己的地址空间，这些地址空间被分成多个块，每一块称为一页。<strong>这些页被映射到物理内存，但不要求连续，也不要求所有也都在物理内存中。</strong>然后由操作系统来处理它们之间的映射关系，当程序引用不在物理内存中的页时，通过映射关系调入页面。</p><p><img src="http://img.benboby.top/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.png" alt="虚拟内存空间分布"></p><p>实现：</p><ol><li>足够容量的内存和外存</li><li>缺页中断：如果需执行的指令或访问的数据尚未在内存（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段调入到内存，然后继续执行程序</li><li>虚拟地址空间 ：逻辑地址到物理地址的变换。</li></ol><h3 id="分页系统地址映射"><a href="#分页系统地址映射" class="headerlink" title="分页系统地址映射"></a>分页系统地址映射</h3><p>内存管理单元（MMU）实现了虚拟地址和物理地址之间的转换，其中的页表（数组）存储着程序地址空间和物理内存空间的映射表。</p><p>一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。例如对于虚拟地址（0010 000000000100），前 4 位是存储页面号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。</p><p>物理地址 = 内存块号 * 页面大小 + 页内偏移量</p><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><ol><li>先来先服务FCFS：<br> 非枪占式，按请求顺序进行调度。如果前面的进程太长，导致后面作业等待时间过长。</li><li>短作业优先SJF：<br> 非抢占式，按估计运行时间最短的顺序进行调度。如果短作业一直来，长作业容易饿死。</li><li>最短剩余时间优先SRTN：<br> 抢占式，按剩余运行时间进行调度。一个新作业来时，与当前进程的剩余时间进行比较。</li><li>时间片轮转：<br> 按FCFS分配成一个队列，每个进程轮流执行一个时间片。效率和时间片大小有很大关系。时间片太短，进程切换太频繁；时间片太长，实时性无法保证。</li><li>优先级调度<br> 给每个进程分配一个优先级，按优先级调度。为了防止低优先永远等不到，可以随着时间推移增加优先级。</li><li>多级反馈队列<br> 设计出多个队列，每个队列时间片大小都不同，时间片小的队列优先级越高。<br> 例如：一个进程先去时间片为1的队列，若出队后没有执行完，就去时间片2的队列队尾，以此类推。<br> 可以看成是时间片轮转+优先级调度结合，效率较高。</li></ol><h3 id="OS缺页置换算法，虚拟内存置换方式"><a href="#OS缺页置换算法，虚拟内存置换方式" class="headerlink" title="OS缺页置换算法，虚拟内存置换方式"></a>OS缺页置换算法，虚拟内存置换方式</h3><p>当访问内存中一个不存在的页时，且内存已满，就需要从内存中替换一个页。</p><ul><li>FIFO（先进先出）：置换最先进来的页面，即逗留时间最久的页面。</li><li>LFU：最不经常访问淘汰算法</li><li>LRU（最近最少访问）：置换最近一段时间内最久没被访问过的页面。</li></ul><h3 id="Linux锁机制"><a href="#Linux锁机制" class="headerlink" title="Linux锁机制"></a>Linux锁机制</h3><ol><li>互斥锁：mutex，用于保证任何时刻只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒。</li><li>读写锁：rwlock，分为读锁和写锁。允许多个线程同时读，但只能有一个线程写。写优先于读，一旦有写，则读必须等待。适用于读频率远远大于写的情况。</li><li>自旋锁：在任何时刻只能有一个线程访问对象，但是获取锁操作失败时，不会进入睡眠，而是在原地自旋，直到锁被释放。节省了线程从睡眠到被唤醒的消耗。适用于加锁时间短暂的情况下。</li></ol><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>多个进行相互等待对方资源，在得到所有资源继续运行之前，都不会释放自己已有的资源，这样造成了循环等待的现象，称为死锁。</p><p>产生死锁的的四个条件：</p><ol><li>互斥条件：一个资源每次只能被一个进程使用；</li><li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放；</li><li>不剥夺条件：进程已获得的资源，在没使用完之前，不能强行剥夺；</li><li>循环等待条件：多个进程之间形成一种互相循环等待资源的关系。</li></ol><p>防止死锁（程序运行前防止）的发生只需破坏死锁产生的四个必要条件之一即可，但开销非常之大，目前没有一个操作系统可以实现。因此最好的办法是预防，而不是解决。</p><p>而一般来说，大多数操作系统解决死锁的策略仅仅是忽略它。</p><p>预防（程序运行时防止）：银行家算法，在进行系统资源分配之前，先计算此次资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源分配给进程；否则，让进程等待。</p><p>解除：</p><ul><li>剥夺资源：从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态</li><li>撤消进程：可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态消除为止；所谓代价是指优先级、运行代价、进程的重要性和价值等。</li></ul><h3 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h3><p>由于需要限制不同程序之间的访问能力，防止获取别的内存数据进行随意读写，产生了用户态和内核态。当程序需要申请外部资源就会由用户态进入内核态。</p><p>内核态：系统程序在内核态运行。该状态下，CPU可以访问内存的所有数据，包括外围设备，例如硬盘、网卡等。</p><p>用户态：应用程序只在用户态运行。该状态下只能受限的访问内存且不允许访问外设，占用CPU的能力被剥夺，导致CPU资源可以被其他程序获得。</p><p>用户态切换内核态：</p><ol><li>系统调用：进程主动要求切换到内核态的一种方式，很多事情直接让程序去做是很危险的，于是内核态提供一些系统调用，程序通过这些系统调用让危险的事交由内核来执行。如fork，open，write，malloc等。</li><li>异常：<strong>异常是由CPU产生的</strong>，用户态程序发生未知异常，如常见的运行错误，除0，地址访问错误等等，转换到内核态处理此异常的相关程序中。如缺页异常。</li><li>中断：<strong>中断是由硬件设备产生的</strong>，设备完成用户请求操作后，会向CPU发出中断信号，然后内核放下手头的工作去处理中断信号。如硬盘读写结束后，发出中断信号，内核态处理该信号。</li></ol><h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p>kill掉子进程，父进程会收到SIGCHILD信号，子进程变成僵尸进程。</p><p>一个子进程结束了，但父进程还活着。因为内核认为父进程可能还需要子进程的一些信息，所以就没有将他关闭。</p><p>解决掉僵尸进程方式有：重启电脑，或者把父进程kill掉。</p><p>我们应该坚决不允许僵尸进程的存在。所以对于fork行为，我们应该拦截到SIGCHILD信号，然后使用waitpid获取子进程终止状态（返回0表示获取到子进程已被关闭）。</p><p><strong>孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</strong></p><p><strong>守护进程：一般来说生存周期长，随着操作系统一起开启和关闭。与终端无关联，不会占用终端。</strong></p><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。<strong>但协程的特点在于是一个线程执行。</strong></p><p>和多线程比，协程最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。</p><p>第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：按要求补齐数组</title>
      <link href="2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%8C%89%E8%A6%81%E6%B1%82%E8%A1%A5%E9%BD%90%E6%95%B0%E7%BB%84.html"/>
      <url>2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%8C%89%E8%A6%81%E6%B1%82%E8%A1%A5%E9%BD%90%E6%95%B0%E7%BB%84.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个已排序的正整数数组 $nums$，和一个正整数 $n$ 。从 $[1, n]$ 区间内选取任意个数字补充到 $nums$ 中，使得 $[1, n]$ 区间内的任何数字都可以用 $nums$ 中某几个数字的和来表示。请输出满足上述要求的最少需要补充的数字个数。</p><h2 id="Soluiton"><a href="#Soluiton" class="headerlink" title="Soluiton"></a>Soluiton</h2><p>容易证明，对于正整数 $x$，如果区间 $[1,x−1]$ 内的所有数字都已经被覆盖，且 $x$ 在数组中，则区间 $[1,2x−1]$ 内的所有数字也都被覆盖。<br><a id="more"></a> </p><p>由此可以提出一个贪心的方案。每次找到未被数组 $nums$ 覆盖的最小的整数 $x$，在数组中补充 $x$，然后寻找下一个未被覆盖的最小的整数，重复上述步骤直到区间 $[1,n]$ 中的所有数字都被覆盖。</p><p>具体实现：</p><p>$x$ 表示当前能表示出 $[1, x - 1]$ 的所有数字，初始化为 $1$，枚举数组。</p><ul><li>若枚举到的数小等于 $x$，则加上，表示能表示出 $[1, x + num[i] - 1]$ 的所有数字，然后下标加 $1$</li><li>若枚举到的数大于 $x$，则说明 $x$ 无法被表示出来，我们需要增加一个数 $x$，然后$x$ 加上 $x$，表示能表示出 $[1, x + x - 1]$ 的所有数字</li></ul><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPatches</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, i = <span class="number">0</span>, m = a.size();</span><br><span class="line">        <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; m &amp;&amp; a[i] &lt;= x) &#123;</span><br><span class="line">                x += a[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                x *= <span class="number">2</span>;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：最大矩形</title>
      <link href="2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2.html"/>
      <url>2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个仅包含 $0$ 和 $1$ 、大小为 $n * m$ 的二维二进制矩阵，找出只包含 $1$ 的最大矩形，并返回其面积。$(n, m \in [1, 200])$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>有一个子问题，求柱状图最大矩形。预先求出 $1-i$ 层的 $h[i]$ 然后利用套用子问题的模板即可，复杂度 $O(n * m)$.<br><a id="more"></a> </p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; h)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        st.push(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> n = h.size();</span><br><span class="line">        vector&lt;int&gt; l(n), r(n, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (st.top() != <span class="number">-1</span> &amp;&amp; h[st.top()] &gt;= h[i]) &#123;</span><br><span class="line">                r[st.top()] = i;</span><br><span class="line">                st.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            l[i] = st.top();</span><br><span class="line">            st.push(i); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) res = max(res, (r[i] - l[i] - <span class="number">1</span>) * h[i]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = a[<span class="number">0</span>].size(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">h</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) </span><br><span class="line">                h[j] = (a[i][j] == <span class="string">&#x27;1&#x27;</span> ? h[j] + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">            res = max(res, largestRectangleArea(h));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：共鸣问题</title>
      <link href="2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%85%B1%E9%B8%A3%E9%97%AE%E9%A2%98.html"/>
      <url>2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%85%B1%E9%B8%A3%E9%97%AE%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>现在有 $n$ 个音符和 $m$ 对共鸣关系，编号为 $1-n$，每个音符自己有一个奏响时的优美程度，共鸣关系 $(x,y,z)$ 表示音符 $x$ 和 $y$ 同时奏响的额外优美程度是 $z$，同时不奏响则为 $-z$，其他情况为 $0$，求最大优美程度。$(n,m \in [1,1e5])$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对于一对共鸣关系而言，在不选的情况下收益为 $-z$，则选择一个的话，收益为 $-z + z = 0$，都选择的话为 $-z + 2z = z$。因此可以预先把每对关系的两个数都加上 $z$，刚开始我们是不选任何有联系的音符的，因此初值为 $-z$，那么选择一个数就会加上 $z$，选择两个就会加上 $2z$，满足了之前所讨论的关系。答案初始化为所有关系都不选的情况，即 $-sum(z)$，然后只要贪心的选择对答案有正贡献的值就行了。<br><a id="more"></a> </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param n int整型 </span></span><br><span class="line"><span class="comment">     * @param m int整型 </span></span><br><span class="line"><span class="comment">     * @param a int整型vector </span></span><br><span class="line"><span class="comment">     * @param b int整型vector&lt;vector&lt;&gt;&gt; </span></span><br><span class="line"><span class="comment">     * @return long长整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">wwork</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; c;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : a) c.push_back(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : b) &#123;</span><br><span class="line">            c[v[<span class="number">0</span>] - <span class="number">1</span>] += v[<span class="number">2</span>];</span><br><span class="line">            c[v[<span class="number">1</span>] - <span class="number">1</span>] += v[<span class="number">2</span>];</span><br><span class="line">            res -= v[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : c) res += max(x, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：大逃离</title>
      <link href="2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%A4%A7%E9%80%83%E7%A6%BB.html"/>
      <url>2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%A4%A7%E9%80%83%E7%A6%BB.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>从 $n$ 个数中任选 $k$ 个数，取得这 $k$ 个数中最大的一个数，求每个数被取得的概率。$(n, k \in [1, 2e5])$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>将数组排序后，枚举每个数被作为最大值的可能性，当第 $i$ 个数作为最大值时，其它 $k - 1$ 个一定从前 $i - 1$ 个里面选，即方案数为 $C(i - 1, k - 1)$，将其除以总方案数 $C(n, k)$ 即为被取得概率。<br><a id="more"></a> </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param n int整型 </span></span><br><span class="line"><span class="comment">     * @param k int整型 </span></span><br><span class="line"><span class="comment">     * @param Point int整型vector </span></span><br><span class="line"><span class="comment">     * @return int整型vector</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> f[<span class="number">200005</span>];</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">qp</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (b) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b &amp; <span class="number">1</span>) sum = sum * a % mod;</span><br><span class="line">            a = a * a % mod;</span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == m || m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> f[n] * qp(f[m], mod - <span class="number">2</span>) % mod * qp(f[n - m], mod - <span class="number">2</span>) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">city</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">auto</span> b = a;</span><br><span class="line">        sort(a.begin(), a.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">long</span> <span class="keyword">long</span>&gt; mp;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= <span class="number">200000</span>; ++i) &#123;</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &gt;= k) </span><br><span class="line">                mp[a[i]] = C(i, k - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = C(n, k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            g.push_back(mp[b[i]] * qp(sum, mod - <span class="number">2</span>) % mod);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> g;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GCC编译器和GDB调试器</title>
      <link href="2020/12/GCC%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8CGDB%E8%B0%83%E8%AF%95%E5%99%A8.html"/>
      <url>2020/12/GCC%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8CGDB%E8%B0%83%E8%AF%95%E5%99%A8.html</url>
      
        <content type="html"><![CDATA[<h2 id="GCC编译器"><a href="#GCC编译器" class="headerlink" title="GCC编译器"></a>GCC编译器</h2><p>GCC 编译器支持编译 Go、Objective-C，Objective-C++，Fortran，Ada，D 和 BRIG（HSAIL）等程序。</p><p>实际使用中，使用 gcc 指令编译 C 代码，使用 g++ 指令编译 C++ 代码。</p><h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p>例如 <strong>g++ test.cpp -o test</strong> 可拆解为以下步骤：</p><a id="more"></a> <ol><li><p>预处理：处理以 # 开头的预处理命令</p> <figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># -E 选项指示编译器仅对输入文件进行预处理</span></span><br><span class="line"><span class="meta"># test.i 文件将头文件及宏定义具体内容全部展开，其余保持不变</span></span><br><span class="line">g++ -E test.cpp -o test.i    <span class="comment">// 生成.i文件</span></span><br></pre></td></tr></table></figure></li><li><p>编译：翻译成汇编文件</p> <figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># -S 编译选项告诉 g++ 在为 C++ 代码产生了汇编语言文件后停止编译</span></span><br><span class="line"><span class="meta"># g++ 产生的汇编语言文件缺省拓展名是 .s</span></span><br><span class="line"><span class="meta"># test.s 汇编语言文件内容为汇编指令</span></span><br><span class="line">g++ -S test.i -o test.s</span><br></pre></td></tr></table></figure></li><li><p>汇编：将汇编文件翻译成可重定位目标文件</p> <figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># -c 选项告诉 g++ 仅把源代码编译为机器语言的目标代码</span></span><br><span class="line"><span class="meta"># 缺省时 g++ 建立的目标代码文件有一个 .o 的拓展名</span></span><br><span class="line"><span class="meta"># test.o 为机器语言识别的二进制代码</span></span><br><span class="line">g++ -c test.s -o test.o</span><br></pre></td></tr></table></figure></li><li><p>链接：将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -o 编译选项来为将产生的可执行文件用指定的文件名</span></span><br><span class="line"><span class="comment"># test 为可执行文件</span></span><br><span class="line">g++ <span class="keyword">test</span>.o -o <span class="keyword">test</span></span><br></pre></td></tr></table></figure><h3 id="静态链接和动态链接"><a href="#静态链接和动态链接" class="headerlink" title="静态链接和动态链接"></a>静态链接和动态链接</h3><p>动态库一般都会存在/usr/lib/ 目录下；而静态库可以在任何目录下，只要你第一次链接的时候，用绝对路径去链接就行了，之后再删除，是不会影响你的生成的执行文件的。</p></li></ol><p>当然动态库和静态库可以放置到你想放的任何地方，只是动态库需要设置环境变量，而静态库链接的时候需要绝对路径。</p><p><strong>静态连接：</strong><br>源文件中包含的头文件和程序中使用到的库函数，如stdio.h中定义的printf()函数，在libc.a中找到目标文件printf.o(这里暂且不考虑printf()函数的依赖关系)，然后将这个目标文件和我们hello.o这个文件进行链接形成我们的可执行文件。</p><p>可以发现静态运行库里面的一个目标文件只包含一个函数，如libc.a里面的printf.o只有printf()函数，strlen.o里面只有strlen()函数。因为如果很多函数都放在一个目标文件中，很可能很多没用的函数都被一起链接进了输出结果中，十分浪费空间。</p><p>缺点是浪费空间，因为每一个可执行程序都需要堆关联的静态库目标文件有一份拷贝，因此同一个目标文件可能在内存里就有多次拷贝。一旦代码修改，也得重新进行编译。<br>优点就是可执行程序已经具备了这些库文件，因此运行时的速度更快。</p><p><strong>动态连接：</strong><br>简单来说就是目标文件不会在链接阶段链接，而是推迟到了运行时，检查相关目标文件是否已经存在于内存之中，即共享一份副本。</p><p>也就是生成的可执行文件并没有要链接的内容，代码运行后再去找，这时候如果动态库被删除，就无法成功运行。 </p><p>优点是空间占用更少，缺点是运行时效率降低，但一般不超过5%，因此可以忽略。</p><h3 id="g-重要编译参数"><a href="#g-重要编译参数" class="headerlink" title="g++重要编译参数"></a>g++重要编译参数</h3><ol><li><p>-g 编译带调试信息的可执行文件</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -g 选项告诉 GCC 产生能被 GNU 调试器 GDB 使用的调试信息，以调试程序。</span></span><br><span class="line"><span class="comment"># 产生带调试信息的可执行文件 test（不加则 test 不包含调试信息）</span></span><br><span class="line">g++ -g <span class="keyword">test</span>.cpp -o <span class="keyword">test</span></span><br></pre></td></tr></table></figure></li><li><p>-O[n] 优化源代码</p> <figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 所谓优化，比如省略代码中从未使用过的变量，直接将常量表达式用结果值来替代等等，这些操作会缩减目标文件所包含的代码量，提高最终生成的可执行文件的运行效率。</span></span><br><span class="line"><span class="meta"># -O 选项告诉 g++ 对源代码进行基本优化。这些操作在大多数情况下都会使程序执行的更快。-O2 选项告诉 g++ 产生尽可能小和尽可能快的代码。</span></span><br><span class="line"><span class="meta"># -O 同时减小代码长度和执行时间，效果等价为 -O1</span></span><br><span class="line"><span class="meta"># -O0 表示不做优化</span></span><br><span class="line"><span class="meta"># -O1 默认优化</span></span><br><span class="line"><span class="meta"># -O2 除了完成 -O1 的优化之外，还进行一些额外的调整工作，如指令调整等</span></span><br><span class="line"><span class="meta"># -O3 包括循环展开和其他一些与处理特性相关的优化操作</span></span><br><span class="line"><span class="meta"># 选项将使编译的速度比使用 -O 时慢，但通常产生的代码执行速度会更快</span></span><br><span class="line"><span class="meta"># 可以用如 &quot;time ./test&quot; 来查看可执行文件的运行效率，比较优化效果</span></span><br><span class="line">g++ -O2 test.cpp</span><br></pre></td></tr></table></figure></li><li><p>-l 和 -L 指定库文件 ｜ 指定库文件路径</p> <figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># -l 参数就是用来指定程序要链接的库，-l 参数紧接着就是库名</span></span><br><span class="line"><span class="meta"># 在 /lib 和 /usr/lib 和 /usr/local/lib 里的库可以直接用 -l 来进行链接</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 链接 glog库</span></span><br><span class="line">g++ -lglog test.cpp</span><br><span class="line"></span><br><span class="line"><span class="meta"># 如果库文件没放在上面三个目录里，需要使用 -L 参数指定库文件所在目录</span></span><br><span class="line"><span class="meta"># -L 参数紧接着的是库文件所在的目录名</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 链接 mytest 库，libmytest.so 在 /home/Test 目录下</span></span><br><span class="line">g++ -L/home/Test -lmytest test.cpp</span><br></pre></td></tr></table></figure></li><li><p>-I 指定头文件搜索目录</p> <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 若头文件在 /usr/<span class="keyword">include</span> 目录下一般是不需要指定的，否则就需要 -I 参数来指定了，比如头文件放在 /myinclude 目录里，否则会报错 “xxxx.<span class="keyword">h</span>: <span class="keyword">No</span> such <span class="keyword">file</span> or directory” 。</span><br><span class="line"><span class="keyword">g</span>++ -I/myinclude <span class="keyword">test</span>.cpp</span><br></pre></td></tr></table></figure></li><li><p>-Wall 打印警告信息 | -w 关闭警告信息</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印出 gcc 的警告信息</span></span><br><span class="line">g++ -Wall <span class="keyword">test</span>.cpp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭所有警告信息</span></span><br><span class="line">g++ -w <span class="keyword">test</span>.cpp</span><br></pre></td></tr></table></figure></li><li><p>-std=c++11 设置编译标准</p> <figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span> <span class="comment">使用</span> <span class="comment">c</span>++<span class="comment">11</span> <span class="comment">标准编译</span> <span class="comment">test</span><span class="string">.</span><span class="comment">cpp</span></span><br><span class="line"><span class="comment">g</span>++ <span class="literal">-</span><span class="comment">std=c</span>++<span class="comment">11</span> <span class="comment">test</span><span class="string">.</span><span class="comment">cpp</span></span><br></pre></td></tr></table></figure></li><li>-o 指定输出文件名 <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定即将产生的文件名</span></span><br><span class="line"><span class="comment"># 指定输出可执行文件名为test</span></span><br><span class="line">g++ <span class="keyword">test</span>.cpp -o <span class="keyword">test</span></span><br></pre></td></tr></table></figure></li><li><p>-D 定义宏</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 在使用gcc/g++编译的时候定义宏</span><br><span class="line"># 常用场景：</span><br><span class="line"># -DDEBUG 定义 DEBUG 宏，可能文件中有DEBUG宏部分的相关信息，用 DDEBUG 来选择开启或关闭 DEBUG</span><br><span class="line"># 举例：</span><br><span class="line"><span class="comment">// -Dname 定义宏 name，默认定义内容为字符串 “1”</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;DEBUG LOG\n&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;in\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1. 在编译的时候，使用g++ -DDEBUG main.cpp</span></span><br><span class="line"><span class="comment">// 2. 第七行代码可以被执行</span></span><br></pre></td></tr></table></figure><h2 id="GDB调试器"><a href="#GDB调试器" class="headerlink" title="GDB调试器"></a>GDB调试器</h2></li></ol><p>GDB(GNU Debugger) 是一个用来调试C/C++程序的功能强大的调试器，是 Linux 系统开发 C/C++ 最常用的调试器。</p><p>GDB主要功能：</p><ul><li>设置断点(断点可以是条件表达式)</li><li>使程序在指定的代码行上暂停执行，便于观察</li><li>单步执行程序，便于调试</li><li>查看程序中变量值的变化</li><li>动态改变程序的执行环境</li><li>分析崩溃程序产生的core文件</li></ul><p>调试开始：执行gdb [filename] ，进入gdb调试程序，其中 filename 为要调试的可执行文件名。</p><p>编译程序时需要加上 -g，之后才能用 gdb 进行调试：g++ -g main.cpp -o main<br>回车键：重复上一命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">help</span>(h)        <span class="comment"># 查看命令帮助，具体命令查询在gdb中输入help + 命令</span></span> </span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)run(r)         <span class="comment"># 重新开始运行文件（run-text：加载文本文件，run-bin：加载二进制文件）</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)start          <span class="comment"># 单步执行，运行程序，停在第一行执行语句</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)list(l)        <span class="comment"># 查看原代码（list-n,从第n行开始查看代码。list+ 函数名：查看具体函数）</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">set</span>            <span class="comment"># 设置变量的值</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)next(n)        <span class="comment"># 单步调试（逐过程，函数直接执行）</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)step(s)        <span class="comment"># 单步调试（逐语句：跳入自定义函数内部执行）</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)backtrace(bt)  <span class="comment"># 查看函数的调用的栈帧和层级关系</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)frame(f)       <span class="comment"># 切换函数的栈帧</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)info(i)        <span class="comment"># 查看函数内部局部变量的数值</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)finish         <span class="comment"># 结束当前函数，返回到函数调用点</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">continue</span>(c)    <span class="comment"># 继续运行</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">print</span>(p)       <span class="comment"># 打印值及地址</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)quit(q)        <span class="comment"># 退出gdb</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">break</span>+num(b)                 <span class="comment"># 在第num行设置断点</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)info breakpoints             <span class="comment"># 查看当前设置的所有断点</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)delete breakpoints num(d)    <span class="comment"># 删除第num个断点</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)display                      <span class="comment"># 追踪查看具体变量值</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)undisplay                    <span class="comment"># 取消追踪观察变量</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)watch                        <span class="comment"># 被设置观察点的变量发生修改时，打印显示</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)i watch                      <span class="comment"># 显示观察点</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">enable</span> breakpoints           <span class="comment"># 启用断点</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">disable</span> breakpoints          <span class="comment"># 禁用断点</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)x                            <span class="comment"># 查看内存x/20xw 显示20个单元，16进制，4字节每单元</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)run argv[1] argv[2]          <span class="comment"># 调试时命令行传参</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">set</span> follow-fork-mode child   <span class="comment"># Makefile项目管理：选择跟踪父子进程（fork()）</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：区间和的个数</title>
      <link href="2020/11/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%8C%BA%E9%97%B4%E5%92%8C%E7%9A%84%E4%B8%AA%E6%95%B0.html"/>
      <url>2020/11/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%8C%BA%E9%97%B4%E5%92%8C%E7%9A%84%E4%B8%AA%E6%95%B0.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 $a$，返回区间和在 $[lower, upper]$ 之间的个数，包含 $lower$ 和 $upper$。<br>区间和 $S(i, j)$ 表示在 $a$ 中，位置从 $i$ 到 $j$ 的元素之和，包含 $i$ 和 $j$ $(i ≤ j)$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><a id="more"></a> <p>维护前缀和，对于每个前缀和 $sum[i]$，等价于 $sum[0…i-1]$ 里面有多少个数满足差值在 $[lower, upper]$ 之间。</p><p>$sum[i] - sum[j] = [lower, upper]$ 等价于求出现在区间 $sum[j] \in [sum[i] - upper, sum[i] - lower]$ 的数的个数，故可以用树状数组维护。</p><p>遍历前缀和数组，对于当前前缀和 $sum[i]$，满足的个数便为：$query(sum[i] - lower) - query(sum[i] - upper - 1)$，累加答案即可。</p><p>由于数很大，故需要将所有出现的数离散化。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BIT</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span>* c;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        BIT(<span class="keyword">int</span> _n) &#123;</span><br><span class="line">            n = _n;</span><br><span class="line">            c = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) c[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">                c[x]++;</span><br><span class="line">                x += lowbit(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x) &#123;</span><br><span class="line">                sum += c[x];</span><br><span class="line">                x -= lowbit(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countRangeSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> lower, <span class="keyword">int</span> upper)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> m = a.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> *sum = <span class="keyword">new</span> <span class="keyword">long</span> <span class="keyword">long</span>[m + <span class="number">1</span>];</span><br><span class="line">        sum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i) sum[i] = sum[i - <span class="number">1</span>] + a[i - <span class="number">1</span>];</span><br><span class="line">            s.insert(sum[i]);</span><br><span class="line">            s.insert(sum[i] - upper);</span><br><span class="line">            s.insert(sum[i] - lower);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">int</span> n = s.size(), idx = <span class="number">0</span>;</span><br><span class="line">        <span class="function">BIT <span class="title">bit</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : s) mp[x] = ++idx;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = mp[sum[i] - upper], r = mp[sum[i] - lower];</span><br><span class="line">            res += bit.query(r) - bit.query(l - <span class="number">1</span>);</span><br><span class="line">            bit.add(mp[sum[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++内存管理</title>
      <link href="2020/11/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"/>
      <url>2020/11/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html</url>
      
        <content type="html"><![CDATA[<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="内存管理详解"><a href="#内存管理详解" class="headerlink" title="内存管理详解"></a>内存管理详解</h3><h4 id="内存分配方式"><a href="#内存分配方式" class="headerlink" title="内存分配方式"></a>内存分配方式</h4><h5 id="分配方式简介"><a href="#分配方式简介" class="headerlink" title="分配方式简介"></a>分配方式简介</h5><p>在C++中，内存分为5个区：</p><ol><li>栈：执行函数时，函数内部局部变量存储单元在栈上创建，结束时自动释放。效率很高，但存储容量有限。</li><li>堆：由 <strong>new</strong> 分配的内存块，编译器不会自动释放，需要应用程序对应的 <strong>delete</strong> 进行释放。如果没有释放，则程序运行结束后会由操作系统自动回收。</li><li>自由存储区：由 <strong>malloc</strong> 等分配的内存块，类似堆，由 <strong>free</strong> 结束自己的生命。</li><li>全局/静态存储区：存储全局变量和静态变量。</li><li>常量存储区：存放常量，不允许修改。</li></ol><a id="more"></a> <h5 id="明确区分堆和栈"><a href="#明确区分堆和栈" class="headerlink" title="明确区分堆和栈"></a>明确区分堆和栈</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在栈内存中存放了一个指向一块堆内存的指针 p。程序会先确定在堆中分配内存的大小，然后调用 <strong>operator new</strong> 分配内存，然后返回这块内存的首地址，放入栈中。</p><p>这里并没有释放内存，因此需要 <strong>delete[] p</strong>，告诉编译器删除的是数组，然后编译器根据Cookie信息去释放内存。</p><h5 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h5><ol><li>管理方式：栈由编译器自动管理，无需手动控制；堆的释放工作由程序员控制，容易产生内存泄露。</li><li>空间大小：堆栈的内存都可以自己设定，堆内存一般不超过系统内存都是可以申请，栈内存个人测试默认值为8M。</li><li>碎片问题：对于堆而言，频繁的 <strong>new/delete</strong> 势必会造成内存空间的不连续，造成大量的碎片，使程序的效率降低；对于栈而言，则不会发生这样的情况，先进后出排列有序，以至于永远不可能有一个内存块从非栈顶位置弹出。</li><li>生长方向：对于堆而言，生长方向向上，向着内存地址增加的方向增长；对于栈而言，生长方向向下，向着内存地址减小的方向增长。</li><li>分配方式：堆都是动态分配的，没有静态分配的堆。栈有动态分配和静态分配两种，静态分配由编译器完成，比如局部变量的分配；动态分配由 <strong>alloca</strong> 函数进行分配，都由编译器进行释放。</li><li>分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持，这就决定了栈的效率比较高。堆则是 C/C++ 函数库提供的，机制比较复杂，用到许多算法的实现内存的分配。显然，堆的效率比栈要低得多。</li></ol><p>因此，更推荐尽量使用栈而不是堆。但是栈和堆相比并不灵活。如果需要分配大量内存空间，还是堆好一些。</p><h4 id="控制-C-的内存分配"><a href="#控制-C-的内存分配" class="headerlink" title="控制 C++ 的内存分配"></a>控制 C++ 的内存分配</h4><p>无论如何，一定要保守的使用内存分配。<br>一个防止堆破碎的通用方法是从不同固定大小的内存池中分配不同类型的对象。对每个类重载 <strong>new</strong> 和 <strong>delete</strong> 就提供了这样的控制。</p><h5 id="重载全局的new和delete操作"><a href="#重载全局的new和delete操作" class="headerlink" title="重载全局的new和delete操作"></a>重载全局的new和delete操作</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">void</span> *p = <span class="built_in">malloc</span>(size); </span><br><span class="line">    <span class="keyword">return</span> (p); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *p)</span></span>; </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">free</span>(p); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以对单个类的 new 和 delete 操作符重载。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *p)</span></span>; </span><br><span class="line">    <span class="comment">// .. other members here ... </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">void</span> *TestClass::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">void</span> *p = <span class="built_in">malloc</span>(size); <span class="comment">// Replace this with alternative allocator </span></span><br><span class="line">    <span class="keyword">return</span> (p); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> TestClass::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *p)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">free</span>(p); <span class="comment">// Replace this with alternative de-allocator</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="为单个类重载-new-和-delete"><a href="#为单个类重载-new-和-delete" class="headerlink" title="为单个类重载 new[] 和 delete[]"></a>为单个类重载 new[] 和 delete[]</h5><p>C++将对象数组的内存分配作为一个单独的操作，而不同于单个对象的内存分配。为了改变这种方式，同样需要重载 new[] 和 delete[]操作符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">void</span> * <span class="keyword">operator</span> <span class="keyword">new</span>[ ](<span class="keyword">size_t</span> size); </span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[ ](<span class="keyword">void</span> *p); </span><br><span class="line">    <span class="comment">// .. other members here .. </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">void</span> *TestClass::<span class="keyword">operator</span> <span class="keyword">new</span>[ ](<span class="keyword">size_t</span> size) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">void</span> *p = <span class="built_in">malloc</span>(size); </span><br><span class="line">    <span class="keyword">return</span> (p); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">void</span> TestClass::<span class="keyword">operator</span> <span class="keyword">delete</span>[ ](<span class="keyword">void</span> *p) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">free</span>(p); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    TestClass *p = <span class="keyword">new</span> TestClass[<span class="number">10</span>]; </span><br><span class="line">    <span class="comment">// ... etc ... </span></span><br><span class="line">    <span class="keyword">delete</span>[ ] p; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：对于多数 C++ 的实现，<strong>new[]</strong> 操作符中的个数参数是数组的大小加上额外的存储对象数目的一些字节。因此应该尽量避免分配对象数组，使内存分配策略简单。</p><h4 id="常见的内存错误"><a href="#常见的内存错误" class="headerlink" title="常见的内存错误"></a>常见的内存错误</h4><ol><li>内存分配未成功，却使用了它。<ul><li>如果是用 malloc 或 new 来申请内存，应该用 if(p==NULL) 或 if(p!=NULL)进行防错。</li></ul></li><li>内存分配虽然成功，但未初始化就引用它。<ul><li>无论用何种方式创建数组，都要赋初值，即便是零值。</li></ul></li><li>内存分配成功并且已经初始化，但操作越界。<ul><li>多发生在下标“多1”或“少1”。</li></ul></li><li>忘记了释放内存，造成内存泄漏。<ul><li>动态内存的申请与释放必须配对，程序中 <strong>malloc</strong> 与 <strong>free</strong> 的使用次数一定要相同，否则肯定有错误（new/delete同理）。</li></ul></li><li>释放了内存却继续使用它。<ul><li>程序过于复杂，难以分清是否释放了内存，此时应当重新设计数据结构，解决混乱。</li><li>return语句写错，不要返回指向“栈内存”的指针或引用，因为该内存在函数体结束时被自动销毁。</li><li>free或delete释放内存后，没有将指针设为NULL，导致“野指针”。</li></ul></li></ol><h4 id="指针与数组对比"><a href="#指针与数组对比" class="headerlink" title="指针与数组对比"></a>指针与数组对比</h4><p>数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。数组名对应着（<strong>而不是指向</strong>）一块内存，其地址和容量在生命周期内保持不变，只有数组的内容可以改变。</p><p>指针可以随时指向任何类型的内存块，它的特征是“可变”的，所以常用指针来操作动态内存，指针远比数组灵活，但也更危险。</p><h5 id="修改数组内容"><a href="#修改数组内容" class="headerlink" title="修改数组内容"></a>修改数组内容</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[] = “hello”; </span><br><span class="line">a[<span class="number">0</span>] = ‘X’; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"><span class="comment">// 可以拆分为 char s[] = &quot;world&quot;; char *p = str;</span></span><br><span class="line"><span class="keyword">char</span> *p = “world”; <span class="comment">// 注意 p 指向常量字符串</span></span><br><span class="line">p[<span class="number">0</span>] = ‘X’; <span class="comment">// 编译器不能发现该错误，但运行时产生[Bus error]</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h5 id="内容复制与比较"><a href="#内容复制与比较" class="headerlink" title="内容复制与比较"></a>内容复制与比较</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组… </span></span><br><span class="line"><span class="keyword">char</span> a[] = <span class="string">&quot;hello&quot;</span>; </span><br><span class="line"><span class="keyword">char</span> b[<span class="number">10</span>]; </span><br><span class="line"><span class="built_in">strcpy</span>(b, a); <span class="comment">// 不能用 b = a; </span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(b, a) == <span class="number">0</span>) <span class="comment">// 不能用 if (b == a) </span></span><br><span class="line">… </span><br><span class="line"><span class="comment">// 指针… </span></span><br><span class="line"><span class="comment">// 语句 p = a 并不能把 a 的内容复制给指针 p，而是把 a 的地址赋给了 p。</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(a); </span><br><span class="line"><span class="keyword">char</span> *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*(len+<span class="number">1</span>)); </span><br><span class="line"><span class="built_in">strcpy</span>(p, a); <span class="comment">// 不要用 p = a; </span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(p, a) == <span class="number">0</span>) <span class="comment">// 不要用 if (p == a) </span></span><br></pre></td></tr></table></figure><h5 id="计算内存容量"><a href="#计算内存容量" class="headerlink" title="计算内存容量"></a>计算内存容量</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[] = <span class="string">&quot;hello world&quot;</span>; </span><br><span class="line"><span class="keyword">char</span> *p = a; </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(a) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 12 字节</span></span><br><span class="line"><span class="comment">// sizeof(p) 等价于 sizeof(char *)，没有办法的值指针所指的内存容量，除非申请内存时就记住它</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(p) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 4 字节</span></span><br></pre></td></tr></table></figure><p>注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(<span class="keyword">char</span> a[<span class="number">100</span>])</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// 不论数组 a 的容量是多少，sizeof(a)始终等于 sizeof(char *)。</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(a) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 4 字节而不是 100 字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="指针参数如何传递内存"><a href="#指针参数如何传递内存" class="headerlink" title="指针参数如何传递内存"></a>指针参数如何传递内存</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetMemory</span><span class="params">(<span class="keyword">char</span> *p, <span class="keyword">int</span> num)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    p = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * num); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>; </span><br><span class="line">    GetMemory(str, <span class="number">100</span>); <span class="comment">// str 仍然为 NULL </span></span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello&quot;</span>); <span class="comment">// 运行错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.benboby.top/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%89%AF%E6%9C%AC.png" alt></p><p>如果函数的参数是一个指针，不要指望用该指针去申请动态内存。编译器总是要为函数的每个参数制作临时副本，指针参数 p 的副本是 _p，编译器使 _p = p。如果函数体内的程序修改了_p 的内容，就导致参数 p 的内容作相应的修改。这就是指针可以用作输出参数的原因。_p 申请了新的内存，只是把 _p 所指的内存地址改变了，但是 p 丝毫未变。所以函数 GetMemory 并不能输出任何东西。事实上，每执行一次 GetMemory 就会泄露一块内存，因为没有用 free 释放内存。</p><p>如果非得要用指针参数去申请内存，那么应该改用“指向指针的指针”:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetMemory2</span><span class="params">(<span class="keyword">char</span> **p, <span class="keyword">int</span> num)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * num); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test2</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>; </span><br><span class="line">    GetMemory2(&amp;str, <span class="number">100</span>); <span class="comment">// 注意参数是 &amp;str，而不是 str </span></span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello&quot;</span>); </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; str &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">free</span>(str); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="/2020/11/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.htm/指针的指针.png" alt></p><p>比较好的方法是 <strong>传指针的引用</strong>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetMemory</span><span class="params">(<span class="keyword">char</span> *&amp;p, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    GetMemory(str, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">free</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以用函数返回值来传递动态内存。这种方法更加简单：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">GetMemory3</span><span class="params">(<span class="keyword">int</span> num)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * num); </span><br><span class="line">    <span class="keyword">return</span> p; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test3</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>; </span><br><span class="line">    str = GetMemory3(<span class="number">100</span>); </span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello&quot;</span>); </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; str &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">free</span>(str); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在使用返回值时，千万别返回 <strong>指向“栈内存”</strong> 的指针、引用，因为该内存在函数结束时 <strong>自动消亡</strong> 了，返回的指针是个野指针了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">GetString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> p[] = <span class="string">&quot;hello world&quot;</span>; <span class="comment">//数组内容存储在栈区，函数结束时，会释放掉</span></span><br><span class="line">     <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    str = GetString();      <span class="comment">//因为非配的内存早已释放掉，此时的str是个野指针，内容是垃圾</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在函数中不定义数组，定义指针：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">GetString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> *p = <span class="string">&quot;hello world&quot;</span>; <span class="comment">//数组内容存储在静态区，函数结束时，不会释放掉</span></span><br><span class="line">     <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    str = GetString();      </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h4 id="杜绝“野指针”"><a href="#杜绝“野指针”" class="headerlink" title="杜绝“野指针”"></a>杜绝“野指针”</h4><p>“野指针”不是 NULL 指针，是指向“垃圾”内存的指针。“野指针”是很危险的，if 语句对它不起作用。出现的原因有：</p><ol><li>指针变量没有被初始化。任何指针变量刚被创建时不会自动成为 NULL 指针，它的缺省值是随机的。所以，指针变量在创建的同时应当被初始化，要么将指针设置为 NULL，要么让它指向合法的内存。</li><li>指针 p 被 free 或者 delete 之后，没有置为 NULL，让人误以为 p 是个合法的指针。</li><li>指针操作超越了变量的作用域范围。</li></ol><h4 id="有了-malloc-free-为什么还要-new-delete？"><a href="#有了-malloc-free-为什么还要-new-delete？" class="headerlink" title="有了 malloc/free 为什么还要 new/delete？"></a>有了 malloc/free 为什么还要 new/delete？</h4><p><strong>malloc 与 free</strong> 是 C++/C 语言的标准库函数，<strong>new/delete</strong> 是 C++ 的运算符。它们都可用于申请动态内存和释放内存。<br>对于非内部数据类型的对象而言，光用 <strong>malloc/free</strong> 无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于 <strong>malloc/free</strong> 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于 <strong>malloc/free</strong>。<br>而C++程序经常要调用 C 函数，而 C 程序只能用 <strong>malloc/free</strong> 管理动态内存，因此不能只用 <strong>new/delete</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">public</span> : </span><br><span class="line">    Obj(<span class="keyword">void</span>)&#123; <span class="built_in">cout</span> &lt;&lt; “Initialization” &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">    ~Obj(<span class="keyword">void</span>)&#123; <span class="built_in">cout</span> &lt;&lt; “Destroy” &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Initialize</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; “Initialization” &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Destroy</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; “Destroy” &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UseMallocFree</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Obj *a = (obj *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(obj)); <span class="comment">// 申请动态内存</span></span><br><span class="line">    a-&gt;Initialize(); <span class="comment">// 初始化</span></span><br><span class="line">    <span class="comment">//… </span></span><br><span class="line">    a-&gt;Destroy(); <span class="comment">// 清除工作</span></span><br><span class="line">    <span class="built_in">free</span>(a); <span class="comment">// 释放内存</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UseNewDelete</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Obj *a = <span class="keyword">new</span> Obj; <span class="comment">// 申请动态内存并且初始化</span></span><br><span class="line">    <span class="comment">//… </span></span><br><span class="line">    <span class="keyword">delete</span> a; <span class="comment">// 清除并且释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内存耗尽怎么办？"><a href="#内存耗尽怎么办？" class="headerlink" title="内存耗尽怎么办？"></a>内存耗尽怎么办？</h4><p>如果在申请动态内存时找不到足够大的内存块，<strong>malloc</strong> 和 <strong>new</strong> 将返回 <strong>NULL</strong> 指针，表示内存申请失败。<br>处理“内存耗尽”问题，一般可以通过判断指针是否为 <strong>NULL</strong>，是的话用 <strong>return</strong> 或 <strong>exit(1)</strong> 终止整个程序的运行，也可以自己为 <strong>new 和 molloc</strong> 设置异常处理函数。<br>如果一个函数内有多处需要申请动态内存，那么应该用 <strong>exit(1)</strong> 及时终止程序。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树状数组经典题</title>
      <link href="2020/10/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%BB%8F%E5%85%B8%E9%A2%98.html"/>
      <url>2020/10/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%BB%8F%E5%85%B8%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<h2 id="一个简单的整数问题"><a href="#一个简单的整数问题" class="headerlink" title="一个简单的整数问题"></a>一个简单的整数问题</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>第一类指令形如 “C-l-r-d”，表示把数列中第 $l-r$ 个数都加 $d$。</p><p>第二类指令形如 “Q-X”，表示询问数列中第 $x$ 个数的值。<br><a id="more"></a> </p><p>对于每个询问，输出一个整数表示答案。</p><p>数据范围：$(n, m \in [1, 100000])$</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>用树状数组解决动态差分问题。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">ll c[N], a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">        c[x] += y;</span><br><span class="line">        x += lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        sum += c[x];</span><br><span class="line">        x -= lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">int</span> x, y, z;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">&quot;Q&quot;</span>) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; query(x) + a[x] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">            add(x, z);</span><br><span class="line">            add(y + <span class="number">1</span>, -z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="谜一样的牛"><a href="#谜一样的牛" class="headerlink" title="谜一样的牛"></a>谜一样的牛</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定序列长度 $n$ 和 数组 $a$，$a[i]$ 表示第 $i$ 个数前面有多少个数比它小，复原原序列，原序列为 $1-n$ 的排列。$(n \in [1, 100000])$</p><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>最后一个数的大小明显是一开始就可以推断出来的，假设其大小是 $x$，接着从 $1-n$ 这 $n$ 个数字中把 $x$ 删掉，然后再看倒数第二个数，假设其前面有 $y$ 个数比它小，说明这个数是剩下的数里面第 $y + 1$ 大的数。</p><p>由此可以发现，我们可以倒推过来，第 $i$ 个数的大小便是当前还没有被选的数中第 $a[i] + 1$ 小的数。</p><p>可以使用树状数组解决，将每个位置置为 $1$ 表示未被选，$0$ 表示已被选，得到的前缀和是单调递增的，因此每次只需要二分查找满足前缀和刚好等于 $a[i] + 1$ 的位置即为当前数的大小。</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, c[N], a[N], res[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">        c[x] += y;</span><br><span class="line">        x += lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        sum += c[x];</span><br><span class="line">        x -= lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    add(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        add(i, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n + <span class="number">1</span>, mid;</span><br><span class="line">        <span class="keyword">while</span> (l + <span class="number">1</span> &lt; r) &#123;</span><br><span class="line">            mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (query(mid) &lt; a[i] + <span class="number">1</span>) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        res[i] = r;</span><br><span class="line">        add(r, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cout</span> &lt;&lt; res[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集拓展</title>
      <link href="2020/10/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%8B%93%E5%B1%95.html"/>
      <url>2020/10/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%8B%93%E5%B1%95.html</url>
      
        <content type="html"><![CDATA[<h2 id="边带权"><a href="#边带权" class="headerlink" title="边带权"></a>边带权</h2><h3 id="银河英雄传说"><a href="#银河英雄传说" class="headerlink" title="银河英雄传说"></a>银河英雄传说</h3><p>有 $T$ 条指令，每条指令格式为以下两种之一：</p><ol><li><p>$M-i-j$，表示让第 $i$ 号战舰所在列的全部战舰保持原有顺序，接在第 $j$ 号战舰所在列的尾部。</p><a id="more"></a> </li><li><p>$C-i-j$，表示询问第 $i$ 号战舰与第 $j$ 号战舰当前是否处于同一列中，如果在同一列中，它们之间间隔了多少艘战舰。</p></li></ol><p>数据范围：$N≤30000, T≤500000$</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>维护数组 $dp$ 表示 $i$ 到 $root$ 的距离，那么查询的答案便是 $abs(dp[a] - dp[b]) - 1$。</p><p>当 $a$ 向 $b$ 连一条边时，有 $fa[a] = b$，此时根结点 $a$ 的深度会增加 $b$ 的集合大小，因此我们需要一个 $sz$ 数组维护集合大小。</p><p>同时在进行路径压缩时，对于未更新的结点也要一同更新深度。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[N], sz[N], fa[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != fa[x]) &#123;</span><br><span class="line">        <span class="keyword">int</span> root = find(fa[x]);</span><br><span class="line">        dp[x] += dp[fa[x]];</span><br><span class="line">        fa[x] = root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t, a, b;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">30000</span>; i++) &#123;</span><br><span class="line">        dp[i] = <span class="number">0</span>;</span><br><span class="line">        sz[i] = <span class="number">1</span>;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">int</span> pa = find(a), pb = find(b);</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">&quot;M&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pa != pb) &#123;</span><br><span class="line">                fa[pa] = pb;</span><br><span class="line">                dp[pa] = sz[pb];</span><br><span class="line">                sz[pb] += sz[pa];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (pa != pb) <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; max(<span class="built_in">abs</span>(dp[a] - dp[b]) - <span class="number">1</span>, <span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓展域"><a href="#拓展域" class="headerlink" title="拓展域"></a>拓展域</h2><h3 id="食物链"><a href="#食物链" class="headerlink" title="食物链"></a>食物链</h3><p>动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。</p><ol><li><p>$1-X-Y$，表示 $X$ 和 $Y$ 是同类。</p></li><li><p>$2-X-Y$，表示 $X$ 吃 $Y$。</p></li></ol><p>判断有多少句假话。$(1≤N≤50000,0≤K≤100000)$</p><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>$1-n$ 表示动物 $i$ 的同类，$n+1-2n$ 表示动物 $i$ 的猎物，$2n+1 - 3n$ 表示动物 $i$ 的天敌。</p><p>对于操作1: 查询 $x$ 和 $y$ 的天敌域，猎物域是不是在一个集合，是则累加答案，否则进行合并。</p><p>对于操作2: 查询 $x$ 和 $y$ 的同类域，猎物域是不是在一个集合，是则累加答案，否则进行合并。</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">1000005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != fa[x]) </span><br><span class="line">        fa[x] = find(fa[x]);</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    a = find(a), b = find(b);</span><br><span class="line">    <span class="keyword">if</span> (a != b) fa[a] = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k, a, b, c, res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;  i &lt;= n * <span class="number">3</span>; i++) fa[i] = i;</span><br><span class="line">    <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; c &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; n || b &gt; n) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (find(a) == find(b + n) || find(a) == find(b + <span class="number">2</span> * n)) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/// a和b是同类，a和b的猎物也是同类，a和b的天敌也是同类</span></span><br><span class="line">                join(a, b);</span><br><span class="line">                join(a + n, b + n);</span><br><span class="line">                join(a + <span class="number">2</span> * n, b + <span class="number">2</span> * n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (a == b || find(a) == find(b) || find(a) == find(b + n)) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/// a的猎物是b， b的天敌是a，b的猎物是a的天敌</span></span><br><span class="line">                join(a, b + <span class="number">2</span> * n);</span><br><span class="line">                join(a + n, b);</span><br><span class="line">                join(a + <span class="number">2</span> * n, b + n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="奇偶游戏"><a href="#奇偶游戏" class="headerlink" title="奇偶游戏"></a>奇偶游戏</h3><p>给你 $m$ 个询问，每一个询问给出一个区间的左右端点和区间中的 $1$ 的数量的奇偶性，输出不出现矛盾的最大的 $k$ 值，即 $1-k$ 无矛盾，$1- k + 1$ 矛盾。$(N≤10^9,M≤10000)$</p><h3 id="Solution1（边带权）"><a href="#Solution1（边带权）" class="headerlink" title="Solution1（边带权）"></a>Solution1（边带权）</h3><ol><li>我们可以用 $sum$ 数组表示序列 S 的前缀和,那么会得到以下性质.</li></ol><p>$s[l~r]$ 有偶数个 $1$，等价于 $sum[l-1]$ 与 $sum[r]$ 奇偶性相同 $(1+0=1,0+0=0,1是奇数,0是偶数)$<br>$s[l~r]$ 有奇数个 $1$，等价于 $sum[l-1]$ 与 $sum[r]$ 奇偶性不同 $(1+1=0,0+1=0,1是奇数,0是偶数)$</p><ol><li><p>根据传递性，可以使用边带权，边权 $d[x] = 0$，表示 $x$ 与 $f[x]$ 的奇偶性相同; 为 $1$，表示 $x$ 与 $fa[x]$ 的奇偶性不同,在路径压缩的过程中,对 $x$ 到树根路径的所有边权做异或$(xor)$。</p></li><li><p>对于每个问题, 设离散化后 $l - 1$ 和 $r$ 的值分别是 $x$ 和 $y$ , 设 $c$ 表示当前问题的回答($c = 0$ 表示偶数个, $c = 1$ 表示奇数个)</p></li></ol><p>若 $x$ 和 $y$ 在一个集合中, 直接判断 $d[x] xor d[y]$ 是否等于 $c$，若不等于,则矛盾，直接输出结果。</p><p>若 $x$ 和 $y$ 不在一个集合中，说明无法判断，此时合并两个集合，得到俩个的树根 $p$ 和 $q$, $d[x]$ 与 $d[y]$ 分别表示 $x - p$ 与 $y - q$ 之间所有边权的 “xor” 和，$p - q$ 之间的边权为 $d[p]$, 显然, 路径 $x - y$ 由 $x - p$, $p - q$, $q - y$ 组成，所以 $x$ 与 $y$ 的奇偶性关系 $c = d[x] (xor) d[y] (xor) d[p]$，得到 $d[p] = d[x] (xor) d[y] (xor) c$。</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[N], d[N];</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">&#125; q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != fa[x]) &#123;</span><br><span class="line">        <span class="keyword">int</span> root = find(fa[x]);</span><br><span class="line">        d[x] ^= d[fa[x]];</span><br><span class="line">        fa[x] = root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L, n, a, b, pa, pb;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; L &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; q[i].a &gt;&gt; q[i].b &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;e&#x27;</span>) q[i].c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> q[i].c = <span class="number">1</span>;</span><br><span class="line">        g.push_back(q[i].a - <span class="number">1</span>);</span><br><span class="line">        g.push_back(q[i].b);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(g.begin(), g.end());</span><br><span class="line">    g.erase(unique(g.begin(), g.end()), g.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= (<span class="keyword">int</span>)g.size(); i++) &#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">        mp[g[i - <span class="number">1</span>]] = i;</span><br><span class="line">        d[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= n; i++) &#123;</span><br><span class="line">        a = mp[q[i].a - <span class="number">1</span>], b = mp[q[i].b];</span><br><span class="line">        pa = find(a), pb = find(b);</span><br><span class="line">        <span class="keyword">if</span> (pa != pb) &#123;</span><br><span class="line">            fa[pa] = pb;</span><br><span class="line">            d[pa] ^= d[a] ^ d[b] ^ q[i].c;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (d[a] ^ d[b] != q[i].c) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i - <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Solution2（拓展域）"><a href="#Solution2（拓展域）" class="headerlink" title="Solution2（拓展域）"></a>Solution2（拓展域）</h3><p>$1 - n$ 表示 $sum[i]$ 为奇，$n + 1 - 2 * n$ 表示 $sum[i]$ 为偶。</p><p>当查询区间为奇数时：判断 $a$ 的奇数域是否与 $b$ 的奇数域同在一个集合，是则矛盾，否则合并 $a$ 的奇数域与 $b$ 的偶数域，$a$ 的偶数域与 $b$ 的奇数域。</p><p>当查询区间为偶数时：判断 $a$ 的奇数域是否与 $b$ 的偶数域同在一个集合，是则矛盾，否则合并 $a,b$ 的奇数域和偶数域。</p><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">&#125; q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != fa[x]) </span><br><span class="line">        fa[x] = find(fa[x]);</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x = find(x), y = find(y);</span><br><span class="line">    <span class="keyword">if</span> (x != y) fa[x] = y;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L, m, n, a, b;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; L &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; q[i].a &gt;&gt; q[i].b &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">&quot;even&quot;</span>) q[i].c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> q[i].c = <span class="number">1</span>;</span><br><span class="line">        g.push_back(q[i].a - <span class="number">1</span>);</span><br><span class="line">        g.push_back(q[i].b);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(g.begin(), g.end());</span><br><span class="line">    g.erase(unique(g.begin(), g.end()), g.end());</span><br><span class="line">    n = g.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        mp[g[i - <span class="number">1</span>]] = i;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">        fa[i + n] = i + n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= m; i++) &#123;</span><br><span class="line">        a = mp[q[i].a - <span class="number">1</span>], b = mp[q[i].b];</span><br><span class="line">        <span class="keyword">if</span> (q[i].c) &#123;</span><br><span class="line">            <span class="keyword">if</span> (find(a) == find(b) || find(a + n) == find(b + n)) <span class="keyword">break</span>;</span><br><span class="line">            join(a, b + n); <span class="comment">// 合并a的奇数域和b的偶数域</span></span><br><span class="line">            join(a + n, b); <span class="comment">// 合并a的偶数域和a的奇数域</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (find(a) == find(b + n) || find(a + n) == find(b)) <span class="keyword">break</span>;</span><br><span class="line">            join(a, b);     <span class="comment">// 合并a的奇数域和b的奇数域</span></span><br><span class="line">            join(a + n, b + n);  <span class="comment">// 合并a的偶数域和b的偶数域</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i - <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反向并查集"><a href="#反向并查集" class="headerlink" title="反向并查集"></a>反向并查集</h2><h3 id="星球大战"><a href="#星球大战" class="headerlink" title="星球大战"></a>星球大战</h3><p>求每次拆边后的连通块个数。$(m \in [1, 2e5], n \in [1, 2*m])$</p><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>拆边很难维护集合数量，考虑离线后反过来建图。这样便相当于每次增加增加一条边，查询两个点是否为同一个集合即可知道集合数量是否减少。</p><h3 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k, pre[N], b[N], vis[N];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = x, j = x;</span><br><span class="line">  <span class="keyword">while</span> (i != pre[i])</span><br><span class="line">    i = pre[i];</span><br><span class="line">  <span class="keyword">while</span> (i != j) &#123;</span><br><span class="line">    <span class="keyword">int</span> temp = pre[j];</span><br><span class="line">    pre[j] = i;</span><br><span class="line">    j = temp;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> fx = find(x), fy = find(y);</span><br><span class="line">  <span class="keyword">if</span> (fx != fy) &#123;</span><br><span class="line">    pre[fx] = fy;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    pre[i] = i;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    g[x].push_back(y);</span><br><span class="line">    g[y].push_back(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">    vis[b[i]] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> res = n - k;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; g[i].size(); j++) &#123;</span><br><span class="line">      <span class="keyword">int</span> x = g[i][j];</span><br><span class="line">      <span class="keyword">if</span> (!vis[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (join(i, x)) res--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  b[k + <span class="number">1</span>] = res;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">    res++;</span><br><span class="line">    vis[b[i]] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; g[b[i]].size(); j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!vis[g[b[i]][j]] &amp;&amp; join(b[i], g[b[i]][j])) </span><br><span class="line">        res--;</span><br><span class="line">    &#125;</span><br><span class="line">    b[i] = res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k + <span class="number">1</span>; i++) </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Total-Eclipse"><a href="#Total-Eclipse" class="headerlink" title="Total Eclipse"></a>Total Eclipse</h3><p>给你 $n$ 个节点 $m$ 条边的图，每个点有一个权值，你现在要做的操作是选择一个连通图，并将其中的每一个点的权值都减一，问你最少需要多少次才能将所有的点都变为0。$(1≤n≤100000, 1≤m≤200000)$</p><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>贪心地想，每次必然是选择权值最小的点，然后联通的边都减少该权值，但这样很难维护，因此可以考虑反向。</p><p>每次选择权值最大的点，然后这个点需要减少到和次小的点一样的权值，即减少的权值为和次小点权值之差。由于一次可以减少一个联通块，因此我们只需要乘以当前点联通块个数即可。</p><h3 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, n, m, pre[N], vis[N];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> w;</span><br><span class="line">  <span class="keyword">int</span> id;</span><br><span class="line">&#125; q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node x, Node y)</span> </span>&#123; <span class="keyword">return</span> x.w &gt; y.w; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = x, j = x;</span><br><span class="line">  <span class="keyword">while</span> (i != pre[i]) i = pre[i];</span><br><span class="line">  <span class="keyword">while</span> (j != i) &#123;</span><br><span class="line">    <span class="keyword">int</span> temp = pre[j];</span><br><span class="line">    pre[j] = i;</span><br><span class="line">    j = temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> fx = find(x), fy = find(y);</span><br><span class="line">  <span class="keyword">if</span> (fx != fy) &#123;</span><br><span class="line">    pre[fx] = fy;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">  <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;q[i].w);</span><br><span class="line">      q[i].id = i;</span><br><span class="line">      pre[i] = i;</span><br><span class="line">      g[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> u, v;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">      g[u].push_back(v);</span><br><span class="line">      g[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> cnt = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + n + <span class="number">1</span>, cmp);</span><br><span class="line">    q[n + <span class="number">1</span>].w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      cnt++;</span><br><span class="line">      vis[q[i].id] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> x : g[q[i].id]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[x] &amp;&amp; join(x, q[i].id)) cnt--;</span><br><span class="line">      &#125;</span><br><span class="line">      res += cnt * (q[i].w - q[i + <span class="number">1</span>].w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：编辑距离</title>
      <link href="2020/10/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.html"/>
      <url>2020/10/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两个单词 $a$ 和 $b$，请你计算出将 $a$ 转换成 $b$ 所使用的最少操作数。</p><p>你可以对一个单词进行如下三种操作：</p><ol><li>插入一个字符<a id="more"></a> </li><li>删除一个字符</li><li>替换一个字符</li></ol><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>$dp[i][j]$ 表示 $a$ 的前 $i$ 个字母和 $b$ 的前 $j$ 个字母匹配的最少操作次数。</p><p>可以从三种状态转移过来：</p><p>$dp[i][j] = dp[i - 1][j] + 1$    在 $b[j]$ 后面插入一个字符 $a[i]$</p><p>$dp[i][j] = dp[i][j - 1] + 1$    在 $a[i]$ 后面插入一个字符 $b[j]$</p><p>$dp[i][j] = dp[i - 1][j - 1] + (a[i - 1] != b[j - 1])$    修改一个字符</p><p>选择最小的操作步数进行转移即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.size();</span><br><span class="line">        <span class="keyword">int</span> m = b.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">            dp[<span class="number">0</span>][i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = dp[i - <span class="number">1</span>][j] + <span class="number">1</span>;   <span class="comment">// 在 b[j] 后面插入一个字符 a[i]</span></span><br><span class="line">                <span class="keyword">int</span> y = dp[i][j - <span class="number">1</span>] + <span class="number">1</span>;   <span class="comment">// 在 a[i] 后面插入一个字符 b[j]</span></span><br><span class="line">                <span class="keyword">int</span> z = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + (a[i - <span class="number">1</span>] != b[j - <span class="number">1</span>]);   <span class="comment">// 修改一个字符</span></span><br><span class="line">                dp[i][j] = min(&#123;x, y, z&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二维差分</title>
      <link href="2020/10/%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86.html"/>
      <url>2020/10/%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86.html</url>
      
        <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="http://img.benboby.top/%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86.png" alt></p><p>紫色部分为所求区域，黄色区域为当前覆盖的区域。</p><p>$d[x1][y1] += w$ 表示将 $[x1, y1]$ 右下部分全部加上增量 $w$。<br><a id="more"></a> </p><p>$d[x1][y2 + 1] -= w$ 用于抵消对 $y2$ 右边元素的影响，即图三蓝色区域。</p><p>$d[x2 + 1][y1] -= w$ 用于抵消对 $x2$ 下边元素的影响，即图四蓝色区域。</p><p>$d[x2 + 1][y2 + 1] += w$ 由于绿色区域被抵消了两次，因此需要加回增量 $w$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1005</span>][<span class="number">1005</span>], d[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, m, q, x1, y1, x2, y2, w;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) <span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">  <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; w;</span><br><span class="line">    d[x1][y1] += w;</span><br><span class="line">    d[x1][y2 + <span class="number">1</span>] -= w;</span><br><span class="line">    d[x2 + <span class="number">1</span>][y1] -= w;</span><br><span class="line">    d[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += w;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">      d[i][j] -= d[i - <span class="number">1</span>][j - <span class="number">1</span>] - d[i - <span class="number">1</span>][j] - d[i][j - <span class="number">1</span>];</span><br><span class="line">      a[i][j] += d[i][j];</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RMQ算法原理及实现</title>
      <link href="2020/10/RMQ%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0.html"/>
      <url>2020/10/RMQ%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0.html</url>
      
        <content type="html"><![CDATA[<p>RMQ（Range Minimum/Maximum Query），区间最值查询问题，是指：对于长度为 $n$ 的数列A，回答若干次询问 $RMQ(i,j)$，返回数列A中下标在区间 $[i,j]$ 中的最小/大值。</p><p>这里介绍Tarjan的Sparse-Table算法，预处理时间为 $O(nlogn)$，但查询只需要 $O(1)$，并且常数很小，算法也很容易写出。</p><p>1）预处理：</p><p>　设 $A[i]$ 是要求区间最值的数列，$d[i, j]$ 表示从第i个数起连续 $2^j$ 个数中的最小值。(DP的状态)<br><a id="more"></a> </p><p>　显然 $d[i][0]$ 的值就是 $A[i]$ (DP初值)，我们把 $d[i，j]$ 平均分成两段(因为 $d[i，j]$ 一定是偶数个数字)，从 $i$ 到 $i + 2 ^ (j - 1) - 1$ 为一段，$i + 2 ^ (j - 1)$ 到 $i + 2 ^ j - 1$ 为一段(长度都为 $2 ^ (j - 1)$)。于是我们得到了状态转移方程 $d[i, j] = min(d[i，j-1], d[i + 2^(j-1)，j-1])$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RMQ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) d[i][<span class="number">0</span>] = a[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) &lt;= n; ++j)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt; n; ++i)</span><br><span class="line">      d[i][j] = min(d[i][j - <span class="number">1</span>], d[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）查询：</p><p>　假如我们需要查询的区间为 $(i,j)$ ，那么我们需要找到覆盖这个闭区间(左边界取 $i$，右边界取 $j$)的最小幂（可以重复，比如查询1，2，3，4，5，5不是2的任意次方，但我们可以查询1234和2345）。</p><p>　这个查询长度我们取范围小于等于区间长度的最大 $(2^k)$，这样我们查询 $i$ 到 $i + (2^k)$ 与 $j - (2^k) + 1$ 到 $j$ 的值，取二者最小值即可，代码实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; (k + <span class="number">1</span>)) &lt;= R - L + <span class="number">1</span>) ++k;</span><br><span class="line">  <span class="keyword">return</span> min(d[L][k], d[R - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：树中距离之和</title>
      <link href="2020/10/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%A0%91%E4%B8%AD%E8%B7%9D%E7%A6%BB%E4%B9%8B%E5%92%8C.html"/>
      <url>2020/10/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%A0%91%E4%B8%AD%E8%B7%9D%E7%A6%BB%E4%B9%8B%E5%92%8C.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个无向、连通的树。树中有 $N$ 个标记为 $0…N-1$ 的节点以及 $N-1$ 条边 。</p><p>第 $i$ 条边连接节点 $edges[i][0]$ 和 $edges[i][1]$ 。</p><p>返回一个表示节点 $i$ 与其他所有节点距离之和的列表 $res$。<br><a id="more"></a> </p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>首先只考虑查询一个点的情况，容易得到状态转移：$dp[u] = \sum_{v \in son[u]}{dp[v] + sz[v]}$。</p><p>$son[u]$ 表示 $u$ 的所有子节点，$sz[v]$ 表示以 $v$ 为根的子树大小，$dp[u]$ 表示以 $u$ 为根的子树，它的所有子节点到它的距离之和。</p><p>那么 $dp[u]$ 就是所有子节点的 $dp[v]$ + 子节点对应的子树大小个点从 $u$ 到 $v$ 的距离。</p><p>然后考虑换根，根从 $u$ 变为子节点 $v$，以 $u$ 为根的子树大小减少 $sz[v]$，$dp[u]$ 也要减去 $v$ 的贡献：</p><p>$sz[u] -= sz[v], dp[u] -= dp[v] + sz[v]$</p><p>然后 $v$ 做为根，获得了 $u$ 结点的贡献，同时以 $v$ 为根的子树大小增大 $sz[u]$：</p><p>$sz[v] += sz[u], dp[v] += dp[u] + sz[u]$</p><p>同时注意：递归在进行回溯的时候，需要恢复现场，否则在计算兄弟结点时，维护的 $dp$ 和 $sz$ 将是错误的。</p><p>需要两次dfs，时间复杂度为 $O(n)$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[<span class="number">10005</span>];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">10005</span>], sz[<span class="number">10005</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        sz[u] = <span class="number">1</span>;</span><br><span class="line">        dp[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v: g[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">            dfs1(v, u);</span><br><span class="line">            sz[u] += sz[v];</span><br><span class="line">            dp[u] += dp[v] + sz[v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        res[u] = dp[u];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v: g[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> du = dp[u], dv = dp[v];</span><br><span class="line">            <span class="keyword">int</span> su = sz[u], sv = dp[v];</span><br><span class="line">            dp[u] -= dp[v] + sz[v];</span><br><span class="line">            sz[u] -= sz[v];</span><br><span class="line">            dp[v] += dp[u] + sz[u];</span><br><span class="line">            sz[v] += sz[u];</span><br><span class="line">            dfs2(v, u);</span><br><span class="line">            dp[u] = du, dp[v] = dv;</span><br><span class="line">            sz[u] = su, sz[v] = sv;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sumOfDistancesInTree</span><span class="params">(<span class="keyword">int</span> N, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> edge: edges) &#123;</span><br><span class="line">            g[edge[<span class="number">0</span>]].push_back(edge[<span class="number">1</span>]);</span><br><span class="line">            g[edge[<span class="number">1</span>]].push_back(edge[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        res.resize(N, <span class="number">0</span>);</span><br><span class="line">        dfs1(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">        dfs2(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：小y的序列</title>
      <link href="2020/10/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%B0%8Fy%E7%9A%84%E5%BA%8F%E5%88%97.html"/>
      <url>2020/10/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%B0%8Fy%E7%9A%84%E5%BA%8F%E5%88%97.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>最少修改几个数，使得数列满足 $a[i + 1] - a[i] = i$。$(n \in [1, 1e5], a[i] \in [-1e9, 1e9])$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>先构造一个长度为 $n$ 满足题意的初始数列，然后将所给的数减去对应的初始构造的数，差值出现的次数最多的就是最长的满足题意的序列，要修改的就是剩余的那些数。<br><a id="more"></a> </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, x, p = <span class="number">0</span>, res;</span><br><span class="line">  <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; x;</span><br><span class="line">  res = mp[x] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    p += i;</span><br><span class="line">    res = max(res, ++mp[x - p]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; n - res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：Arithmetic Progressions</title>
      <link href="2020/10/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AArithmetic-Progressions.html"/>
      <url>2020/10/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AArithmetic-Progressions.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>从给定数列中能选出组成的最长等差数列长度为多少？$(n \in [1, 5000], a[i] \in [1, 1e9])$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>$dp[i][j]$ 表示 $a[i]$ 为等差数列最后一个数，$a[j]$ 为倒数第二个数。<br><a id="more"></a> </p><p>排序后二维枚举 $i$ 和 $j$，二分找到对应的下标 $k$ 使得 $a[k]+a[i]=2*a[j]$ ，直接转移 $dp[i][j] = max(dp[i][j], dp[j][k] + 1)$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, res, a[<span class="number">5005</span>], dp[<span class="number">5005</span>][<span class="number">5005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">  sort(a, a + n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="keyword">int</span> k = lower_bound(a, a + n, a[j] * <span class="number">2</span> - a[i]) - a;</span><br><span class="line">      <span class="keyword">if</span> (a[k] == a[j] * <span class="number">2</span> - a[i]) dp[i][j] = max(dp[i][j], dp[j][k] + <span class="number">1</span>);</span><br><span class="line">      res = max(res, dp[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res + <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：Medians and Partition</title>
      <link href="2020/10/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AMedians-and-Partition.html"/>
      <url>2020/10/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AMedians-and-Partition.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>最多可以把数组分成几个部分，使得每部分中位数都大于等于$m$。$(n,m,a[i] \in [1,5000])$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>思维题，可以发现答案就是大于等于 $m$ 的个数减去小于 $m$ 的个数。<br><a id="more"></a> </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, x, s1 = <span class="number">0</span>, s2 = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= m)</span><br><span class="line">            s1++;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            s2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; max(<span class="number">0</span>, s1 - s1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客国庆集训day1</title>
      <link href="2020/10/%E7%89%9B%E5%AE%A2%E5%9B%BD%E5%BA%86%E9%9B%86%E8%AE%ADday1.html"/>
      <url>2020/10/%E7%89%9B%E5%AE%A2%E5%9B%BD%E5%BA%86%E9%9B%86%E8%AE%ADday1.html</url>
      
        <content type="html"><![CDATA[<h2 id="A-ABB"><a href="#A-ABB" class="headerlink" title="A. ABB"></a>A. ABB</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>在给定的字符串后面最少添加多少个字符可以让整个字符串变成一个回文字符串$(n \in [1, 4e5])$。</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><a id="more"></a> <p>等价于求包含最后一个字符的最长回文子串，可以用前后遍历两次哈希解决。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> ull base = <span class="number">13331</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, len, res;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line">ull r, l[N], b[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;n, s + <span class="number">1</span>);</span><br><span class="line">  b[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) b[i] = b[i - <span class="number">1</span>] * base;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) l[i] = l[i - <span class="number">1</span>] * base + s[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">    r = r * base + s[i];</span><br><span class="line">    len++;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= len) &#123;</span><br><span class="line">      ull now1 = l[i] - l[i - len] * b[len];</span><br><span class="line">      <span class="keyword">if</span> (now1 == r) res = max(res, len * <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= len + <span class="number">1</span>) &#123;</span><br><span class="line">      ull now2 = l[i - <span class="number">1</span>] - l[i - <span class="number">1</span> - len] * b[len];</span><br><span class="line">      <span class="keyword">if</span> (now2 == r) res = max(res, len * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n - res);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Bob-in-Wonderland"><a href="#C-Bob-in-Wonderland" class="headerlink" title="C. Bob in Wonderland"></a>C. Bob in Wonderland</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>把一棵树变为一条链的最少操作次数$(n \in [1, 3e5])$。</p><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>其实就是不断把度大于2的点转移到头或者尾，因此答案就是所有度数大于2的点减去2的和。</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, x, y, res, d[<span class="number">500005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">    d[x]++;</span><br><span class="line">    d[y]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res += max(d[i] - <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-Zeldain-Garden"><a href="#E-Zeldain-Garden" class="headerlink" title="E. Zeldain Garden"></a>E. Zeldain Garden</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>求给定区间内所有数的因子个数和$(n \in [1, 1e12])$。</p><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>打表发现 $1-n$ 内因子个数和就是 $n / i$ 的和 $(i \in [1, n])$，然后用除法分块解决。</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">  ll sum = n;</span><br><span class="line">  <span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt;= n;) &#123;</span><br><span class="line">    ll x = n / i;</span><br><span class="line">    ll y = min(n / x, n);</span><br><span class="line">    sum += x * (y - i + <span class="number">1</span>);</span><br><span class="line">    i = y + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll a, b;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; solve(b) - solve(a - <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-Light-Emitting-Hindenburg"><a href="#F-Light-Emitting-Hindenburg" class="headerlink" title="F. Light Emitting Hindenburg"></a>F. Light Emitting Hindenburg</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>从 $n$ 个正整数中选出k个数字使得进行按位与操作得到的结果最大$(n \in [1, 2e5])$。</p><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>考虑二进制位，当且仅当 $k$ 个数字该位都为1，位与结果才为1。因此从高位开始枚举二进制位，当该位为1的数量超过 $k$ 时，剔除所有不为1的数，最后剩下的数即为可以选择的数，且这些数无论怎么选择 $k$ 个，位与结果都相同。</p><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, a[N], vis[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((a[j] &gt;&gt; i) &amp; <span class="number">1</span> &amp;&amp; !vis[j]) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt &gt;= k) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!((a[j] &gt;&gt; i) &amp; <span class="number">1</span>)) vis[j] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[i]) res &amp;= a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="H-Ponk-Warshall"><a href="#H-Ponk-Warshall" class="headerlink" title="H. Ponk Warshall"></a>H. Ponk Warshall</h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>两个字符串s, t仅包含ATCG，求s最少经过多少次交换可以变为t$(n \in [1, 1e6])$。</p><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><p>按四种优先级讨论：</p><ol><li>同一个位置字符相同，直接跳过无需交换。</li><li>交换一次，使得两个字符直接匹配。</li><li>交换两次，使得三个字符直接匹配。</li><li>交换三次，使得四个字符直接匹配。</li></ol><p>数组 $cnt[i][j]$ 表示每个字符的对应关系，按优先级计算累加答案即可。</p><h3 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, res, mp[<span class="number">200</span>], cnt[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> s, t;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; s &gt;&gt; t;</span><br><span class="line">  n = s.size();</span><br><span class="line">  mp[<span class="string">&#x27;A&#x27;</span>] = <span class="number">0</span>, mp[<span class="string">&#x27;T&#x27;</span>] = <span class="number">1</span>, mp[<span class="string">&#x27;C&#x27;</span>] = <span class="number">2</span>, mp[<span class="string">&#x27;G&#x27;</span>] = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s[i] != t[i]) cnt[mp[s[i]]][mp[t[i]]]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="keyword">int</span> x = min(cnt[i][j], cnt[j][i]);</span><br><span class="line">      res += x;</span><br><span class="line">      cnt[i][j] -= x, cnt[j][i] -= x;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; j; k++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = min(cnt[i][j], min(cnt[j][k], cnt[k][i]));</span><br><span class="line">        <span class="keyword">int</span> y = min(cnt[i][k], min(cnt[k][j], cnt[j][i]));</span><br><span class="line">        res += (x + y) * <span class="number">2</span>;</span><br><span class="line">        cnt[i][j] -= x, cnt[j][k] -= x, cnt[k][i] -= x;</span><br><span class="line">        cnt[i][k] -= y, cnt[k][j] -= y, cnt[j][i] -= y;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) res += cnt[<span class="number">0</span>][i] * <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 多校训练 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多校训练 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：不相交线段的最小最大值</title>
      <link href="2020/09/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%BA%BF%E6%AE%B5%E7%9A%84%E6%9C%80%E5%B0%8F%E6%9C%80%E5%A4%A7%E5%80%BC.html"/>
      <url>2020/09/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%BA%BF%E6%AE%B5%E7%9A%84%E6%9C%80%E5%B0%8F%E6%9C%80%E5%A4%A7%E5%80%BC.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>在一维数轴上给出 $m$ 个线段，每个线段都都有 $l,r,w$ 三个数据代表这个线段的左右端点和这个区间权值。 从中取出若干个不相交的线段(区间端点可以共用)，在覆盖满 $[1,n]$ 的情况下，取出的线段中 $权重的最大值]$ 最小能为多少？</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>$dp[i]$ 代表覆盖满 $[1,i]$ 最大权值最小为多少，然后按左端点从小到大枚举线段，就有 $dp[r_i]=min(dp[r_i],max(dp[l_i],w_i))$。<br><a id="more"></a> </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> l, r;</span><br><span class="line">  ll w;</span><br><span class="line">&#125; q[<span class="number">200005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node x, Node y)</span> </span>&#123; <span class="keyword">return</span> x.l &lt; y.l; &#125;</span><br><span class="line"></span><br><span class="line">ll dp[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, m;</span><br><span class="line">  <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>, &amp;q[i].l, &amp;q[i].r, &amp;q[i].w);</span><br><span class="line">    sort(q + <span class="number">1</span>, q + m + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) dp[i] = <span class="number">1e18</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">      dp[q[i].r] = min(dp[q[i].r], max(dp[q[i].l], q[i].w));</span><br><span class="line">    <span class="keyword">if</span> (dp[n] == <span class="number">1e18</span>)</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;invalid data&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, dp[n]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：连通两组点的最小成本</title>
      <link href="2020/09/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%BF%9E%E9%80%9A%E4%B8%A4%E7%BB%84%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E6%88%90%E6%9C%AC.html"/>
      <url>2020/09/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%BF%9E%E9%80%9A%E4%B8%A4%E7%BB%84%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E6%88%90%E6%9C%AC.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你两组点，其中第一组中有 $size1$ 个点，第二组中有 $size2$ 个点，且 $size1 &gt;= size2$。</p><p>任意两点间的连接成本 $cost$ 由大小为 size1 x size2 矩阵给出，其中 $cost[i][j]$ 是第一组中的点 $i$ 和第二组中的点 $j$ 的连接成本。如果两个组中的每个点都与另一组中的一个或多个点连接，则称这两组点是连通的。换言之，第一组中的每个点必须至少与第二组中的一个点连接，且第二组中的每个点必须至少与第一组中的一个点连接。</p><p>返回连通两组点所需的最小成本。<br><a id="more"></a> </p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>$dp[i][j]$ 表示左部前 $i$ 个点连接右部(1&lt;&lt;m)的情况，状态转移方程：dp[i][now | 1 &lt;&lt; j] = min({dp<a href="当前状态">now | 1 &lt;&lt; j</a>, dp[i - 1][j] + cost[i - 1]<a href="前i-1个状态(当前点没连接任何点">j</a> + 当前点连接右边第j个点}, dp[i][j] + cost[i - 1]<a href="前i个状态(当前点可能之前连接了别的点">j</a> + 当前点连接右边第j个点))。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">connectTwoGroups</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cost.size();</span><br><span class="line">        <span class="keyword">int</span> m = cost.get(<span class="number">0</span>).size();</span><br><span class="line">        <span class="keyword">int</span> all = <span class="number">1</span> &lt;&lt; m;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][all];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i], <span class="number">2000000000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> now = <span class="number">0</span>; now &lt; all; now++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                    dp[i][now | <span class="number">1</span> &lt;&lt; j] = Math.min(dp[i][now | <span class="number">1</span> &lt;&lt; j], Math.min(dp[i - <span class="number">1</span>][now] + cost.get(i - <span class="number">1</span>).get(j), dp[i][now] + cost.get(i - <span class="number">1</span>).get(j)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][all - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状压dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础</title>
      <link href="2020/09/MySQL%E5%9F%BA%E7%A1%80.html"/>
      <url>2020/09/MySQL%E5%9F%BA%E7%A1%80.html</url>
      
        <content type="html"><![CDATA[<h2 id="事物四个特性ACID"><a href="#事物四个特性ACID" class="headerlink" title="事物四个特性ACID"></a>事物四个特性ACID</h2><p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p><ol><li>原子性：事务操作要么要么全部成功，要么全部失败回滚，操作失败不能对数据库有任何影响。</li><li>一致性：事务执行前后必须处于一致性。简单来说，A和B的钱加起来是1000，无论他们之间怎么转账，事务结束后他们的钱加起来还是1000。</li><li>隔离性：多个并发事务要互相隔离，即不能互相干扰。</li><li>持久性：事物一旦被提交，改变就是永久性的，即使系统故障也不会丢失事物的操作。</li></ol><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p>先举例说明并发操作数据库可能出现的问题：</p><ol><li>更新丢失<br> 丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。</li><li>读脏数据<br> 读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</li><li>不可重复读<br> 不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</li><li>幻读，本质上也属于不可重复读的情况，T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</li></ol><p><strong>产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</strong></p><p>隔离级别：</p><ol><li>未提交读（READ UNCOMMITTED）：事务中的修改，即使没有提交，对其它事务也是可见的。</li><li>提交读（READ COMMITTED）：一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</li><li>可重复读（REPEATABLE READ）：保证在同一个事务中多次读取同一数据的结果是一样的。</li><li>可串行化（SERIALIZABLE）：强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。</li></ol><p>隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed。它能够避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、幻读和第二类丢失更新这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。大多数数据库的默认级别就是Read committed，比如Sql Server , Oracle。MySQL的默认隔离级别就是Repeatable read。</p><h2 id="乐观锁悲观锁"><a href="#乐观锁悲观锁" class="headerlink" title="乐观锁悲观锁"></a>乐观锁悲观锁</h2><p>数据库的隔离级别可以解决大多数问题，但是灵活度较差，为此又提出了悲观锁和乐观锁的概念。</p><p><strong>悲观锁：对外界修改数据持保守态度。认为外界会修改数据。具有强烈的独占和排他特性。悲观锁的实现往往依靠数据库提供的锁机制。</strong></p><ul><li>共享锁：又称读锁，简称S锁。就是多个事务对于同一数据可以共享一把锁，但是只能读不能修改。</li><li>互斥锁：又称写锁，简称X锁。就是不能与其他锁并存，如果一个事务获取了一个数据行的互斥锁，其他事务就不能再获取该行的其他锁，包括共享锁和互斥锁，但是获取互斥锁的事务是可以对数据行读取和修改。</li></ul><p>适合于写操作多的情况，为数据安全提供保障，但因为加锁也降低了效率，增加了产生死锁的机会，降低了并发性。</p><p><strong>乐观锁：假设认为数据一般情况下不会造成冲突，在提交的时候才去判断是不是存在冲突。如果发现冲突了，则返回用户错误的信息，让用户决定如何去做。适合于读操作多的情况，较好的实现了并发性。</strong><br>乐观锁的实现一般有两种方式：</p><ul><li>使用版本号：为数据增加一个版本标识，一般是为数据库增加一个数字类型的version字段来实现。读取数据时，讲version一同取出，每更新一次，version加1。提交更新时，判断表当前version是否与第一次取出一致，否则认为是过期数据。</li><li>使用时间戳：增加一个字段，类型为时间戳，和第一种同理。</li></ul><h2 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h2><p><a href="https://blog.csdn.net/u013235478/article/details/50625677">Mysql索引原理</a><br><a href="https://blog.csdn.net/wangfeijiu/article/details/113409719?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&amp;dist_request_id=d5683f4e-db9e-4506-af05-230782b326af&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control">Mysql索引详解</a><br><a href="https://www.cnblogs.com/heishuichenzhou/p/10813463.html">主键索引和非主键索引</a></p><p>数据库索引是为了增加查询速度而对表字段附加的一种标识，可以认为是数据库的目录。</p><p>优点在于查询速度快，但增删改慢，因为要去同步维护索引文件。</p><ol><li>普通索引：加快数据查询速度，应该只为那些经常被查询的数据列创建索引。查找到满足条件的第一个记录后，一直查找到不满足的第一个记录为止。</li><li>唯一索引：保证数据的唯一性，找到第一个满足条件的记录后就停止。</li><li>主键索引：使用主键作为索引，叶子结点存放的是整行数据，又被称为聚簇索引，建议主键自增，这样每次插入时就只要插入到最后一个位置即可，就不需要调整树结构。<br> 非主键索引，叶子结点存放的是主键，通过非主键索引搜索到主键ID，然后再通过主键索引搜索数据。因此也被称为二级索引。</li><li>联合索引：对表的多个列进行索引，与其它索引相比，键值数量大于1。<br> 最左匹配原则：在MySQL建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配，遇到范围查询条件就停下来。Mysql会自动优化查询语句使得与索引排序顺序保持一致。因此，应该将最经常查询的字段放在左边。<br> 如 where a = 3 and b = 4 and c &gt; 5 and d = 6，如果建立的是(a,b,c,d) 联合索引，则d是用不到索引的，如果建立的是(a,b,d,c)的话就都可以用到。<br> 使用联合索引可以减少开销，建一个等于多个，因为无需访问多个索引，因此减少了很多不必要的IO操作，提高了效率。                       </li></ol><p>B树和B+树的区别：</p><ul><li>B树每个节点都存储了key和data值，B+树只有叶子结点才存储data值，其它结点都存储key值，因此一个结点可以存储更多key值</li><li>B树不需要到叶子结点就可以找到对应数据，B+树必须到叶子结点才能找到，相对稳定</li><li>B+树的叶子结点用链表维护起来，支持区间查询</li></ul><p>索引使用的数据结构还有哈希索引，底层就是哈希表，只包含哈希值和指针，只支持等值比较查询，不能用于范围查询，因为哈希值是无序的。</p><h2 id="InnoDB和MyISAM"><a href="#InnoDB和MyISAM" class="headerlink" title="InnoDB和MyISAM"></a>InnoDB和MyISAM</h2><ol><li>MyISAM采用表级锁，InnoDB支持行级锁和表级锁,默认为行级锁。</li><li>MyISAM强调性能，执行速度更快，但不提供事务支持。InnoDB支持事务，回滚，崩溃修复和事务安全。</li><li>InnoDB支持外键。</li><li>InnoDB是聚簇索引，MylSAM是非聚簇索引。</li><li>仅InnoDB支持MVCC，应对高并发事务，MVCC比加锁更高效。</li></ol><p>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据<br>非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行。</p><p>表级锁：粒度最大的锁，对整张表加锁，实现简单，资源消耗少，触发锁冲突概率最高，并发度最低。<br>行级锁：粒度最小的锁，只针对当前操作的行进行加锁，大大减少数据库操作的冲突，并发度高，但加锁的开销也很大。</p><p>数据库语句执行很慢，可能迟迟拿不到锁，或者是没有使用索引或者选错索引。</p><h2 id="多版本并发控制MVCC"><a href="#多版本并发控制MVCC" class="headerlink" title="多版本并发控制MVCC"></a>多版本并发控制MVCC</h2><p>是一种实现并发控制的方法，用更好的方式去处理读写冲突。</p><p>当前读：想select lock in share mode，select for update；这些操作都是一种当前读，因为它读取的是记录的最新版本，还要保证其它并发事务不能修改当前记录，会对读取的记录进行加锁。</p><p>快照读：</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java常量池</title>
      <link href="2020/09/Java%E5%B8%B8%E9%87%8F%E6%B1%A0.html"/>
      <url>2020/09/Java%E5%B8%B8%E9%87%8F%E6%B1%A0.html</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="什么是常量"><a href="#什么是常量" class="headerlink" title="什么是常量"></a>什么是常量</h3><p>用final修饰的成员变量表示常量，值一旦给定就无法改变！</p><p>final修饰的变量有三种：<strong>静态变量</strong>、<strong>实例变量</strong>和<strong>局部变量</strong>，分别表示三种类型的常量。</p><h3 id="Class文件中的常量池"><a href="#Class文件中的常量池" class="headerlink" title="Class文件中的常量池"></a>Class文件中的常量池</h3><p>在Class文件结构中，最头的4个字节用于存储魔数Magic Number，用于确定一个文件是否能被JVM接受，再接着4个字节用于存储版本号，前2个字节存储次版本号，后2个存储主版本号，再接着是用于存放常量的常量池，由于常量的数量是不固定的，所以常量池的入口放置一个U2类型的数据(constant_pool_count)存储常量池容量计数值。<br><a id="more"></a> </p><p>常量池主要用于存放两大类常量：字面量(Literal)和符号引用量(Symbolic References)，字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等，符号引用则属于编译原理方面的概念，包括了如下三种类型的常量：<strong>类和接口的全限定名</strong>，<strong>字段名称和描述符</strong>，<strong>方法名称和描述符</strong>。</p><h3 id="方法区中的运行时常量池"><a href="#方法区中的运行时常量池" class="headerlink" title="方法区中的运行时常量池"></a>方法区中的运行时常量池</h3><p>运行时常量池是方法区的一部分。</p><p>CLass文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p><p>运行时常量池相对于CLass文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入CLass文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是String类的intern()方法。</p><h3 id="常量池的好处"><a href="#常量池的好处" class="headerlink" title="常量池的好处"></a>常量池的好处</h3><p>常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。</p><p>例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。<br>（1）节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。<br>（2）节省运行时间：比较字符串时，== 比 equals()快。对于两个引用变量，只用 == 判断引用是否相等，也就可以判断实际值是否相等。</p><h3 id="双等号-的含义"><a href="#双等号-的含义" class="headerlink" title="双等号==的含义"></a>双等号==的含义</h3><p><strong>基本数据类型</strong>之间应用双等号，比较的是他们的<strong>数值</strong>。</p><p><strong>复合数据类型(类)</strong>之间应用双等号，比较的是他们在<strong>内存中的存放地址</strong>。</p><h2 id="8种基本类型的包装类和常量池"><a href="#8种基本类型的包装类和常量池" class="headerlink" title="8种基本类型的包装类和常量池"></a>8种基本类型的包装类和常量池</h2><p>java中基本类型的包装类的大部分都实现了常量池技术，即Byte,Short,Integer,Long,Character,Boolean；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;</span><br><span class="line">Integer i2 = <span class="number">40</span>;</span><br><span class="line">System.out.println(i1==i2);<span class="comment">//输出TRUE</span></span><br></pre></td></tr></table></figure><p>这5种包装类默认创建了数值[-128，127]的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Integer 缓存代码 ：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">     <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">         <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">400</span>;</span><br><span class="line">Integer i2 = <span class="number">400</span>;</span><br><span class="line">System.out.println(i1==i2);<span class="comment">//输出false</span></span><br></pre></td></tr></table></figure><p>两种浮点数类型的包装类Float,Double并没有实现常量池技术。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Double i1=<span class="number">1.2</span>;</span><br><span class="line">Double i2=<span class="number">1.2</span>;</span><br><span class="line">System.out.println(i1==i2);<span class="comment">//输出false</span></span><br></pre></td></tr></table></figure><h3 id="应用常量池的场景"><a href="#应用常量池的场景" class="headerlink" title="应用常量池的场景"></a>应用常量池的场景</h3><ol><li><p>Integer i1=40; Java在编译的时候会直接将代码封装成 Integer i1=Integer.valueOf(40);，从而使用常量池中的对象。</p></li><li><p>Integer i1 = new Integer(40); 这种情况下会创建新的对象。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;</span><br><span class="line">Integer i2 = <span class="number">40</span>;</span><br><span class="line">Integer i3 = <span class="number">0</span>;</span><br><span class="line">Integer i4 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i5 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i6 = <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;i1=i2   &quot;</span> + (i1 == i2));</span><br><span class="line">System.out.println(<span class="string">&quot;i1=i2+i3   &quot;</span> + (i1 == i2 + i3));</span><br><span class="line">System.out.println(<span class="string">&quot;i1=i4   &quot;</span> + (i1 == i4));</span><br><span class="line">System.out.println(<span class="string">&quot;i4=i5   &quot;</span> + (i4 == i5));</span><br><span class="line">System.out.println(<span class="string">&quot;i4=i5+i6   &quot;</span> + (i4 == i5 + i6));</span><br><span class="line">System.out.println(<span class="string">&quot;40=i5+i6   &quot;</span> + (<span class="number">40</span> == i5 + i6));</span><br><span class="line"></span><br><span class="line">i1=i2   <span class="keyword">true</span></span><br><span class="line">i1=i2+i3   <span class="keyword">true</span></span><br><span class="line">i1=i4   <span class="keyword">false</span></span><br><span class="line">i4=i5   <span class="keyword">false</span></span><br><span class="line">i4=i5+i6   <span class="keyword">true</span></span><br><span class="line"><span class="number">40</span>=i5+i6   <span class="keyword">true</span></span><br></pre></td></tr></table></figure><p> 解释：语句i4 == i5 + i6，因为 + 这个操作符不适用于Integer对象，首先 i5 和 i6 进行自动拆箱操作，进行数值相加，即i4 == 40。然后Integer对象无法与数值进行直接比较，所以i4自动拆箱转为int值40，最终这条语句转为40 == 40进行数值比较。</p></li></ol><h2 id="String类和常量池"><a href="#String类和常量池" class="headerlink" title="String类和常量池"></a>String类和常量池</h2><h3 id="String对象创建方式"><a href="#String对象创建方式" class="headerlink" title="String对象创建方式"></a>String对象创建方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">System.out.println(str1==str2);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>这两种不同的创建方法是有差别的，第一种方式是在常量池中拿对象，第二种方式是直接在堆内存空间创建一个新的对象。<br>只要使用new方法，便需要创建新的对象。</p><h3 id="连接表达式"><a href="#连接表达式" class="headerlink" title="连接表达式 +"></a>连接表达式 +</h3><ol><li>只有使用引号包含文本的方式创建的String对象之间使用“+”连接产生的新对象才会被加入字符串池中。</li><li>对于所有包含new方式新建对象（包括null）的“+”连接表达式，它所产生的新对象都不会被加入字符串池中。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;str&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"></span><br><span class="line">String str3 = <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;</span><br><span class="line">String str4 = str1 + str2;</span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">String str5 = <span class="string">&quot;string&quot;</span>;</span><br><span class="line">System.out.println(str3 == str5);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>特例1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String A = <span class="string">&quot;ab&quot;</span>; <span class="comment">// 常量A</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String B = <span class="string">&quot;cd&quot;</span>; <span class="comment">// 常量B</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String s = A + B;  <span class="comment">// 将两个常量用+连接对s进行初始化</span></span><br><span class="line">String t = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (s == t) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;s等于t，它们是同一个对象&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;s不等于t，它们不是同一个对象&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// s等于t，它们是同一个对象</span></span><br></pre></td></tr></table></figure><p>A和B都是常量，值是固定的，因此s的值也是固定的，它在类被编译时就已经确定了。也就是说：String s = A + B; 等同于：String s = ”ab” + ”cd”;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String A; <span class="comment">// 常量A</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String B; <span class="comment">// 常量B</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    A = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    B = <span class="string">&quot;cd&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将两个常量用+连接对s进行初始化</span></span><br><span class="line">    String s = A + B;</span><br><span class="line">    String t = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (s == t) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;s等于t，它们是同一个对象&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;s不等于t，它们不是同一个对象&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// s不等于t，它们不是同一个对象</span></span><br></pre></td></tr></table></figure><p>A和B虽然被定义为常量，但是它们都没有马上被赋值。在运算出s的值之前，他们何时被赋值，以及被赋予什么样的值，都是个变数。因此A和B在被赋值之前，性质类似于一个变量。那么s就不能在编译期被确定，而只能在运行时被创建了。</p><h3 id="String-s1-new-String-“xyz”-创建了几个对象？"><a href="#String-s1-new-String-“xyz”-创建了几个对象？" class="headerlink" title="String s1 = new String(“xyz”); 创建了几个对象？"></a>String s1 = new String(“xyz”); 创建了几个对象？</h3><p>考虑类加载阶段和实际执行时。</p><ol><li><p>类加载对一个类只会进行一次。”xyz”在类加载时就已经创建并驻留了（如果该类被加载之前已经有”xyz”字符串被驻留过则不需要重复创建用于驻留的”xyz”实例）。驻留的字符串是放在全局共享的字符串常量池中的。</p></li><li><p>在这段代码后续被运行的时候，”xyz”字面量对应的String实例已经固定了，不会再被重复创建。所以这段代码将常量池中的对象复制一份放到heap中，并且把heap中的这个对象的引用交给 s1 持有。</p></li></ol><p>这条语句创建了2个对象。</p><h3 id="java-lang-String-intern"><a href="#java-lang-String-intern" class="headerlink" title="java.lang.String.intern()"></a>java.lang.String.intern()</h3><p>运行时常量池相对于CLass文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入CLass文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是String类的intern()方法。</p><p>String的intern()方法会查找在常量池中是否存在一份equal相等的字符串,如果有则返回该字符串的引用,如果没有则添加自己的字符串进入常量池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   String s1 = <span class="keyword">new</span> String(<span class="string">&quot;计算机&quot;</span>);</span><br><span class="line">   String s2 = s1.intern();</span><br><span class="line">   String s3 = <span class="string">&quot;计算机&quot;</span>;</span><br><span class="line">   System.out.println(<span class="string">&quot;s1 == s2? &quot;</span> + (s1 == s2));</span><br><span class="line">   System.out.println(<span class="string">&quot;s3 == s2? &quot;</span> + (s3 == s2));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// s1 == s2? false</span></span><br><span class="line"><span class="comment">// s3 == s2? true</span></span><br></pre></td></tr></table></figure><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   String hello = <span class="string">&quot;Hello&quot;</span>, lo = <span class="string">&quot;lo&quot;</span>;</span><br><span class="line">   System.out.println((hello == <span class="string">&quot;Hello&quot;</span>) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">   System.out.println((Other.hello == hello) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">   System.out.println((other.Other.hello == hello) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">   System.out.println((hello == (<span class="string">&quot;Hel&quot;</span>+<span class="string">&quot;lo&quot;</span>)) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">   System.out.println((hello == (<span class="string">&quot;Hel&quot;</span>+lo)) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">   System.out.println(hello == (<span class="string">&quot;Hel&quot;</span>+lo).intern());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Other</span> </span>&#123; <span class="keyword">static</span> String hello = <span class="string">&quot;Hello&quot;</span>; &#125;</span><br><span class="line"><span class="keyword">package</span> other;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Other</span> </span>&#123; <span class="keyword">public</span> <span class="keyword">static</span> String hello = <span class="string">&quot;Hello&quot;</span>; &#125;</span><br><span class="line"><span class="comment">// true true true true false true</span></span><br></pre></td></tr></table></figure><p>在同包同类下，引用自同一String对象。</p><p>在同包不同类下，引用自同一String对象。</p><p>在不同包不同类下，依然引用自同一String对象。</p><p>在编译成.class时能够识别为同一字符串的，自动优化成常量，引用自同一String对象。</p><p>在运行时创建的字符串具有独立的内存地址，所以不引用自同一String对象。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMakeLists的编写</title>
      <link href="2020/09/CMakeLists%E7%9A%84%E7%BC%96%E5%86%99.html"/>
      <url>2020/09/CMakeLists%E7%9A%84%E7%BC%96%E5%86%99.html</url>
      
        <content type="html"><![CDATA[<h2 id="CMake简介："><a href="#CMake简介：" class="headerlink" title="CMake简介："></a><strong>CMake简介：</strong></h2><p>CMake是一种跨平台的开源项目管理工具，所做的事其实就是告诉编译器如何去编译链接源代码。与之相似的是直接编写makefile文件，但makefile最大的缺点就是不能跨平台，一旦更换环境就要重新编写，于是我们可以使用CMake编写CMakeLists文件来解决此问题。</p><h2 id="检查是否安装CMake"><a href="#检查是否安装CMake" class="headerlink" title="检查是否安装CMake"></a>检查是否安装CMake</h2><p>首先检查是否安装CMake，在终端输入cmake —version来检查，若显示未安装，可以使用sudo apt-get install camke ( ubuntu)，或者brew install cmake (macos)，windows直接去官网下载，来安装CMake。</p><a id="more"></a> <h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#cmake最小版本需求</span></span><br><span class="line">cmake_minimum_required(VERSION xxx)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置此项目的名称</span></span><br><span class="line">project(xxx)</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成可执行文件target ，后面填写的是生成此可执行文件所依赖的源文件列表。</span></span><br><span class="line">add_executable(target target_source_codes)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置一个名字var_name 的变量，同时给此变量赋值为var_value</span></span><br><span class="line">SET(var_name var_value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定编译器</span></span><br><span class="line"><span class="comment"># CMAKE_C_FLAGS_DEBUG          ----  C 编译器</span></span><br><span class="line"><span class="comment"># CMAKE_CXX_FLAGS_DEBUG        ----  C++ 编译器</span></span><br><span class="line"><span class="comment"># -std=c++11  使用 C++11</span></span><br><span class="line"><span class="comment"># -g：只是编译器，在编译的时候，产生调试信息。</span></span><br><span class="line"><span class="comment"># -Wall：生成所有警告信息。一下是具体的选项，可以单独使用</span></span><br><span class="line"><span class="built_in">set</span> (CMAKE_CXX_FLAGS &amp;quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++<span class="number">11</span>   -g  -wall  &amp;quot;)</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定编译类型，debug 或者为 release</span></span><br><span class="line"><span class="comment"># debug 会生成相关调试信息，可以使用 GDB 进行</span></span><br><span class="line"><span class="comment"># release 不会生成调试信息。当无法进行调试时查看此处是否设置为 debug.</span></span><br><span class="line"><span class="built_in">set</span>(CMAKE_BUILD_TYPE Debug)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印消息</span></span><br><span class="line">MESSAGE(&amp;quot;MSG&amp;quot;)</span><br><span class="line"></span><br><span class="line"><span class="comment">#给变量var_name赋值为var_value，comment是此变量的注释，和SET 有类似的功效，用于给某变量设置默认值</span></span><br><span class="line">option(var_name &amp;quot;comment&amp;quot; var_value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加include路径，也就是头文件路径</span></span><br><span class="line">include_directories(xxx)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用xxx子目录的CMakeLists.txt执行</span></span><br><span class="line">add_subdirectory(xxx)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给编译器添加xxx参数</span></span><br><span class="line">add_compile_options(xxx)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给编译器添加库目录，</span></span><br><span class="line">link_directories(xxx)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成库文件，SHARED代表动态库，STATIC代表静态库， 最后一个参数代表此库的源文件列表</span></span><br><span class="line">add_library(lib_name SHARED <span class="keyword">or</span> STATIC lib_source_code)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给目标添加依赖库</span></span><br><span class="line">target_link_libraries(target_name lib_name ...)</span><br></pre></td></tr></table></figure><h2 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h2><p>下图是一般的项目文件格式，include 存放头文件，src存放源代码文件，build存放临时编译文件。<br><img src="https://uploadfiles.nowcoder.com/files/20200501/391840006_1588307113197_20200407144630731.png" alt><br>假设工程文件夹名为Test，我们可以将CMakeLists.txt文件放在Test文件夹下，也就是src，include的同级目录下，以下是简单的CMakeLists文件编写格式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最低指定的CMake版本</span></span><br><span class="line">cmake_minimum_required(VERSION <span class="number">3.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 括号里面填你的工程名</span></span><br><span class="line">PROJECT(Test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 头文件路径</span></span><br><span class="line">INCLUDE_DIRECTORIES(include)</span><br><span class="line">INCLUDE_DIRECTORIES(/usr/local/include/)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找src下的所有cpp文件，然后将结果存进指定变量名(这里是DIR_SRCS)</span></span><br><span class="line">AUX_SOURCE_DIRECTORY(src DIR_SRCS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定语言要求，以下命令为c++ 11</span></span><br><span class="line">SET(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成可执行文件，生成的test即为可执行文件</span></span><br><span class="line">add_executable(test $&#123;DIR_SRCS&#125;)</span><br></pre></td></tr></table></figure><p>由于该过程中会产生很多中间文件，因此我们在build文件夹下使用cmake命令，这样这些文件就都放在build文件夹下，然后make运行就好：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">./test</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Makefile </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式：策略模式</title>
      <link href="2020/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.html"/>
      <url>2020/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.html</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>定义一种算法，将每个算法都封装起来，并且使它们之间可以互换。是一种行为类模式。</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>为了通俗易懂，我们拿各国的税率计算来举例子：</p><p>假设当前我们的程序只能支持计算中国和美国的税率：<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tax_Cal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CN_Cal</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;       <span class="comment">// 计算中国税</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">US_Cal</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;       <span class="comment">// 计算美国税</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样写看起来没什么问题，但实际上我们想想，如果以后公司还要拓展，开始支持法国，日本等等国家，那么我们这个类就得不断但改啊改，是不是特别麻烦且危险？比如万一和前面的某个国家冲突了，就会影响到前面的计算。</p><p>所以我们干脆分开来写，把所有的国家税的计算都独立出来，实现的都是同一个接口，都有一个共同的参数x。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Strategy</span> </span>&#123;          <span class="comment">// 策略模式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Cal</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CN_Tax</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;     <span class="comment">// 实现中国税计算接口</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Cal</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">US_Tax</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;     <span class="comment">// 实现美国税计算接口</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@jOverride</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Cal</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tax_Cal</span> </span>&#123;            <span class="comment">// 税计算类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Strategy = strategy;         <span class="comment">// 定义一个策略</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStrategy</span><span class="params">(Strategy strategy)</span> </span>&#123;     <span class="comment">// 接入策略</span></span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTax</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;      <span class="comment">// 得到结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.strategy.cal</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，所有的税务计算就互不影响啦，因为它们的计算已经被我们独立出来了，要计算哪一个国家的税，只需要接入该国家的算法，调用一下getTax就可以了。我们来写一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(string[] args)</span> </span>&#123;</span><br><span class="line">        Tax_Cal tax_cal = <span class="keyword">new</span> Tax_Cal();       <span class="comment">// 实例化对象</span></span><br><span class="line">        tax_cal.setStrategy(<span class="keyword">new</span> CN_Tax());     <span class="comment">// 接入中国税计算</span></span><br><span class="line">        <span class="keyword">int</span> res = tax_cal.getTax(<span class="number">100</span>);       <span class="comment">// 得到结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就实现了中国的税计算。由此可见，这样设计是更有策略性的，以后要有新的国家加入，不需要再修改原代码，只需要再实现一个新的国家接口就可以了。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>优点：</p><ol><li>策略间可以自由的切换，因为它们都实现自同一个抽象。</li><li>易于拓展，基本上可以在不改变原有代码的基础上进行拓展。</li><li>避免使用多重条件语句，否则就得一直if else, switch case，这样非常不利于维护。</li></ol><p>策略模式是一种简单常用的设计模式，一般来说不会单独使用，而是和其它模式混合使用。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式：单例模式</title>
      <link href="2020/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html"/>
      <url>2020/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h2><p>单例模式，顾名思义，就是整个系统就只有一个实例存在。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>单例类只能有一个实例。</li><li>单例类必须自己创建自己的唯一实例。</li><li>单例类必须给所有其他对象提供这一实例。</li></ol><a id="more"></a> <p>讲的通俗一点，我们拿女娲造人来举例：</p><p>我们先写一个女娲类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">N_Wa</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，任何人都不能创造女娲，所以女娲的构造应该是私有的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">N_Wa</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">N_Wa</span><span class="params">()</span> </span>&#123;&#125;   <span class="comment">// 构造方法私有化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有人可能要质疑：那女娲应该是谁创造的？<br>这个问题千百万年来都没有人能解开过，所以在我们的潜意识中认为：神是自己创造自己的！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">N_Wa</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> N_Wa n_wa = <span class="keyword">new</span> N_Wa();   <span class="comment">// 神自己创造自己</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">N_Wa</span><span class="params">()</span> </span>&#123;&#125;     <span class="comment">// 构造方法私有化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>private 保证了女娲的私有性，毕竟这个世界上没有人见过女娲。<br>static   保证了女娲的静态性，她与类共存亡。<br>final     保证了女娲是“终极”常量，不可能再被修改。</p><p>女娲已经出来了，接下来干什么呢？<br>当然就是请她开始造人啦：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">N_Wa</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> N_Wa n_wa = <span class="keyword">new</span> N_Wa();   <span class="comment">// 神自己创造自己</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">N_Wa</span><span class="params">()</span> </span>&#123;&#125;     <span class="comment">// 构造方法私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> N_Wa <span class="title">getInstance</span><span class="params">()</span> </span>&#123;    <span class="comment">// 请求女娲</span></span><br><span class="line">        <span class="keyword">return</span> n_wa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getInstance 和 new？<br>new 是重新创建一个对象，且只能单次使用。<br>getInstance 是没有对象的时候创建对象，有了之后就保留在内存中，下次就不用再重新创建了，因此它的对象一定是static的。</p><p>这样一来，只需要调用 N_Wa.getInstance(); 女娲就请过来了，而且不论是谁，请来的都是同一个女娲，也就是我们构造的“终极”常量：n_wa。当然你还可以往里面加入其它的功能（造人功能未写出）。</p><p>到此为止，我们就已经学会了单例模式——<strong>“饿汉模式”</strong>，即我们先把女娲给造好，需要的时候直接用就好了。</p><p>随之而来的是另一个问题：要是我们根本没有用到女娲呢？那不是白造了？于是又出现了一种叫“<strong>懒汉模式</strong>”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">N_Wa</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> N_Wa n_wa;   <span class="comment">// 这里并没有new一个女娲</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">N_Wa</span><span class="params">()</span> </span>&#123;&#125;     <span class="comment">// 构造方法私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> N_Wa <span class="title">getInstance</span><span class="params">()</span> </span>&#123;    <span class="comment">// 请求女娲</span></span><br><span class="line">        <span class="keyword">if</span>(n_wa == <span class="keyword">null</span>) &#123;</span><br><span class="line">            n_wa = <span class="keyword">new</span> N_Wa();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n_wa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，我们不再是提前造女娲了，而是需要的时候再去造她（实例化），但这样子的坏处就是每次都要重新造一次女娲，所以速度肯定不如之前的“饿汉模式”。而且有个大问题，就是一旦有很多人同时请女娲的话，依然可能造成多个神的情况。</p><p>所以我们让这些人排队？看起来挺有道理，但仔细想想，有些人做事总是拖拖拉拉，毛手毛脚的，万一给让它排到前面去了，那后面的人不得等半天吗？等下队伍直接排出地球外了，所以我们干脆让他们直接抢，谁抢到就是谁的，这样一直抢下去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">N_Wa</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> N_Wa n_wa;   <span class="comment">// 这里并没有new一个女娲</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">N_Wa</span><span class="params">()</span> </span>&#123;&#125;     <span class="comment">// 构造方法私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> N_Wa <span class="title">getInstance</span><span class="params">()</span> </span>&#123;    <span class="comment">// 请求女娲</span></span><br><span class="line">        <span class="keyword">if</span>(n_wa == <span class="keyword">null</span>)&#123;      <span class="comment">// 代表还没有人抢到</span></span><br><span class="line">            <span class="keyword">synchronized</span> (N_Wa.class) &#123;    <span class="comment">// 放他们进去抢</span></span><br><span class="line">                <span class="keyword">if</span>(n_wa == <span class="keyword">null</span>) &#123;       <span class="comment">// 第一个抢到的给他 new一个然后返回</span></span><br><span class="line">                    n_wa = <span class="keyword">new</span> N_Wa();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n_wa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>synchronized 是一种同步锁，可以防止同步发生，通俗来讲就是第一个人先用，这时锁被锁上，等他用完，锁再打开，以此类推。只有当锁是开着的，才能轮到下一个人。</p><p>到此为止，最基础的两种“恶汉模式”和“懒汉模式”就完成了，单例模式还有其它的一些变种，但思想上都大同小异，我们需要灵活运用，发挥出最大的价值！</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：至少被一个元素整除的数个数</title>
      <link href="2020/09/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%87%B3%E5%B0%91%E8%A2%AB%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E6%95%B4%E9%99%A4%E7%9A%84%E6%95%B0%E4%B8%AA%E6%95%B0.html"/>
      <url>2020/09/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%87%B3%E5%B0%91%E8%A2%AB%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E6%95%B4%E9%99%A4%E7%9A%84%E6%95%B0%E4%B8%AA%E6%95%B0.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个 $m$ 个元素的集合，问 $1-n$ 中有多少个数能被集合中至少一个元素整除。$(n &lt;= 1e9, m &lt;= 20)$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>容斥原理，二进制枚举集合的所有子集，求子集的 $lcm$，如果子集大小是奇数，则 $res += n / lcm$，否则 $res-= n / lcm$。<br><a id="more"></a> </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line">LL a[<span class="number">40</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  LL N, M, ans = <span class="number">0</span>, gd;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;N, &amp;M);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i - <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  LL F = (<span class="number">1</span> &lt;&lt; M) - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= F; i++) &#123;</span><br><span class="line">    LL cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; j)) &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">1</span>)</span><br><span class="line">          gd = a[j];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          gd = gd * a[j] / (__gcd(a[j], gd));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt &amp; <span class="number">1</span>) &#123;</span><br><span class="line">      ans += N / gd;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      ans -= N / gd;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>存在负数的背包问题</title>
      <link href="2020/09/%E5%AD%98%E5%9C%A8%E8%B4%9F%E6%95%B0%E7%9A%84%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98.html"/>
      <url>2020/09/%E5%AD%98%E5%9C%A8%E8%B4%9F%E6%95%B0%E7%9A%84%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h2><p>体积和价值可能为负数的01背包。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>逆向思维，对于体积为负的物品，我们可以一开始就装进去，背包对应的进行扩容，物品的体积和价值也对应取反。这样在进行背包dp 的时候就代表移除这个物品，答案取最大值即可。<br><a id="more"></a> </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">410</span>;</span><br><span class="line"><span class="keyword">int</span> c[N], v[N], ans;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">40010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N, M;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;N, &amp;M);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;c[i], &amp;v[i]);</span><br><span class="line">    <span class="keyword">if</span> (c[i] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      ans += v[i];</span><br><span class="line">      M -= c[i];</span><br><span class="line">      c[i] = -c[i];</span><br><span class="line">      v[i] = -v[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = M; j &gt;= c[i]; j--) dp[j] = max(dp[j], dp[j - c[i]] + v[i]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= M; i++) &#123;</span><br><span class="line">    dp[M] = max(dp[M], dp[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans + dp[M]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h2><p>体积和价值可能为负数且要求所取的物品体积之和和价值之和都大于0的条件下，两者总和最大的01背包。$(n = 100, -1000&lt;=v,w&lt;=1000)$</p><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2><p>由于体积可能为负，因此需要负数转化为正数，以 $100000$ 为分界线划分为左边代表正数，右边代表负数做背包dp即可，当体积为负时，转移是由大的容量转移过来，需要从小到大遍历。最后取分界线右侧且dp值大于 0 的体积加价值最大值即可。</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> m = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, x, y, res, dp[m];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) dp[i] = -m;</span><br><span class="line">  dp[<span class="number">100000</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= x; j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[j - x] != -m) dp[j] = max(dp[j], dp[j - x] + y);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m + x; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[j - x] != -m) dp[j] = max(dp[j], dp[j - x] + y);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">100000</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dp[i] &gt; <span class="number">0</span>) res = max(res, dp[i] + i - <span class="number">100000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12种Java中常用的语法糖</title>
      <link href="2020/09/12%E7%A7%8DJava%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96.html"/>
      <url>2020/09/12%E7%A7%8DJava%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是语法糖"><a href="#什么是语法糖" class="headerlink" title="什么是语法糖"></a>什么是语法糖</h2><p>语法糖（Syntactic Sugar），也称糖衣语法，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。简而言之，语法糖让程序更加简洁，有更高的可读性。</p><h2 id="解语法糖"><a href="#解语法糖" class="headerlink" title="解语法糖"></a>解语法糖</h2><p>前面提到过，语法糖的存在主要是方便开发人员使用。但其实，Java虚拟机并不支持这些语法糖。这些语法糖在编译阶段就会被还原成简单的基础语法结构，这个过程就是解语法糖。说到编译，大家肯定都知道，Java语言中，javac命令可以将后缀名为.java的源文件编译为后缀名为.class的可以运行于Java虚拟机的字节码。如果你去看com.sun.tools.javac.main.JavaCompiler的源码，你会发现在compile()中有一个步骤就是调用desugar()，这个方法就是负责解语法糖的实现的。Java 中最常用的语法糖主要有泛型、变长参数、条件编译、自动拆装箱、内部类等。</p><h2 id="糖块一：-switch-支持-String-与枚举"><a href="#糖块一：-switch-支持-String-与枚举" class="headerlink" title="糖块一： switch 支持 String 与枚举"></a>糖块一： switch 支持 String 与枚举</h2><p>从Java 7 开始，switch 开始支持 String。其实Java中的switch自身原本就支持基本类型。比如int、char等。对于int类型，直接进行数值的比较。对于char类型则是比较其 ascii 码。<br><a id="more"></a> </p><p>所以，对于编译器来说，<strong>switch中其实只能使用整型，任何类型的比较都要转换成整型</strong>。比如byte。short，char(ascii码是整型)以及int。</p><p>那么接下来看下 switch 对 String 的支持，有以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwitchTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;Shuke&quot;</span>;</span><br><span class="line">        <span class="keyword">switch</span> (s) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Shuke&quot;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;Shuke&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Bata&quot;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;Bata&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后的内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwitchTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SwitchTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;Shuke&quot;</span>;</span><br><span class="line">        <span class="keyword">byte</span> var3 = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">switch</span>(s.hashCode()) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2063116</span>:</span><br><span class="line">            <span class="keyword">if</span> (s.equals(<span class="string">&quot;Bata&quot;</span>)) &#123;</span><br><span class="line">                var3 = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">79866362</span>:</span><br><span class="line">            <span class="keyword">if</span> (s.equals(<span class="string">&quot;Shuke&quot;</span>)) &#123;</span><br><span class="line">                var3 = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(var3) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;Shuke&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;Bata&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现字符串的switch是通过equals()和hashCode()方法来实现的，hashCode()方法返回的是int，而不是long。</p><p>进行switch的实际是哈希值，然后通过使用equals方法比较进行安全检查，这个检查是必要的，因为<strong>哈希可能会发生碰撞</strong>。</p><h2 id="糖块二：-泛型"><a href="#糖块二：-泛型" class="headerlink" title="糖块二： 泛型"></a>糖块二： 泛型</h2><p>很多语言都是支持泛型的，但不同的编译器对于泛型的处理方式是不同的。</p><p>通常情况下，一个编译器处理泛型有两种方式：Code specialization和Code sharing。</p><p>C++和C#是使用Code specialization的处理机制，而Java使用的是Code sharing的机制。</p><p>Code sharing方式为每个泛型类型创建唯一的字节码表示，并且将该泛型类型的实例都映射到这个唯一的字节码表示上。将多种泛型类形实例映射到唯一的字节码表示是通过类型擦除（type erasue）实现的。</p><p>也就是说，对于Java虚拟机来说，它根本不认识 Map&lt;String, String&gt; map 这样的语法。需要在编译阶段通过类型擦除的方式进行解语法糖。</p><p>类型擦除的主要过程如下：</p><ol><li><p>将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。</p></li><li><p>移除所有的类型参数。</p></li></ol><ul><li><p>例如:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">map.put(<span class="string">&quot;111&quot;</span>, <span class="string">&quot;222&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;333&quot;</span>, <span class="string">&quot;444&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;555&quot;</span>, <span class="string">&quot;666&quot;</span>);</span><br></pre></td></tr></table></figure><p>  解语法糖后：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">map.put(<span class="string">&quot;111&quot;</span>, <span class="string">&quot;222&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;333&quot;</span>, <span class="string">&quot;444&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;555&quot;</span>, <span class="string">&quot;666&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><p><strong>虚拟机中没有泛型，只有普通类和普通方法，所有泛型类的类型参数在编译时都会被擦除</strong>，并没有自己独有的 Class 类对象。比如并不存在 List&lt;String&gt;.class 或是List&lt;Integer&gt;.class，而只有 List.class。</p><p>补充：</p><ol><li>当泛型遇到重载</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTypes</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;invoke method(List&lt;String&gt; list)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;invoke method(List&lt;Integer&gt; list)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码，有两个重载的函数，因为他们的参数类型不同，但是，这段代码是编译不通过的。因为参数 List 和 List 编译之后都被擦除了，变成了一样的原生类型 List，擦除动作导致这两个方法的特征签名变得一模一样。</p><ol><li>当泛型遇到catch</li></ol><p>泛型的类型参数不能用在 Java 异常处理的 catch 语句中。因为异常处理是由JVM在运行时刻来进行的。由于类型信息被擦除，JVM是无法区分两个异常类型 MyException&lt;String&gt; 和 MyException&lt;Integer&gt; 的。</p><ol><li>当泛型内包含静态变量</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GT&lt;Integer&gt; gti = <span class="keyword">new</span> GT&lt;Integer&gt;();</span><br><span class="line">        gti.<span class="keyword">var</span> = <span class="number">1</span>;</span><br><span class="line">        GT&lt;String&gt; gts = <span class="keyword">new</span> GT&lt;String&gt;();</span><br><span class="line">        gts.<span class="keyword">var</span> = <span class="number">2</span>;</span><br><span class="line">        System.out.println(gti.<span class="keyword">var</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GT</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="keyword">var</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nothing</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码输出结果为：2 !!! 由于经过类型擦除，所有的泛型类实例都关联到同一份字节码上，泛型类的所有静态变量是共享的。</p><h2 id="糖块三：-自动装箱与拆箱"><a href="#糖块三：-自动装箱与拆箱" class="headerlink" title="糖块三： 自动装箱与拆箱"></a>糖块三： 自动装箱与拆箱</h2><p>自动装箱就是Java自动将原始类型值转换成对应的对象，比如将int的变量转换成Integer对象，这个过程叫做装箱，反之将Integer对象转换成int类型值，这个过程叫做拆箱。</p><p>因为这里的装箱和拆箱是自动进行的非人为转换，所以就称作为自动装箱和拆箱。</p><p>原始类型byte, short, char, int, long, float, double 和 boolean 对应的封装类为Byte, Short, Character, Integer, Long, Float, Double, Boolean。</p><p>先来看个自动装箱的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    Integer n = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    Integer n = Integer.valueOf(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看个自动拆箱的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> n = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Integer i = Integer.valueOf(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">int</span> n = i.intValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从反编译得到内容可以看出，<strong>装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的</strong>。</p><p>补充：</p><p>自动装箱与拆箱——对象相等比较：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer a = <span class="number">1000</span>;</span><br><span class="line">    Integer b = <span class="number">1000</span>;</span><br><span class="line">    Integer c = <span class="number">100</span>;</span><br><span class="line">    Integer d = <span class="number">100</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;a == b is &quot;</span> + (a == b));</span><br><span class="line">    System.out.println((<span class="string">&quot;c == d is &quot;</span> + (c == d)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Java 5中，在Integer的操作上引入了一个新功能来节省内存和提高性能。整型对象通过使用相同的对象引用实现了缓存和重用。适用于整数值区间-128 至 +127。只适用于自动装箱。使用构造函数创建对象不适用。数据会被自动装箱成包装类，JVM在比较之前会看在不在常量池范围内，在就字面量比较，不在就比较地址值。</p><h2 id="糖块四：-方法变长参数"><a href="#糖块四：-方法变长参数" class="headerlink" title="糖块四： 方法变长参数"></a>糖块四： 方法变长参数</h2><p>可变参数(variable arguments)是在Java 1.5中引入的一个特性。它允许一个方法把任意数量的值作为参数。</p><p>看下以下可变参数代码，其中print方法接收可变参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    print(<span class="string">&quot;111&quot;</span>, <span class="string">&quot;222&quot;</span>, <span class="string">&quot;333&quot;</span>, <span class="string">&quot;444&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String... strs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(strs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后得到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    print(<span class="keyword">new</span> String[] &#123;</span><br><span class="line">    <span class="string">&quot;111&quot;</span>, <span class="string">&quot;222&quot;</span>, <span class="string">&quot;333&quot;</span>, <span class="string">&quot;444&quot;</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">transient</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String strs[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++)</span><br><span class="line">    System.out.println(strs[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从反编译后代码可以看出，可变参数在被使用的时候，他首先会创建一个数组，数组的长度就是调用该方法是传递的实参的个数，然后再把参数值全部放到这个数组当中，然后再把这个数组作为参数传递到被调用的方法中。</p><h2 id="糖块五：-枚举"><a href="#糖块五：-枚举" class="headerlink" title="糖块五： 枚举"></a>糖块五： 枚举</h2><p>Java SE5 提供了一种新的类型 — Java的枚举类型，关键字enum可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用，这是一种非常有用的功能。enumn就和 class 一样，只是一个关键字，并不是一个类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">t</span> </span>&#123;</span><br><span class="line">        SPRING,SUMMER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> <span class="keyword">extends</span> <span class="title">Enum</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="title">T</span><span class="params">(String s, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s, i);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> T[] values()</span><br><span class="line">     &#123;</span><br><span class="line">        T at[];</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        T at1[];</span><br><span class="line">        System.arraycopy(at = ENUM$VALUES, <span class="number">0</span>, at1 = <span class="keyword">new</span> T[i = at.length], <span class="number">0</span>, i);</span><br><span class="line">        <span class="keyword">return</span> at1;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">valueOf</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T)Enum.valueOf(demo/T, s);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> T SPRING;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> T SUMMER;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> T ENUM$VALUES[];</span><br><span class="line">     <span class="keyword">static</span></span><br><span class="line">     &#123;</span><br><span class="line">        SPRING = <span class="keyword">new</span> T(<span class="string">&quot;SPRING&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        SUMMER = <span class="keyword">new</span> T(<span class="string">&quot;SUMMER&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        ENUM$VALUES = (<span class="keyword">new</span> T[] &#123;</span><br><span class="line">        SPRING, SUMMER</span><br><span class="line">     &#125;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>public final class T extends Enum 说明该类是继承了Enum类的，同时final关键字意味着这个类也是不能被继承的。</p><p>当我们使用enmu来定义一个枚举类型的时候，编译器会自动帮我们创建一个final类型的类继承Enum类，所以枚举类型不能被继承。</p><h2 id="糖块六：-内部类"><a href="#糖块六：-内部类" class="headerlink" title="糖块六： 内部类"></a>糖块六： 内部类</h2><p>内部类又称为嵌套类，可以把内部类理解为外部类的一个普通成员。内部类之所以也是语法糖，是因为它仅仅是一个编译时的概念。</p><p>比如在 A.java 里面定义了一个内部类 B，一旦编译成功，就会生成两个完全不同的.class文件，分别是 A.class 和 A$B.class。所以内部类的名字完全可以和它的外部类名字相同。</p><p><strong>一个类对应一个.class文件，多个类嵌套就会有多个.class文件</strong>。</p><h2 id="糖块七：条件编译"><a href="#糖块七：条件编译" class="headerlink" title="糖块七：条件编译"></a>糖块七：条件编译</h2><p>一般情况下，程序中的每一行代码都要参加编译。但有时候出于对程序代码优化的考虑，希望只对其中一部分内容进行编译，此时就需要在程序中加上条件，让编译器只对满足条件的代码进行编译，将不满足条件的代码舍弃，这就是条件编译。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionalCompilation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(DEBUG) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello, DEBUG!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> ONLINE = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(ONLINE)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello, ONLINE!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionalCompilation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConditionalCompilation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> DEBUG = <span class="keyword">true</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, DEBUG!&quot;</span>);</span><br><span class="line">        <span class="keyword">boolean</span> ONLINE = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们发现，在反编译后的代码中没有 System.out.println(“Hello, ONLINE!”);，这其实就是条件编译。当 if(ONLINE) 为 false 的时候，编译器就没有对其内的代码进行编译。</p><p>所以，Java语法的条件编译，是通过判断条件为常量的 if 语句实现的。根据 if 判断条件的真假，编译器直接把分支为 false 的代码块消除。通过该方式实现的条件编译，必须在方法体内实现，而无法在正整个Java类的结构或者类的属性上进行条件编译。</p><h2 id="糖块八：-断言"><a href="#糖块八：-断言" class="headerlink" title="糖块八： 断言"></a>糖块八： 断言</h2><p>在Java中，assert关键字是从JAVA SE 1.4 引入的，为了避免和老版本的Java代码中使用了assert关键字导致错误，Java在执行的时候默认是不启动断言检查的（这个时候，所有的断言语句都将忽略！）。如果要开启断言检查，则需要用开关 -enableassertions 或 -ea来开启。</p><p>assert关键字语法很简单，有两种用法：</p><ol><li><p>assert boolean表达式</p><p> 如果为true，则程序继续执行。</p><p> 如果为false，则程序抛出AssertionError，并终止执行。</p></li><li><p>assert boolean表达式 : 错误信息表达式</p><p> 如果为true，则程序继续执行。</p><p> 如果为false，则程序抛出java.lang.AssertionError，并输入\&lt;错误信息表达式&gt;。</p></li></ol><p>例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AssertFoo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="comment">//断言1结果为true，则继续往下执行</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">true</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;断言1没有问题，Go！&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;\n-----------------\n&quot;</span>);</span><br><span class="line">        <span class="comment">//断言2结果为false,程序终止</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">false</span> : <span class="string">&quot;断言失败，此表达式的信息将会在抛出异常的时候输出！&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;断言2没有问题，Go！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>开启-ea开关，执行程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt;java -ea AssertFoo</span><br><span class="line"></span><br><span class="line">断言<span class="number">1</span>没有问题，Go！</span><br><span class="line">-----------------</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.AssertionError: 断言失败，此表达式的信息将会在抛出异常的时候输出！at AssertFoo.main(AssertFoo.java:<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>其实断言的底层实现就是 if 语言，如果断言结果为 true，则什么都不做，程序继续执行，如果断言结果为 false，则程序抛出 AssertionError 来打断程序的执行。</p><h2 id="糖块十：-for-each"><a href="#糖块十：-for-each" class="headerlink" title="糖块十： for-each"></a>糖块十： for-each</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForEachTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        String[] strs = &#123;<span class="string">&quot;111&quot;</span>, <span class="string">&quot;222&quot;</span>, <span class="string">&quot;333&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (String s : strs) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForEachTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForEachTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        String[] strs = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;111&quot;</span>, <span class="string">&quot;222&quot;</span>, <span class="string">&quot;333&quot;</span>&#125;;</span><br><span class="line">        String[] var2 = strs;</span><br><span class="line">        <span class="keyword">int</span> var3 = strs.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> var4 = <span class="number">0</span>; var4 &lt; var3; ++var4) &#123;</span><br><span class="line">            String s = var2[var4];</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for-each 的实现原理其实就是使用了普通的 for 循环和迭代器。</p><p>补充：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Student stu : students) &#123; </span><br><span class="line">    <span class="keyword">if</span> (stu.getId() == <span class="number">2</span>) </span><br><span class="line">    students.remove(stu); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会抛出ConcurrentModificationException异常。</p><p>Iterator是工作在一个独立的线程中，并且拥有一个 mutex 锁。 Iterator被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，这个索引表的内容不会同步改变，所以当索引指针往后移动的时候就找不到要迭代的对象，所以按照 fail-fast 原则 Iterator 会马上抛出 java.util.ConcurrentModificationException 异常。</p><p>所以 Iterator 在工作的时候是不允许被迭代的对象被改变的。但你可以使用 Iterator 本身的方法remove()来删除对象，Iterator.remove() 方法会在删除当前迭代对象的同时维护索引的一致性。</p><h2 id="糖块十一：-try-with-resource"><a href="#糖块十一：-try-with-resource" class="headerlink" title="糖块十一： try-with-resource"></a>糖块十一： try-with-resource</h2><p>Java里，对于文件操作IO流、数据库连接等开销非常昂贵的资源，用完之后必须及时通过close方法将其关闭，否则资源会一直处于打开状态，可能会导致内存泄露等问题。</p><p>关闭资源的常用方式就是在 finally 块里是释放，即调用 close 方法。比如，我们经常会写这样的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String line;</span><br><span class="line">        br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;xxx&quot;</span>));</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// handle exception</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (br != <span class="keyword">null</span>) &#123;</span><br><span class="line">                br.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="comment">// handle exception</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从Java 7开始，jdk 提供了一种更好的方式关闭资源，使用 try-with-resources 语句，改写一下上面的代码，效果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;xxx&quot;</span>)))            &#123;</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// handle exception</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实背后的原理也很简单，那些我们没有做的关闭资源的操作，编译器都帮我们做了。</p><h2 id="糖块十二：-Lambda表达式"><a href="#糖块十二：-Lambda表达式" class="headerlink" title="糖块十二： Lambda表达式"></a>糖块十二： Lambda表达式</h2><p>Labmda 表达式不是匿名内部类的语法糖，但是他也是一个语法糖。实现方式其实是依赖了几个 JVM 底层提供的 lambda 相关 api。</p><p>它并不是内部类的语法糖，前面讲内部类我们说过，内部类在编译之后会有对应的 class 文件，但是，包含 lambda 表达式的类编译后只有一个文件。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode486：预测赢家</title>
      <link href="2020/09/LeetCode486%EF%BC%9A%E9%A2%84%E6%B5%8B%E8%B5%A2%E5%AE%B6.html"/>
      <url>2020/09/LeetCode486%EF%BC%9A%E9%A2%84%E6%B5%8B%E8%B5%A2%E5%AE%B6.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个表示分数的非负整数数组。 玩家 1 从数组任意一端拿取一个分数，随后玩家 2 继续从剩余数组任意一端拿取分数，然后玩家 1 拿，…… 。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。</p><p>给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。<br><a id="more"></a> </p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>很容易想到递归解决，但显然复杂度太大。所以我们采用记忆化搜索，把已经搜索过的状态记录下来，回溯过程中取最大值。</p><p>$dp[l][r]$ 表示在区间 $[l,r]$ 中，能赢过对方的最大分数。</p><p>状态转移：$dp[l][r] = max(nums[l] - dp[l + 1][r], nums[r] - dp[l][r - 1])$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">30</span>][<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[l][r] != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> dp[l][r];</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> dp[l][r] = nums[l];</span><br><span class="line">        <span class="keyword">return</span> dp[l][r] = Math.max(nums[l] - dfs(l + <span class="number">1</span>, r, nums), nums[r] - dfs(l, r - <span class="number">1</span>, nums));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i], <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, n - <span class="number">1</span>, nums) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 记忆化搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：牛牛构造等差数列</title>
      <link href="2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%89%9B%E7%89%9B%E6%9E%84%E9%80%A0%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97.html"/>
      <url>2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%89%9B%E7%89%9B%E6%9E%84%E9%80%A0%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有 $n$ 个数，他们对每个数可以进行 $+1$ 或 $-1$ 操作，但对于每一个数，该操作最多只能执行一次。使用最少的操作次数，将这几个数构造成一个等差数列。如果完全不能构造成功，就输出 $-1$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>每个数最多只能修改一次，因此我们只要枚举前两个数的修改状态就能确定首项和公差，只有 $9$ 种可能，然后逐一判断取最小值即可。<br><a id="more"></a> </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = -<span class="number">1</span>; i &lt;= <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = -<span class="number">1</span>; j &lt;= <span class="number">1</span>; j++) &#123;</span><br><span class="line">                b[<span class="number">0</span>] += i;</span><br><span class="line">                b[<span class="number">1</span>] += j;</span><br><span class="line">                <span class="keyword">int</span> d = b[<span class="number">1</span>] - b[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> pre = b[<span class="number">1</span>], now, cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span>)</span><br><span class="line">                    cnt++;</span><br><span class="line">                <span class="keyword">if</span> (j != <span class="number">0</span>)</span><br><span class="line">                    cnt++;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt; n; k++) &#123;</span><br><span class="line">                    now = pre + d;</span><br><span class="line">                    <span class="keyword">if</span> (Math.abs(now - b[k]) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                        flag = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Math.abs(now - b[k]) == <span class="number">1</span>) &#123;</span><br><span class="line">                        cnt++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    pre = now;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (flag == <span class="keyword">false</span>) &#123;</span><br><span class="line">                    res = Math.min(res, cnt);</span><br><span class="line">                &#125;</span><br><span class="line">                b[<span class="number">0</span>] -= i;</span><br><span class="line">                b[<span class="number">1</span>] -= j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == Integer.MAX_VALUE ? -<span class="number">1</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：Playing Tag on Tree</title>
      <link href="2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9APlaying-Tag-on-Tree.html"/>
      <url>2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9APlaying-Tag-on-Tree.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一棵树，A 在 $x$ 点，B 在 $y$ 点，B 追 A，两人每次可以往相邻点移动，A 先跑，问 A 最晚什么时候被追上。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>结论：找到一个点，满足 $dis_B &gt; dis_A$ 且 $dis_B$ 最大，即为最终落脚点。<br><a id="more"></a> </p><p>因为直观上来说，明显最后的点离 B 越远越好，但这个点可能离 A 更远，因此需要满足 $dis_B &gt; dis_A$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">2</span>][N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> be, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">  q.push(be);</span><br><span class="line">  dis[id][be] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = q.front();</span><br><span class="line">    q.pop();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : g[u]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!dis[id][v]) &#123;</span><br><span class="line">        dis[id][v] = dis[id][u] + <span class="number">1</span>;</span><br><span class="line">        q.push(v);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, x, y, u, v, res = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; x &gt;&gt; y;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    g[u].push_back(v);</span><br><span class="line">    g[v].push_back(u);</span><br><span class="line">  &#125;</span><br><span class="line">  bfs(x, <span class="number">0</span>);</span><br><span class="line">  bfs(y, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dis[<span class="number">0</span>][i] &lt; dis[<span class="number">1</span>][i]) res = max(res, dis[<span class="number">1</span>][i] - <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode：最短回文串</title>
      <link href="2020/08/LeetCode214%EF%BC%9A%E6%9C%80%E7%9F%AD%E5%9B%9E%E6%96%87%E4%B8%B2.html"/>
      <url>2020/08/LeetCode214%EF%BC%9A%E6%9C%80%E7%9F%AD%E5%9B%9E%E6%96%87%E4%B8%B2.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个字符串 $s$，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>等价于求字符串 $s$ 以 $s_0$ 开头的最长回文串，然后多出来的后缀翻转后就是需要补足的最小长度，判断回文可以采用哈希。<br><a id="more"></a> </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">shortestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">long</span> left = <span class="number">0</span>, right = <span class="number">0</span>, base = <span class="number">13331</span>, mod = <span class="number">1000000007</span>, pre = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pos = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            left = (left * base + s.charAt(i)) % mod;</span><br><span class="line">            right = (right + pre * s.charAt(i)) % mod;</span><br><span class="line">            <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">                pos = i;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = pre * base % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        String add = (pos == n-<span class="number">1</span> ? <span class="string">&quot;&quot;</span> : s.substring(pos+<span class="number">1</span>,n));</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder(add).reverse();</span><br><span class="line">        res.append(s);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：Assassin’s Creed</title>
      <link href="2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AAssassin%E2%80%99s-Creed.html"/>
      <url>2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AAssassin%E2%80%99s-Creed.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>有 $n$ 个敌人，你现在的武器的耐久度为 $m$,杀每个敌人要消耗 $a_i$ 点耐久度，同时得到可以再杀死 $b_i$ 个人的权利。问最多可以杀死多少人，在杀人最多的情况下最少要消耗多少耐久度？</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>首先会想到对人进行分类，一类是 $b_i$ 为 $0$ 的，一类是 $b_i$ 不为 $0$ 的。<br><a id="more"></a> </p><p>杀死一个 $b_i$ 不为 $0$ 的，一定能杀死所有 $b_i$ 不为 $0$ 的，而且还能再额外杀死 $b_i$ 为 $0$ 的，显然只要杀 $a_i$ 最小的那个人即可。</p><p>分两种情况：</p><ol><li><p>只杀 $b_i$ 为 $0$ 的，可能原因：没有 $b_i$ 不为 $0$ 的，或者耐久度不够，或者消耗耐久度过大，还不如直接杀 $b_i$ 为 $0$ 来的划算。</p></li><li><p>杀一个 $b_i$ 不为 $0$的，且消耗耐久度最小的，那么所有的 $b_i$ 不为 $0$ 都将被杀死，额外的免费杀人机会都拿来杀 $b_i$ 为 $0$ 的，用剩下的耐久度从小到大杀剩下的怪即可。但这样有缺陷，可能存在手动杀 $b_i$ 不为 $0$ 的人会更划算，因为这个怪可能消耗的耐久度非常小，而你用这次机会杀 $b_i$ 为 $0$ 的人可能消耗非常大。于是得出结论：所有 $b_i$ 不为 $0$ 的人肯定会被杀死，但我只要把所有的怪按耐久度从小到大杀即可。</p></li></ol><p>两种情况取最大值即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g1, g2, g3;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> t, n, m, x, y, c = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">  <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    g1.clear();</span><br><span class="line">    g2.clear();</span><br><span class="line">    g3.clear();</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">      <span class="keyword">if</span> (y) </span><br><span class="line">        g1.push_back(x);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        g2.push_back(x);</span><br><span class="line">      sum+=y;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(g1.begin(), g1.end());</span><br><span class="line">    sort(g2.begin(), g2.end());</span><br><span class="line">    <span class="keyword">int</span> cost1 = <span class="number">0</span>, cost2 = <span class="number">0</span>, num1 = <span class="number">0</span>, num2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g2.size(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (cost1 + g2[i] &gt; m) <span class="keyword">break</span>;</span><br><span class="line">      cost1 += g2[i];</span><br><span class="line">      num1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (g2.size() == n || m &lt; g1[<span class="number">0</span>])</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %d %d\n&quot;</span>, ++c, num1, cost1);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      cost2 = g1[<span class="number">0</span>];</span><br><span class="line">      sum++;</span><br><span class="line">      num2 = min(sum, n);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g2.size(); i++) g3.push_back(g2[i]);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; g1.size(); i++) g3.push_back(g1[i]);</span><br><span class="line">      sort(g3.begin(), g3.end());</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g3.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num2 &gt;= n || cost2 + g3[i] &gt; m) <span class="keyword">break</span>;</span><br><span class="line">        cost2 += g3[i];</span><br><span class="line">        num2++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (num1 &gt; num2 || num1 == num2 &amp;&amp; cost1 &lt; cost2)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %d %d\n&quot;</span>, ++c, num1, cost1);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %d %d\n&quot;</span>, ++c, num2, cost2);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：物质分裂</title>
      <link href="2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%89%A9%E8%B4%A8%E5%88%86%E8%A3%82.html"/>
      <url>2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%89%A9%E8%B4%A8%E5%88%86%E8%A3%82.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>一个 $A$ 每天可以生产 $x1$ 个 $B$，$y1$ 个 $C$，一个 $B$ 每天可以生产 $x2$ 个 $A$，$y2$ 个 $C$，一个 $C$ 每天可以生产 $x3$ 个 $A$，$y3$ 个 $B$，最开始各有 $x,y,z$ 个，问 $n$ 天后各有多少个？ $n = 1e9$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>$B$ 和 $C$ 每天可以生产 $x2 + x3$ 个 $A$，那么第一天：$x$，第二天：$x<em>(x2+x3)$，第三天：$(x</em>(x2+x3))*(x2+x3)$ … 显然是等比数列求和。<br><a id="more"></a> </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">ll x, y, z, n, b1, c1, a1, c2, a2, b2;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qp</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">  ll sum = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (b) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>) sum = sum * a % mod;</span><br><span class="line">    a = a * a % mod;</span><br><span class="line">    b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; z &gt;&gt; n;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; b1 &gt;&gt; c1 &gt;&gt; a1 &gt;&gt; c2 &gt;&gt; a2 &gt;&gt; b2;</span><br><span class="line">  ll a =</span><br><span class="line">      x * (<span class="number">1</span> - qp(a1 + a2, n + <span class="number">1</span>) + mod) * qp(<span class="number">1</span> - a1 - a2 + mod, mod - <span class="number">2</span>) % mod;</span><br><span class="line">  ll b =</span><br><span class="line">      y * (<span class="number">1</span> - qp(b1 + b2, n + <span class="number">1</span>) + mod) * qp(<span class="number">1</span> - b1 - b2 + mod, mod - <span class="number">2</span>) % mod;</span><br><span class="line">  ll c =</span><br><span class="line">      z * (<span class="number">1</span> - qp(c1 + c2, n + <span class="number">1</span>) + mod) * qp(<span class="number">1</span> - c1 - c2 + mod, mod - <span class="number">2</span>) % mod;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：竞赛图</title>
      <link href="2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%AB%9E%E8%B5%9B%E5%9B%BE.html"/>
      <url>2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%AB%9E%E8%B5%9B%E5%9B%BE.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个 $n$ 元有向完全图，每次操作可以翻转一条边。求最少的操作次数，使得图中不存在三元环。$(n &lt;= 10)$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p><img src="http://img.benboby.top/%E8%AF%81%E6%98%8E.png" alt></p><a id="more"></a> <h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, pre[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; s[i], pre[i] = i;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) sum += s[pre[j]][pre[i]] &amp; <span class="number">1</span>;</span><br><span class="line">      res = min(res, sum);</span><br><span class="line">    &#125; <span class="keyword">while</span> (next_permutation(pre, pre + n));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode1563：石子游戏V</title>
      <link href="2020/08/LeetCode1563%EF%BC%9A%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8FV.html"/>
      <url>2020/08/LeetCode1563%EF%BC%9A%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8FV.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>几块石子 排成一行 ，每块石子都有一个关联值，关联值为整数，由数组 stoneValue 给出。</p><p>游戏中的每一轮：Alice 会将这行石子分成两个 非空行（即，左侧行和右侧行）；Bob 负责计算每一行的值，即此行中所有石子的值的总和。Bob 会丢弃值最大的行，Alice 的得分为剩下那行的值（每轮累加）。如果两行的值相等，Bob 让 Alice 决定丢弃哪一行。下一轮从剩下的那一行开始。</p><p>只 <strong>剩下一块石子</strong> 时，游戏结束。Alice 的分数最初为 <strong>0</strong> 。</p><a id="more"></a> <p>返回 Alice 能够获得的最大分数 。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>$dp[l][r]$ 表示区间 $[l,r]$ Alice能得到的最大值，然后区间dp。</p><p>若$sum[l…mid] == sum[mid+1…r]$ ，则 $dp[l][r] = max(dp[l][r], dp[l][mid] + dp[mid + 1][r] + sum[l…mid])$。</p><p>若$sum[l…mid] != sum[mid+1…r]$ :</p><ul><li>$sum[l…mid] &gt; sum[mid + 1][r]$ ，则 $dp[l][r] = max(dp[l][r], dp[mid + 1][r] + sum[mid+1…r])$。</li><li>$sum[l…mid] &lt; sum[mid + 1][r]$ ，则 $dp[l][r] = max(dp[l][r], dp[l][mid] + sum[l…mid])$。</li></ul><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">stoneGameV</span><span class="params">(<span class="keyword">int</span>[] stoneValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = stoneValue.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">int</span>[] sum = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        sum[<span class="number">0</span>] = stoneValue[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] + stoneValue[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; len++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l + len - <span class="number">1</span> &lt; n; l++) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = l + len - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> mid = l; mid &lt; r; mid++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> fl = sum[mid] - (l &gt; <span class="number">0</span> ? sum[l - <span class="number">1</span>] : <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">int</span> fr = sum[r] - sum[mid];</span><br><span class="line">                    <span class="keyword">if</span> (fl == fr) &#123;</span><br><span class="line">                        dp[l][r] = Math.max(dp[l][r], Math.max(dp[l][mid], dp[mid + <span class="number">1</span>][r]) + fl);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (fl &gt; fr) &#123;</span><br><span class="line">                            dp[l][r] = Math.max(dp[l][r], dp[mid + <span class="number">1</span>][r] + fr);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            dp[l][r] = Math.max(dp[l][r], dp[l][mid] + fl);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区间dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：二维网格图中探测环</title>
      <link href="2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E4%BA%8C%E7%BB%B4%E7%BD%91%E6%A0%BC%E5%9B%BE%E4%B8%AD%E6%8E%A2%E6%B5%8B%E7%8E%AF.html"/>
      <url>2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E4%BA%8C%E7%BB%B4%E7%BD%91%E6%A0%BC%E5%9B%BE%E4%B8%AD%E6%8E%A2%E6%B5%8B%E7%8E%AF.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>问二维矩阵中是否存在相同字母构成的环。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>判环问题，显然可以想到并查集。遍历矩阵，若该点与之前遍历过的相邻点字符相同且是同一个根的话，说明存在环，否则合并这两个点。<br><a id="more"></a> </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] pre = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">500005</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pre[x] == x ? x : (pre[x] = find(pre[x]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fx = find(x), fy = find(y);</span><br><span class="line">        <span class="keyword">if</span> (fx == fy) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        pre[fx] = fy;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsCycle</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.length, m = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n * m; i++)</span><br><span class="line">            pre[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; grid[i][j] == grid[i - <span class="number">1</span>][j] &amp;&amp; join(i * m + j, (i - <span class="number">1</span>) * m + j)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; grid[i][j] == grid[i][j - <span class="number">1</span>] &amp;&amp; join(i * m + j, i * m + j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：数数组</title>
      <link href="2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%95%B0%E6%95%B0%E7%BB%84.html"/>
      <url>2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%95%B0%E6%95%B0%E7%BB%84.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>构造一个长度为 $n$ 的序列，每个数字大小必须满足 $l &lt;= a[i] &lt;= r$，且和被 3 整除，问有多少种方法？</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><a id="more"></a> <p>$dp[i][j]$ 表示长度为 $i$，余数为 $j$ 的构造数量。$a,b,c$ 表示区间内余数为 $0,1,2$ 的数的数量。</p><p>转移方程：</p><p>$dp[i][0] = a <em> dp[i - 1][0] + b </em> dp[i - 1][2] + c <em> dp[i - 1][1]$;<br>$dp[i][1] = (a </em> dp[i - 1][1] + b <em> dp[i - 1][0] + c </em> dp[i - 1][2]$;<br>$dp[i][2] = (a <em> dp[i - 1][2] + b </em> dp[i - 1][1] + c * dp[i - 1][0]$;</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll n, l, r, dp[<span class="number">200005</span>][<span class="number">3</span>], a, b, c;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; l &gt;&gt; r;</span><br><span class="line">  <span class="keyword">while</span> (l % <span class="number">3</span> != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = l % <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span>)</span><br><span class="line">      b++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">2</span>)</span><br><span class="line">      c++;</span><br><span class="line">    l++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (r % <span class="number">3</span> != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = r % <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">2</span>)</span><br><span class="line">      c++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">1</span>)</span><br><span class="line">      b++;</span><br><span class="line">    r--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> p = (r - l) / <span class="number">3</span>;</span><br><span class="line">  a += p;</span><br><span class="line">  b += p;</span><br><span class="line">  c += p;</span><br><span class="line">  a++;</span><br><span class="line">  dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = (a * dp[i - <span class="number">1</span>][<span class="number">0</span>] + b * dp[i - <span class="number">1</span>][<span class="number">2</span>] + c * dp[i - <span class="number">1</span>][<span class="number">1</span>]) % mod;</span><br><span class="line">    dp[i][<span class="number">1</span>] = (a * dp[i - <span class="number">1</span>][<span class="number">1</span>] + b * dp[i - <span class="number">1</span>][<span class="number">0</span>] + c * dp[i - <span class="number">1</span>][<span class="number">2</span>]) % mod;</span><br><span class="line">    dp[i][<span class="number">2</span>] = (a * dp[i - <span class="number">1</span>][<span class="number">2</span>] + b * dp[i - <span class="number">1</span>][<span class="number">1</span>] + c * dp[i - <span class="number">1</span>][<span class="number">0</span>]) % mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; dp[n][<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 计数dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机类加载机制</title>
      <link href="2020/08/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.html"/>
      <url>2020/08/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>虚拟机把描述类的数据从 Class 文件<strong>加载到内存</strong>，井对数据进行<strong>校验</strong>、转换<strong>解析</strong>和<strong>初始化</strong>，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。</p><h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>类从被加载到虚拟机内存中开始，到卸栽出内存为止，它的整个生命周期包括了：加载、验证、准备、解析、初始化、使用和卸载七个阶段。其中验证、准备和解析三个部分统称为连接。</p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>加载是类加载过程中的一个阶段，这个阶段虚拟机要完成3件事。<br><a id="more"></a> </p><ol><li><p>通过一个类的全限定名来获取定义此类的二进制字节流。</p></li><li><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</p></li><li><p>会在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个 Class 文件获取，这里既可以从 ZIP 包中读取（比如从 jar 包和 war 包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将 JSP 文件转换成对应的 Class 类）</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>这一阶段的主要目的是为了确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，保证被加载类的正确性，不会危害虚拟机自身的安全。验证主要包含4个阶段的校验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。</p></li></ol><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。注意这里所说的初始值概念，比如一个类变量定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>实际上变量 value 在准备阶段过后的初始值为 0 而不是 123，将 value 赋值为 123 的 putstatic 指令是程序被编译后，存放于类构造器方法之中。</p><p>但是注意如果声明为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>在编译阶段会为 value 生成 ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 属性将 value 赋值为 123。</p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是在 class 文件中以： CONSTANT_Class_info、CONSTANT_Field_info<br>、CONSTANT_Method_info等类型的常量出现。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由 JVM 主导。到了初始阶段，才开始真正执行类中定义的 Java 程序代码。</p><p>那么，什么时候开始初始化？</p><p>使用 new 该类实例化对象的时候；</p><p>读取或设置类静态字段的时候（但被final修饰的字段，在编译器时就被放入常量池的静态字段除外static final）；</p><p>调用类静态方法的时候；</p><p>使用反射 Class.forName(“xxxx”) 对类进行反射调用的时候，该类需要初始化；</p><p>初始化一个类的时候，有父类，先初始化父类（注：1. 接口除外，父接口在调用的时候才会被初始化；2.子类引用父类静态字段，只会引发父类初始化）；</p><p>被标明为启动类的类（即包含main()方法的类）要初始化；</p><p>当使用 JDK1.7 的动态语言支持时，如果一个 java.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</p><p>以上情况称为对一个类进行主动引用，且有且只要以上几种情况需要对类进行初始化。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现kth_element</title>
      <link href="2020/08/%E5%AE%9E%E7%8E%B0kth-element.html"/>
      <url>2020/08/%E5%AE%9E%E7%8E%B0kth-element.html</url>
      
        <content type="html"><![CDATA[<p>快排的思想，选定一个基准数，将大于 $mid$ 的数放到右边，小于的放到左边，然后比较 $mid$ 和 $k$ 的位置，递归重复操作即可。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">&quot;Ofast&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&lt;!--more--&gt; </span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">0</span>, w = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> c = getchar();</span><br><span class="line">  <span class="keyword">while</span> (c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) w ^= <span class="number">1</span>;</span><br><span class="line">    c = getchar();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (c &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; c &gt;= <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">    x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    c = getchar();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> w &amp; <span class="number">1</span> ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kth_element</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> mid = l - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; r; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] &lt; a[r] &amp;&amp; a[i] ^ a[++mid]) a[i] ^= a[mid] ^= a[i] ^= a[mid];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (a[++mid] ^ a[r]) a[mid] ^= a[r] ^= a[mid] ^= a[r];</span><br><span class="line">  <span class="keyword">if</span> (mid == k) <span class="keyword">return</span> a[mid];</span><br><span class="line">  <span class="keyword">return</span> (mid &gt;= k) ? kth_element(a, l, mid - <span class="number">1</span>, k)</span><br><span class="line">                    : kth_element(a, mid + <span class="number">1</span>, r, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">2000006</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, k;</span><br><span class="line">  n = read();</span><br><span class="line">  k = read();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) a[i] = read();</span><br><span class="line">  <span class="comment">// random_shuffle(a, a + n);</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, kth_element(a, <span class="number">0</span>, n - <span class="number">1</span>, n - k));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：队列之和</title>
      <link href="2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E9%98%9F%E5%88%97%E4%B9%8B%E5%92%8C.html"/>
      <url>2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E9%98%9F%E5%88%97%E4%B9%8B%E5%92%8C.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两个队列$a$和$b$，问你能否构造出给定的队列$c$。</p><h2 id="Solutuon"><a href="#Solutuon" class="headerlink" title="Solutuon"></a>Solutuon</h2><p>很经典的动态规划，$dp[i][j]$ 表示第一个队列的前 $i$ 个数和第二个队列的第 $j$ 个数能否组成第三个队列的前 $i+j$ 个数。状态转移方程：$dp[i][j] = (dp[i - 1][j]$ $and$ $a[i] == c[i + j]$ $or$ $dp[i][j - 1]$ $and$ $b[j] == c[i + j])$。<br><a id="more"></a> </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1005</span>][<span class="number">1005</span>], T, A, B, a[<span class="number">1005</span>], b[<span class="number">1005</span>], c[<span class="number">2005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;A, &amp;B);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= A; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= B; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= A + B; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c[i]);</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">1</span>; t &lt;= A + B; t++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= A; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = t - i;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; <span class="number">0</span> || j &gt; B) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; c[t] == a[i] &amp;&amp; dp[i - <span class="number">1</span>][j]) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (j &amp;&amp; c[t] == b[j] &amp;&amp; dp[i][j - <span class="number">1</span>]) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dp[A][B])</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;possible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;not possible&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杭电多校：Tree</title>
      <link href="2020/08/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%EF%BC%9ATree.html"/>
      <url>2020/08/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%EF%BC%9ATree.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一颗树，路径只能由父节点指向子节点，你可以增加一条有向边，使得联通点对最多。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>容易发现，当叶子结点往根结点连一条边时，增加的点对会是最多的。$dp1[i]$ 表示从 $i$ 结点出发可以到达多少点，$dp2[i]$ 表示当前以 $i$ 为根结点，能增加的最大点对数（最大值）。<br><a id="more"></a> </p><p>对于 $dp1[i]$，状态转移方程：$dp1[fa] += dp1[son]$。</p><p>对于 $dp2[i]$，状态转移方程：$ for All(son): dp2[fa] = max(dp2[fa], dp2[son]), dp2[fa] += n - dp1[fa]$。</p><p>$sum(dp1)$ 即为不加边的点对数和，$dp2[1]$ 得到的即为增加一条边能增加的最大点对数。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"><span class="keyword">int</span> t, n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> res, dp1[N], dp2[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">  dp1[u] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> v : g[u]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">    dfs(v, u);</span><br><span class="line">    dp2[u] = max(dp2[u], dp2[v]);</span><br><span class="line">    dp1[u] += dp1[v];</span><br><span class="line">  &#125;</span><br><span class="line">  dp2[u] += n - dp1[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">  <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      g[i].clear();</span><br><span class="line">      dp1[i] = <span class="number">0</span>;</span><br><span class="line">      dp2[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> x;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">      g[x].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res += dp1[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res + dp2[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 多校训练 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多校训练 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：高度不超过m的二叉树个数</title>
      <link href="2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E9%AB%98%E5%BA%A6%E4%B8%8D%E8%B6%85%E8%BF%87m%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AA%E6%95%B0.html"/>
      <url>2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E9%AB%98%E5%BA%A6%E4%B8%8D%E8%B6%85%E8%BF%87m%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AA%E6%95%B0.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>求 $n$ 个节点，高度不超过 $h$ 的二叉树的个数，结果模 $1e9 + 7$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><a id="more"></a> <p>定义 $f[i][j]$ 为 $i$ 个点组成高度不超过 $j$ 的二叉树的数量，则得到状态转移方程：$f[i][j] = f[k][j-1] * f[i-k-1][j-1]$，表示即选出一个根节点，两边子树高度不超过 $j - 1$ 的数量，初始状态为 $f[0][i] = 1$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, h;</span><br><span class="line">ll f[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;h);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) f[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; k++)</span><br><span class="line">        f[i][j] = (f[i][j] + f[k][j - <span class="number">1</span>] * f[i - k - <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, f[n][h]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 计数dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：完美对物品</title>
      <link href="2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%AE%8C%E7%BE%8E%E5%AF%B9%E7%89%A9%E5%93%81.html"/>
      <url>2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%AE%8C%E7%BE%8E%E5%AF%B9%E7%89%A9%E5%93%81.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>$n$ 个物体，每个物品都有 $k$ 个属性，实际上就是 $a[n][k]$ 的数组，满足 $a[i][0]+a[j][0]=a[i][1]+a[j][1]=…=a[i][k−1]+a[j][k−1]$ 的物体 $i$ 和物体 $j$ 称为一对完美对，求完美对对数。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><a id="more"></a> <p>公式变形：$x1 + y1 = x2 + y2 -&gt; x1-x2 = -(y1-y2)$，用一个 $map(vector, int)$ 来记录每件物品的差值即可，然后去 $map$ 里面查找有几个正好是相反数 $vector$，累加答案即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">15</span>];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, k, res = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++) </span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; a[j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= k; j++) &#123;</span><br><span class="line">      g.push_back(a[j] - a[j - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    res += mp[g];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; g.size(); j++) &#123;</span><br><span class="line">      g[j] = -g[j];</span><br><span class="line">    &#125;</span><br><span class="line">    mp[g]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：Optimal Sum</title>
      <link href="2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AOptimal-Sum.html"/>
      <url>2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AOptimal-Sum.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你长度为 $n$ 的序列，你有一种能力可以将序列中的任意一个数变为相反数，在你不超过 $k$ 次使用能力的情况下，长度为 $len$ 的子区间的和的绝对值的最大值是多少？</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>用两个multiset维护区间前k大的负数，扫一遍就好了，细节略多。<br><a id="more"></a> </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, len, k;</span><br><span class="line">ll x1, x2, a[<span class="number">200005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll sum = <span class="number">0</span>, ma = <span class="number">-1e18</span>;</span><br><span class="line">  <span class="built_in">multiset</span>&lt;ll&gt; s1, s2;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] &gt;= <span class="number">0</span>)</span><br><span class="line">      sum += a[i];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s1.size() &lt; k) &#123;</span><br><span class="line">      s1.insert(a[i]);</span><br><span class="line">      sum -= a[i];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &amp;&amp; a[i] &lt; *(--s1.end())) &#123;</span><br><span class="line">      ll x = *(--s1.end());</span><br><span class="line">      sum += <span class="number">2</span> * x;</span><br><span class="line">      s1.erase(--s1.end());</span><br><span class="line">      s2.insert(x);</span><br><span class="line">      s1.insert(a[i]);</span><br><span class="line">      sum -= a[i];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      s2.insert(a[i]);</span><br><span class="line">      sum += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> j = i - len;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j] &gt;= <span class="number">0</span>)</span><br><span class="line">        sum -= a[j];</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (s1.find(a[j]) != s1.end()) &#123;</span><br><span class="line">        s1.erase(s1.find(a[j]));</span><br><span class="line">        sum += a[j];</span><br><span class="line">        <span class="keyword">if</span> (s2.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          ll x = *(s2.begin());</span><br><span class="line">          s1.insert(x);</span><br><span class="line">          s2.erase(s2.begin());</span><br><span class="line">          sum -= <span class="number">2</span> * x;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s2.erase(s2.find(a[j]));</span><br><span class="line">        sum -= a[j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt;= <span class="number">0</span>) ma = max(ma, sum);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ma;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;len);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">  x1 = solve();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = -a[i];</span><br><span class="line">  x2 = solve();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, max(x1, x2));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：异或</title>
      <link href="2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%BC%82%E6%88%96.html"/>
      <url>2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%BC%82%E6%88%96.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定整数 $m$ 以及 $n$ 各数字 $A_1,A_2,..A_n$，将数列 $A$ 中所有元素两两异或，共能得到 $n(n-1)/2$ 个结果，请求出这些结果中大于 $m$ 的有多少个。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>为了避免重复计算，字典树可以边维护边插入，先查询之前有多少个数与当前数 $x$ 异或和大于 $m$，我们从高位向低位枚举，对于两个数的同一个二进制位，需要分四种情况讨论：<br><a id="more"></a> </p><ol><li><p>$x_i = 1, m_i = 1$，则查询的数当前位必须为 $0$ 才可。</p></li><li><p>$x_i = 0, m_i = 1$，则查询的数当前位必须为 $1$ 才可。</p></li><li><p>$x_i = 1, m_i = 0$，则查询数当前位为 $0$ 的直接满足条件计入答案，当前位为 $1$ 的继续向下查找。</p></li><li><p>$x_i = 0, m_i = 0$，则查询数当前位为 $1$ 的直接满足条件计入答案，当前位为 $0$ 的继续向下查找。</p></li></ol><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">6e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, m, idx, cnt[N], trie[N][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p = <span class="number">0</span>, y;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; ~i; i--) &#123;</span><br><span class="line">    y = x &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;s = trie[p][y];</span><br><span class="line">    <span class="keyword">if</span> (!s) s = ++idx;</span><br><span class="line">    p = s;</span><br><span class="line">    cnt[p]++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p = <span class="number">0</span>, p1, sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; ~i; i--) &#123;</span><br><span class="line">    <span class="keyword">int</span> y = x &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> z = m &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="number">1</span> &amp;&amp; z == <span class="number">1</span>) &#123;</span><br><span class="line">      p = trie[p][<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y == <span class="number">0</span> &amp;&amp; z == <span class="number">1</span>) &#123;</span><br><span class="line">      p = trie[p][<span class="number">1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y == <span class="number">1</span> &amp;&amp; z == <span class="number">0</span>) &#123;</span><br><span class="line">      p1 = trie[p][<span class="number">0</span>];</span><br><span class="line">      p = trie[p][<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span> (p1) sum += cnt[p1];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y == <span class="number">0</span> &amp;&amp; z == <span class="number">0</span>) &#123;</span><br><span class="line">      p1 = trie[p][<span class="number">1</span>];</span><br><span class="line">      p = trie[p][<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">if</span> (p1) sum += cnt[p1];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    res += query(x);</span><br><span class="line">    insert(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字典树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim配置</title>
      <link href="2020/08/Vim%E9%85%8D%E7%BD%AE.html"/>
      <url>2020/08/Vim%E9%85%8D%E7%BD%AE.html</url>
      
        <content type="html"><![CDATA[<p>写C++还是用vim爽啊，曾经三次尝试vim，寒假的时候终于能得到一份比较不错的配置了。</p><p>配色用的是atom的onedark，个人感觉挺好看的。</p><p><img src="http://img.benboby.top/%E7%95%8C%E9%9D%A2.png" alt></p><p>贴个配置，即开即用。</p><a id="more"></a> <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&quot; Vundle set nocompatible</span></span><br><span class="line"><span class="keyword">filetype</span> off</span><br><span class="line"><span class="keyword">set</span> rtp+=~/.<span class="keyword">vim</span>/bundle/Vundle.<span class="keyword">vim</span></span><br><span class="line"><span class="keyword">call</span> vundle#begin()</span><br><span class="line">Plugin <span class="string">&#x27;VundleVim/Vundle.vim&#x27;</span></span><br><span class="line">Plugin <span class="string">&#x27;gdbmgr&#x27;</span></span><br><span class="line">Plugin <span class="string">&#x27;The-NERD-Tree&#x27;</span> <span class="comment">&quot; 目录树</span></span><br><span class="line">Plugin <span class="string">&#x27;mbbill/undotree&#x27;</span> <span class="comment">&quot; 撤回树</span></span><br><span class="line">Plugin <span class="string">&#x27;majutsushi/tagbar&#x27;</span> <span class="comment">&quot; 函数、变量名</span></span><br><span class="line">Plugin <span class="string">&#x27;vim-airline/vim-airline&#x27;</span> <span class="comment">&quot; 状态栏</span></span><br><span class="line">Plugin <span class="string">&#x27;vim-airline/vim-airline-themes&#x27;</span> <span class="comment">&quot;状态栏</span></span><br><span class="line">Plugin <span class="string">&#x27;arzg/vim-colors-xcode&#x27;</span>  <span class="comment">&quot; xcode 主题</span></span><br><span class="line"><span class="string">&quot;Plugin &#x27;cohlin/vim-colorschemes&#x27; &quot;</span> xcode 主题</span><br><span class="line">Plugin <span class="string">&#x27;tomasr/molokai&#x27;</span> <span class="comment">&quot; molokai 主题</span></span><br><span class="line">Plugin <span class="string">&#x27;ashfinal/vim-colors-violet&#x27;</span> <span class="comment">&quot; violet 主题</span></span><br><span class="line">Plugin <span class="string">&#x27;joshdick/onedark.vim&#x27;</span> <span class="comment">&quot; onedark主题</span></span><br><span class="line">Plugin <span class="string">&#x27;sheerun/vim-polyglot&#x27;</span> <span class="comment">&quot; 语法突出显示</span></span><br><span class="line">Plugin <span class="string">&#x27;jiangmiao/auto-pairs&#x27;</span> <span class="comment">&quot; 括号补全</span></span><br><span class="line">Plugin <span class="string">&#x27;iamcco/mathjax-support-for-mkdp&#x27;</span> <span class="comment">&quot; 数学公式</span></span><br><span class="line">Plugin <span class="string">&#x27;plasticboy/vim-markdown&#x27;</span>  <span class="comment">&quot; markdown预览</span></span><br><span class="line">Plugin <span class="string">&#x27;iamcco/markdown-preview.vim&#x27;</span> <span class="comment">&quot; markdown预览</span></span><br><span class="line">Plugin <span class="string">&#x27;Valloric/YouCompleteMe&#x27;</span> <span class="comment">&quot; 代码补全</span></span><br><span class="line">Plugin <span class="string">&#x27;zxqfl/tabnine-vim&#x27;</span> <span class="comment">&quot;代码补全</span></span><br><span class="line">Plugin <span class="string">&#x27;tpope/vim-commentary&#x27;</span> <span class="comment">&quot; 代码注释</span></span><br><span class="line">Plugin <span class="string">&#x27;sillybun/vim-repl&#x27;</span>   <span class="comment">&quot; 代码调试</span></span><br><span class="line">Plugin <span class="string">&#x27;w0rp/ale&#x27;</span> <span class="comment">&quot; 语法纠错</span></span><br><span class="line"><span class="string">&quot;Plugin &#x27;octol/vim-cpp-enhanced-highlight&#x27; &quot;</span> <span class="keyword">c</span>++语法高亮</span><br><span class="line">Plugin <span class="string">&#x27;TagHighlight&#x27;</span> <span class="comment">&quot; c++语法高亮</span></span><br><span class="line">Plugin <span class="string">&#x27;Shougo/echodoc.vim&#x27;</span> <span class="comment">&quot; c++函数提示</span></span><br><span class="line">Plugin <span class="string">&#x27;rhysd/vim-clang-format&#x27;</span> <span class="comment">&quot; 代码格式化</span></span><br><span class="line">Plugin <span class="string">&#x27;Chiel92/vim-autoformat&#x27;</span> <span class="comment">&quot; c++代码格式化</span></span><br><span class="line">Plugin <span class="string">&#x27;scrooloose/nerdcommenter&#x27;</span> <span class="comment">&quot; c++代码注释</span></span><br><span class="line">Plugin <span class="string">&#x27;artur-shaik/vim-javacomplete2&#x27;</span> <span class="comment">&quot; java代码补全</span></span><br><span class="line">Plugin <span class="string">&#x27;python-mode/python-mode&#x27;</span>  <span class="comment">&quot; python mode</span></span><br><span class="line">Plugin <span class="string">&#x27;fatih/vim-go&#x27;</span>  <span class="comment">&quot; go语言</span></span><br><span class="line">Plugin <span class="string">&#x27;terryma/vim-multiple-cursors&#x27;</span> <span class="comment">&quot; vim 多行编辑</span></span><br><span class="line">Plugin <span class="string">&#x27;mhinz/vim-startify&#x27;</span> <span class="comment">&quot; 欢迎界面</span></span><br><span class="line"><span class="keyword">call</span> vundle#end()</span><br><span class="line"><span class="keyword">filetype</span> plugin <span class="built_in">indent</span> <span class="keyword">on</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> backspace=<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; javacomplete2</span></span><br><span class="line"><span class="comment">&quot; https://github.com/artur-shaik/vim-javacomplete2</span></span><br><span class="line"><span class="keyword">autocmd</span> FileType java <span class="keyword">setlocal</span> omnifunc=javacomplete#Complete</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot;   TagHighlight</span></span><br><span class="line"><span class="comment">&quot; UpdateTypesFile</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; multiple cursors</span></span><br><span class="line"><span class="comment">&quot;start: &lt;C-n&gt; start multicursor and add a virtual cursor + selection on the match</span></span><br><span class="line"><span class="comment">&quot;next: &lt;C-n&gt; add a new virtual cursor + selection on the next match</span></span><br><span class="line"><span class="comment">&quot;skip: &lt;C-x&gt; skip the next match</span></span><br><span class="line"><span class="comment">&quot;prev: &lt;C-p&gt; remove current virtual cursor + selection and go back on previous match</span></span><br><span class="line"><span class="comment">&quot;select all: &lt;A-n&gt; start multicursor and directly select all matches</span></span><br><span class="line"><span class="comment">&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; plugin nerdcommenter</span></span><br><span class="line"><span class="keyword">let</span> mapleader = <span class="string">&quot;,&quot;</span></span><br><span class="line"><span class="keyword">let</span> NERDSpaceDelims=<span class="number">1</span>           <span class="comment">&quot; 让注释符与语句之间留一个空格</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDDefaultAlign</span> = <span class="string">&#x27;left&#x27;</span>  <span class="comment">&quot;将行注释符左对齐</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; auto save</span></span><br><span class="line"><span class="string">&quot; let g:auto_save = 5  &quot;</span> enable AutoSave <span class="keyword">on</span> Vim startup</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; plugin undotree</span></span><br><span class="line"><span class="comment">&quot; :UndotreeToggle</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; plugin NERDTree</span></span><br><span class="line"><span class="comment">&quot; :NERDTreeToggle</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; plugin tarbar</span></span><br><span class="line"><span class="comment">&quot; :TagbarToggle</span></span><br><span class="line"><span class="comment">&quot;</span></span><br><span class="line"><span class="comment">&quot; plugin autoformat</span></span><br><span class="line"><span class="comment">&quot; :Autoformat</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:autoformat_verbosemode</span>=<span class="number">1</span> <span class="comment">&quot;开启详细模式便于查错</span></span><br><span class="line"><span class="comment">&quot; c++</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:formatdef_clangformat_google</span> = <span class="string">&#x27;&quot;clang-format -style google -&quot;&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:formatters_cpp</span> = [<span class="string">&#x27;clangformat_google&#x27;</span>]</span><br><span class="line"><span class="comment">&quot; python</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:formatdef_autopep8</span> = <span class="string">&quot;&#x27;autopep8 - --range &#x27;.a:firstline.&#x27; &#x27;.a:lastline&quot;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:formatters_python</span> = [<span class="string">&#x27;autopep8&#x27;</span>]</span><br><span class="line"><span class="comment">&quot; java</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:formatdef_astyle_java</span> = <span class="string">&#x27;&quot;astyle --mode=java --style=google -pcHs2&quot;&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:formatdef_java</span> = [<span class="string">&#x27;astyle_java&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; plugin echodoc</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:echodoc</span>#type = <span class="string">&quot;echo&quot;</span> <span class="comment">&quot; Default value</span></span><br><span class="line"><span class="keyword">set</span> noshowmode</span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:echodoc_enable_at_startup</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; plugin YCM</span></span><br><span class="line"><span class="comment">&quot;let g:ycm_global_ycm_extra_conf=&#x27;~/.ycm_extra_conf.py&#x27;</span></span><br><span class="line"><span class="comment">&quot;set completeopt=menu</span></span><br><span class="line"><span class="comment">&quot; YouCompleteMe</span></span><br><span class="line"><span class="keyword">set</span> runtimepath+=~/.<span class="keyword">vim</span>/bundle/YouCompleteMe</span><br><span class="line"><span class="keyword">set</span> completeopt=longest,<span class="keyword">menu</span>    <span class="comment">&quot;让Vim的补全菜单行为与一般IDE一致(参考VimTip1228)</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_collect_identifiers_from_tags_files</span> = <span class="number">1</span>           <span class="comment">&quot; 开启 YCM 基于标签引擎</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_collect_identifiers_from_comments_and_strings</span> = <span class="number">1</span> <span class="comment">&quot; 注释与字符串中的内容也用于补全</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:syntastic_ignore_files</span>=[<span class="string">&quot;.*\.py$&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_seed_identifiers_with_syntax</span> = <span class="number">1</span>                  <span class="comment">&quot; 语法关键字补全</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_complete_in_comments</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_confirm_extra_conf</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_key_list_select_completion</span> = [<span class="string">&#x27;&lt;c-n&gt;&#x27;</span>, <span class="string">&#x27;&lt;Down&gt;&#x27;</span>]  <span class="comment">&quot; 映射按键, 没有这个会拦截掉tab, 导致其他插件的tab不能用.</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_key_list_previous_completion</span> = [<span class="string">&#x27;&lt;c-p&gt;&#x27;</span>, <span class="string">&#x27;&lt;Up&gt;&#x27;</span>]</span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_complete_in_comments</span> = <span class="number">1</span>                          <span class="comment">&quot; 在注释输入中也能补全</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_complete_in_strings</span> = <span class="number">1</span>                           <span class="comment">&quot; 在字符串输入中也能补全</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_collect_identifiers_from_comments_and_strings</span> = <span class="number">1</span> <span class="comment">&quot; 注释和字符串中的文字也会被收入补全</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_global_ycm_extra_conf</span>=<span class="string">&#x27;~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_show_diagnostics_ui</span> = <span class="number">0</span>                           <span class="comment">&quot; 禁用语法检查</span></span><br><span class="line"><span class="comment">&quot; 回车即选中当前项</span></span><br><span class="line"><span class="keyword">inoremap</span> <span class="symbol">&lt;expr&gt;</span> <span class="symbol">&lt;CR&gt;</span> <span class="built_in">pumvisible</span>() ? <span class="string">&quot;\&lt;C-y&gt;&quot;</span> : <span class="string">&quot;\&lt;CR&gt;&quot;</span> |</span><br><span class="line"><span class="comment">&quot; 跳转到定义处</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;c-j&gt;</span> :YcmCompleter GoToDefinitionElseDeclaration<span class="symbol">&lt;CR&gt;</span>|</span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_min_num_of_chars_for_completion</span>=<span class="number">2</span>                 <span class="comment">&quot; 从第2个键入字符就开始罗列匹配项</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot;disable ycm 语法检查</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_enable_diagnostic_signs</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_enable_diagnostic_highlighting</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_error_symbol</span> = <span class="string">&#x27;K&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_warning_symbol</span> = <span class="string">&#x27;O&#x27;</span></span><br><span class="line"><span class="comment">&quot; plugin vim-markdown 自动折叠关闭</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:vim_markdown_folding_disabled</span>=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot;auto-format 格式化</span></span><br><span class="line"><span class="comment">&quot;F5自动格式化代码并保存</span></span><br><span class="line"><span class="comment">&quot;自动格式化代码，针对所有支持的文件</span></span><br><span class="line"><span class="comment">&quot;au BufWrite * :Autoformat</span></span><br><span class="line"><span class="comment">&quot;自动格式化python代码</span></span><br><span class="line"><span class="comment">&quot;au BufWrite *.py :Autoformatet g:autoformat_verbosemode=1</span></span><br><span class="line"><span class="comment">&quot;默认情况下是pep8，还可以选择google,facebook和chromium</span></span><br><span class="line"><span class="comment">&quot;let g:formatter_yapf_style = &#x27;google&#x27;</span></span><br><span class="line"><span class="string">&quot;let g:formatdef_my_cpp = &#x27;&quot;</span>astyle --style=webkit<span class="comment">&quot;&#x27;</span></span><br><span class="line"><span class="comment">&quot;let g:formatters_cpp = [&#x27;my_cpp&#x27;]</span></span><br><span class="line"><span class="comment">&quot;au BufWrite * :Autoformat</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; 代码调试快捷键</span></span><br><span class="line"><span class="keyword">autocmd</span> Filetype <span class="keyword">python</span> <span class="keyword">nnoremap</span> <span class="symbol">&lt;F12&gt;</span> <span class="symbol">&lt;Esc&gt;</span>:REPLDebugStopAtCurrentLine<span class="symbol">&lt;Cr&gt;</span></span><br><span class="line"><span class="keyword">autocmd</span> Filetype <span class="keyword">python</span> <span class="keyword">nnoremap</span> <span class="symbol">&lt;F10&gt;</span> <span class="symbol">&lt;Esc&gt;</span>:REPLPDBN<span class="symbol">&lt;Cr&gt;</span></span><br><span class="line"><span class="keyword">autocmd</span> Filetype <span class="keyword">python</span> <span class="keyword">nnoremap</span> <span class="symbol">&lt;F11&gt;</span> <span class="symbol">&lt;Esc&gt;</span>:REPLPDBS<span class="symbol">&lt;Cr&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; Let clangd fully control code completion</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_clangd_uses_ycmd_caching</span> = <span class="number">0</span></span><br><span class="line"><span class="comment">&quot; Use installed clangd, not YCM-bundled clangd which doesn&#x27;t get updates.</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_clangd_binary_path</span> = exepath(<span class="string">&quot;clangd&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot;目录树</span></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;F2&gt;</span> :NERDTreeToggle<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot;Python缩进</span></span><br><span class="line"><span class="keyword">autocmd</span> FileType <span class="keyword">python</span> <span class="keyword">set</span> tabstop=<span class="number">4</span> | <span class="keyword">set</span> expandtab | <span class="keyword">set</span> autoindent</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; plugin airline</span></span><br><span class="line"><span class="keyword">set</span> laststatus=<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; plugin ale</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ale_linters</span> = &#123;</span><br><span class="line">      \   <span class="string">&#x27;cpp&#x27;</span>: [<span class="string">&#x27;gcc&#x27;</span>],</span><br><span class="line">      \&#125;</span><br><span class="line"><span class="comment">&quot;始终开启标志列</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ale_sign_column_always</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ale_set_highlights</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ale_echo_msg_format</span> = <span class="string">&#x27;ale[%linter%] %code: %%s&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ale_cpp_gcc_executable</span> = <span class="string">&#x27;/usr/local/bin/g++-9 -I /usr/local/Cellar/eigen/3.3.7/include/eigen3&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ale_sign_error</span> = <span class="string">&#x27;✗&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ale_sign_warning</span> = <span class="string">&#x27;⚡&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ale_lint_on_text_changed</span> = <span class="string">&#x27;always&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; 语法高亮</span></span><br><span class="line"><span class="keyword">let</span> c_no_curly_error = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:cpp_class_scope_highlight</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:cpp_member_variable_highlight</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:cpp_class_decl_highlight</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:cpp_experimental_simple_template_highlight</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:cpp_experimental_template_highlight</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:cpp_concepts_highlight</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">&quot;let g:cpp_no_function_highlight=1</span></span><br><span class="line"><span class="keyword">syntax</span> <span class="keyword">on</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; 主题</span></span><br><span class="line"><span class="comment">&quot;colorscheme xcode-default</span></span><br><span class="line"><span class="comment">&quot;colorscheme molokai</span></span><br><span class="line"><span class="comment">&quot;colorscheme violet</span></span><br><span class="line"><span class="keyword">colorscheme</span> onedark</span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:rehash256</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">set</span> cursorline    <span class="comment">&quot;or set cul 设置光标所在的行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> et <span class="comment">&quot;tab用空格替换</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> tabstop=<span class="number">2</span></span><br><span class="line"><span class="keyword">set</span> expandtab</span><br><span class="line"><span class="comment">&quot; Tab键的宽度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> softtabstop=<span class="number">2</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">shiftwidth</span>=<span class="number">2</span></span><br><span class="line"><span class="comment">&quot;  统一缩进为2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">number</span></span><br><span class="line"><span class="comment">&quot; 显示行号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">history</span>=<span class="number">10000</span></span><br><span class="line"><span class="comment">&quot; 历史纪录数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> hlsearch</span><br><span class="line"><span class="keyword">set</span> incsearch</span><br><span class="line"><span class="comment">&quot; 搜索逐字符高亮</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> encoding=utf-<span class="number">8</span></span><br><span class="line"><span class="keyword">set</span> fileencodings=utf-<span class="number">8</span>,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936,utf-<span class="number">16</span>,big5,euc-jp,latin1</span><br><span class="line"><span class="comment">&quot; 编码设置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; set mouse=a</span></span><br><span class="line"><span class="comment">&quot; use mouse</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> langmenu=zn_CN.UTF-<span class="number">8</span></span><br><span class="line"><span class="keyword">set</span> helplang=<span class="keyword">cn</span></span><br><span class="line"><span class="comment">&quot; 语言设置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> laststatus=<span class="number">2</span></span><br><span class="line"><span class="comment">&quot; 总是显示状态行 就是那些显示 --insert-- 的怪东西</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> showcmd</span><br><span class="line"><span class="comment">&quot; 在状态行显示目前所执行的命令，未完成的指令片段亦会显示出来</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> scrolloff=<span class="number">3</span></span><br><span class="line"><span class="comment">&quot; 光标移动到buffer的顶部和底部时保持3行距离</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> showmatch</span><br><span class="line"><span class="comment">&quot; 高亮显示对应的括号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> matchtime=<span class="number">1</span></span><br><span class="line"><span class="comment">&quot; 对应括号高亮的时间（单位是十分之一秒）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; 共享剪切板</span></span><br><span class="line"><span class="keyword">set</span> clipboard=unnamed</span><br><span class="line"><span class="keyword">set</span> norelativenumber</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &amp;t_SI.=<span class="string">&quot;\e[5 q&quot;</span> <span class="comment">&quot;SI = INSERT mode</span></span><br><span class="line"><span class="keyword">let</span> &amp;t_SR.=<span class="string">&quot;\e[4 q&quot;</span> <span class="comment">&quot;SR = REPLACE mode</span></span><br><span class="line"><span class="keyword">let</span> &amp;t_EI.=<span class="string">&quot;\e[1 q&quot;</span> <span class="comment">&quot;EI = NORMAL mode (ELSE)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:syntastic_cpp_compiler_options</span> = <span class="string">&#x27; -std=c++11 -stdlib=libc++&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; c++ 路径</span></span><br><span class="line"><span class="keyword">set</span> path=.,/usr/local/bin/g++-<span class="number">9</span>,/usr/local/include/<span class="keyword">c</span>++/<span class="number">9.3</span>.<span class="number">0</span>,/usr/local/Cellar/eigen/<span class="number">3.3</span>.<span class="number">7</span>/include/eigen3,/usr/local/Cellar/boost/<span class="number">1.72</span>.<span class="number">0</span>/include,/usr/local/Cellar/gcc/<span class="number">9.2</span>.<span class="number">0</span>_1/include/<span class="keyword">c</span>++/<span class="number">9.2</span>.<span class="number">0</span>,/usr/local/Cellar/gcc/<span class="number">9.2</span>.<span class="number">0</span>_1/include/<span class="keyword">c</span>++/<span class="number">9.2</span>.<span class="number">0</span>/x86_64-apple-darwin19,/usr/local/Cellar/gcc/<span class="number">9.2</span>.<span class="number">0</span>_1/include/<span class="keyword">c</span>++/<span class="number">9.2</span>.<span class="number">0</span>/backward,/usr/local/Cellar/gcc/<span class="number">9.2</span>.<span class="number">0</span>_1/lib/gcc/<span class="number">9</span>/gcc/x86_64-apple-darwin19/<span class="number">9.2</span>.<span class="number">0</span>/include,/usr/local/Cellar/gcc/<span class="number">9.2</span>.<span class="number">0</span>_1/lib/gcc/<span class="number">9</span>/gcc/x86_64-apple-darwin19/<span class="number">9.2</span>.<span class="number">0</span>/include-fixed,/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include,/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/System/Library/Frameworks,</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：数数</title>
      <link href="2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%95%B0%E6%95%B0.html"/>
      <url>2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%95%B0%E6%95%B0.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="http://img.benboby.top/%E9%A2%98%E7%9B%AE.png" alt></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p><img src="http://img.benboby.top/%E9%A2%98%E8%A7%A3.png" alt><br><a id="more"></a> </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> ll M = <span class="number">1e7</span>;</span><br><span class="line">ll t, n, ans1, ans2, x, p[M + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qp</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            ans = (ans * a) % mod;</span><br><span class="line">        a = (a * a) % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt;= M; i++)</span><br><span class="line">        p[i] = (p[i - <span class="number">1</span>] * i) % mod;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;t))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (t--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">            ans1 = <span class="number">0</span>, ans2 = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                x = (n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                ans1 = (((x * n) % mod) * ((x * n) % mod)) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                x = n / <span class="number">2</span>;</span><br><span class="line">                ans1 = (((x * (n + <span class="number">1</span>)) % mod) * ((x * (n + <span class="number">1</span>)) % mod)) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            ans2 = qp(p[n], <span class="number">2</span> * n);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>, ans1, ans2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode440：字典序的第K小数字</title>
      <link href="2020/08/LeetCode440%EF%BC%9A%E5%AD%97%E5%85%B8%E5%BA%8F%E7%9A%84%E7%AC%ACK%E5%B0%8F%E6%95%B0%E5%AD%97.html"/>
      <url>2020/08/LeetCode440%EF%BC%9A%E5%AD%97%E5%85%B8%E5%BA%8F%E7%9A%84%E7%AC%ACK%E5%B0%8F%E6%95%B0%E5%AD%97.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定整数 n 和 k，找到 1 到 n 中字典序第 k 小的数字。</p><p>注意：1 ≤ k ≤ n ≤ 10^9。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><a id="more"></a> <p>我们可以把每个字符看作是字符串，这样我们只需要考虑前缀即可。显然最小的字符串一定是0，然后是所有以1开头的数。。。</p><p>我们只需要枚举所有首位数字 $1-9$，计算每个前缀在区间 $[0, n]$ 内有多少个数就好了，当累加和超过 $n$ 时，说明答案一定是以这个首位数字开头的，然后向下枚举。比如当以得知答案以3开头时，扣除3本身，然后向下枚举前缀30,31重复上述操作。。。直到 $k$ 为0。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get_Count</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">long</span> x, <span class="keyword">long</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">            sum += Math.min(n + <span class="number">1</span>, y) - x;  <span class="comment">// 如n=15,则sum+=min(16,20)-10</span></span><br><span class="line">            x *= <span class="number">10</span>;</span><br><span class="line">            y *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthNumber</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">1</span>;</span><br><span class="line">        k--; <span class="comment">// 扣除数字0</span></span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> now = get_Count(n, pre, pre + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (k &gt;= now) &#123;  <span class="comment">// 说明不在这个前缀区间里</span></span><br><span class="line">                pre++;  <span class="comment">// 找下一个字典序前缀</span></span><br><span class="line">                k -= now;  <span class="comment">// 扣除这个前缀的所有数</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 说明答案是这个前缀</span></span><br><span class="line">                pre *= <span class="number">10</span>;  <span class="comment">// 往下找</span></span><br><span class="line">                k--; <span class="comment">// 扣除当前这个数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：Functions again</title>
      <link href="2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AFunctions-again.html"/>
      <url>2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AFunctions-again.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p><img src="http://img.benboby.top/fomula.png" alt></p><p>给定数组，求上述式子的最大值。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><a id="more"></a> <p>可以看出，上述式子是交替加减求最大子段和。预处理两项差的绝对值，那么只需要枚举起点是奇数位置还是偶数位置就可以了，根据贪心原则，起点肯定选正数，然后交替正负就好了，这样问题就转化成就求最大子段和了，贪心即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll a[N], b[N], d[N];</span><br><span class="line"> </span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll c[])</span> </span>&#123;</span><br><span class="line">  ll now = <span class="number">0</span>, ma = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (now &lt;= <span class="number">0</span>)</span><br><span class="line">      now = c[i];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      now += c[i];</span><br><span class="line">    ma = max(ma, now);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ma;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; a[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    ll x = llabs(a[i] - a[i - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (i &amp; <span class="number">1</span>)</span><br><span class="line">      b[i] = -x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      b[i] = x;</span><br><span class="line">    d[i] = -b[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; max(solve(b), solve(d)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode424：替换后的最长重复字符</title>
      <link href="2020/08/LeetCode424%EF%BC%9A%E6%9B%BF%E6%8D%A2%E5%90%8E%E7%9A%84%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6.html"/>
      <url>2020/08/LeetCode424%EF%BC%9A%E6%9B%BF%E6%8D%A2%E5%90%8E%E7%9A%84%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。</p><h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><p>枚举重复的字符，然后计算对应字符的能构成的最大长度，取最大值。<br><a id="more"></a> </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characterReplacement</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            List&lt;Integer&gt; l = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            l.add(-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(j) - <span class="string">&#x27;A&#x27;</span> != i) &#123;</span><br><span class="line">                    l.add(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l.size() &lt;= k + <span class="number">1</span>) &#123;</span><br><span class="line">                res = n;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            l.add(n);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = k + <span class="number">1</span>; j &lt; l.size(); j++) &#123;</span><br><span class="line">                res = Math.max(res, l.get(j) - l.get(j - k - <span class="number">1</span>) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><p>滑动窗口，一个区间满足条件的原则是$当前区间的长度&lt;=区间内出现次数最多的字符 + k$，用滑动窗口维护即可。即当满足条件时，滑动窗口拓展，右端点++；不满足时，滑动窗口平移，左右端点++。滑动窗口的长度只会不断增大，遍历结束后滑动窗口的长度即为答案。</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characterReplacement</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), res = <span class="number">0</span>, l = <span class="number">0</span>, r = <span class="number">0</span>, ma = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (r = <span class="number">0</span>; r &lt; n; r++) &#123;</span><br><span class="line">            <span class="keyword">int</span> now = s.charAt(r) - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            b[now]++;</span><br><span class="line">            ma = Math.max(ma, b[now]);</span><br><span class="line">            <span class="keyword">if</span> (ma + k &lt; r - l + <span class="number">1</span>) &#123;</span><br><span class="line">                b[s.charAt(l) - <span class="string">&#x27;A&#x27;</span>]--;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode354：俄罗斯套娃信封问题</title>
      <link href="2020/08/LeetCode354%EF%BC%9A%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98.html"/>
      <url>2020/08/LeetCode354%EF%BC%9A%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>求二维最长上升子序列</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>对第一维进行从小到大排序，然后第二维从大到小排序，对第二维做LIS即可。<br><a id="more"></a> </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="keyword">int</span>[][] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] low = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(a, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt; () &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] c1, <span class="keyword">int</span>[] c2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (c1[<span class="number">0</span>] == c2[<span class="number">0</span>]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> c2[<span class="number">1</span>] - c1[<span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> c1[<span class="number">0</span>] - c2[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (low[res] &lt; a[i][<span class="number">1</span>])</span><br><span class="line">                low[++res] = a[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> pos = Arrays.binarySearch(low, <span class="number">1</span>, res, a[i][<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line">                    pos = -pos - <span class="number">1</span>;</span><br><span class="line">                low[pos] = a[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：找出最长的超赞子字符串</title>
      <link href="2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%89%BE%E5%87%BA%E6%9C%80%E9%95%BF%E7%9A%84%E8%B6%85%E8%B5%9E%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html"/>
      <url>2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%89%BE%E5%87%BA%E6%9C%80%E9%95%BF%E7%9A%84%E8%B6%85%E8%B5%9E%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你一个字符串 s 。请返回 s 中最长的 超赞子字符串 的长度。</p><p>「超赞子字符串」需满足满足下述两个条件：</p><p>该字符串是 s 的一个非空子字符串<br><a id="more"></a><br>进行任意次数的字符交换重新排序后，该字符串可以变成一个回文字符串</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>首先，一个字符串可以重新排序得到一个回文字符串的充要条件是：对字符计数，出现奇数次的字符个数小于等于1。</p><p>由此我们可以发现：我们没有必要知道这个数字到底出现了几次，我们只需要关心它到底是出现了奇数次还是偶数次。我们用 $0,1$ 来表示出现了 $偶数/奇数$ 次，由于需要统计的字符只有 $0-9$ 十个数字，因此我们只需要一个十位的二进制数 $status$ 即可表示当前所有字符出现次数的奇偶状态，即第i位表示数字 $i$ 出现次数的奇偶性。</p><p>假设当前遇到的数字是 i ，那么更新它的状态就是 $status ^= (1 &lt;&lt; i)$ ，因为根据异或的特性，相同为0，不同为1，能够很好的实现我们需要的 $奇+奇(1+1)=偶+偶(0+0)=偶(0),奇+偶(1+0)= 偶+奇(0+1)=奇(1)$，改变对应二进制位的状态。</p><p>我们遍历字符串维护这样一个 $status$，采用数组标记的思想，$pre[status]$ 表示 $status$ 出现的最早位置。</p><p>满足超赞字符串的条件：</p><ol><li><p>再一次遇到之前已经出现过的 $status$ ，说明所有数字都出现了偶数次。（因为每一位二进制位的奇偶性都相同的话，不论都是1还是0，$奇-奇=偶-偶=偶$，都代表这些字符在中间这一段出现了偶数次，长度为 $当前位置i - 最早出现的位置pre[status]$）</p></li><li><p>与之前出现过的 $status$ 只有一个二进制位不同，说明这个不同的二进制位出现了奇数次 $(奇-偶=偶-奇=奇)$，其余的二进制位出现了偶数次，仍然满足回文字符串的条件。针对这种情况，我们只需要从 $0-9$ 枚举二进制位，然后看之前是否出现过即可，同时维护答案。</p></li></ol><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] pre = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span> &lt;&lt; <span class="number">11</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestAwesome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), status = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        Arrays.fill(pre, -<span class="number">2</span>);  <span class="comment">// pre数组初始化为-2，代表都没有出现过</span></span><br><span class="line">        pre[status] = -<span class="number">1</span>;  <span class="comment">// 最初的状态为0，代表都出现了0次（偶数次）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            status ^= <span class="number">1</span> &lt;&lt; (s.charAt(i) - <span class="string">&#x27;0&#x27;</span>);  <span class="comment">// 更新当前状态</span></span><br><span class="line">            <span class="keyword">if</span> (pre[status] != -<span class="number">2</span>) &#123;  <span class="comment">// 之前已经存在过</span></span><br><span class="line">                res = Math.max(res, i - pre[status]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 没有存在过</span></span><br><span class="line">                pre[status] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;  <span class="comment">// 枚举0-9</span></span><br><span class="line">                <span class="keyword">int</span> status1 = status ^ (<span class="number">1</span> &lt;&lt; j);  <span class="comment">// 将对应位置的奇偶性改变</span></span><br><span class="line">                <span class="keyword">if</span> (pre[status1] != -<span class="number">2</span>) &#123;  <span class="comment">// 之前是否出现过</span></span><br><span class="line">                    res = Math.max(res, i - pre[status1]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：最长有效括号</title>
      <link href="2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.html"/>
      <url>2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>栈里面存左括号的位置，当遇到右括号时：<br><a id="more"></a> </p><p>栈为空：记录这个位置，说明下一轮的合法括号可能从这里开始。</p><p>栈不为空：先弹出左括号表示匹配。</p><ul><li>此时栈为空，说明之前可能还有合法括号，用当前下标减去之前记录的那个位置。</li><li>此时栈不为空，减去当前栈顶的位置即可（最接近的没有被匹配的左括号）。</li></ul><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, last = -<span class="number">1</span>;</span><br><span class="line">        Stack&lt;Integer&gt; st = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                st.push(i);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (st.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    st.pop();</span><br><span class="line">                    <span class="keyword">if</span> (st.size() &gt; <span class="number">0</span>)</span><br><span class="line">                        res = Math.max(res, i - st.peek());</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        res = Math.max(res, i - last);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    last = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：最大得分</title>
      <link href="2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86.html"/>
      <url>2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定两个严格递增数组，从任意一个数组出发到任意一个数组结束，当遇到相同元素时可以切换到另一个数组，只能从左到右走且每个数只计算一次，求最大累计得分。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>当遇到两个数组都有的元素时可以切换，那其实从上一次遇到相同到这一次，假设中间这部分元素和是 $sum$，无非是看到底是上面这部分的 $sum$ 更大还是下面的 $sum$ 更大，然后选走罢了，如此循环下去。至于判断相同元素，提前用map记录每个元素的位置就好了。时间复杂度$O(n)$。<br><a id="more"></a> </p><p>比如: </p><p>$nums1: [2, 4, 5, 8, 10]$</p><p>$nums2: [4, 6, 8, 9]$</p><p>首先第一部分（从起点开始，碰到第一次相同）是 $sum1(nums1[2, 4]) = 6$, $sum2(nums2[4]) = 4$，选择 $max(sum1, sum2) = 6$</p><p>第二部分（第二次相同）是 $sum1(nums1[5, 8]) = 13$, $sum2(nums2[6, 8]) = 14$，选择 $max(sum1, sum2) = 14$</p><p>第三部分（一直循环到结尾也没再发现相同元素，换不了路线，故只能一直走到终点）是 $sum1(nums1[10]) = 10$, $sum2(nums2[9]) = 9$，选择 $max(sum1, sum2) = 10$</p><p>故答案为 $6 + 14 + 10 = 20$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSum</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.length, m = b.length;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; mp = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            mp.put(b[i], i);  <span class="comment">// 预处理b[i]数组的位置</span></span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>, sum1 = <span class="number">0</span>, sum2 = <span class="number">0</span>, mod = <span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sum1 += a[i];  <span class="comment">// 计算a数组这部分的和</span></span><br><span class="line">            <span class="keyword">if</span>(mp.get(a[i]) != <span class="keyword">null</span>) &#123;  <span class="comment">// 说明a[i]在b数组中也存在</span></span><br><span class="line">                <span class="keyword">int</span> pos = mp.get(a[i]);</span><br><span class="line">                <span class="keyword">for</span>(; j &lt;= pos; j++) &#123;  <span class="comment">// 开始计算b数组这部分的和</span></span><br><span class="line">                    sum2 += b[j];</span><br><span class="line">                &#125;</span><br><span class="line">                res = (res + Math.max(sum1, sum2)) % mod;  <span class="comment">// 选择更大的那部分加</span></span><br><span class="line">                sum1 = sum2 = <span class="number">0</span>;  <span class="comment">// 归零，开始下一部分的计算</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(; j &lt; m; j++) &#123;  <span class="comment">// b数组可能还没走完</span></span><br><span class="line">            sum2 += b[j];</span><br><span class="line">        &#125;</span><br><span class="line">        res = (res + Math.max(sum1, sum2)) % mod;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(res % <span class="number">1000000007</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：最小区间</title>
      <link href="2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E5%8C%BA%E9%97%B4.html"/>
      <url>2020/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E5%8C%BA%E9%97%B4.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>你有 k 个升序排列的整数数组。找到一个最小区间，使得 k 个列表中的每个列表至少有一个数包含在其中。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>直接对所有的数排序，然后优先队列维护一个k个数组都有值存在且对当前来说长度最小的滑动窗口，同时维护答案即可。<br><a id="more"></a> </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> val, id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] smallestRange(List&lt;List&lt;Integer&gt;&gt; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        PriorityQueue&lt;Node&gt; q = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Node&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a.val - b.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        PriorityQueue&lt;Node&gt; q1 = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Node&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a.val - b.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            List&lt;Integer&gt; num = nums.get(i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num.size(); j++) &#123;</span><br><span class="line">                Node node = <span class="keyword">new</span> Node(num.get(j), i);</span><br><span class="line">                q.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, dis = <span class="number">1000000000</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">while</span> (q.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Node now = q.poll();</span><br><span class="line">            q1.add(now);</span><br><span class="line">            <span class="keyword">if</span>(map.get(now.id) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                map.put(now.id, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> x = map.get(now.id);</span><br><span class="line">                map.remove(now.id);</span><br><span class="line">                map.put(now.id, x + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(q1.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                Node x = q1.peek();</span><br><span class="line">                <span class="keyword">if</span>(map.get(x.id) == <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    q1.poll();</span><br><span class="line">                    <span class="keyword">int</span> y = map.get(x.id);</span><br><span class="line">                    map.remove(x.id);</span><br><span class="line">                    map.put(x.id, y - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(q1.size() &gt; <span class="number">0</span> &amp;&amp; cnt == n &amp;&amp; dis &gt; now.val - q1.peek().val) &#123;</span><br><span class="line">                dis = now.val - q1.peek().val;</span><br><span class="line">                res[<span class="number">0</span>] = q1.peek().val;</span><br><span class="line">                res[<span class="number">1</span>] = now.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：最多的不重叠子字符串</title>
      <link href="2020/07/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%A4%9A%E7%9A%84%E4%B8%8D%E9%87%8D%E5%8F%A0%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html"/>
      <url>2020/07/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%A4%9A%E7%9A%84%E4%B8%8D%E9%87%8D%E5%8F%A0%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你一个只包含小写字母的字符串 s ，你需要找到 s 中最多数目的非空子字符串，满足如下条件：</p><ol><li>这些字符串之间互不重叠，也就是说对于任意两个子字符串 s[i..j] 和 s[k..l] ，要么 j &lt; k 要么 i &gt; l 。</li><li>如果一个子字符串包含字符 char ，那么 s 中所有 char 字符都应该在这个子字符串中。</li></ol><a id="more"></a> <p>请你找到满足上述条件的最多子字符串数目。如果有多个解法有相同的子字符串数目，请返回这些子字符串总长度最小的一个解。可以证明最小总长度解是唯一的。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>先对每个字母求出合法的最短长度，可以记录每个字母出现的左右端点，但这样不一定是合法的，因为之间会有别的字母，而这些字母没有被完全包含，所以必须枚举这个区间内的所有字母，一直拓展这个区间直到合法位置。</p><p>然后问题就转变为不相交线段数最多且长度和最短的问题，考虑贪心。显然可以看出先对右端点进行排序从小到大排序（保证右边剩余的空间尽量大），然后对左端点从大到小排序（保证长度尽可能小），然后贪心着取，遇到可以加入的线段将其加入答案即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node&amp; node) <span class="keyword">const</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (r == node.r) </span><br><span class="line">        <span class="keyword">return</span> l &gt; node.l;</span><br><span class="line">      <span class="keyword">return</span> r &lt; node.r;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; p[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">maxNumOfSubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) p[i].l = p[i].r = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (p[s[i] - <span class="string">&#x27;a&#x27;</span>].l == <span class="number">-1</span>) p[s[i] - <span class="string">&#x27;a&#x27;</span>].l = i;</span><br><span class="line">      p[s[i] - <span class="string">&#x27;a&#x27;</span>].r = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (p[i].l == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">int</span> le = p[i].l;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = p[i].l; j &lt;= p[i].r; j++) &#123;</span><br><span class="line">        p[i].l = min(p[i].l, p[s[j] - <span class="string">&#x27;a&#x27;</span>].l);</span><br><span class="line">        p[i].r = max(p[i].r, p[s[j] - <span class="string">&#x27;a&#x27;</span>].r);</span><br><span class="line">        <span class="keyword">if</span> (le &gt; p[i].l) &#123;</span><br><span class="line">          le = p[i].l;</span><br><span class="line">          j = le;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(p, p + <span class="number">26</span>);</span><br><span class="line">    <span class="keyword">int</span> ri = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (p[i].r == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (p[i].l &gt; ri) &#123;</span><br><span class="line">        ri = p[i].r;</span><br><span class="line">        res.push_back(s.substr(p[i].l, p[i].r - p[i].l + <span class="number">1</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java自动内存管理机制</title>
      <link href="2020/07/Java%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6.html"/>
      <url>2020/07/Java%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java内存区域与内存溢出异常"><a href="#Java内存区域与内存溢出异常" class="headerlink" title="Java内存区域与内存溢出异常"></a>Java内存区域与内存溢出异常</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>对于Java程序员来说，有虚拟机的自动内存管理机制，不再需要像C++那样为每个new操作去写配对的delete/free代码。但正因如此，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是如何使用内存的，那排查错误将会变得异常困难。</p><h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><p>Java虚拟机在执行Java程序过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。</p><p><img src="http://img.benboby.top/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png" alt><br><a id="more"></a> </p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器是一块较小的内存空间，它的作用可以看做是<strong>当前线程所执行的字节码的行号指示器</strong>。在虚拟机的概念模型里，字节码解释器工作时就是<strong>通过改变这个计数器的值来选取下一条需要执行的字节码指令</strong>， 分支、循环 、跳转、异常 处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>线程私有：由于 Java 虚拟机的多线程是通过<strong>线程轮流切换</strong>并<strong>分配处理器执行时间</strong>的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令，切换时也并不会记录上一个线程执行到那个位置。因此，为了线程<strong>切换后能恢复到正确的执行位控</strong>，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><p>如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是<strong> Native 方法</strong>，这个<strong>计数器值则为空</strong> ( Undefined )。</p><ul><li>Native方法大多是通过C实现并未编译成需要执行的字节码指令，也就不需要去存储字节码文件的行号</li></ul><p>程序计数器的内存区域是<strong>唯一</strong>一个在 Java 虚拟机规范中<strong>没有</strong>规定任何OutOfMemoryError情况的区域，因为<strong>程序计数器存储的是字节码文件的行号，这个范围是可知晓的，在一开始分配内存时就可以分配一个绝对不会溢出的内存</strong>。</p><p>总结：</p><ol><li>线程私有的，每个线程都有一个程序计数器</li><li>是java虚拟机规范里面，唯一一个没有规定任何 OutOfMemoryError 情况的区域 </li><li>生活周期随着线程的创建而创建，随着线程的结束而消亡</li><li>程序计数器是一块较小的内存区域</li></ol><h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>与程序计数器一样，Java虚拟机栈也是线程私有的，它的<strong>生命周期与线程相同</strong>。虚拟机栈描述的是 Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个<strong>栈帧</strong>用于存储局部变量表、操作栈、动态链接、方法出口等信息。<strong>每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从人栈到出栈的过程</strong>。</p><p>虚拟机栈是Java执行方法的内存模型。每个方法被执行的时候，都会创建一个栈帧，把栈帧压入栈，当方法正常返回或者抛出未捕获的异常时，栈帧就会出栈。</p><blockquote><p><strong>栈对应线程，栈帧对应方法</strong></p></blockquote><p>在活动线程中，只有位于栈顶的帧才是有效的，称为当前栈帧。正在执行的方法称为当前方法。在执行引擎运行时，所有指令都只能针对当前栈帧进行操作。而 StackOverflowError 表示请求的栈溢出，导致内存耗尽，通常出现在递归方法中。</p><blockquote><p>一般把Java内存区分为堆内存（Heap）和栈内存（Stack），其中『栈』指的是虚拟机栈，『堆』指的是Java堆。在 Java 虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过 Java 虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出 OutOfMemoryError 异常。</p><ul><li>StackOverflowError：递归过深，递归没有出口</li><li>OutOfMemoryError：JVM空间溢出，创建对象速度高于GC回收速度，可能是申请了较多空间没有及时释放</li></ul></blockquote><p><strong>局部变量表</strong>：存放方法参数和方法内部定义的局部变量的区域。</p><p>局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是<strong>虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务</strong>。在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并<strong>没有强制规定</strong>，因此具体的虚拟机可以自由实现它。与虚拟机栈一样，<strong>本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常</strong>。</p><h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><p>Java堆是披<strong>所有线程共享</strong>的一块内存区域，在<strong>虚拟机启动时创建</strong>。此内存区域的唯一目的就是存放<strong>对象实例</strong>，几乎所有的对象实例以及数组都要在堆上分配。</p><p>是垃圾收集器管理的主要区域，也被称做“GC堆”，也是Java虚拟机所管理的内存中最大的一块。</p><p>根据 Java 虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。在实现时，既可以实现成固定大小的，也可以是可扩展的。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出 OutOfMemoryError 异常。</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>用于<strong>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</strong>。与Java堆一样，是<strong>各个线程共享的内存区域</strong>。</p><p>人们更愿意把这个区域称为“永久代”，本质上两者并不等价，或者说是永久代来实现方法区而已。它还有个别名叫做Non-Heap（非堆）。</p><p>和Java堆一样不需要连续的内存和可以选择固定大小或可扩展外，还可选择不实现GC。相对而言，<strong>垃圾收集行为在这个区域是比较少出现的</strong>，但并非数据进入了方法区就如永久代的名字一样“永久” 存在了。这个区域的内存回收目标主要是<strong>针对常量池的回收和对类型的卸载</strong>，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的，未完全回收可能会导致内存泄漏。</p><p>在Java虚拟机规范中，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是<strong>常量池</strong>，用于<strong>存放编译期生成的各种字面量和符号引用</strong>，这部分内容将在<strong>类加载后进入方法区的运行时常量池中存放</strong>。</p><p>相对于<strong>Class文件常量池</strong>的一个重要特征是具备<strong>动态性</strong>，体现在并非只有预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中。是方法区的一部分，会受到方法区内存的限制。在Java虚拟机规范中，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p><h3 id="对象访问"><a href="#对象访问" class="headerlink" title="对象访问"></a>对象访问</h3><p>由于 reference 类型在 Java 虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访间到 Java 堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：</p><ol><li><p>通过句柄方式访问<br>  如果使用句柄访问的话，那么Java堆中将会划分一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象的实例数据与类型数据各自的具体地址信息。</p><p> <img src="http://img.benboby.top/%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE.png" alt></p><ul><li><p>优点：当对象移动的时候（垃圾回收的时候移动很普遍），这样值需要改变句柄中的指针，但是栈中的指针不需要变化，因为栈中存储的是句柄的地址</p></li><li><p>缺点：需要进行二次定位，寻找两次指针，开销相对更大一些</p></li></ul></li><li><p>使用指针访问<br>  如果使用直接指针访问方式，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象的地址。</p><p> <img src="http://img.benboby.top/%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE.png" alt></p><ul><li>优点：速度快，不需要和句柄一样指针定位的开销</li></ul></li></ol><h2 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>当需要排查各种内存溢出、内存泄涌问题时，当垃圾收集成为系统达到<strong>更高并发</strong>的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。</p><p>程序计数器、虚拟机栈、本地方法栈三个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行若出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具备确定性，在这几个区域内不需要过多考虑回收的问题，因为方法结束或线程结束时，内存自然就跟随着回收了。</p><p>而 Java 堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存，</p><h3 id="对象已死？"><a href="#对象已死？" class="headerlink" title="对象已死？"></a>对象已死？</h3><p>堆中几乎存放着 Java 中所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象有哪些还“存活”着，哪些已经“死去”（即不可能再披任何途径使用的对象）。</p><h4 id="引用计数器法"><a href="#引用计数器法" class="headerlink" title="引用计数器法"></a>引用计数器法</h4><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加 1; 当引用失效时，计数器值就减 1; 任何时刻计数器都为 0 的对象就是不可能再被使用的。</p><p>Java语言中没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间的相互循环引用的问题。</p><h4 id="根搜索算法"><a href="#根搜索算法" class="headerlink" title="根搜索算法"></a>根搜索算法</h4><p>通过一系列的名为 “GCRoots” 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链 (ReferenceChain) , 当一个对象到 GCRoots 没有任何引用链相连（用图论的话来说就是从 GCRoots 到这个对象不可达）时，则证明此对象是不可用的。</p><p>在 Java 语言里，可作为 GCRoots 的对象包括下面几种 ：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中的引用的对象。</li><li>方法区中的类静态属性引用的对象。</li><li>方法区中的常扯引用的对象。</li><li>本地方法栈中 JNI (即一般说的 Native 方法）的引用的对象</li></ul><h4 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h4><p>在 JDK 1.2 之前，Java中的引用的定义很传统 ：如果 reference 类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。</p><p>在 JDK 1.2 之后，Java 对引用的概念进行了扩充，将引用分为<strong>强引用、软引用、弱引用、虚引用</strong>四种，这四种引用强度依次逐渐减弱。</p><ul><li>强引用就是指在程序代码之中普遍存在的，类似 “Object obj = new Object()” 这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</li><li>软引用用来描述一些还有用，但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中并进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。在 JDK1.2 之后，提供了 SoftReference 类来实现软引用。</li><li>弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在 JDK 1.2 之后，提供了 WeakReference 类来实现弱引用。</li><li>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知。在 JDK 1.2 之后，提供了 PhantomReference 类来实现虚引用。</li></ul><h4 id="生存还是死亡？"><a href="#生存还是死亡？" class="headerlink" title="生存还是死亡？"></a>生存还是死亡？</h4><p>要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行根搜索后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法。当对象没有覆盖 finalize()方法，或者 finalize () 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</p><p>如果这个对象被判定为有必要执行 finalize() 方法，那么这个对象将会被放置在一个名为 F-Queue 的队列之中，并在稍后由一条由虚拟机自动建立的、低优先级的 Finalizer 线程去执行。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象在 finalize() 方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致 F-Queue 队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。finalize() 方法是对象逃脱死亡命运的最后一次机会，稍后 GC 将对 F-Queue 中的对象进行第二次小规模的标记，如果对象要在 finalize() 中成功拯救自己 —— 只要重新与引用链上的任何一个对象建立关联即可，譬如把自己 (this 关键字）赋值给某个类变址或对象的成员变量，那在第二次标记时它将被移除出 “即将回收” 的集合；如果对象这时候还没有逃脱，那它就真的离死不远了。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程</title>
      <link href="2020/07/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B.html"/>
      <url>2020/07/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B.html</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>程序：是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念。</p><p>进程：执行程序的一次执行过程，它是一个动态的概念，是系统资源分配的单位。</p><p>线程：通常在一个进程中可以包含若干个进程，当然一个进程中至少有一个线程，不然没有存在的意义。线程是CPU调度和执行的单位。</p><p>多线程：多条执行路径，主线程和子线程并行交替执行。很多多线程是模拟出来的，真正的多线程是指有多个CPU，即多核，如服务器。如果是模拟出来的多线程，即在一个CPU的情况下，在同一个时间点，CPU只能执行一个代码，因为切换的很快，所以就有同时执行的错觉。 </p><a id="more"></a> <ul><li>线程就是独立的执行路径</li><li>在程序运行时，即使没有自己创建线程，后台也会有多个线程，如主线程，gc线程（负责垃圾回收）</li><li>main()称之为主线程，为系统的入口，用于执行整个程序</li><li>在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器是与操作系统密切相关的，先后顺序是不能人为干预的</li><li>对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制（如抢票问题，需要让线程排队）</li><li>线程会带来额外的开销，如CPU调度时间，并发控制开销</li><li>每个线程在自己的工作内存交互，内存控制不会造成数据不一致</li></ul><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><p>方法一： Thread class -&gt; 继承Thread类</p><ul><li>自定义线程类继承Thread类</li><li>重写run()方法，编写线程执行体</li><li><p>创建线程对象，调用start()方法启动线程</p><p><strong>不建议使用：避免OOP单继承局限性</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程的创建方式一：继承Thread类，重写run()方法，调用start开启线程</span></span><br><span class="line"><span class="comment">// 总结：线程开启不一定立即执行，由CPU调度器执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test15</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;看书&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个线程对象</span></span><br><span class="line">        Test15 test15 = <span class="keyword">new</span> Test15();</span><br><span class="line">        test15.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;刷剧&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二： Runnable接口 -&gt; 实现Runnable接口</p><ul><li>定义MyRunnable类实现Runnable接口</li><li>实现run()方法，编写线程执行体</li><li><p>创建线程对象，调用start()方法启动线程</p><p>  <strong>推荐使用：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线程方式2：实现Runnable接口，重写run()方法，执行线程需要丢入runnable接口实现类，调用start()方法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test16</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;看书&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Runnable接口的实现类对象</span></span><br><span class="line">        Test16 test16 = <span class="keyword">new</span> Test16();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程对象，通过线程对象来开启线程，代理</span></span><br><span class="line">        <span class="comment">//Thread t = new Thread(test16);</span></span><br><span class="line">        <span class="comment">//t.start();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等价于上一种写法</span></span><br><span class="line">        <span class="keyword">new</span> Thread(test16).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;追剧&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法三： Callable接口 -&gt; 实现Callable接口</p><ul><li>实现Callable接口，需要返回值类型</li><li>重写call方法，需要抛出异常</li><li>创建目标对象</li><li>创建执行服务：ExecutorService ser = Executors.newFixedThreadPool(1);</li><li>提交执行：Future<Boolean>result1 = ser.submit(t1);</Boolean></li><li>获取结果：boolean r1 = result1.get();</li><li>关闭服务：ser.shutdownNow();</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程创建方式三：实现Callable接口</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    callable的好处：</span></span><br><span class="line"><span class="comment">    1. 可以定义返回值</span></span><br><span class="line"><span class="comment">    2. 可以抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test17</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test17</span><span class="params">(String url, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        WebDownloader webDownloader = <span class="keyword">new</span> WebDownloader();</span><br><span class="line">        webDownloader.downloader(url, name);</span><br><span class="line">        System.out.println(<span class="string">&quot;下载图片名为：&quot;</span> + name);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        Test17 t1 = <span class="keyword">new</span> Test17(<span class="string">&quot;http://kmlerc.coding-pages.com/images/head.JPG&quot;</span>, <span class="string">&quot;1.jpg&quot;</span>);</span><br><span class="line">        Test17 t2 = <span class="keyword">new</span> Test17(<span class="string">&quot;https://www5.jiumodiary.com/images/front/eleps.png&quot;</span>, <span class="string">&quot;2.png&quot;</span>);</span><br><span class="line">        Test17 t3 = <span class="keyword">new</span> Test17(<span class="string">&quot;https://pic.cnblogs.com/avatar/1569506/20190731001716.png&quot;</span>, <span class="string">&quot;3.png&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建执行服务</span></span><br><span class="line">        ExecutorService ser = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交执行</span></span><br><span class="line">        Future&lt;Boolean&gt; result1 = ser.submit(t1);</span><br><span class="line">        Future&lt;Boolean&gt; result2 = ser.submit(t2);</span><br><span class="line">        Future&lt;Boolean&gt; result3 = ser.submit(t3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取结果</span></span><br><span class="line">        <span class="keyword">boolean</span> r1 = result1.get();</span><br><span class="line">        <span class="keyword">boolean</span> r2 = result2.get();</span><br><span class="line">        <span class="keyword">boolean</span> r3 = result3.get();</span><br><span class="line"></span><br><span class="line">        System.out.println(r1 + <span class="string">&quot; &quot;</span> + r2 + <span class="string">&quot; &quot;</span> + r3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭服务</span></span><br><span class="line">        ser.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下载器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebDownloader</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下载方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">downloader</span><span class="params">(String url, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileUtils.copyURLToFile(<span class="keyword">new</span> URL(url), <span class="keyword">new</span> File(name));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;IO异常，downloader方法出现问题&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程状态分析"><a href="#线程状态分析" class="headerlink" title="线程状态分析"></a>线程状态分析</h3><ol><li>Thread t = new Thread() 线程对象一旦创建就进入到新生状态</li><li>当调用start()方法，线程立即进入就绪状态，但不意味着立即调度执行</li><li>进入运行状态，线程才真正执行线程体的代码块</li><li>当调用sleep,wait或同步锁定时，线程进入阻塞状态，就是代码不往下执行，阻塞事件解除后，重新进入就绪状态，等待cpu调度执行</li><li>线程中断或者结束，一旦进入死亡状态，就不能再次启动</li></ol><h3 id="线程方法"><a href="#线程方法" class="headerlink" title="线程方法"></a>线程方法</h3><div class="table-container"><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>setPriority(int newPriority)</td><td>更改线程的优先级</td></tr><tr><td>static void sleep(long millis)</td><td>在指定毫秒数内让当前正在执行的线程休眠</td></tr><tr><td>void join()</td><td>等待该线程终止</td></tr><tr><td>static void yield()</td><td>暂停当前正在执行的线程对象，并执行线程其他线程</td></tr><tr><td>void interrupt()</td><td>中断线程，别用这个方式</td></tr><tr><td>boolean isAlive()</td><td>测试线程是否处于活动状态</td></tr></tbody></table></div><h3 id="线程停止"><a href="#线程停止" class="headerlink" title="线程停止"></a>线程停止</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程停止</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 建议让线程正常停止</span></span><br><span class="line"><span class="comment">    2. 建议使用标志</span></span><br><span class="line"><span class="comment">    3. 不要使用stop或destroy等过时的不推荐使用的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test20</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;run...Thread&quot;</span> + ++i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test20 test20 = <span class="keyword">new</span> Test20();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(test20).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;main&quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">999</span>)&#123;</span><br><span class="line">                <span class="comment">// 修改标志位，让线程停止</span></span><br><span class="line">                test20.stop();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程停止了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h3><ul><li>sleep(时间)指定当前线程阻塞的毫秒数</li><li>sleep存在异常InterruptedException</li><li>sleep时间达到后线程进入就绪状态</li><li>sleep可以模拟网络延时，倒计时等</li><li>每一个对象都有一个锁，slepp不会释放锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程睡眠：打印时间</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test21</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getTime</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;HH:mm:ss&quot;</span>).format(date));</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            date = <span class="keyword">new</span> Date(System.currentTimeMillis());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        getTime();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程礼让"><a href="#线程礼让" class="headerlink" title="线程礼让"></a>线程礼让</h3><ul><li>让当前正在执行的线程暂停，但不阻塞</li><li>将线程从运行状态转为就绪状态</li><li>让cpu重新调度，礼让不一定成功！看cpu心情</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程礼让</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test22</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyYield myYield = <span class="keyword">new</span> MyYield();</span><br><span class="line">        <span class="keyword">new</span> Thread(myYield, <span class="string">&quot;a&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(myYield, <span class="string">&quot;b&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyYield</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始运行&quot;</span>);</span><br><span class="line">        Thread.yield(); <span class="comment">// 礼让</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;停止运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程强制执行（插队）"><a href="#线程强制执行（插队）" class="headerlink" title="线程强制执行（插队）"></a>线程强制执行（插队）</h3><ul><li>Join合并线程，待此线程完成后，再执行其他线程，其他线程阻塞</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程强制执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test23</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;vip线程&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Test23 test23 = <span class="keyword">new</span> Test23();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(test23);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">200</span>) &#123;</span><br><span class="line">                thread.join();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;main&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程状态观测"><a href="#线程状态观测" class="headerlink" title="线程状态观测"></a>线程状态观测</h3><p><strong>Thread.State</strong>: 线程状态</p><ul><li>NEW 尚未启动的线程处于此状态</li><li>RUNNABLE 在Java虚拟机中执行的线程处于此状态</li><li>BLOCKED 被阻塞等待监视器锁定的处于此状态</li><li>WAITING 正在等待另一个线程执行特定动作的线程处于此状态</li><li>TIMED_WAITING 正在等待另一个线程执行达到指定等待时间的线程处于此状态</li><li>TERMINATED 已退出的线程处于此状态</li></ul><p>一个线程可以在给定时间点处于一个状态。这些状态是不反应任何操作系统线程状态的虚拟机状态。</p><h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><ul><li>Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度那个线程来执行</li><li>线程的优先级用数字表示，范围从1-10<ul><li>Thread.MIN_PRIORITY = 1</li><li>Thread.MAX_PRIORITY = 10</li><li>Thread.NORM_PRIORITY = 5</li></ul></li><li>使用 getPriority() 获取优先级</li><li>使用 setPriority(int x) 改变优先级</li></ul><h3 id="守护-daemon-线程"><a href="#守护-daemon-线程" class="headerlink" title="守护(daemon)线程"></a>守护(daemon)线程</h3><ul><li>线程分为用户线程和守护线程</li><li>虚拟机必须确保用户线程执行完毕</li><li>虚拟机不必等待守护线程执行完毕</li><li>如：后台记录操作日志，监控内存，垃圾回收等等… </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 守护线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test24</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        God god = <span class="keyword">new</span> God();</span><br><span class="line">        People people = <span class="keyword">new</span> People();</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(god);</span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>); <span class="comment">// 设置为守护线程</span></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(people).start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当people结束，守护线程也就自动结束了。。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上帝线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">God</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;上帝保佑人类&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 人类线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;人类开心的活着&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Goodbye, world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程同步-多个线程操作同一个资源"><a href="#线程同步-多个线程操作同一个资源" class="headerlink" title="线程同步(多个线程操作同一个资源)"></a>线程同步(多个线程操作同一个资源)</h3><blockquote><p>处理多线程问题时，多个线程访问同一个对象(并发问题)，并且某些线程还想修改这个对象，这时候就需要线程同步。线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个对象的等待池形成队列，等待前面线程使用完毕，下一个线程再使用。</p><p>由于同一进程的多个线程共享同一块存储空间，在带来方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问时的正确性，在访问时加入锁机制synchronized，当一个线程获得对象的排它锁，独占资源，其他线程必须等待，使用后释放锁即可，存在以下问题：</p><ul><li>一个线程持有锁会导致其他所有需要此锁的线程挂起</li><li>在多线程竞争下，加锁，释放锁会导致比较多的上下文切换和调度延时，引起性能问题</li><li>如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，引起性能问题</li></ul></blockquote><h3 id="同步方法及同步块"><a href="#同步方法及同步块" class="headerlink" title="同步方法及同步块"></a>同步方法及同步块</h3><blockquote><p>由于我们可以通过private关键字来保证数据对象只能被方法访问，所以我们只需要针对方法提出一套机制，这套机制就是synchronized关键字，它包括两种用法：synchronized方法和synchronized块。</p><ul><li>同步方法：public synchronized void method(int args){}</li></ul><p>synchronized方法控制对”对象”的访问，每个对象对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞。方法一旦执行，就独占该锁，直到方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行。</p><ul><li>缺陷：若将一个大的方法声明为synchronized将会影响效率</li></ul><p>同步块：synchronized(Obj) {}<br>Obj称之为同步监视器</p><ul><li>Obj可以是任何对象，但是推荐使用共享资源作为同步监视器</li><li>同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是这个对象本身，或者是class</li></ul><p>同步监视器的执行过程</p><ol><li>第一个线程访问，锁定同步监视器，执行其中代码</li><li>第二个线程访问，发现同步监视器被锁定，无法访问</li><li>第一个线程访问完毕，解锁同步监视器</li><li>第二个线程访问，发现同步监视器没有锁，然后锁定并访问</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 买票测试synchronized方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test25</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BuyTicket buyTicket = <span class="keyword">new</span> BuyTicket();</span><br><span class="line">        <span class="keyword">new</span> Thread(buyTicket, <span class="string">&quot;小米&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(buyTicket, <span class="string">&quot;小明&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(buyTicket, <span class="string">&quot;小红&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuyTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticketNums = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                buy();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ticketNums &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Thread.sleep(10);</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;抢到&quot;</span> + ticketNums--);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 同步块</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuyTicket1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticketNums = <span class="number">100000</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (flag)</span><br><span class="line">            buy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;     <span class="comment">// 同步块，可以锁任何对象，默认为this</span></span><br><span class="line">            <span class="keyword">if</span>(ticketNums &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//Thread.sleep(10);</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;抢到&quot;</span> + ticketNums--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><blockquote><p>多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形。某一个同步块同时拥有“两个以上对象的锁”时，就可能会发生”死锁“的问题。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 死锁：多个线程互相抱着对方需要的线程，形成僵持</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test26</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Makeup q1 = <span class="keyword">new</span> Makeup(<span class="number">0</span>, <span class="string">&quot;小明&quot;</span>);</span><br><span class="line">        Makeup q2 = <span class="keyword">new</span> Makeup(<span class="number">1</span>, <span class="string">&quot;小红&quot;</span>);</span><br><span class="line">        q1.start();</span><br><span class="line">        q2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gun</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Makeup</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 需要的资源只有一份，用static来保证只有一份</span></span><br><span class="line">    <span class="keyword">static</span> Gun gun = <span class="keyword">new</span> Gun();</span><br><span class="line">    <span class="keyword">static</span> Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> choice;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    Makeup(<span class="keyword">int</span> choice, String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.choice = choice;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            makeup();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">makeup</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (choice == <span class="number">0</span>) &#123;   <span class="comment">// 小明想要枪，他本来有狗</span></span><br><span class="line">            <span class="keyword">synchronized</span>(gun) &#123;</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;获得枪的锁&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="comment">/*   发生死锁</span></span><br><span class="line"><span class="comment">                synchronized(dog) &#123;</span></span><br><span class="line"><span class="comment">                    System.out.println(this.name + &quot;获得狗的锁&quot;);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span>(dog) &#123;  <span class="comment">// 放到外面即可解决死锁问题</span></span><br><span class="line">                System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;获得狗的锁&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (choice == <span class="number">1</span>) &#123;  <span class="comment">// 小红想要狗，她本来有枪</span></span><br><span class="line">            <span class="keyword">synchronized</span>(dog) &#123;</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;获得狗的锁&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                <span class="comment">/*  发生死锁</span></span><br><span class="line"><span class="comment">                synchronized(gun) &#123;</span></span><br><span class="line"><span class="comment">                    System.out.println(this.name + &quot;获得枪的锁&quot;);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span>(gun) &#123;  <span class="comment">// 放到外面即可解决死锁问题</span></span><br><span class="line">                System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;获得枪的锁&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>死锁产生的四个必要条件(只需要破解其中一个即可解决死锁问题)：</p><ol><li>互斥条件：一个资源每次只能被一个进程使用</li><li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放</li><li>不剥夺条件：进程以获得的资源，在未使用完之前，不能强行剥夺</li><li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系</li></ol><h3 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h3><ul><li>Lock是显式锁（手动开启和关闭锁），synchronized是隐式锁，出了作用域自动释放</li><li>Lock只有代码块锁，synchronized有代码块锁和方法锁</li><li>使用Lock锁，JVM将花费较少时间来调度线程，性能更好，并且具有更好的拓展性（提供更多子类）</li><li>优先使用顺序：Lock &gt; 同步代码块 &gt; 同步方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lock锁</span></span><br><span class="line"><span class="comment">/*  格式：</span></span><br><span class="line"><span class="comment">    class A &#123;</span></span><br><span class="line"><span class="comment">            private final ReentrantLock lock = new ReentrantLock();</span></span><br><span class="line"><span class="comment">            public void m() &#123;</span></span><br><span class="line"><span class="comment">                lock.lock();</span></span><br><span class="line"><span class="comment">                try &#123;</span></span><br><span class="line"><span class="comment">                    // 保证线程安全的代码</span></span><br><span class="line"><span class="comment">                &#125; finally &#123;</span></span><br><span class="line"><span class="comment">                    lock.unlock();</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test27</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BuyTicket1 buyTicket1 = <span class="keyword">new</span> BuyTicket1();</span><br><span class="line">        <span class="keyword">new</span> Thread(buyTicket1).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(buyTicket1).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(buyTicket1).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuyTicket1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> TicketNums = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义lock锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();  <span class="comment">// 加锁</span></span><br><span class="line">                <span class="keyword">if</span>(TicketNums &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(TicketNums--);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();  <span class="comment">// 解锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态代理模式"><a href="#静态代理模式" class="headerlink" title="静态代理模式"></a>静态代理模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态代理方法</span></span><br><span class="line"><span class="comment">/*  总结：</span></span><br><span class="line"><span class="comment">    真实对象和代理对象都要实现同一个接口</span></span><br><span class="line"><span class="comment">    代理对象要代理真实角色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*  优点：</span></span><br><span class="line"><span class="comment">    代理对象可以做很多真实对象做不了的事情</span></span><br><span class="line"><span class="comment">    真实对象可以专心做自己的事情</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test18</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*  举例模拟结婚：</span></span><br><span class="line"><span class="comment">        你只需要负责结婚，其他的事情都由婚庆公司（代理）帮你包办即可。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread( () -&gt; System.out.println(<span class="string">&quot;我爱你&quot;</span>) ).start();</span><br><span class="line">        <span class="keyword">new</span> Company(<span class="keyword">new</span> You()).HappyMarry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Marry</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">HappyMarry</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真实角色，即你自己</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">You</span> <span class="keyword">implements</span> <span class="title">Marry</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HappyMarry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;新郎结婚中。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理角色，即婚庆公司</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Company</span> <span class="keyword">implements</span> <span class="title">Marry</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 要结婚的对象</span></span><br><span class="line">    <span class="keyword">private</span> Marry target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Company</span><span class="params">(Marry target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HappyMarry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        <span class="keyword">this</span>.target.HappyMarry();</span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;布置场地&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收拾场地&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h2><blockquote><p>应用场景：生产者和消费者问题</p><ul><li>假设仓库只能存放一件商品，生产者将生产出来的产品放入仓库，消费者将仓库中产品消费取走。</li><li>如果仓库没有商品，则生产者将产品放入仓库，否则停止生产并等待，直到仓库中的产品被消费者取走为止</li><li>如果仓库中放有产品，则消费者可以将产品取走消费，否则停止消费并等待，直到仓库中再次放入产品为止</li></ul><p>这是一个线程同步问题，生产者和消费者共享一个资源，并且生产者和消费者之间相互依赖，互为条件。</p><ul><li>对于生产者，没有生产产品之前，要通知消费者等待。而生产之后，又需要通知消费者消费</li><li>对于消费者，在消费之后，要通知生产者已经结束消费，需要生产新的产品以供消费</li><li>在生产者消费者问题中，仅有synchronized是不够的<ul><li>synchronized可以阻止并发更新同一个共享资源，实现了同步</li><li>synchronized不能用来实现不同线程之间的消息传递（通信） </li></ul></li></ul><p>Java提供了几个方法解决线程通信问题</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">方法名</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">wait()</td><td style="text-align:center">表示线程一直等待，直到其他线程通知，与sleep不同，会释放锁</td></tr><tr><td style="text-align:center">wait(long timeout)</td><td style="text-align:center">指定等待的毫秒数</td></tr><tr><td style="text-align:center">notify()</td><td style="text-align:center">唤醒一个处于等待状态的线程</td></tr><tr><td style="text-align:center">notifyAll()</td><td style="text-align:center">唤醒同一个对象上所有调用wait()方法的线程，优先级别高的线程优先调度</td></tr></tbody></table></div><p>注意：均是Object类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常IllegalMonitorStateException</p><h3 id="管程法"><a href="#管程法" class="headerlink" title="管程法"></a>管程法</h3><blockquote><p>消费者不能直接使用生产者的数据，他们之间有个“缓冲区”<br>生产者将生产好的数据放入缓冲区，消费者从缓冲区拿出数据</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试：生产者消费者模型 --&gt; 利用缓冲区解决：管程法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test28</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynContainer container = <span class="keyword">new</span> SynContainer();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Productor(container).start();</span><br><span class="line">        <span class="keyword">new</span> Consumer(container).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Productor</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    SynContainer container;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Productor</span><span class="params">(SynContainer container)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.container = container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;生产了&quot;</span> + i + <span class="string">&quot;个产品&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                container.push(<span class="keyword">new</span> Product(i));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    SynContainer container;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span> <span class="params">(SynContainer container)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.container = container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消费了--&gt;&quot;</span> + container.pop().id + <span class="string">&quot;产品&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 产品</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Product</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓冲区</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynContainer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 需要一个容器大小</span></span><br><span class="line">    Product[] products = <span class="keyword">new</span> Product[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">// 容器计数器</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产者放入产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Product product)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 如果容器满了，就需要等待消费者消费</span></span><br><span class="line">        <span class="keyword">if</span>(count == products.length) &#123;</span><br><span class="line">            <span class="comment">// 通知消费者消费，等待生产</span></span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有满，我们就需要丢入产品</span></span><br><span class="line">        products[count] = product;</span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知生产者消费</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费者消费商品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Product <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 判断能否消费</span></span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 等待生产者生产，消费者等待</span></span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果可以消费</span></span><br><span class="line">        count--;</span><br><span class="line">        Product product = products[count];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费空了，通知生产者生产</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><blockquote><p>背景：经常创建和销毁，使用量特别大的资源，比如并发情况下的线程，对性能影响很大。<br>思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。<br>可以避免频繁创建销毁，实现重复利用。类似生活中的公共交通工具。</p><ul><li>提高响应速度（减少了创建新线程的时间）</li><li>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</li><li>便于线程管理<ul><li>corePoolSize：核心池的大小</li><li>maximumPoolSize：最大线程数</li><li>keepAliveTime：线程没有任务时最多保持多长时间后会终止</li></ul></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test29</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建服务，创建线程池</span></span><br><span class="line">        <span class="comment">// newFixedThreadPool参数为线程池大小</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭链接</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>为什么要使用lambda表达式：</p><ul><li>避免匿名内部类定义过多</li><li>让代码更加简洁</li><li>去掉了没有意义的代码，只留下核心逻辑</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lambda表达式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test19</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Like2</span> <span class="keyword">implements</span> <span class="title">ILike</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I like lambda2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现类</span></span><br><span class="line">        ILike like = <span class="keyword">new</span> Like1();</span><br><span class="line">        like.lambda();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 静态内部类</span></span><br><span class="line">        like = <span class="keyword">new</span> Like2();</span><br><span class="line">        like.lambda();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 局部内部类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Like3</span> <span class="keyword">implements</span> <span class="title">ILike</span> </span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;I like lambda3&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        like = <span class="keyword">new</span> Like3();</span><br><span class="line">        like.lambda();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匿名内部类，没有类的名称，必须借助父类或接口</span></span><br><span class="line">        like = <span class="keyword">new</span> ILike() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;I like lambda4&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        like.lambda();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// lambda表达式</span></span><br><span class="line">        like = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I like lambda5&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        like.lambda();</span><br><span class="line"></span><br><span class="line">        ILove love = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// lambda表达式2</span></span><br><span class="line">        love = (a, b) -&gt; System.out.println(<span class="string">&quot;I like lambda &quot;</span> + a + <span class="string">&quot; &quot;</span>+ b);</span><br><span class="line">        love.lambda(<span class="number">20</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  总结：</span></span><br><span class="line"><span class="comment">            1. lambda表达式只能在一行代码的情况下简化成一行，否则必须用代码块包装。</span></span><br><span class="line"><span class="comment">            2. 使用的前提是接口必须为函数式接口且只有一个函数。</span></span><br><span class="line"><span class="comment">            3. 可以都去掉参数类型，且只有一个参数时可以不加括号。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数式接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ILike</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Like1</span> <span class="keyword">implements</span> <span class="title">ILike</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I like lambda1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ILove</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lambda</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：矩阵中最长递增路径（记忆化搜索）</title>
      <link href="2020/07/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84%EF%BC%88%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%EF%BC%89.html"/>
      <url>2020/07/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84%EF%BC%88%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个整数矩阵，找出最长递增路径的长度。</p><p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><a id="more"></a> <p>记忆化搜索模板题。$dp[i][j]$记录之前已经计算得到的结果，之后直接读取即可。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution329</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">           [7,8,9]</span></span><br><span class="line"><span class="comment">           [9,7,6]</span></span><br><span class="line"><span class="comment">           [7,2,3]</span></span><br><span class="line"><span class="comment">           输出：6</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] dirs = &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] a, <span class="keyword">int</span>[][] dp, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[x][y] != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> dp[x][y];</span><br><span class="line">        dp[x][y] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] dir : dirs) &#123;</span><br><span class="line">            <span class="keyword">int</span> fx = x + dir[<span class="number">0</span>], fy = y + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(fx &gt;= <span class="number">0</span> &amp;&amp; fx &lt; n &amp;&amp; fy &gt;= <span class="number">0</span> &amp;&amp; fy &lt; m &amp;&amp; a[fx][fy] &gt; a[x][y])</span><br><span class="line">                dp[x][y] = Math.max(dp[x][y], dfs(a, dp, fx, fy) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[x][y];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] a)</span> </span>&#123;</span><br><span class="line">        n = a.length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        m = a[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                res = Math.max(res, dfs(a, dp, i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记忆化搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 注解与反射</title>
      <link href="2020/07/Java-%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84.html"/>
      <url>2020/07/Java-%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84.html</url>
      
        <content type="html"><![CDATA[<h2 id="注解-Annotation"><a href="#注解-Annotation" class="headerlink" title="注解 Annotation"></a>注解 Annotation</h2><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li>对程序作出解释（类似于注释）</li><li>可以被其他程序读取（如：编译器等）</li></ul><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><ul><li>注解以 “@注释名” 形式存在，如 “@Override”，有些可以添加一些参数值，如 “@SuppressWarnings(value=”unchecked”)”<a id="more"></a> </li><li>附加在package，class，method，field等上方，等于给他们添加额外辅助信息，我们可以通过反射机制编程实现对这些元数据的访问</li></ul><h3 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h3><ul><li>@Override: 此注释只适用于修饰方法，表示一个方法声明打算重写超类中的另一个方法声明</li><li>@SuppressWarnings: 用于抑制编译时的警告信息(Warning)，需要添加参数才能使用，如：(“all”),(“unchecked”),(value={“unchecked”,”deprecation”})等等</li></ul><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>元注解作用就是负责注解其他注解，Java定义了4个标准的meta-annotation类型，他们被用来提供对其他annotation类型作说明</p><ul><li><strong>@Target</strong>: 用于描述注解的使用范围（被描述的注解可以用在什么地方）</li><li><strong>@Retention</strong>: 表示需要在什么级别保存该注释信息，用于描述注解的生命周期(SOURCE &lt; CLASS &lt; RUNTIME)</li><li>@Document: 说明该注解将被包含在javadoc中</li><li>@Inherited: 说明子类可以<strong>继承</strong>父类中的该注解</li></ul><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>使用@interface自定义注解时，自动继承java.lang.annotation.Annotation接口</p><ul><li>@interface用来声明一个注释，格式：@interface 注解名 { 定义内容 }</li><li>其中的每一个方法实际上是声明了一个配置参数</li><li>方法的名称就是参数的名称</li><li>返回值类型就是参数的类型，返回值只能是基本类型(Class, String, enum)</li><li>可以通过default来声明参数的默认值</li><li>如果只有一个参数成员，一般参数名为value</li><li>注解必须要有值，我们定义注解元素时，经常使用空字符串或者0来作为默认值(default)</li></ul><h2 id><a href="#" class="headerlink" title></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注解可以显示赋值，没有先后顺序之分，如果没有默认值，就必须给注解赋值</span></span><br><span class="line">    <span class="meta">@MyAnnotation01(id = 1, age = 18, name = &quot;Benboby&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当注解只有一个参数时，默认定义为 value() , 则可以省略 &quot;value = &quot;</span></span><br><span class="line">    <span class="meta">@MyAnnotation02(&quot;Benboby&quot;)</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span> <span class="comment">// 作用域可以在类上或者方法上</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">// 在运行时有效</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation01 &#123;</span><br><span class="line">    <span class="comment">// 注解的参数：参数类型 + 参数名() (+ 默认值);</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    String[] schools() <span class="keyword">default</span> &#123;<span class="string">&quot;本科&quot;</span>,<span class="string">&quot;带专&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span> <span class="comment">// 作用域可以在类上或者方法上</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">// 在运行时有效</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation02 &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h2 id="反射（Java-Reflection）"><a href="#反射（Java-Reflection）" class="headerlink" title="反射（Java Reflection）"></a>反射（Java Reflection）</h2><h3 id="动态-VS-静态语言"><a href="#动态-VS-静态语言" class="headerlink" title="动态 VS 静态语言"></a>动态 VS 静态语言</h3><p>动态语言：运行时代码可以根据某些条件改变自身结构。如：C#, JavaScript, PHP, Python等。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// var 是万能类型</span></span><br><span class="line">    <span class="keyword">var</span> x = <span class="string">&quot;var a=1; var b=2; alert(a+b)&quot;</span>; <span class="comment">// 可以认为目前是字符串类型</span></span><br><span class="line">    <span class="built_in">eval</span>(x) <span class="comment">// 执行 x ，x 变为 a+b 的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>静态语言：运行时结构不可改变的语言就是静态语言。如：Java, C, C++。</p><ul><li>Java不是动态语言，但Java有一定的动态性，我们可以利用反射机制获得类似动态语言的特性，使得Java在编程的时候变得更灵活。</li></ul><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Reflection是Java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。</p><p>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构，这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射。</p><p>正常方式： 引入需要的“包类”名称 -&gt; 通过new实例化 -&gt; 取得实例化对象<br>反射方式： 实例化对象 -&gt; getClass()方法 -&gt; 得到完整的“包类”名称</p><p>优点：可以实现创建对象和编译，体现出很大的灵活性<br>缺点：对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于直接执行相同的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 通过反射获取对象类的Class对象</span></span><br><span class="line">        Class c1 = Class.forName(<span class="string">&quot;pers.Shuke.reflection.User&quot;</span>);</span><br><span class="line">        System.out.println(c1); <span class="comment">// 输出：class pers.Shuke.reflection.User</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><p>在Object类中定义了以下的方法，此方法将所有子类继承：<strong>public final Class getClass()</strong></p><p>以上方法的返回值类型是一个Class类，此类是Java反射的源头，即：可以通过对象反射求出类名称。</p><h3 id="获取Class类型的几种方式"><a href="#获取Class类型的几种方式" class="headerlink" title="获取Class类型的几种方式"></a>获取Class类型的几种方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Student();</span><br><span class="line">        <span class="comment">// 方式1：通过对象获得</span></span><br><span class="line">        Class c1 = person.getClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式2：forname获得</span></span><br><span class="line">        Class c2 = Class.forName(<span class="string">&quot;pers.Shuke.reflection.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式3：通过类名.class获得</span></span><br><span class="line">        Class c3 = Student.class;</span><br><span class="line">        System.out.println(c3);</span><br><span class="line">        <span class="comment">// c1 = c2 = c3 = &quot;class pers.Shuke.reflection.Student&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式4：基本内置类型的包装类都有一个Type属性</span></span><br><span class="line">        Class c4 = Integer.TYPE;   <span class="comment">// c4 = int</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式5：</span></span><br><span class="line">        Class c5 = c1.getSuperclass();  <span class="comment">// c5 = &quot;class pers.Shuke.reflection.Person&quot;</span></span><br><span class="line">        System.out.println(c5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><h3 id="所有类型的Class对象"><a href="#所有类型的Class对象" class="headerlink" title="所有类型的Class对象"></a>所有类型的Class对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class c1 = Object.class; <span class="comment">// 类 c1 = &quot;class java.lang.Object&quot;</span></span><br><span class="line">        Class c2 = Comparable.class; <span class="comment">// 接口 c2 = &quot;interface java.lang.Comparable&quot;</span></span><br><span class="line">        Class c3 = String[].class; <span class="comment">// 一维数组 c3 = &quot;class [Ljava.lang.String;&quot;</span></span><br><span class="line">        Class c4 = <span class="keyword">int</span>[][].class; <span class="comment">// 二维数组 c4 = &quot;class [[I&quot;</span></span><br><span class="line">        Class c5 = Override.class; <span class="comment">// 注解 c5 = &quot;interface java.lang.Override&quot;</span></span><br><span class="line">        Class c6 = ElementType.class; <span class="comment">// 枚举 c6 = &quot;class java.lang.annotation.ElementType&quot;</span></span><br><span class="line">        Class c7 = Integer.class; <span class="comment">// 基本数据类型 c7 = &quot;class java.lang.Integer&quot;</span></span><br><span class="line">        Class c8 = <span class="keyword">void</span>.class; <span class="comment">// void c8 = &quot;void&quot;</span></span><br><span class="line">        Class c9 = Class.class; <span class="comment">// Class c9 = &quot;class java.lang.Class&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        Class c10 = a.getClass();</span><br><span class="line">        Class c11 = b.getClass();</span><br><span class="line">        <span class="comment">// c10 = c11</span></span><br><span class="line">        <span class="comment">// 只有元素类型与维度一样，就是同一个Class</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java内存分析"><a href="#Java内存分析" class="headerlink" title="Java内存分析"></a>Java内存分析</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>堆：存放new的对象和数组，可以被所有的线程共享，不会存放别的对象引用<br>栈：存放基本变量类型（包含具体数值），引用对象的变量（会存放这个引用在堆里面的具体地址）<br>方法区：可以被所有的线程共享，包含所有的class和static变量</p><h4 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h4><p>当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过以下三个步骤来对该类进行初始化。</p><ol><li>类的加载(Load)：将类的class文件读入内存，并为之创建一个java.lang.Class对象。此过程由类加载器完成。</li><li>类的连接(Link)：将类的二进制数据合并到JRE中。</li><li>类的初始化(Initialize)：JVM负责对类进行初始化。</li></ol><h4 id="类的初始化"><a href="#类的初始化" class="headerlink" title="类的初始化"></a>类的初始化</h4><ol><li>类的主动引用（一定会发生类的初始化）</li></ol><ul><li>当虚拟机启动，先初始化main方法所在的类</li><li>new一个类的对象</li><li>调用类的静态成员（除了final常量）和静态方法</li><li>使用java.lang.reflect包的方法对类进行反射调用</li><li>当初始化一个类，如果其父类没有被初始化，则会先初始化他的父类</li></ul><ol><li>类的被动引用</li></ol><ul><li>当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类初始化</li><li>通过数组定义类引用，不会触发此类的初始化</li><li>引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试类什么时候会被初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test08</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main类被加载&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 主动调用</span></span><br><span class="line">        <span class="comment">//Son son = new Son();</span></span><br><span class="line">        <span class="comment">/* main类被加载</span></span><br><span class="line"><span class="comment">           父类被加载</span></span><br><span class="line"><span class="comment">           子类被加载</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射</span></span><br><span class="line">        <span class="comment">//Class.forName(&quot;pers.Shuke.Initialization.Son&quot;);</span></span><br><span class="line">        <span class="comment">/*  main类被加载</span></span><br><span class="line"><span class="comment">            父类被加载</span></span><br><span class="line"><span class="comment">            子类被加载</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 引用父类常量</span></span><br><span class="line">        <span class="comment">//System.out.println(Son.b);</span></span><br><span class="line">        <span class="comment">/*  main类被加载</span></span><br><span class="line"><span class="comment">            父类被加载</span></span><br><span class="line"><span class="comment">            2</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 引用自身常量</span></span><br><span class="line">        <span class="comment">//System.out.println(Son.m);</span></span><br><span class="line">        <span class="comment">/*  main类被加载</span></span><br><span class="line"><span class="comment">            父类被加载</span></span><br><span class="line"><span class="comment">            子类被加载</span></span><br><span class="line"><span class="comment">            100</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义数组</span></span><br><span class="line">        <span class="comment">//Son[] array = new Son[5];</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            main类被加载</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 引用final常量</span></span><br><span class="line">        <span class="comment">//System.out.println(Son.f);</span></span><br><span class="line">        <span class="comment">/*  main类被加载</span></span><br><span class="line"><span class="comment">            10</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类被加载&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类被加载&quot;</span>);</span><br><span class="line">        m = <span class="number">300</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> f = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类加载器的作用"><a href="#类加载器的作用" class="headerlink" title="类加载器的作用"></a>类加载器的作用</h4><p>类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据转化成方法区的运行时数据结构，然后在堆中生成一个代表这个类的Class对象，作为方法区中类数据的访问入口。</p><p>类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，他将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象。</p><p>源程序(.java文件) -&gt; Java编译器 -&gt; 字节码(.class文件) -&gt; 类装载器 -&gt; 字节码校验器 -&gt; 解释器 -&gt; 操作系统平台</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test09</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取系统类加载器</span></span><br><span class="line">        ClassLoader classLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(classLoader); <span class="comment">// 输出：jdk.internal.loader.ClassLoaders$AppClassLoader@3d4eac69</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取系统类父类的加载器 -&gt; 拓展类加载器</span></span><br><span class="line">        ClassLoader parent = classLoader.getParent();</span><br><span class="line">        System.out.println(parent); <span class="comment">// 输出：jdk.internal.loader.ClassLoaders$PlatformClassLoader@77459877</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取拓展类加载器的父类加载器 -&gt; 引导类加载器/根加载器（C/C++）</span></span><br><span class="line">        ClassLoader root = parent.getParent();</span><br><span class="line">        System.out.println(root); <span class="comment">// 输出：null （无法直接获取）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试当前类是哪个加载器加载的</span></span><br><span class="line">        ClassLoader classLoader1 = Class.forName(<span class="string">&quot;pers.Shuke.Initialization.Test09&quot;</span>).getClassLoader();</span><br><span class="line">        System.out.println(classLoader1); <span class="comment">// 输出：jdk.internal.loader.ClassLoaders$AppClassLoader@3d4eac69</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试jdk内置的类是哪个加载器加载的</span></span><br><span class="line">        ClassLoader classLoader2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getClassLoader();</span><br><span class="line">        System.out.println(classLoader2); <span class="comment">// 输出：null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如何获得系统类加载器可以加载的路径</span></span><br><span class="line">        System.out.println(System.getProperty(<span class="string">&quot;java.class.path&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取类的运行时结构"><a href="#获取类的运行时结构" class="headerlink" title="获取类的运行时结构"></a>获取类的运行时结构</h3><p>通过反射获取类运行时的完整结构：</p><ul><li>实现的全部接口（Interface）</li><li>所继承的父类（Superclass）</li><li>全部的构造器（Constructor）</li><li>全部的方法（Method）</li><li>全部的Field</li><li>注解</li><li>…</li></ul><p>PS：public/private/protected区别（默认为friendly）</p><div class="table-container"><table><thead><tr><th style="text-align:center">作用域</th><th style="text-align:center">当前类</th><th style="text-align:center">同一public</th><th style="text-align:center">子孙类</th><th style="text-align:center">其他package</th></tr></thead><tbody><tr><td style="text-align:center">public</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">protected</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">friendly</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">private</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test05</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, NoSuchMethodException </span>&#123;</span><br><span class="line">        Class c1 = Class.forName(<span class="string">&quot;pers.Shuke.reflection.User&quot;</span>);</span><br><span class="line">        System.out.println(c1.getName()); <span class="comment">// 输出：pers.Shuke.reflection.User</span></span><br><span class="line">        System.out.println(c1.getSimpleName()); <span class="comment">// 输出：User</span></span><br><span class="line"></span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        c1 = user.getClass();</span><br><span class="line">        System.out.println(c1.getName()); <span class="comment">// 输出：pers.Shuke.reflection.User</span></span><br><span class="line">        System.out.println(c1.getSimpleName()); <span class="comment">// 输出：User</span></span><br><span class="line"></span><br><span class="line">        Field[] fields = c1.getFields(); <span class="comment">// 输出：null  解释：只能找到public属性</span></span><br><span class="line">        fields = c1.getDeclaredFields();</span><br><span class="line">        <span class="comment">/*  private java.lang.String pers.Shuke.reflection.User.name</span></span><br><span class="line"><span class="comment">            private int pers.Shuke.reflection.User.age</span></span><br><span class="line"><span class="comment">            private int pers.Shuke.reflection.User.id</span></span><br><span class="line"><span class="comment">            解释：可以找到全部属性</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span>(Field field : fields) &#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得指定属性的值</span></span><br><span class="line">        <span class="comment">//Field name = c1.getField(&quot;name&quot;); // 报错：只能获取public对象</span></span><br><span class="line">        Field name = c1.getDeclaredField(<span class="string">&quot;name&quot;</span>); <span class="comment">// 输出：private java.lang.String pers.Shuke.reflection.User.name</span></span><br><span class="line">        System.out.println(name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取类的方法</span></span><br><span class="line">        Method[] methods = c1.getMethods(); <span class="comment">// 获取本类和父类所有public方法</span></span><br><span class="line">        methods = c1.getDeclaredMethods(); <span class="comment">// 获取本类所有方法</span></span><br><span class="line">        <span class="keyword">for</span>(Method method : methods) &#123;</span><br><span class="line">            System.out.println(method);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取类的指定方法(需要传参)</span></span><br><span class="line">        Method getname = c1.getMethod(<span class="string">&quot;getName&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        Method setname = c1.getMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">        System.out.println(getname); <span class="comment">// 输出：public java.lang.String pers.Shuke.reflection.User.getName()</span></span><br><span class="line">        System.out.println(setname); <span class="comment">// 输出：public void pers.Shuke.reflection.User.setName(java.lang.String)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得指定的构造器</span></span><br><span class="line">        Constructor[] constructors = c1.getConstructors(); <span class="comment">// 获取public构造器</span></span><br><span class="line">        constructors = c1.getDeclaredConstructors(); <span class="comment">// 获取指定构造器</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得指定构造器</span></span><br><span class="line">        Constructor constructor = c1.getDeclaredConstructor(String.class, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class);</span><br><span class="line">        System.out.println(constructor); <span class="comment">// 输出：public pers.Shuke.reflection.User(java.lang.String,int,int)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态创建对象执行方法"><a href="#动态创建对象执行方法" class="headerlink" title="动态创建对象执行方法"></a>动态创建对象执行方法</h3><p>创建类的对象：<br>有无参构造器：调用Class对象的newInstance()方法</p><ul><li>类必须有一个无参数构造器</li><li>类的构造器的访问权限要足够</li></ul><p>没有无参构造器：</p><ol><li>通过Class类的getDeclaredConstructor()取得本类的指定形参类型的构造器</li><li>向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的哥哥参数</li><li>通过Constructor</li></ol><p>调用指定的方法：<br>通过反射，调用类中的方法，通过Method完成。</p><ol><li>通过Class类的getMethod()方法取得一个Method对象，并设置此方法操作时所需要的参数类型。</li><li>之后使用Object invoke()进行调用，并向方法中传递需要设置的obj对象的参数信息。</li></ol><p>setAccessible：</p><ul><li>Method，Field和Constructor对象都有setAccessible()方法</li><li>作用为启动和禁用访问安全检查的开关</li><li>参数值为true则指示反射的对象在使用时应该取消Java语言访问检测，这样可以提高反射的效率，使得原本无法访问的私有成员也可以访问</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test11</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取class对象</span></span><br><span class="line">        Class c1 = Class.forName(<span class="string">&quot;pers.Shuke.reflection.User&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造一个对象</span></span><br><span class="line">        User user = (User)c1.newInstance(); <span class="comment">// 本质上调用类的无参构造器</span></span><br><span class="line">        System.out.println(user); <span class="comment">// pers.Shuke.reflection.User@5b2133b1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过构造器创建对象</span></span><br><span class="line">        Constructor constructor = c1.getDeclaredConstructor(String.class, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class);</span><br><span class="line">        User user2 = (User)constructor.newInstance(<span class="string">&quot;舒克&quot;</span>, <span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">        System.out.println(user2); <span class="comment">// pers.Shuke.reflection.User@72ea2f77</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射调用普通方法</span></span><br><span class="line">        User user3 = (User)c1.newInstance();</span><br><span class="line">        <span class="comment">// 通过反射获取一个方法</span></span><br><span class="line">        Method setName = c1.getDeclaredMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// invoke : 激活的意思</span></span><br><span class="line">        <span class="comment">// &#123;对象，方法的值&#125;</span></span><br><span class="line">        setName.invoke(user3, <span class="string">&quot;舒克&quot;</span>);</span><br><span class="line">        System.out.println(user3.getName()); <span class="comment">// 舒克</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射操作属性</span></span><br><span class="line">        User user4 = (User)c1.newInstance();</span><br><span class="line">        Field name = c1.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">        name.setAccessible(<span class="keyword">false</span>); <span class="comment">// 关闭权限检测，否则无法直接修改private变量</span></span><br><span class="line">        name.set(user4, <span class="string">&quot;舒克2&quot;</span>);</span><br><span class="line">        System.out.println(user4.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="性能对比分析"><a href="#性能对比分析" class="headerlink" title="性能对比分析"></a>性能对比分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分析性能问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test12</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 普通方式调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Test12_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++) &#123;</span><br><span class="line">            user.getName();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;普通方法执行10亿次：&quot;</span> + (endTime - startTime) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反射方式调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Test12_2</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        Class c1 = user.getClass();</span><br><span class="line">        Method getName = c1.getDeclaredMethod(<span class="string">&quot;getName&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++) &#123;</span><br><span class="line">            getName.invoke(user, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;反射调用不关检测执行10亿次：&quot;</span> + (endTime - startTime) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反射反射调用（关闭检测）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Test12_3</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        Class c1 = user.getClass();</span><br><span class="line">        Method getName = c1.getDeclaredMethod(<span class="string">&quot;getName&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        getName.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++) &#123;</span><br><span class="line">            getName.invoke(user, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;反射调用不关检测执行10亿次：&quot;</span> + (endTime - startTime) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException </span>&#123;</span><br><span class="line">        Test12_1(); <span class="comment">// 6ms</span></span><br><span class="line">        Test12_2(); <span class="comment">// 2686ms</span></span><br><span class="line">        Test12_3(); <span class="comment">// 1065ms</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据结果可知：<strong>普通调用效率 &gt;&gt; 关闭检测反射调用效率 &gt; 不关闭检测反射调用效率</strong></p><h3 id="获取泛型信息"><a href="#获取泛型信息" class="headerlink" title="获取泛型信息"></a>获取泛型信息</h3><p>Java采用泛型擦除机制来引入泛型，Java中的泛型仅仅是给编译器javac使用的，确保数据的安全性和免去强制类型转换问题，但是，一旦编译完成，所有和泛型相关的类型全部擦除</p><p>为了通过反射操作这些类型，Java新增了ParameterizedType，GenericArrayType，TypeVariable和WildcardType这几种类型来代表不能被归一到Class类中的类型但是又和原始类型齐名的类型</p><ul><li>ParameterizedType: 表示一种参数化类型，比如Collection<String></String></li><li>GenericArrayType: 表示一种元素类型是参数化类型或者类型变量的数组类型</li><li>TypeVariable: 是各种类型变量的公共父接口</li><li>WildcardType: 代表一种通配符类型表达式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过反射获取泛型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test13</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Test13_1</span><span class="params">(Map&lt;String, User&gt; map, List&lt;User&gt; list)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test13_1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, User&gt; <span class="title">Test13_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test13_2&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取方法</span></span><br><span class="line">        Method method = Test13.class.getMethod(<span class="string">&quot;Test13_1&quot;</span>, Map.class, List.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取泛型参数类型</span></span><br><span class="line">        Type[] genericParameterTypes = method.getGenericParameterTypes();</span><br><span class="line">        <span class="keyword">for</span>(Type genericParameterType : genericParameterTypes) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;#&quot;</span> + genericParameterType);</span><br><span class="line">            <span class="comment">/*  #java.util.Map&lt;java.lang.String, pers.Shuke.reflection.User&gt;</span></span><br><span class="line"><span class="comment">                ------------</span></span><br><span class="line"><span class="comment">                #java.util.List&lt;pers.Shuke.reflection.User&gt;</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">// 是否属于参数化类型</span></span><br><span class="line">            <span class="keyword">if</span>(genericParameterType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">                <span class="comment">// 强制转化，获得真实的参数类型</span></span><br><span class="line">                Type[] actualTypeArguments = ((ParameterizedType) genericParameterType).getActualTypeArguments();</span><br><span class="line">                <span class="keyword">for</span>(Type actualTypeArgument : actualTypeArguments) &#123;</span><br><span class="line">                    System.out.println(actualTypeArgument);</span><br><span class="line">                    <span class="comment">/*  class java.lang.String</span></span><br><span class="line"><span class="comment">                        class pers.Shuke.reflection.User</span></span><br><span class="line"><span class="comment">                        ------------</span></span><br><span class="line"><span class="comment">                        class pers.Shuke.reflection.User</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        method = Test13.class.getMethod(<span class="string">&quot;Test13_2&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 获取返回值类型</span></span><br><span class="line">        Type genericParameterType = method.getGenericReturnType();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否为泛型</span></span><br><span class="line">        <span class="keyword">if</span>(genericParameterType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">            <span class="comment">// 强制转化为具体泛型</span></span><br><span class="line">            Type[] actualTypeArguments = ((ParameterizedType) genericParameterType).getActualTypeArguments();</span><br><span class="line">            <span class="keyword">for</span>(Type actualTypeArgument : actualTypeArguments) &#123;</span><br><span class="line">                System.out.println(actualTypeArgument);</span><br><span class="line">                <span class="comment">/*  class java.lang.String</span></span><br><span class="line"><span class="comment">                    class pers.Shuke.reflection.User</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取注解信息"><a href="#获取注解信息" class="headerlink" title="获取注解信息"></a>获取注解信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反射操作注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test14</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException </span>&#123;</span><br><span class="line">        Class c1 = Class.forName(<span class="string">&quot;pers.Shuke.reflection.People&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射获得注解</span></span><br><span class="line">        Annotation[] annotations = c1.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span>(Annotation annotation : annotations) &#123;</span><br><span class="line">            System.out.println(annotation); <span class="comment">// @pers.Shuke.reflection.TableShuke(&quot;db_people&quot;)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得注解的value的值</span></span><br><span class="line">        TableShuke tableShuke = (TableShuke)c1.getAnnotation(TableShuke.class);</span><br><span class="line">        String value = tableShuke.value();</span><br><span class="line">        System.out.println(value); <span class="comment">// db_people</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得类的指定注解</span></span><br><span class="line">        Field field = c1.getDeclaredField(<span class="string">&quot;name&quot;</span>); <span class="comment">// 获得name属性的注解</span></span><br><span class="line">        FieldShuke annotation = field.getAnnotation(FieldShuke.class);</span><br><span class="line">        System.out.println(annotation.columnName() + <span class="string">&quot; &quot;</span> + annotation.type() + <span class="string">&quot; &quot;</span> + annotation.length()); <span class="comment">// db_name varchar 8</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@TableShuke(&quot;db_people&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="meta">@FieldShuke(columnName = &quot;db_name&quot;, type = &quot;varchar&quot;, length = 8)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@FieldShuke(columnName = &quot;db_age&quot;, type = &quot;int&quot;, length = 4)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="meta">@FieldShuke(columnName = &quot;db_id&quot;, type = &quot;int&quot;, length = 12)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类名的注解</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> TableShuke &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性的注解</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> FieldShuke &#123;</span><br><span class="line">    <span class="function">String <span class="title">columnName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">type</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静态代码块，构造代码块，构造函数及其执行顺序和逻辑</title>
      <link href="2020/07/%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%8C%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E5%92%8C%E9%80%BB%E8%BE%91.html"/>
      <url>2020/07/%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%8C%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E5%92%8C%E9%80%BB%E8%BE%91.html</url>
      
        <content type="html"><![CDATA[<h2 id="静态代码块："><a href="#静态代码块：" class="headerlink" title="静态代码块："></a>静态代码块：</h2><ol><li>随着类的加载而执行，只执行一次，并优先于主函数。具体说，静态代码块是由类调用的。类调用时，先执行静态代码块，然后才执行主函数的。</li><li>静态代码块其实就是给类初始化的，而构造代码块是给对象初始化的。</li><li>静态代码块中的变量是局部变量，与普通函数中的局部变量性质没有区别。</li><li>一个类中可以有多个静态代码块（顺序由上至下）。</li></ol><h2 id="构造代码块"><a href="#构造代码块" class="headerlink" title="构造代码块"></a>构造代码块</h2><ol><li>构造代码块的作用是给对象进行初始化。<a id="more"></a> </li><li>对象一建立就运行构造代码块了，而且优先于构造函数执行。这里要强调一下，有对象建立，才会运行构造代码块，类不能调用构造代码块的，而且构造代码块与构造函数的执行顺序是前者先于后者执行。</li><li>构造代码块与构造函数的区别是：构造代码块是给所有对象进行统一初始化，而构造函数是给对应的对象初始化，因为构造函数是可以多个的，运行哪个构造函数就会建立什么样的对象，但无论建立哪个对象，都会先执行相同的构造代码块。也就是说，构造代码块中定义的是不同对象共性的初始化内容。</li></ol><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ol><li>对象一建立，就会调用与之相应的构造函数，也就是说，不建立对象，构造函数是不会运行的。</li><li>构造函数的作用是用于给对象进行初始化。</li><li>一个对象建立，构造函数只运行一次，而一般方法可以被该对象调用多次。</li></ol><h2 id="Java类初始化顺序"><a href="#Java类初始化顺序" class="headerlink" title="Java类初始化顺序"></a>Java类初始化顺序</h2><ol><li>单一类：静态变量，静态代码块 &gt; 变量，构造代码块 &gt; 构造函数<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test06</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String x = <span class="string">&quot;静态变量&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> String y = <span class="string">&quot;变量&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test06</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(y);</span><br><span class="line">        System.out.println(<span class="string">&quot;构造代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 输出：静态变量</span></span><br><span class="line"><span class="comment">                静态代码块</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        Test06 test06 = <span class="keyword">new</span> Test06();</span><br><span class="line">        <span class="comment">/* 输出：变量</span></span><br><span class="line"><span class="comment">                构造代码块</span></span><br><span class="line"><span class="comment">                构造函数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>继承情况：父类静态 &gt; 子类静态 &gt; 父类构造代码块 &gt; 父类构造函数 &gt; 子类构造代码块 &gt; 子类构造函数</li></ol><p><strong>静态变量是属于类的，和继承无关！！！</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test06</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test06</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类构造代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test06_1</span> <span class="keyword">extends</span> <span class="title">Test06</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test06_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类构造代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 输出：父类静态代码块</span></span><br><span class="line"><span class="comment">                子类静态代码块</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        Test06_1 test06_1 = <span class="keyword">new</span> Test06_1();</span><br><span class="line">        <span class="comment">/* 输出：父类构造代码块</span></span><br><span class="line"><span class="comment">                父类构造函数</span></span><br><span class="line"><span class="comment">                子类构造代码块</span></span><br><span class="line"><span class="comment">                子类构造函数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        staticFunction();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态变量（有实例化的过程,这就是本题的重点）</span></span><br><span class="line">    <span class="keyword">static</span> StaticTest st = <span class="keyword">new</span> StaticTest();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//System.out.println(b); // 编译报错：因为b在构造代码块后边，此处不能引用。因此Java代码是从上到下的顺序</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    StaticTest() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;a=&quot;</span> + a + <span class="string">&quot;,b=&quot;</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这两个变量写在最后面</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">110</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">112</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出：2</span></span><br><span class="line"><span class="comment">        3</span></span><br><span class="line"><span class="comment">        a=110,b=0</span></span><br><span class="line"><span class="comment">        1</span></span><br><span class="line"><span class="comment">        4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ol><li>先初始化静态变量，也就是执行new StaticTest()，先执行构造代码块，输出 2</li><li>再执行构造函数，输出 3 和 a=110,b=0<ul><li>在执行构造函数前，必须初始化实例属性，故 a = 110</li><li>静态变量从上到下初始化，还没有轮到，因此 b = 0</li></ul></li><li>执行静态代码块，输出 1</li><li>最后进入main函数，执行静态方法staticFunction，输出 4</li></ol><p>可以发现：<strong>static变量并不一定在实例化变量前被初始化</strong>。</p><h3 id="父类和子类有同名属性时"><a href="#父类和子类有同名属性时" class="headerlink" title="父类和子类有同名属性时"></a>父类和子类有同名属性时</h3><pre><code class="lang-Java">public class Test07 &#123;    public static void main(String[] args) &#123;        // 使用多态        Parent chidParent = new Child();        System.out.println(&quot;Parent:&quot; + chidParent.getAge()); //40        System.out.println(&quot;Parent:&quot; + chidParent.age); //18        System.out.println(&quot;Parent:&quot; + chidParent.id); //08        // 直接使用原本类型        Child child = new Child();        System.out.println(&quot;Child:&quot; + child.getAge()); //40        System.out.println(&quot;Child:&quot; + child.age); //40        System.out.println(&quot;Child:&quot; + child.id); //8    &#125;&#125;class Child extends Parent &#123;    public Integer age = 40;    public Integer id = 8;    public int getAge() &#123;        return age;    &#125;&#125;class Parent &#123;    public Integer age = 18;    public String id = &quot;08&quot;;    public int getAge() &#123;        return age;    &#125;&#125;</code></pre><p>对于输出 18 的解释（Java的继承机制）：</p><ol><li>属性属于实例自己的，所以Parent的age属性值是18</li><li>属性不存在覆盖（即使同名），而方法是实实在在的覆盖（复写）</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客多校2020第二场补题</title>
      <link href="2020/07/%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A12020%E7%AC%AC%E4%BA%8C%E5%9C%BA%E8%A1%A5%E9%A2%98.html"/>
      <url>2020/07/%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A12020%E7%AC%AC%E4%BA%8C%E5%9C%BA%E8%A1%A5%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<h2 id="F-Fake-Maxpooling"><a href="#F-Fake-Maxpooling" class="headerlink" title="F Fake Maxpooling"></a>F Fake Maxpooling</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>规定矩阵对应的值为其下标的 $lcm$ ，求所有 $k * k$ 子矩阵最大值之和。 $( n,m,k = 5000 )$</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><a id="more"></a> <p>线性求 $lcm$ + 二维单调队列</p><p>线性求 $lcm$ ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!g[i][j]) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">1</span>; h * i &lt;= n &amp;&amp; h * j &lt;= m; h++) &#123;</span><br><span class="line">          g[h * i][h * j] = h;</span><br><span class="line">          a[h * i][h * j] = i * j * h;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>先对每一行进行单调队列（滑动窗口）维护出最大值矩阵 $g$ ，再对列进行单调队列维护矩阵 $g$ 的最大值即可。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5005</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k, a[N][N], g[N][N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> res;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!g[i][j]) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">1</span>; h * i &lt;= n &amp;&amp; h * j &lt;= m; h++) &#123;</span><br><span class="line">          g[h * i][h * j] = h;</span><br><span class="line">          a[h * i][h * j] = i * j * h;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">      <span class="keyword">while</span> (!q.empty() &amp;&amp; a[i][q.back()] &lt; a[i][j]) q.pop_back();</span><br><span class="line">      <span class="keyword">while</span> (!q.empty() &amp;&amp; j - q.front() &gt;= k) q.pop_front();</span><br><span class="line">      q.push_back(j);</span><br><span class="line">      <span class="keyword">if</span> (j &gt;= k) g[i][j] = a[i][q.front()];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">      <span class="keyword">while</span> (!q.empty() &amp;&amp; g[q.back()][i] &lt; g[j][i]) q.pop_back();</span><br><span class="line">      <span class="keyword">while</span> (!q.empty() &amp;&amp; j - q.front() &gt;= k) q.pop_front();</span><br><span class="line">      q.push_back(j);</span><br><span class="line">      <span class="keyword">if</span> (j &gt;= k) &#123;</span><br><span class="line">        a[j][i] = g[q.front()][i];</span><br><span class="line">        res += a[j][i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Cover-the-Tree"><a href="#C-Cover-the-Tree" class="headerlink" title="C Cover the Tree"></a>C Cover the Tree</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给定无根树，用最少的链覆盖树的所有点。 $( n = 2e5 )$</p><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>思维 + dfs序</p><p>首先不难想到所取的链两个端点都在叶子上才会是最优的，因此答案应为 $(叶子结点数 + 1)/2$ 。</p><p>经过一番玄学证明，得到结论为按 dfs序 构造链会是最优的，任取非叶子结点为根，由 dfs序 得到叶子结点 $l<em>1, l_2 ….l_x$ ，然后将 $l_1$ 与 $l</em>{x/2+1}$ 构成链以此类推，若多出一个点，则与根结点连起来即可。</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, u, v, root, de[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[N], res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (de[u] == <span class="number">1</span>) res.push_back(u);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> v : g[u]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">    dfs(v, u);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">    g[u].push_back(v);</span><br><span class="line">    g[v].push_back(u);</span><br><span class="line">    de[u]++;</span><br><span class="line">    de[v]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (de[i] &gt; <span class="number">1</span>) root = i;</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(root, <span class="number">-1</span>);</span><br><span class="line">  n = res.size();</span><br><span class="line">  <span class="keyword">if</span> (n &amp; <span class="number">1</span>) res.push_back(root), n++;</span><br><span class="line">  n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, res[i], res[i + n]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Boundary"><a href="#B-Boundary" class="headerlink" title="B Boundary"></a>B Boundary</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>已知一个圆必过点 $(0,0)$ ，需要构造该圆使得尽可能多的给定点在该圆的边界上，问最多能有几个点。 $( n = 2000, |x,y| = 100000 )$</p><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>三个点可以确定一个圆，因此不妨枚举两个点，求出圆心，圆心重合次数最多的即为答案。</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, res;</span><br><span class="line"><span class="keyword">double</span> X, Y, R;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">  <span class="keyword">double</span> x, y;</span><br><span class="line">&#125; p[N];</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt;, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">(Point a, Point b, Point c)</span>  <span class="comment">//三点共圆圆心公式</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">2</span> * (a.y - c.y) * (a.x - b.x) - <span class="number">2</span> * (a.y - b.y) * (a.x - c.x) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">      <span class="number">2</span> * (a.y - b.y) * (a.x - c.x) - <span class="number">2</span> * (a.y - c.y) * (a.x - b.x) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  X = ((a.x * a.x - b.x * b.x + a.y * a.y - b.y * b.y) * (a.y - c.y) -</span><br><span class="line">       (a.x * a.x - c.x * c.x + a.y * a.y - c.y * c.y) * (a.y - b.y)) /</span><br><span class="line">      (<span class="number">2</span> * (a.y - c.y) * (a.x - b.x) - <span class="number">2</span> * (a.y - b.y) * (a.x - c.x));</span><br><span class="line">  Y = ((a.x * a.x - b.x * b.x + a.y * a.y - b.y * b.y) * (a.x - c.x) -</span><br><span class="line">       (a.x * a.x - c.x * c.x + a.y * a.y - c.y * c.y) * (a.x - b.x)) /</span><br><span class="line">      (<span class="number">2</span> * (a.y - b.y) * (a.x - c.x) - <span class="number">2</span> * (a.y - c.y) * (a.x - b.x));</span><br><span class="line">  R = <span class="built_in">sqrt</span>((X - a.x) * (X - a.x) + (Y - a.y) * (Y - a.y));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>, &amp;p[i].x, &amp;p[i].y);</span><br><span class="line">  Point o = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    mp.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (solve(o, p[i], p[j])) &#123;</span><br><span class="line">        <span class="keyword">auto</span> now = <span class="built_in">make_pair</span>(X, Y);</span><br><span class="line">        res = max(res, ++mp[now]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ++res);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="J-Just-Shuffle"><a href="#J-Just-Shuffle" class="headerlink" title="J Just Shuffle"></a>J Just Shuffle</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>一个排列经过质数次置换后得到排列 A ，求原排列。 ( n = 1e5 )</p><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>直接拍个置换开根板子就过了。。。</p><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, i, j, k, o, x, l, d, a[N], g[N], nxt[N], t, q[N], b[N], ans[N];</span><br><span class="line"><span class="keyword">bool</span> v[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, k = m, t = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">2</span>; i * i &lt;= x; i++)</span><br><span class="line">    <span class="keyword">if</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i, t *= i;</span><br><span class="line">      <span class="keyword">while</span> (k % i == <span class="number">0</span>) k /= i, t *= i;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (t *= x; k % x == <span class="number">0</span>; k /= x, t *= x)</span><br><span class="line">      ;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">if</span> (!v[i]) &#123;</span><br><span class="line">      t = v[i] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (j = a[i]; j != i; j = a[j]) v[j] = <span class="number">1</span>, t++;</span><br><span class="line">      nxt[i] = g[t], g[t] = i;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">if</span> (g[i]) &#123;</span><br><span class="line">      <span class="keyword">for</span> (t = <span class="number">0</span>, j = g[i]; j; j = nxt[j]) q[++t] = j;</span><br><span class="line">      d = __gcd(l = cal(i), m);</span><br><span class="line">      <span class="keyword">if</span> (t % d) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>), <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (x = <span class="number">1</span>; x &lt;= t; x += d) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; d; j++)</span><br><span class="line">          <span class="keyword">for</span> (k = <span class="number">0</span>, o = q[x + j]; k &lt; i; k++, o = a[o])</span><br><span class="line">            b[(j + <span class="number">1L</span>L * k * m) % l] = o;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; l; j++) ans[b[j]] = b[(j + <span class="number">1</span>) % l];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 多校训练 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多校训练 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：地下城游戏 （dp）</title>
      <link href="2020/07/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F-%EF%BC%88dp%EF%BC%89.html"/>
      <url>2020/07/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F-%EF%BC%88dp%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定权值矩阵，需要从左上角走到右下角，只能往右或往下走且权值会累加，问至少需要提前准备多少权值才能保证过程中不出现权值被耗尽的情况。</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>正着不太好写，可以尝试倒过来dp，$dp[i][j]$ 表示当前位置到终点至少需要准备多少权值，这样每个点要么从下边转移，要么从右边转移，选择最小的那个点转移即可，过程中需要保证权值至少为1，得到转移方程：$dp[i][j] = max(min(dp[i+1][j],dp[i][j+1])-mp[i][j],1)$。<br><a id="more"></a> </p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="keyword">int</span>[][] mp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = mp.length, m = mp[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            Arrays.fill(dp[i], Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[n][m - <span class="number">1</span>] = dp[n - <span class="number">1</span>][m] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                dp[i][j] = Math.max(Math.min(dp[i + <span class="number">1</span>][j], dp[i][j + <span class="number">1</span>]) - mp[i][j], <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：Contest （树状数组）</title>
      <link href="2020/06/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AContest-%EF%BC%88%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%EF%BC%89.html"/>
      <url>2020/06/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AContest-%EF%BC%88%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p> $n$ 支队伍一共参加了三场比赛。<br>一支队伍 $x$ 认为自己比另一支队伍 $y$ 强当且仅当 $x$ 在至少一场比赛中比 $y$ 的排名高。<br>求有多少组 $(x,y)$，使得 $x$ 自己觉得比 $y$ 强，$y$ 自己也觉得比 $x$ 强，$(x, y)$, $(y, x)$算一组。</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><a id="more"></a> <p>若 $x$ 和 $y$ 都互相认为更强，那么必定存在两场，一场 $x$ 强于 $y$，一场 $y$ 强于 $x$，那么就是对于任意两场求逆序数，最后的答案需要除以2，因为如果两队互认为更强，必定存在 $x$ 有两场更强，或者 $y$ 有两场更强，那么计算逆序数时就多计算了一次。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const ll N = <span class="number">2</span>e5 + <span class="number">5</span>;</span><br><span class="line">ll n, res, t[N];</span><br><span class="line"></span><br><span class="line">struct Node &#123;</span><br><span class="line">  ll a, b, c;</span><br><span class="line">&#125; <span class="string">q[N]</span>;</span><br><span class="line"></span><br><span class="line">bool cmpa(Node <span class="keyword">x</span>, Node <span class="keyword">y</span>) &#123; <span class="keyword">return</span> x.a &lt; y.a; &#125;</span><br><span class="line">bool cmpb(Node <span class="keyword">x</span>, Node <span class="keyword">y</span>) &#123; <span class="keyword">return</span> x.b &lt; y.b; &#125;</span><br><span class="line"></span><br><span class="line">void add(ll <span class="keyword">x</span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">x</span> &lt;= n) &#123;</span><br><span class="line">    t[<span class="keyword">x</span>]++;</span><br><span class="line">    <span class="keyword">x</span> += <span class="keyword">x</span> &amp; -<span class="keyword">x</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll query(ll <span class="keyword">x</span>) &#123;</span><br><span class="line">  ll sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">x</span>) &#123;</span><br><span class="line">    sum += t[<span class="keyword">x</span>];</span><br><span class="line">    <span class="keyword">x</span> -= <span class="keyword">x</span> &amp; -<span class="keyword">x</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main() &#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; <span class="string">q[i]</span>.a &gt;&gt; <span class="string">q[i]</span>.b &gt;&gt; <span class="string">q[i]</span>.c;</span><br><span class="line">  <span class="keyword">sort</span>(<span class="keyword">q</span> + <span class="number">1</span>, <span class="keyword">q</span> + n + <span class="number">1</span>, cmpa);</span><br><span class="line">  <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    add(<span class="string">q[i]</span>.b);</span><br><span class="line">    res += i - query(<span class="string">q[i]</span>.b);</span><br><span class="line">  &#125;</span><br><span class="line">  memset(t, <span class="number">0</span>, sizeof(t));</span><br><span class="line">  <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    add(<span class="string">q[i]</span>.c);</span><br><span class="line">    res += i - query(<span class="string">q[i]</span>.c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">sort</span>(<span class="keyword">q</span> + <span class="number">1</span>, <span class="keyword">q</span> + n + <span class="number">1</span>, cmpb);</span><br><span class="line">  memset(t, <span class="number">0</span>, sizeof(t));</span><br><span class="line">  <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    add(<span class="string">q[i]</span>.c);</span><br><span class="line">    res += i - query(<span class="string">q[i]</span>.c);</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; res / <span class="number">2</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：Protecting the Flower （贪心）</title>
      <link href="2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AProtecting-the-Flower-%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%89.html"/>
      <url>2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AProtecting-the-Flower-%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>一共有 $n$ 只牛在花坛旁边，第 $i$ 头牛每分钟破坏 $d_i$ 朵花，把第i头牛带回牛棚需要 $2 \times ti$ 这么多时间，每次只能带回一头牛，请问怎样能使得被破坏的花最少。</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>以小化大，先考虑两头牛，先领 $a$ ，损失为：$2\times{t_a}\times{d_b}$，先领 $b$，损失为 $2\times{t_b}\times{d_a}$，故得到排序条件 ${a_t \times {b_d} &lt; b_t \times {a_d}}$，最后模拟得出答案。<br><a id="more"></a> </p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">ll n, sum, res;</span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; p[i].x &gt;&gt; p[i].y;</span><br><span class="line">  sort(p + <span class="number">1</span>, p + n + <span class="number">1</span>, [](PI a, PI b) &#123; <span class="keyword">return</span> a.x * b.y &lt; b.x * a.y; &#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    res += sum * p[i].y;</span><br><span class="line">    sum += p[i].x * <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：货币系统 （背包dp）</title>
      <link href="2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%B4%A7%E5%B8%81%E7%B3%BB%E7%BB%9F-%EF%BC%88%E8%83%8C%E5%8C%85dp%EF%BC%89.html"/>
      <url>2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%B4%A7%E5%B8%81%E7%B3%BB%E7%BB%9F-%EF%BC%88%E8%83%8C%E5%8C%85dp%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>$n$ 种面额货币，数量无限，问最多保留几种，使得原来可以组成的仍然可以组成。（$t&lt;=20,n&lt;=100,a[i]&lt;=25000$）</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>由于大的只会被小的组成，所以先排序，对于存在性问题就显然是完全背包了，dp[i] 表示是否能表示出 $i$ 价值，得到状态转移方程：$dp[i]|=dp[i-a[i]]$，对于已经可以表示出来对 $a[i]$，已经可以由小的组成，因此不需要在枚举。<br><a id="more"></a> </p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, n, res, a[<span class="number">105</span>], dp[<span class="number">300005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">  <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    res = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!dp[a[i]]) &#123;</span><br><span class="line">        res++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = a[i]; j &lt;= a[n]; j++) dp[j] |= dp[j - a[i]];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 背包dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：建筑抢修 （贪心）</title>
      <link href="2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%BB%BA%E7%AD%91%E6%8A%A2%E4%BF%AE-%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%89.html"/>
      <url>2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%BB%BA%E7%AD%91%E6%8A%A2%E4%BF%AE-%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>$n$ 栋建筑，第 $i$ 栋建筑需要 $s_i$ 时间修，截止到 $t_i$ 时间，问最多可以修多少建筑。</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>我们可以类比成写作业，先截止的我们会先做，这是大体的贪心策略。但他并不是最优的，因为可能那一科会花你非常多的时间，够你做更多的科目，得不偿失。因此我们用优先队列维护做过的作业中花费时间最大的那份，当目前要做的作业时间不够的时候，与这个最大值比较看是否花的时间更少，可行的话就把这个塞进去，那个丢出来，这样做了同样多的作业却花了更少的时间，同时维护答案。<br><a id="more"></a> </p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, sum, res;</span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p[N];</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; p[i].y &gt;&gt; p[i].x;</span><br><span class="line">  sort(p, p + n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sum + p[i].y &lt;= p[i].x) &#123;</span><br><span class="line">      sum += p[i].y;</span><br><span class="line">      res++;</span><br><span class="line">      q.push(p[i].y);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p[i].y &lt; q.top()) &#123;</span><br><span class="line">      sum -= q.top();</span><br><span class="line">      q.pop();</span><br><span class="line">      q.push(p[i].y);</span><br><span class="line">      sum += p[i].y;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：中位数图</title>
      <link href="2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E4%B8%AD%E4%BD%8D%E6%95%B0%E5%9B%BE.html"/>
      <url>2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E4%B8%AD%E4%BD%8D%E6%95%B0%E5%9B%BE.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个 $1-n$ 排列，求长度为奇数子串以 $b$ 为中位数的子串个数。</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>由于求的是中位数，所以我们只需要关心这个数和 $b$ 的大小关系就好了，大于 $b$ 看作 1，小于 $b$ 看作 -1，等于 $b$ 看作 0，问题转化为求包含 0 且和为 0 的子串有多少个。<br><a id="more"></a> </p><p>从 $b$ 的位置开始遍历，map 统计右边累加的和，然后从左边累加的和中查找对应的相反数个数，累加即可。同时，如果遍历过程中任何一边已经存在和为 0 的情况，也为可行解。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="keyword">int</span> n, b, sum, pos, res, a[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; b;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">if</span> (a[i] &gt; b)</span><br><span class="line">      a[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a[i] &lt; b)</span><br><span class="line">      a[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a[i] == b) &#123;</span><br><span class="line">      a[i] = <span class="number">0</span>;</span><br><span class="line">      pos = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = pos + <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    sum += a[i];</span><br><span class="line">    mp[sum]++;</span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">0</span>) res++;</span><br><span class="line">  &#125;</span><br><span class="line">  sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = pos - <span class="number">1</span>; i; i--) &#123;</span><br><span class="line">    sum += a[i];</span><br><span class="line">    res += mp[-sum];</span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">0</span>) res++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res + <span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：简单瞎搞题 （STL）</title>
      <link href="2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%AE%80%E5%8D%95%E7%9E%8E%E6%90%9E%E9%A2%98-%EF%BC%88STL%EF%BC%89.html"/>
      <url>2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%AE%80%E5%8D%95%E7%9E%8E%E6%90%9E%E9%A2%98-%EF%BC%88STL%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>一共有 $n$ 个数，第 $i$ 个数是 $x_i$ 可以取 $[l_i , r_i]$ 中任意的一个值。设 $S = \sum{ {x_i}^2}$，求 $S$ 种类数。（0 ~ n,l,r ~ 100）</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>$dp[i][j]$ 表示前 $i$ 个数能不能组成 $j$，可以得到转移方程：$dp[i][j]=dp[i-1][j-x^2]$，最后统计 $dp[n]$ 层组成的 $j$ 的数量即可。因为 dp 的值只有 0 和 1 ，因此使用 bitset 优化，把第二维看成二进制位，这样就可以用位移的形式来表示加法运算，得到转移方程：dp[i]=dp[i-1] &lt;&lt; (j*j)，复杂度 $10^{10}/64$。<br><a id="more"></a> </p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">bitset</span>&lt;1000005&gt; dp[<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, l, r;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = l; j &lt;= r; j++) dp[i] |= dp[i - <span class="number">1</span>] &lt;&lt; (j * j);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>, dp[n].count());</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：图的遍历</title>
      <link href="2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86.html"/>
      <url>2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>无向图 $n$ 个点，每次必须跳两个，至少需要加多少条边可以遍历所有点。</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>首先，如果图不联通，那么需要加联通分量 - 1 条边使图联通，然后发现一点，只要这个图存在奇数环，就一定能全部走完，不存在的话，随便加一条边生成奇数环即可。<br><a id="more"></a> </p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, odd, x, y, res, vis[N], color[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> v : g[u]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">      vis[v] = <span class="number">1</span>;</span><br><span class="line">      color[v] = !color[u];</span><br><span class="line">      dfs(v);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (color[u] == color[v])</span><br><span class="line">      odd = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    g[x].push_back(y);</span><br><span class="line">    g[y].push_back(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">      res++;</span><br><span class="line">      vis[i] = color[i] = <span class="number">1</span>;</span><br><span class="line">      dfs(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res - odd &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：比赛</title>
      <link href="2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%AF%94%E8%B5%9B.html"/>
      <url>2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%AF%94%E8%B5%9B.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>一共12道题，你有 $a_i$ 的概率做对第 $i$ 题，有 $b_i$ 的概率抄到左边的，有 $c_i$ 的概率抄到右边的，问做对 $0-12$ 题的概率是多少。</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>做对的概率不太好求，可以反过来求做错的概率，即 $(1-a[i])\times(1-b[i])\times(1-c[i])$，然后 $dp[i][j]$ 表示前 $i$ 道题做对 $j$ 道的概率，设 $dp[0][0] =1$，得到状态转移方程：$dp[i][j]=dp[i-1][j-1]\times(ac=(1-wa))+dp[i-1][j]*wa$ 。<br><a id="more"></a> </p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">double a[<span class="number">15</span>], b[<span class="number">15</span>], c[<span class="number">15</span>], dp[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line">int main() &#123;</span><br><span class="line">  for (int i = <span class="number">1</span>; i &lt;= <span class="number">12</span>; i++) cin &gt;&gt; a[i];</span><br><span class="line">  for (int i = <span class="number">1</span>; i &lt;= <span class="number">12</span>; i++) cin &gt;&gt; b[i];</span><br><span class="line">  for (int i = <span class="number">1</span>; i &lt;= <span class="number">12</span>; i++) cin &gt;&gt; c[i];</span><br><span class="line">  dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  for (int i = <span class="number">1</span>; i &lt;= <span class="number">12</span>; i++) &#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] * (<span class="number">1</span> - a[i]) * (<span class="number">1</span> - b[i]) * (<span class="number">1</span> - c[i]);</span><br><span class="line">    for (int j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">      double wa = (<span class="number">1</span> - a[i]) * (<span class="number">1</span> - b[i]) * (<span class="number">1</span> - c[i]);</span><br><span class="line">      dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] * (<span class="number">1</span> - wa) + dp[i - <span class="number">1</span>][j] * wa;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i = <span class="number">0</span>; i &lt;= <span class="number">12</span>; i++) printf(<span class="string">&quot;%f\n&quot;</span>, dp[<span class="number">12</span>][i]);</span><br><span class="line">  return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：加分二叉树 （树形dp/区间dp）</title>
      <link href="2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%8A%A0%E5%88%86%E4%BA%8C%E5%8F%89%E6%A0%91-%EF%BC%88%E6%A0%91%E5%BD%A2dp-%E5%8C%BA%E9%97%B4dp%EF%BC%89.html"/>
      <url>2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%8A%A0%E5%88%86%E4%BA%8C%E5%8F%89%E6%A0%91-%EF%BC%88%E6%A0%91%E5%BD%A2dp-%E5%8C%BA%E9%97%B4dp%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有一颗二叉树，树的每一个节点都有一个值，设他的中序遍历为（l,2,3,…,n），其中数字1,2,3,…,n为节点编号。</p><p>任一棵子树subtree（也包含tree本身）的加分计算方法如下：<br><a id="more"></a> </p><p>subtree的左子树的加分× subtree的右子树的加分＋subtree的根的分数<br>若某个子树为主，规定其加分为1，叶子的加分就是叶节点本身的分数。不考虑它的空子树。 试求一棵符合中序遍历为（1,2,3,…,n）且加分最高的二叉树tree。</p><p>要求输出：（1）tree的最高加分（2）tree的前序遍历</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>符合条件的二叉树是加分最高的二叉树，它的总分依题意得 总分 = 左子树分数 * 右子树分数 + 根节点分数 ，想要总分最高，左右子树的分数应当也分别取最高。 </p><p>题目中给出的节点序号根据二叉树的中序遍历排列，$dp[l][r]$ （l&lt;r） 表示从节点 $l$ 到节点 $r$ 所构成的子树的最高加分。设$k(l \le k \le r)$为该子树的根节点，通过枚举当前 $[l,r]$ 某点为根来取得不同的左右子树和根节点分数，维护最大值。</p><p>状态转移方程：</p><p>$dp[i][j]=max(dp[i][j],dp[i][k-1]*dp[k+1][r]+dp[k][k])$</p><p>最后维护一个 $root$ 数组表示节点 $l-r$ 最高分子树的根即可。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int <span class="symbol">N</span> = <span class="number">35</span>;</span><br><span class="line"></span><br><span class="line">int n, root[<span class="symbol">N</span>][<span class="symbol">N</span>];</span><br><span class="line">ll dp[<span class="symbol">N</span>][<span class="symbol">N</span>];</span><br><span class="line"></span><br><span class="line">void dfs(int l, int r) &#123;</span><br><span class="line">  if (l &gt; r) return;</span><br><span class="line">  cout &lt;&lt; root[l][r] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  dfs(l, root[l][r] - <span class="number">1</span>);</span><br><span class="line">  dfs(root[l][r] + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  for (int i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    cin &gt;&gt; dp[i][i];</span><br><span class="line">    dp[i][i - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[i + <span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">    root[i][i] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    for (int l = <span class="number">1</span>; l + i &lt;= n; l++) &#123;</span><br><span class="line">      int r = l + i;</span><br><span class="line">      for (int k = l; k &lt;= r; k++) &#123;</span><br><span class="line">        int tmp = dp[l][k - <span class="number">1</span>] * dp[k + <span class="number">1</span>][r] + dp[k][k];</span><br><span class="line">        if (dp[l][r] &lt; tmp) &#123;</span><br><span class="line">          dp[l][r] = tmp;</span><br><span class="line">          root[l][r] = k;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; dp[<span class="number">1</span>][n] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  dfs(<span class="number">1</span>, n);</span><br><span class="line">  return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区间dp </tag>
            
            <tag> 树形dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：储物点的距离</title>
      <link href="2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%82%A8%E7%89%A9%E7%82%B9%E7%9A%84%E8%B7%9D%E7%A6%BB.html"/>
      <url>2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%82%A8%E7%89%A9%E7%82%B9%E7%9A%84%E8%B7%9D%E7%A6%BB.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定 $i$ 和 $i+1$两点的距离和 $i$ 点的货物数量，$m$ 次询问将 $[l,r]$ 所有物品搬到 $x$ 点的总费用（区间内每个物品各自离 $x$ 点距离和）。（$n,m &lt;= 200000 , 0 &lt;= ai,bi &lt;= 2000000000$）</p><h3 id="soltuion"><a href="#soltuion" class="headerlink" title="soltuion"></a>soltuion</h3><p>前缀和维护：$sum1$ 表示每个储物点离原点0的距离，$sum2$ 表示前 $i$ 个储物点共有多少货物，$sum3$ 表示前 $i$ 个储物点的所有物品到原点0的和。<br><a id="more"></a> </p><ul><li>$x&lt;=l$，即 $[l,r]$ 所有物品到原点的距离 - 到 $x$ 点的距离。</li><li>$x&gt;=r$，即 $[l,r]$ 所有物品从 $x$ 点到原点的距离 - 从原位置到原点的距离。</li><li>处于中间的情况，就是拆解成 $[l,x],[x+1,r]$ 两种情况，然后分别带入上面情况即可。</li></ul><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const ll <span class="keyword">mod</span> = <span class="number">1000000007</span>;</span><br><span class="line">const int N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">int n, m, l, r;</span><br><span class="line">ll <span class="symbol">x</span>, res, sum1[N], sum2[N], sum3[N];</span><br><span class="line">int main() &#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (int i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    cin &gt;&gt; <span class="symbol">x</span>;</span><br><span class="line">    sum1[i] = (sum1[i - <span class="number">1</span>] + <span class="symbol">x</span>) % <span class="keyword">mod</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    cin &gt;&gt; <span class="symbol">x</span>;</span><br><span class="line">    sum2[i] = (sum2[i - <span class="number">1</span>] + <span class="symbol">x</span>) % <span class="keyword">mod</span>;</span><br><span class="line">    sum3[i] = (sum3[i - <span class="number">1</span>] + sum1[i] * <span class="symbol">x</span>) % <span class="keyword">mod</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    cin &gt;&gt; <span class="symbol">x</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    <span class="keyword">if</span> (<span class="symbol">x</span> &lt;= l)</span><br><span class="line">      res = ((sum3[r] - sum3[l - <span class="number">1</span>] + <span class="keyword">mod</span>) % <span class="keyword">mod</span> -</span><br><span class="line">             (sum2[r] - sum2[l - <span class="number">1</span>] + <span class="keyword">mod</span>) % <span class="keyword">mod</span> * sum1[<span class="symbol">x</span>] % <span class="keyword">mod</span> + <span class="keyword">mod</span>) %</span><br><span class="line">            <span class="keyword">mod</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="symbol">x</span> &gt;= r)</span><br><span class="line">      res = ((sum1[<span class="symbol">x</span>] * ((sum2[r] - sum2[l - <span class="number">1</span>] + <span class="keyword">mod</span>) % <span class="keyword">mod</span>)) % <span class="keyword">mod</span> - sum3[r] +</span><br><span class="line">             sum3[l - <span class="number">1</span>] + <span class="keyword">mod</span>) %</span><br><span class="line">            <span class="keyword">mod</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      res = (((sum3[r] - sum3[<span class="symbol">x</span>] + <span class="keyword">mod</span>) % <span class="keyword">mod</span> -</span><br><span class="line">              (sum2[r] - sum2[<span class="symbol">x</span>] + <span class="keyword">mod</span>) % <span class="keyword">mod</span> * sum1[<span class="symbol">x</span>] + <span class="keyword">mod</span>) %</span><br><span class="line">                 <span class="keyword">mod</span> +</span><br><span class="line">             ((sum1[<span class="symbol">x</span>] * ((sum2[<span class="symbol">x</span>] - sum2[l - <span class="number">1</span>] + <span class="keyword">mod</span>) % <span class="keyword">mod</span>)) % <span class="keyword">mod</span> -</span><br><span class="line">              sum3[<span class="symbol">x</span>] + sum3[l - <span class="number">1</span>] + <span class="keyword">mod</span>) %</span><br><span class="line">                 <span class="keyword">mod</span>) %</span><br><span class="line">            <span class="keyword">mod</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (res + <span class="keyword">mod</span>) % <span class="keyword">mod</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：Moovie Mooving （状压dp）</title>
      <link href="2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AMoovie-Mooving-%EF%BC%88%E7%8A%B6%E5%8E%8Bdp%EF%BC%89.html"/>
      <url>2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AMoovie-Mooving-%EF%BC%88%E7%8A%B6%E5%8E%8Bdp%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有 N 部电影，每部电影有不同的放映时常，和若干个放映起始时间。<br>Bessie 可以在一部电影播放过程中的任何时间进入或退出放映厅。每部电影她最多看1次且她不能在看一部电影的过程中，换到另一个正在播放相同电影的放映厅。</p><p>Bessie 能不能从0到L分钟连续不断地观看电影？如果能，计算她最少看几部电影。</p><a id="more"></a> <p>$(1 \leq L \leq 100,000,000，1\leq N\leq 201≤L≤100,000,000，1≤N≤20)$</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>$n$ 只有20考虑状压dp，$dp[i]$ 表示完成 $i$ 集合需要的最长时间，假设 $i$ 集合最后看的一部电影为 $j$，那么 $dp[i]$ 由 dp[i ^ (2^j)] 转移过来，并二分选取小于转移前集合的电影 $j$ 的最晚放映时间来更新 $p[i]$，同时维护 $dp[i] &gt;=l $ 的最小集合为答案。时间复杂度 $O(2^n*log(1000))$</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">int</span> n, l, t[N], dp[<span class="number">1</span> &lt;&lt; N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; l;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> c, x;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t[i] &gt;&gt; c;</span><br><span class="line">    <span class="keyword">while</span> (c--) &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">      g[i].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    g[i].push_back(l);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> res = n + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((i &gt;&gt; j) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> now = i ^ (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">        <span class="keyword">int</span> pos =</span><br><span class="line">            upper_bound(g[j].<span class="built_in">begin</span>(), g[j].<span class="built_in">end</span>(), dp[now]) - g[j].<span class="built_in">begin</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (pos &gt;= <span class="number">0</span> &amp;&amp; g[j][pos] + t[j] &gt; dp[now])</span><br><span class="line">          dp[i] = <span class="built_in">max</span>(dp[i], g[j][pos] + t[j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dp[i] &gt;= l) res = <span class="built_in">min</span>(res, __builtin_popcount(i));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (res == n + <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状压dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：过河 离散化+dp</title>
      <link href="2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%BF%87%E6%B2%B3-%E7%A6%BB%E6%95%A3%E5%8C%96-dp.html"/>
      <url>2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%BF%87%E6%B2%B3-%E7%A6%BB%E6%95%A3%E5%8C%96-dp.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>桥长度为$L$ ，分布有$n$ 个石子，青蛙每次可以跳 $[S,T]$ 的距离,问青蛙过桥至少要踩多少个石子。</p><p>$(1&lt;=S,T&lt;=10,m&lt;=100,a_i&lt;=10^9, a_i 表示第i个石子的位置)$</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><a id="more"></a> <p>这是个很显然的dp题，难点在于他的 $a_i$ 达到了 $10^9$ ，所以我们需要压缩一下。</p><ol><li>当 $s==t$ 时，答案就是位置能被 $s$ 整除的石子个数。</li><li>当 $s!=t$ 时，我们可以发现：假设当前位置为 $x$ ，那么 $x+s*t$ 之后的所有位置是一定可以被走到的。（可以看做是 $s$ 个 $t$ 步相加或 $t$ 个 $s$ 步相加，然后调整某些步的长度即可。）</li></ol><p>然后，石子之间的距离就被压缩了，只要相邻的两个石子距离 $&gt;=s<em>t$ 的变成 $s</em>t$ 即可。</p><p>但是这样一压缩，最后的落点就不能确定了，但是起点是已知的，所以干脆倒过来dp。</p><p>状态转移方程：</p><ul><li>i 点有石子：$dp[i] = min(dp[i], dp[i+j]+1)$</li><li>i 点无石子：$dp[i] = min(dp[i], dp[i+j])$</li></ul><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const <span class="built_in">int</span> <span class="built_in">N</span> = <span class="number">2</span>e5 + <span class="number">5</span>;</span><br><span class="line"><span class="built_in">int</span> l, s, <span class="built_in">t</span>, <span class="built_in">n</span>, dis, res, a[<span class="built_in">N</span>], dp[<span class="built_in">N</span>], vis[<span class="built_in">N</span>];</span><br><span class="line"><span class="built_in">int</span> main() &#123;</span><br><span class="line">  cin &gt;&gt; l &gt;&gt; s &gt;&gt; <span class="built_in">t</span> &gt;&gt; <span class="built_in">n</span>;</span><br><span class="line">  for (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">n</span>; i++) cin &gt;&gt; a[i];</span><br><span class="line">  <span class="built_in">if</span> (s == <span class="built_in">t</span>) &#123;</span><br><span class="line">    for (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">n</span>; i++) &#123;</span><br><span class="line">      <span class="built_in">if</span> (a[i] % s == <span class="number">0</span>) res++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  sort(a + <span class="number">1</span>, a + <span class="built_in">n</span> + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">int</span> <span class="built_in">len</span> = s * <span class="built_in">t</span>;</span><br><span class="line">  for (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">n</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">int</span> d = a[i] - a[i - <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">if</span> (d &gt; <span class="built_in">len</span>) d = <span class="built_in">len</span>;</span><br><span class="line">    dis += d;</span><br><span class="line">    vis[dis] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  for (<span class="built_in">int</span> i = dis; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    dp[i] = <span class="number">100</span>;</span><br><span class="line">    for (<span class="built_in">int</span> j = s; j &lt;= <span class="built_in">t</span>; j++) &#123;</span><br><span class="line">      dp[i] = <span class="built_in">min</span>(dp[i], dp[i + j] + vis[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; dp[<span class="number">0</span>] &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">  return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：codeJan与旅行（贪心）</title>
      <link href="2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AcodeJan%E4%B8%8E%E6%97%85%E8%A1%8C%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%89.html"/>
      <url>2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AcodeJan%E4%B8%8E%E6%97%85%E8%A1%8C%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定n个城市坐标，每个城市可以多次到达，问一共到m次，最短花费。给出起始位置，并且起始位置不在城市上。</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>不难猜到要么就是一条路走到黑要么就是在路上找的两个城市然后一直往返。因此我们从原来的位置，往左右两边一直走下去，顺便枚举路上每两座城市之间横跳的花费，维护最小花费，同时注意边界情况。<br><a id="more"></a> </p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line">LL ans, a[N];</span><br><span class="line"><span class="keyword">int</span> _, n, m, p;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> res)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; m - (i - k) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      LL tmp = res + (a[i] - a[k]) + (a[i] - a[i - <span class="number">1</span>]) * (m - (i - k));</span><br><span class="line">      ans = <span class="built_in">min</span>(ans, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = k - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; n &amp;&amp; m - (k - i) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      LL tmp = res + (a[k] - a[i]) + (a[i + <span class="number">1</span>] - a[i]) * (m - (k - i));</span><br><span class="line">      ans = <span class="built_in">min</span>(ans, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;_); _; _--) &#123;</span><br><span class="line">    ans = <span class="number">1e18</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;p);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">    m--;</span><br><span class="line">    <span class="keyword">int</span> k = upper_bound(a + <span class="number">1</span>, a + <span class="number">1</span> + n, p) - a;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= n) solve(k, a[k] - p);</span><br><span class="line">    <span class="keyword">if</span> (k &gt; <span class="number">1</span>) solve(k - <span class="number">1</span>, p - a[k - <span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拷贝构造，拷贝复制，析构</title>
      <link href="2020/05/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%EF%BC%8C%E6%8B%B7%E8%B4%9D%E5%A4%8D%E5%88%B6%EF%BC%8C%E6%9E%90%E6%9E%84.html"/>
      <url>2020/05/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%EF%BC%8C%E6%8B%B7%E8%B4%9D%E5%A4%8D%E5%88%B6%EF%BC%8C%E6%9E%90%E6%9E%84.html</url>
      
        <content type="html"><![CDATA[<h3 id="Big-Three（拷贝构造，拷贝复制，析构）"><a href="#Big-Three（拷贝构造，拷贝复制，析构）" class="headerlink" title="Big Three（拷贝构造，拷贝复制，析构）"></a>Big Three（拷贝构造，拷贝复制，析构）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    String (<span class="keyword">const</span> <span class="keyword">char</span>* cstr = <span class="number">0</span>);    <span class="comment">// 构造函数，默认初值为0</span></span><br><span class="line">    String (<span class="keyword">const</span> String&amp; str);       <span class="comment">// 接受的值为类本身，因此为拷贝构造函数</span></span><br><span class="line">    String&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> String&amp; str);  <span class="comment">// = 号重载，拷贝赋值函数</span></span><br><span class="line">    ~String();        <span class="comment">// 析构函数，类死亡时自动调用</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span>* <span class="title">get_c_str</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_data; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* m_data; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">s1</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">String <span class="title">s2</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">String <span class="title">s3</span><span class="params">(s1)</span></span>;      <span class="comment">// 拷贝构造，类还未存在</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; s3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  s3 = s2;            <span class="comment">// 拷贝赋值，类已经存在</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; s3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span></span><br><span class="line">String::String(<span class="keyword">const</span> <span class="keyword">char</span>* cstr = <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (cstr) &#123;               <span class="comment">// 指定初值</span></span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(cstr) + <span class="number">1</span>];    <span class="comment">// 分配传进来的长度+ &#x27;\0&#x27; 的空间</span></span><br><span class="line">    <span class="built_in">strcpy</span>(m_data, cstr);   <span class="comment">// 复制  </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;                    <span class="comment">// 未指定初值</span></span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">    *m_data = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line">String::~String()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">delete</span>[] m_data;      <span class="comment">// 将原来分配的内存释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="function">String <span class="title">p1</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;                   <span class="comment">//栈中分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> String p2 = String(<span class="string">&quot;hello&quot;</span>);　　　　　　　<span class="comment">//栈中分配内存，跟方法1相同，是方法1的完整模式</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> String *p3 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);　　　 <span class="comment">//堆中分配内存</span></span><br></pre></td></tr></table></figure><p><strong><br>方法1、2中都是在栈中分配内存，在栈中内存由系统自动的去分配和释放，释放的顺序也和栈一样，后定义的先释放。</strong></p><p><strong><br>而使用new创建的指针对象是在堆中分配内存，当不需要该对象时，需要我们手动的去释放，否则会造成内存泄漏。</strong></p><h3 id="深拷贝，浅拷贝"><a href="#深拷贝，浅拷贝" class="headerlink" title="深拷贝，浅拷贝"></a>深拷贝，浅拷贝</h3><p>如果类中有指针成员，则必须写拷贝构造和拷贝赋值函数。</p><p>假设 指针a -&gt; “hello”, 指针b -&gt; “world”，当执行 b = a 时，则变成 b 指向 a，造成 “world” 无人指向，发生了内存泄漏，而”hello” 被 a 和 b 同时指向的情况，那么将来一旦改变 a ，b 也会发生改变。那么，这种拷贝称之为 <strong>“浅拷贝”</strong>。</p><p><strong>深拷贝</strong>即为我们自己写的拷贝函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span></span><br><span class="line">String::String(<span class="keyword">const</span> String&amp; str)    <span class="comment">// 拷贝构造</span></span><br><span class="line">&#123;</span><br><span class="line">  m_data = <span class="keyword">new</span> <span class="keyword">char</span>[ <span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span> ];</span><br><span class="line">  <span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line">String&amp; String::<span class="keyword">operator</span>=(<span class="keyword">const</span> String&amp; str)  <span class="comment">// 拷贝赋值</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;str)    <span class="comment">// 有可能是自己赋值给自己（比如引用），如果不写这句，那么delete就是它自己，下面全错</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span>[] m_data;    <span class="comment">// 先将自己删除</span></span><br><span class="line">  m_data = <span class="keyword">new</span> <span class="keyword">char</span>[ <span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span> ];  <span class="comment">// 重新创建和右边一样大的空间</span></span><br><span class="line">  <span class="built_in">strcpy</span>(m_data, str.m_data);     <span class="comment">// 重新赋值</span></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杜教BM模板</title>
      <link href="2020/05/%E6%9D%9C%E6%95%99BM%E6%A8%A1%E6%9D%BF.html"/>
      <url>2020/05/%E6%9D%9C%E6%95%99BM%E6%A8%A1%E6%9D%BF.html</url>
      
        <content type="html"><![CDATA[<p><strong>用于求线性递推式第n项，扔进前k+x项即可</strong></p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstring&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cmath&gt;</span></span><br><span class="line"><span class="comment">#include &lt;algorithm&gt;</span></span><br><span class="line"><span class="comment">#include &lt;vector&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string&gt;</span></span><br><span class="line"><span class="comment">#include &lt;map&gt;</span></span><br><span class="line"><span class="comment">#include &lt;set&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cassert&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long <span class="keyword">ll;</span></span><br><span class="line"><span class="keyword">#define </span>rep(i, a, n) for (int i = a<span class="comment">; i &lt; n; i++)</span></span><br><span class="line"><span class="comment">#define per(i, a, n) for (int i = n - 1; i &gt;= a; i--)</span></span><br><span class="line"><span class="comment">#define pb push_back</span></span><br><span class="line"><span class="comment">#define mp make_pair</span></span><br><span class="line"><span class="comment">#define all(x) (x).begin(), (x).end()</span></span><br><span class="line"><span class="comment">#define fi first</span></span><br><span class="line"><span class="comment">#define se second</span></span><br><span class="line"><span class="comment">#define SZ(x) ((int)(x).size())</span></span><br><span class="line">typedef vector&lt;<span class="keyword">ll&gt; </span>VI;</span><br><span class="line">typedef pair&lt;<span class="keyword">ll, </span><span class="keyword">ll&gt; </span>PII;</span><br><span class="line">const <span class="keyword">ll </span>mod = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">ll </span>powmod(<span class="keyword">ll </span>a, <span class="keyword">ll </span><span class="keyword">b) </span>&#123;</span><br><span class="line">  <span class="keyword">ll </span>res = <span class="number">1</span>;</span><br><span class="line">  a %= mod;</span><br><span class="line">  assert(<span class="keyword">b </span>&gt;= <span class="number">0</span>);</span><br><span class="line">  for (<span class="comment">; b; b &gt;&gt;= 1) &#123;</span></span><br><span class="line">    if (<span class="keyword">b </span>&amp; <span class="number">1</span>) res = res * a % mod;</span><br><span class="line">    a = a * a % mod;</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">ll </span>_, n;</span><br><span class="line">namespace linear_seq &#123;</span><br><span class="line">const <span class="keyword">ll </span>N = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">ll </span>res[N], <span class="keyword">base[N], </span>_c[N], _md[N];</span><br><span class="line">vector&lt;<span class="keyword">ll&gt; </span>Md;</span><br><span class="line">void <span class="keyword">mul(ll </span>*a, <span class="keyword">ll </span>*<span class="keyword">b, </span>int k) &#123;</span><br><span class="line">  rep(i, <span class="number">0</span>, k + k) _c[i] = <span class="number">0</span>;</span><br><span class="line">  rep(i, <span class="number">0</span>, k) if (a[i]) rep(<span class="keyword">j, </span><span class="number">0</span>, k) _c[i + <span class="keyword">j] </span>=</span><br><span class="line">      (_c[i + <span class="keyword">j] </span>+ a[i] * <span class="keyword">b[j]) </span>% mod;</span><br><span class="line">  for (<span class="keyword">ll </span>i = k + k - <span class="number">1</span><span class="comment">; i &gt;= k; i--)</span></span><br><span class="line">    if (_c[i])</span><br><span class="line">      rep(<span class="keyword">j, </span><span class="number">0</span>, SZ(Md)) _c[i - k + Md[<span class="keyword">j]] </span>=</span><br><span class="line">          (_c[i - k + Md[<span class="keyword">j]] </span>- _c[i] * _md[Md[<span class="keyword">j]]) </span>% mod;</span><br><span class="line">  rep(i, <span class="number">0</span>, k) a[i] = _c[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">ll </span>solve(<span class="keyword">ll </span>n, VI a, VI <span class="keyword">b) </span>&#123;</span><br><span class="line">  <span class="keyword">ll </span>ans = <span class="number">0</span>, pnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">ll </span>k = SZ(a);</span><br><span class="line">  assert(SZ(a) == SZ(<span class="keyword">b));</span></span><br><span class="line"><span class="keyword"> </span> rep(i, <span class="number">0</span>, k) _md[k - <span class="number">1</span> - i] = -a[i];</span><br><span class="line">  _md[k] = <span class="number">1</span>;</span><br><span class="line">  Md.clear();</span><br><span class="line">  rep(i, <span class="number">0</span>, k) if (_md[i] != <span class="number">0</span>) Md.push_back(i);</span><br><span class="line">  rep(i, <span class="number">0</span>, k) res[i] = <span class="keyword">base[i] </span>= <span class="number">0</span>;</span><br><span class="line">  res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  while ((<span class="number">1</span>ll &lt;&lt; pnt) &lt;= n) pnt++;</span><br><span class="line">  for (<span class="keyword">ll </span>p = pnt<span class="comment">; p &gt;= 0; p--) &#123;</span></span><br><span class="line">    <span class="keyword">mul(res, </span>res, k);</span><br><span class="line">    if ((n &gt;&gt; p) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">      for (<span class="keyword">ll </span>i = k - <span class="number">1</span><span class="comment">; i &gt;= 0; i--) res[i + 1] = res[i];</span></span><br><span class="line">      res[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">      rep(<span class="keyword">j, </span><span class="number">0</span>, SZ(Md)) res[Md[<span class="keyword">j]] </span>= (res[Md[<span class="keyword">j]] </span>- res[k] * _md[Md[<span class="keyword">j]]) </span>% mod;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  rep(i, <span class="number">0</span>, k) ans = (ans + res[i] * <span class="keyword">b[i]) </span>% mod;</span><br><span class="line">  if (ans &lt; <span class="number">0</span>) ans += mod;</span><br><span class="line">  return ans;</span><br><span class="line">&#125;</span><br><span class="line">VI <span class="keyword">BM(VI </span>s) &#123;</span><br><span class="line">  VI C(<span class="number">1</span>, <span class="number">1</span>), <span class="keyword">B(1, </span><span class="number">1</span>);</span><br><span class="line">  <span class="keyword">ll </span>L = <span class="number">0</span>, m = <span class="number">1</span>, <span class="keyword">b </span>= <span class="number">1</span>;</span><br><span class="line">  rep(n, <span class="number">0</span>, SZ(s)) &#123;</span><br><span class="line">    <span class="keyword">ll </span>d = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">0</span>, L + <span class="number">1</span>) d = (d + (<span class="keyword">ll)C[i] </span>* s[n - i]) % mod;</span><br><span class="line">    if (d == <span class="number">0</span>)</span><br><span class="line">      ++m;</span><br><span class="line">    else if (<span class="number">2</span> * L &lt;= n) &#123;</span><br><span class="line">      VI T = C;</span><br><span class="line">      <span class="keyword">ll </span>c = mod - d * powmod(<span class="keyword">b, </span>mod - <span class="number">2</span>) % mod;</span><br><span class="line">      while (SZ(C) &lt; SZ(<span class="keyword">B) </span>+ m) C.pb(<span class="number">0</span>);</span><br><span class="line">      rep(i, <span class="number">0</span>, SZ(<span class="keyword">B)) </span>C[i + m] = (C[i + m] + c * <span class="keyword">B[i]) </span>% mod;</span><br><span class="line">      L = n + <span class="number">1</span> - L;</span><br><span class="line">      <span class="keyword">B </span>= T;</span><br><span class="line">      <span class="keyword">b </span>= d;</span><br><span class="line">      m = <span class="number">1</span>;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      <span class="keyword">ll </span>c = mod - d * powmod(<span class="keyword">b, </span>mod - <span class="number">2</span>) % mod;</span><br><span class="line">      while (SZ(C) &lt; SZ(<span class="keyword">B) </span>+ m) C.pb(<span class="number">0</span>);</span><br><span class="line">      rep(i, <span class="number">0</span>, SZ(<span class="keyword">B)) </span>C[i + m] = (C[i + m] + c * <span class="keyword">B[i]) </span>% mod;</span><br><span class="line">      ++m;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">ll </span>gao(VI a, <span class="keyword">ll </span>n) &#123;</span><br><span class="line">  VI c = <span class="keyword">BM(a);</span></span><br><span class="line"><span class="keyword"> </span> c.erase(c.<span class="keyword">begin());</span></span><br><span class="line"><span class="keyword"> </span> rep(i, <span class="number">0</span>, SZ(c)) c[i] = (mod - c[i]) % mod;</span><br><span class="line">  return solve(n, c, VI(a.<span class="keyword">begin(), </span>a.<span class="keyword">begin() </span>+ SZ(c)));</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">;  // namespace linear_seq</span></span><br><span class="line">int main() &#123;</span><br><span class="line">  while (~<span class="keyword">scanf(&quot;%lld&quot;, </span>&amp;n) &amp;&amp; n != -<span class="number">1</span>) &#123;</span><br><span class="line">    vector&lt;<span class="keyword">ll&gt;v;</span></span><br><span class="line"><span class="keyword"> </span>      v.push_back(<span class="number">0</span>);</span><br><span class="line">       v.push_back(<span class="number">1</span>);</span><br><span class="line">        v.push_back(<span class="number">1</span>);</span><br><span class="line">        v.push_back(<span class="number">2</span>);</span><br><span class="line">        v.push_back(<span class="number">3</span>);</span><br><span class="line">        v.push_back(<span class="number">5</span>);</span><br><span class="line">        v.push_back(<span class="number">8</span>);</span><br><span class="line">        v.push_back(<span class="number">13</span>);</span><br><span class="line">        v.push_back(<span class="number">21</span>);</span><br><span class="line">        v.push_back(<span class="number">34</span>);</span><br><span class="line">      printf(<span class="string">&quot;%lld\n&quot;</span>, linear_seq::gao(v, n));</span><br><span class="line">  &#125;</span><br><span class="line">  return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：皇家烈焰（线性dp）</title>
      <link href="2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%9A%87%E5%AE%B6%E7%83%88%E7%84%B0%EF%BC%88%E7%BA%BF%E6%80%A7dp%EF%BC%89.html"/>
      <url>2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%9A%87%E5%AE%B6%E7%83%88%E7%84%B0%EF%BC%88%E7%BA%BF%E6%80%A7dp%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>现在帕秋莉告诉你一部分烈焰的分布情况，请你告诉她可能的情况有多少种</p><p>对于一个格子，里面会有以下几种字符：</p><p>0：这个格子没有烈焰，且其左右两个格子均没有烈焰</p><a id="more"></a> <p>1：这个格子没有烈焰，且其左右两个格子中只有一个烈焰</p><p>2：这个格子没有烈焰，且其左右两个格子中均有烈焰</p><p>$*$：这个格子有烈焰</p><p>?：未告诉你本格情况</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>$f[i][0/1][0/1]$表示前i位，当前位和下一位是（1）不是（0）烈焰的方案数</p><p>转移方程分情况讨论：</p><p>当$s[i]=’*’$时：</p><p>$f[i][1][0]=(f[i-1][0][1]+f[i-1][1][1])$</p><p>$f[i][1][1]=(f[i-1][0][1]+f[i-1][1][1])$</p><p>当$s[i]=’0’$时，上一位、当前位和下一位都得是0：</p><p>$f[i][0][0]=f[i-1][0][0]$</p><p>当s[i]=’1’时，上一位或下一位有一个是1：</p><p>$f[i][0][1]=f[i-1][0][0]$</p><p>$f[i][0][0]=f[i-1][1][0]$</p><p>当s[i]=’2’时，上一位和下一位都是1当前位是0：</p><p>$f[i][0][1]=f[i-1][1][0]$</p><p>当s[i]=’?’时：</p><p>$f[i][1][0]=(f[i-1][0][1]+f[i-1][1][1])$</p><p>$f[i][1][1]=(f[i-1][0][1]+f[i-1][1][1])$</p><p>$f[i][0][0]=(f[i-1][0][0]+f[i-1][1][0])$</p><p>$f[i][0][1]=(f[i-1][0][0]+f[i-1][1][0])$</p><p>初值$f[0][0][0] =1,f[0][0][1] = 1$</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int <span class="symbol">N</span> = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line">const int mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">int dp[<span class="symbol">N</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">char s[<span class="symbol">N</span>];</span><br><span class="line">int main() &#123;</span><br><span class="line">  cin &gt;&gt; s + <span class="number">1</span>;</span><br><span class="line">  dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  int len = strlen(s + <span class="number">1</span>);</span><br><span class="line">  for (int i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">    if (s[i] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">      dp[i][<span class="number">0</span>][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    else if (s[i] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">      dp[i][<span class="number">0</span>][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">      dp[i][<span class="number">0</span>][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125; else if (s[i] == <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">      dp[i][<span class="number">0</span>][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    else if (s[i] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">      dp[i][<span class="number">1</span>][<span class="number">0</span>] = (dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] + dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>]) <span class="comment">% mod;</span></span><br><span class="line">      dp[i][<span class="number">1</span>][<span class="number">1</span>] = dp[i][<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      dp[i][<span class="number">0</span>][<span class="number">0</span>] = (dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>] + dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]) <span class="comment">% mod;</span></span><br><span class="line">      dp[i][<span class="number">0</span>][<span class="number">1</span>] = dp[i][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">      dp[i][<span class="number">1</span>][<span class="number">0</span>] = (dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>] + dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]) <span class="comment">% mod;</span></span><br><span class="line">      dp[i][<span class="number">1</span>][<span class="number">1</span>] = dp[i][<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; (dp[len][<span class="number">1</span>][<span class="number">0</span>] + dp[len][<span class="number">0</span>][<span class="number">0</span>]) <span class="comment">% mod &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">  return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：Two Graphs（暴力）</title>
      <link href="2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9ATwo-Graphs%EF%BC%88%E6%9A%B4%E5%8A%9B%EF%BC%89.html"/>
      <url>2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9ATwo-Graphs%EF%BC%88%E6%9A%B4%E5%8A%9B%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给一个小图和一个大图，问大图有多少个子图形状和小图一样。</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>最多只有8个点，因为每个点标号可能不一样，因此可以全排列枚举所有点的位置，然后判断小图有的边大图是否也有（因为原来边的属性还在），并通过hash进行去重。</p><a id="more"></a> <h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m1, m2, res, pre[<span class="number">10</span>], mp1[<span class="number">10</span>][<span class="number">10</span>], mp2[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">int</span>&gt; p;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m1, &amp;m2)) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(mp1, <span class="number">0</span>, <span class="keyword">sizeof</span>(mp1));</span><br><span class="line">    <span class="built_in">memset</span>(mp2, <span class="number">0</span>, <span class="keyword">sizeof</span>(mp2));</span><br><span class="line">    p.<span class="built_in">clear</span>();</span><br><span class="line">    res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m1; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> x, y;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">      mp1[x][y] = mp1[y][x] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m2; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> x, y;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">      mp2[x][y] = mp2[y][x] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) pre[i] = i;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">long</span> <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n &amp;&amp; flag; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n &amp;&amp; flag; j++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (mp1[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mp2[pre[i]][pre[j]]) flag = <span class="number">0</span>;</span><br><span class="line">            now |= <span class="number">1L</span>L &lt;&lt; (mp2[pre[i]][pre[j]]);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (flag &amp;&amp; p[now] == <span class="number">0</span>) &#123;</span><br><span class="line">        res++;</span><br><span class="line">        p[now] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (next_permutation(pre + <span class="number">1</span>, pre + n + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：Different Integers（树状数组/莫队）</title>
      <link href="2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9ADifferent-Integers%EF%BC%88%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-%E8%8E%AB%E9%98%9F%EF%BC%89.html"/>
      <url>2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9ADifferent-Integers%EF%BC%88%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-%E8%8E%AB%E9%98%9F%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定长度为 $n$ 的数组，$q$ 次询问 $[1,l]+[r,n]$ 组成的新数组中不相同的元素个数。$(1&lt;=n,q&lt;=1e5)$</p><h3 id="solution1"><a href="#solution1" class="headerlink" title="solution1"></a>solution1</h3><p>一眼莫队题，主要是要想怎么样把它变成一个连续的区间。其实只要把整个数组再复制一遍接上就可以了，则原来查询的 $r$ 变为 $l$，$l$ 变为 $l+n$，区间连续。<br><a id="more"></a> </p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1812 ms</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> l, r, id;</span><br><span class="line">&#125; node[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q, blocks, a[N], b[N], ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a.l / blocks == b.l / blocks) <span class="keyword">return</span> a.r &lt; b.r;</span><br><span class="line">  <span class="keyword">return</span> a.l &lt; b.l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">      a[i + n] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="keyword">sizeof</span>(b));</span><br><span class="line">    blocks = <span class="built_in">sqrt</span>(<span class="number">2</span> * n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;node[i].r, &amp;node[i].l);</span><br><span class="line">      node[i].r += n;</span><br><span class="line">      node[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(node + <span class="number">1</span>, node + q + <span class="number">1</span>, cmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>, num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">      <span class="keyword">while</span> (l &lt; node[i].l) num -= !--b[a[l++]];</span><br><span class="line">      <span class="keyword">while</span> (l &gt; node[i].l) num += !b[a[--l]]++;</span><br><span class="line">      <span class="keyword">while</span> (r &lt; node[i].r) num += !b[a[++r]]++;</span><br><span class="line">      <span class="keyword">while</span> (r &gt; node[i].r) num -= !--b[a[r--]];</span><br><span class="line">      ans[node[i].id] = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution2"><a href="#solution2" class="headerlink" title="solution2"></a>solution2</h3><p>同样是复制一遍，然后考虑树状数组+离线处理。我们需要保证之前的更新不会对当前的查询构成干扰，可以对查询按照右端点从小到大排序，然后把当前的数更新到当前位置，删除之前的位置，这样保证数是跟排序后的查询一样是从左往右流动的。</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 702 ms</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q, a[N], b[N], c[N], ans[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> l, r, id;</span><br><span class="line">&#125; node[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node x, Node y)</span> </span>&#123; <span class="keyword">return</span> x.r &lt; y.r; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (; x &lt;= n; x += x &amp; (-x)) c[x] += y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (; x &gt;= <span class="number">1</span>; x -= x &amp; (-x)) sum += c[x];</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">      a[i + n] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="keyword">sizeof</span>(b));</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;node[i].r, &amp;node[i].l);</span><br><span class="line">      node[i].r += n;</span><br><span class="line">      node[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(node + <span class="number">1</span>, node + q + <span class="number">1</span>, cmp);</span><br><span class="line">    n &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> pre = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = pre; j &lt;= node[i].r; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b[a[j]]) update(b[a[j]], <span class="number">-1</span>);</span><br><span class="line">        b[a[j]] = j;</span><br><span class="line">        update(b[a[j]], <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      pre = node[i].r + <span class="number">1</span>;</span><br><span class="line">      ans[node[i].id] = query(node[i].r) - query(node[i].l - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：合并回文子串（区间DP）</title>
      <link href="2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%90%88%E5%B9%B6%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%EF%BC%88DP%EF%BC%89.html"/>
      <url>2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%90%88%E5%B9%B6%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%EF%BC%88DP%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定两个字符串，各取出一个子串接在一起，求最长回文子串的长度。</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>先考虑普通的求最长回文子串的dp做法:<br><a id="more"></a> </p><p>$dp[i][j] = 0/1 $ 表示子串 $i~j$ 是否为回文串。</p><p>那么，容易得到：$dp[i][j] = (dp[i+1][j-1]$ &amp;&amp; $s[i]==s[j])$。</p><p>由于 $i$ 是由 $i+1$ 转移过来的，所以我们需要倒着遍历：</p><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (int i = s.size() - <span class="number">1</span><span class="comment">; i &gt;= 0; i--)</span></span><br><span class="line">  for (int <span class="keyword">j </span>= i<span class="comment">; j &lt; s.size(); j++) &#123;</span></span><br><span class="line">    if (s[i] == s[<span class="keyword">j] </span>&amp;&amp; (<span class="keyword">j </span>- i &lt; <span class="number">2</span> <span class="title">||</span> dp[i + <span class="number">1</span>][<span class="keyword">j </span>- <span class="number">1</span>])) &#123;</span><br><span class="line">      dp[i][<span class="keyword">j] </span>= true;</span><br><span class="line">      res = max(res, <span class="keyword">j </span>- i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>那么这题其实可以类比：</p><p>$dp[i][j][k][l]$ 表示a串第i个字符到第j个字符和b串第k个字符到第l个字符是否组成回文串：</p><p>往 $a[i+1]$ 到 $a[j−1]$ 和 $b[k]$ 到 $b[l]$ 构成的串的两端加上 $a[i]$ 和 $a[j]$ 两个字符：</p><p>$dp[i][j][k][l] = dp[i+1][j-1][k][l] and (a[i]==a[j])$</p><p>往 $a[i+1]$ 到 $a[j]$ 和 $b[k]$ 到 $b[l-1]$ 构成的串的两端加上 $a[i]$ 和 $b[l]$ 两个字符：</p><p>$dp[i][j][k][l] = dp[i+1][j][k][l-1] and (a[i]==b[l])$</p><p>往 $a[i]$ 到 $a[j-1]$ 和 $b[k+1]$ 到 $b[l]$ 构成的串的两端加上 $b[k]$ 和 $a[j]$ 两个字符：</p><p>$dp[i][j][k][l] = dp[i][j-1][k+1][l] and (b[k]==a[j])$</p><p>往 $a[i]$ 到 $a[j]$ 和 $b[k+1]$ 到 $b[l-1]$ 构成的串的两端加上 $b[k]$ 和 $b[l]$ 两个字符：</p><p>$dp[i][j][k][l] = dp[i][j][k+1][l-1] and (b[k]==b[l])$</p><p><strong>实际上就是取法由原来的一种变为了四种，注意若组成的字符串长度小于2时需要直接赋值为1</strong></p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int <span class="symbol">N</span> = <span class="number">105</span>;</span><br><span class="line">char a[<span class="symbol">N</span>], b[<span class="symbol">N</span>];</span><br><span class="line">bool f[<span class="symbol">N</span>][<span class="symbol">N</span>][<span class="symbol">N</span>][<span class="symbol">N</span>];</span><br><span class="line">int t, n, m;</span><br><span class="line">int main() &#123;</span><br><span class="line">  scanf(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">  while (t--) &#123;</span><br><span class="line">    int res = <span class="number">0</span>;</span><br><span class="line">    scanf(<span class="string">&quot;%s&quot;</span>, a + <span class="number">1</span>);</span><br><span class="line">    scanf(<span class="string">&quot;%s&quot;</span>, b + <span class="number">1</span>);</span><br><span class="line">    n = strlen(a + <span class="number">1</span>);</span><br><span class="line">    m = strlen(b + <span class="number">1</span>);</span><br><span class="line">    for (int len1 = <span class="number">0</span>; len1 &lt;= n; len1++)    //枚举a串的长度</span><br><span class="line">      for (int len2 = <span class="number">0</span>; len2 &lt;= m; len2++)  //枚举b串的长度</span><br><span class="line">        for (int i = <span class="number">1</span>; i + len1 - <span class="number">1</span> &lt;= n; i++)</span><br><span class="line">          for (int k = <span class="number">1</span>; k + len2 - <span class="number">1</span> &lt;= m; k++) &#123;</span><br><span class="line">            int j = i + len1 - <span class="number">1</span>,</span><br><span class="line">                l = k + len2 - <span class="number">1</span>;  //根据左端点和长度计算右端点</span><br><span class="line">            if (len1 + len2 &lt;= <span class="number">1</span>)</span><br><span class="line">              f[i][j][k][l] = <span class="number">1</span>;</span><br><span class="line">            else &#123;</span><br><span class="line">              f[i][j][k][l] = <span class="number">0</span>;</span><br><span class="line">              if (len1 &gt; <span class="number">1</span>)</span><br><span class="line">                f[i][j][k][l] |= (f[i + <span class="number">1</span>][j - <span class="number">1</span>][k][l] &amp;&amp; (a[i] == a[j]));</span><br><span class="line">              if (len1 &amp;&amp; len2)</span><br><span class="line">                f[i][j][k][l] |= (f[i + <span class="number">1</span>][j][k][l - <span class="number">1</span>] &amp;&amp; (a[i] == b[l]));</span><br><span class="line">              if (len1 &amp;&amp; len2)</span><br><span class="line">                f[i][j][k][l] |= (f[i][j - <span class="number">1</span>][k + <span class="number">1</span>][l] &amp;&amp; (a[j] == b[k]));</span><br><span class="line">              if (len2 &gt; <span class="number">1</span>)</span><br><span class="line">                f[i][j][k][l] |= (f[i][j][k + <span class="number">1</span>][l - <span class="number">1</span>] &amp;&amp; (b[k] == b[l]));</span><br><span class="line">            &#125;</span><br><span class="line">            if (f[i][j][k][l]) res = max(res, len1 + len2);</span><br><span class="line">          &#125;</span><br><span class="line">    printf(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">  &#125;</span><br><span class="line">  return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区间dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>课程安排（状压dp）</title>
      <link href="2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%AF%BE%E7%A8%8B%E5%AE%89%E6%8E%92%EF%BC%88%E7%8A%B6%E5%8E%8Bdp%EF%BC%89.html"/>
      <url>2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%AF%BE%E7%A8%8B%E5%AE%89%E6%8E%92%EF%BC%88%E7%8A%B6%E5%8E%8Bdp%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<p>题意：让你安排课程，保证每学期的课不能冲突，问最少需要几个学期。</p><p>solution：</p><p>因为 n 只有15，可以考虑状压dp。用二进制每位的1/0表示当前是否学习该课程，可以得到 n 个二进制位，那么所有的可能性有 1&lt;&lt;n 种，预处理 g[s] 表示 s 所代表课程的是否可以在一个学期内学完（对于当前要学的所有课程的学时进行标记，若有重复标记则不可能在一学期学完），f[s] 维护学完当前课程所花费的最少学期，枚举子集进行转移。<br>答案的状态应该是所有课全部修完，即 $f[(1&lt;&lt;n)-1]$。时间复杂度 $O(2^n <em> m </em> n)$。</p><a id="more"></a> <h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1</span> &lt;&lt; <span class="number">15</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, sum, f[N], g[N], b[<span class="number">20</span>], a[<span class="number">20</span>][<span class="number">105</span>], vis[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;&gt; i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= b[i]; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[a[i][j]]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        vis[a[i][j]] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= b[i]; j++) <span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f));    <span class="comment">// 因为要维护最小值，因此初值赋为最大值</span></span><br><span class="line">  f[<span class="number">0</span>] = <span class="number">0</span>;                  <span class="comment">//  学完 0 门课需要 0 个学期</span></span><br><span class="line">  sum = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;        <span class="comment">//  每门课代表一个二进制位，枚举所有可能共有 1&lt;&lt;n 种</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt;= sum; ++s) &#123;       </span><br><span class="line">    g[s] = check(s);         <span class="comment">// 验证 s 是否能在一个学期内学完</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = s; t; t = (t - <span class="number">1</span>) &amp; s)         <span class="comment">// 从之前的状态（子集）进行转移</span></span><br><span class="line">      <span class="keyword">if</span> (g[t]) f[s] = <span class="built_in">min</span>(f[s], f[s ^ t] + <span class="number">1</span>);      <span class="comment">// 可以在一个学期学完，则维护最小值</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; f[sum] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状压dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11新特性</title>
      <link href="2020/05/C++11%E6%96%B0%E7%89%B9%E6%80%A7.html"/>
      <url>2020/05/C++11%E6%96%B0%E7%89%B9%E6%80%A7.html</url>
      
        <content type="html"><![CDATA[<h2 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h2><p><strong>nullptr</strong> 出现的目的是为了替代 NULL。传统 C++ 会把 <strong>NULL, 0</strong> 视为同一种东西，有些编译器会将 NULL 定义为 <strong>((void*)0)</strong>，有些则会直接将其定义为 0。C++ 不允许直接将 void <em> 隐式转换到其他类型，但如果 NULL 被定义为 **((void</em>)0)<strong>，那么当编译 </strong>char <em>ch = NULL;*</em> 时，NULL 只好被定义为 0。而这依然会产生问题，将导致了 C++ 中重载特性会发生混乱，考虑：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><br>对于这两个函数来说，如果 NULL 又被定义为了 0 那么 foo(NULL); 这个语句将会去调用 foo(int)，从而导致代码违反直观。为了解决这个问题，C++11 引入了 nullptr 关键字，专门用来区分空指针、0。nullptr 的类型为 nullptr_t，能够隐式的转换为任何指针或成员指针的类型，也能和他们进行相等或者不等的比较。</p><a id="more"></a><h2 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h2><p>C++11 引入了 auto 和 decltype 这两个关键字实现了类型推导。</p><ol><li><p>auto: 使用 auto 进行类型推导的一个最为常见而且显著的例子就是迭代器，可以使代码变得十分简洁。但需要注意的是 auto 不能用于函数传参，不能用于推导数组类型。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator itr = v.cbegin(); itr != v.cend(); ++itr)</span><br><span class="line"><span class="comment">// auto 类型推导</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> itr = v.cbegin(); itr != v.cend(); ++itr)</span><br><span class="line"><span class="comment">// 不能用于函数传参</span></span><br><span class="line"><span class="comment">//! int add(auto x, auto y);</span></span><br><span class="line"><span class="comment">// auto 不能用于推导数组</span></span><br><span class="line"><span class="comment">//! int a = &#123;1, 2, 3&#125;;</span></span><br><span class="line"><span class="comment">//! auto b = a;</span></span><br></pre></td></tr></table></figure></li><li><p>decltype: decltype 关键字是为了解决 auto 关键字只能对变量进行类型推导的缺陷。它的用法和 sizeof 很相似： <strong>decltype(表达式)</strong> 在此过程中，<strong>编译器分析表达式并得到它的类型，却不实际计算表达式的值</strong>。 </p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x + y) z;</span><br></pre></td></tr></table></figure></li><li>拖尾返回类型 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function">R <span class="title">add</span><span class="params">(T x, U y)</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;</span><br></pre></td></tr></table></figure> 很多时候我们并不知道 add() 这个函数会做什么样的操作，获得一个什么样的返回类型。如果用 decltype(x + y) add(T x, U y); 来进行类型推导的话，并不能通过编译。<br> 这是因为在编译器读到 decltype(x + y) 时， x 和 y 尚未被定义。为了解决这个问题，C++11 还引入了一个叫做 <strong>拖尾返回类型</strong>，利用 auto 关键字将返回类型后置： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line">auto add(T x, U y) -&gt; decltype(x + y) &#123; </span><br><span class="line">    <span class="keyword">return</span> x + y; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 而从 C++14 开始，普通函数具备返回值推导的能力： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T x, U y)</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="模板增强"><a href="#模板增强" class="headerlink" title="模板增强"></a>模板增强</h2><ol><li><p>外部模板：传统 C++ 中，模板只有在使用时才会被编译器实例化。只要在每个编译单元（文件）中编译的代码中遇到了被完整定义的模板，都会实例化。这就产生了重复实例化而导致的编译时间的增加。并且，我们没有办法通知编译器不要触发模板实例化。C++11 引入了外部模板，扩充了原来的强制编译器在特定位置实例化模板的语法，使得能够显式的告诉编译器何时进行模板的实例化：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">std</span>:</span>:<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;;   <span class="comment">// 强行实例化</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">std</span>:</span>:<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;;   <span class="comment">// 不在该编译文件中实例化模板</span></span><br><span class="line">    ```    </span><br><span class="line"><span class="number">2.</span> 尖括号 <span class="string">&#x27;&gt;&#x27;</span>：在传统 C++ 的编译器中，&gt;&gt; 一律被当做右移运算符来进行处理。因此对于嵌套模板来说是不能够被编译的，而 C++<span class="number">11</span> 开始，连续的右尖括号将变得合法，并且能够顺利通过编译。</span><br><span class="line"></span><br><span class="line">    ```cpp</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v;</span><br></pre></td></tr></table></figure></li><li><p>类型别名模板：在传统 C++中，typedef 可以为类型定义一个新的名称，但却没有办法为模板定义一个新的名称，因为 <strong>模板不是类型</strong>。于是 C++11 引入了 <strong>using</strong>，并且同时支持对传统 typedef 相同的作用。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U, <span class="keyword">int</span> value&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuckType</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T a;</span><br><span class="line">    U b;</span><br><span class="line">    SuckType(): a(value), b(value)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 不合法</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">typedef</span> SuckType&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, U, <span class="number">1</span>&gt; NewType; </span><br><span class="line"><span class="comment">// 合法</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> NewType = SuckType&lt;<span class="keyword">int</span>, T, <span class="number">1</span>&gt;; </span><br></pre></td></tr></table></figure></li><li><p>默认模板参数：在 C++11 中提供了一种便利，可以指定模板的默认参数。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="keyword">int</span>, <span class="keyword">typename</span> U = <span class="keyword">int</span>&gt;</span><br><span class="line"><span class="keyword">auto</span> add(T x, U y) -&gt; <span class="keyword">decltype</span>(x + y) &#123; </span><br><span class="line">    <span class="keyword">return</span> x + y; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>变长参数模板：在 C++11 之前，无论是类模板还是函数模板，都只能按其指定的样子，接受一组固定数量的模板参数；而 C++11 加入了新的表示方法，允许任意个数、任意类别的模板参数，同时也不需要在定义时将参数的个数固定。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt; <span class="class"><span class="keyword">class</span> <span class="title">Magic</span>;</span></span><br><span class="line"><span class="comment">// 可以指定模板参数以要求模板参数的个数至少为1</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Require, <span class="keyword">typename</span>... Args&gt; <span class="class"><span class="keyword">class</span> <span class="title">Magic</span>;</span></span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2></li><li><p>委托构造：C++11 引入了委托构造的概念，这使得构造函数可以在同一个类中一个构造函数调用另一个构造函数，从而达到简化代码的目的。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> v1;</span><br><span class="line">    <span class="keyword">int</span> v2;</span><br><span class="line">    Base() &#123; v1 = <span class="number">1</span>; &#125;</span><br><span class="line">    Base(<span class="keyword">int</span> v) : Base() &#123; v2 = <span class="number">2</span>; &#125;   <span class="comment">// 委托 Base() 构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>继承构造：在继承体系中，如果派生类想要使用基类的构造函数，需要在构造函数中显式声明。假若基类拥有为数众多的不同版本的构造函数，这样，在派生类中得写很多对应的“透传”构造函数。在 C++11 中，只要一句话搞定。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>:</span>A&#123;</span><br><span class="line">    <span class="comment">// 太麻烦</span></span><br><span class="line">    B(<span class="keyword">int</span> i):A(i)&#123;&#125;</span><br><span class="line">    B(<span class="keyword">double</span> d, <span class="keyword">int</span> i)&#123;&#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>:</span>A &#123;</span><br><span class="line">    <span class="comment">// 一句话搞定</span></span><br><span class="line">    <span class="keyword">using</span> A::A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 如果一个继承构造函数不被相关的代码使用，编译器就不会为之产生真正的函数代码，这样比透传基类各种构造函数更加节省目标代码空间。</p></li></ol><h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><h2 id="新增容器"><a href="#新增容器" class="headerlink" title="新增容器"></a>新增容器</h2><ol><li><p>std::array：保存在栈内存中，相比堆内存中的 std::vector，性能更高。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> len = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 4&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, len&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;  <span class="comment">// 非法，数组大小必为常量表达式</span></span><br></pre></td></tr></table></figure></li><li>std::forward_list 是一个列表容器，使用方法和 std::list 基本类似。和 std::list 的双向链表的实现不同，std::forward_list 使用单向链表进 行实现，提供了 O(1) 复杂度的元素插入，不支持快速随机访问（这也是链表的 特点），也是标准库容器中唯一一个不提供 size() 方法的容器。当不需要双向 迭代时，具有比 std::list 更高的空间利用率。</li><li>无序容器：C++11 引入了两组无序容器： std::unordered_map/std::unordered_multimap 和 std::unordered_set/std::unordered_multiset。无序容器中的元素是不进行排序的，内部通过 Hash 表实现，插入和搜索元素的 平均复杂度为 O(constant)。</li><li>元组：std::tuple 元组的使用有三个核心的函数： <ul><li>std::make_tuple: 构造元组 </li><li>std::get: 获得元组某个位置的值 </li><li>std::tie: 元组拆包</li></ul></li></ol><h2 id="explicit-关键字"><a href="#explicit-关键字" class="headerlink" title="explicit 关键字"></a>explicit 关键字</h2><p>explicit主要是用来修饰类的构造函数，从而使被构造的类只能发生显示转换，而不能进行隐式转化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Test1(<span class="keyword">int</span> n)&#123;  <span class="comment">// 隐式构造函数</span></span><br><span class="line">            num = n;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">Test2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;   <span class="comment">//explicit(显式)构造函数</span></span><br><span class="line">            num = n;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Test1 t1 = <span class="number">10</span>;  <span class="comment">// 隐式转化</span></span><br><span class="line">    <span class="comment">//等同于 Test1 temp(10);  Test1 t1 = temp;</span></span><br><span class="line"></span><br><span class="line">    Test1 t2 = <span class="string">&#x27;c&#x27;</span>;  <span class="comment">// &#x27;c&#x27;被转化为ascii码，然后同上</span></span><br><span class="line"></span><br><span class="line">    Test2 t3 = <span class="number">12</span>;  <span class="comment">// 编译错误,不能隐式调用其构造函数</span></span><br><span class="line"></span><br><span class="line"> Test2 t4 = <span class="string">&#x27;c&#x27;</span>;  <span class="comment">// 编译错误,不能隐式调用其构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Test2 <span class="title">t5</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">//  正常的显式转化</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>explicit关键字只用于类的单参数构造函数，对于无参数和多参数的构造函数总是显示调用，因此使用explicit没有意义。通常情况下，我们约定对于单参数构造函数必须使用explicit关键字，避免产生意外的类型转化，拷贝构造函数除外。</strong></p><h2 id="constexpr关键字"><a href="#constexpr关键字" class="headerlink" title="constexpr关键字"></a>constexpr关键字</h2><p>constexpr 关键字是 C++11 新增的关键字，其语义是“常量表达式”，也就是在编译期可求值的表达式。</p><p>对于constexpr修饰的函数：</p><ol><li>函数体一般只包含一个return语句；</li><li>函数体可以包含其他语句，但是不能是运行期语句，只能是编译期语句；</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">Inc</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> a = Inc(<span class="number">1</span>); <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> b = Inc(<span class="built_in">cin</span>.get()); <span class="comment">// !error</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> c = a * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>constexpr还能用于修饰类的构造函数，即保证如果提供给该构造函数的参数都是constexpr，那么产生的对象中的所有成员都会是constexpr，该对象也就是constexpr对象了，可用于各种只能使用constexpr的场合。注意，constexpr构造函数必须有一个空的函数体，即所有成员变量的初始化都放到初始化列表中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    constexpr A(int xx, int yy): x(xx), y(yy) &#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> A <span class="title">a</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span>SIZE_X = a.x, SIZE_Y = a.y&#125;;</span><br></pre></td></tr></table></figure><p>好处：</p><ol><li>是一种很强的约束，更好地保证程序的正确语义不被破坏。</li><li>编译器可以在编译期对constexpr的代码进行非常大的优化，比如将用到的constexpr表达式都直接替换成最终结果等。</li><li>相比宏来说，没有额外的开销，但更安全可靠。</li></ol><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>const 和 constexpr 变量之间的主要区别在于：const 变量的初始化可以延迟到运行时，而 constexpr 变量必须在编译时进行初始化。所有 constexpr 变量均为常量，因此必须使用常量表达式初始化。</p><h3 id="修饰指针"><a href="#修饰指针" class="headerlink" title="修饰指针"></a>修饰指针</h3><p>在使用const时，如果关键字const出现在星号左边，表示被指物是常量；如果出现在星号右边，表示指针本身是常量；如果出现在星号两边，表示被指物和指针两者都是常量。</p><p>与const不同，在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指对象无关。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> g_tempA = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> g_conTempA = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> g_conexprTempA = <span class="number">4</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tempA = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> conTempA = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> conexprTempA = <span class="number">4</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*1.正常运行,编译通过*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *conptrA = &amp;tempA;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *conptrB = &amp;conTempA;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *conptrC = &amp;conexprTempA;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*2.局部变量的地址要运行时才能确认，故不能在编译期决定，编译不过*/</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *conexprPtrA = &amp;tempA;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *conexprPtrB = &amp;conTempA;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *conexprPtrC = &amp;conexprTempA;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*3.第一个通过，后面两个不过,因为constexpr int *所限定的是指针是常量，故不能将常量的地址赋给顶层const*/</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *conexprPtrD = &amp;g_tempA;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *conexprPtrE = &amp;g_conTempA;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *conexprPtrF = &amp;g_conexprTempA;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*4.局部变量的地址要运行时才能确认，故不能在编译期决定，编译不过*/</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">int</span> *conexprConPtrA = &amp;tempA;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">int</span> *conexprConPtrB = &amp;conTempA;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">int</span> *conexprConPtrC = &amp;conexprTempA;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*5.正常运行，编译通过*/</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">int</span> *conexprConPtrD = &amp;g_tempA;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">int</span> *conexprConPtrE = &amp;g_conTempA;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">int</span> *conexprConPtrF = &amp;g_conexprTempA;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修饰引用"><a href="#修饰引用" class="headerlink" title="修饰引用"></a>修饰引用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> g_tempA = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> g_conTempA = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> g_conexprTempA = <span class="number">4</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tempA = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> conTempA = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> conexprTempA = <span class="number">4</span>;</span><br><span class="line"><span class="comment">/*1.正常运行，编译通过*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;conptrA = tempA;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;conptrB = conTempA;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;conptrC = conexprTempA;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*2.有两个问题：一是引用到局部变量，不能在编译器确定；二是conexprPtrB和conexprPtrC应该为constexpr const类型，编译不过*/</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> &amp;conexprPtrA = tempA;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> &amp;conexprPtrB = conTempA;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> &amp;conexprPtrC = conexprTempA;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*3.第一个编译通过，后两个不通过，原因是因为conexprPtrE和conexprPtrF应该为constexpr const类型*/</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> &amp;conexprPtrD = g_tempA;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> &amp;conexprPtrE = g_conTempA;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> &amp;conexprPtrF = g_conexprTempA;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*4.正常运行，编译通过*/</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">int</span> &amp;conexprConPtrD = g_tempA;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">int</span> &amp;conexprConPtrE = g_conTempA;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">int</span> &amp;conexprConPtrF = g_conexprTempA;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的说 constexpr 所引用的对象必须在编译期就决定地址。可以通过上例 conexprPtrD 来修改 g_tempA 的值，也就是说 constexpr 修饰的引用不是常量，如果要确保常量引用需要 constexpr const 来修饰。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：粉刷匠（背包dp）</title>
      <link href="2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%B2%89%E5%88%B7%E5%8C%A0%EF%BC%88%E8%83%8C%E5%8C%85dp%EF%BC%89.html"/>
      <url>2020/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%B2%89%E5%88%B7%E5%8C%A0%EF%BC%88%E8%83%8C%E5%8C%85dp%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>n 条木板，每条木板都被分成 m 段且每一段都有要涂的颜色，有 t 次机会涂色，每次可以选择一条木板的连续一段涂成同一种颜色，问最多可以涂对多少段。</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>考虑四维dp的做法。$dp[i][j][k][0/1]$ 代表到第 $i$ 条第 $j$ 段时涂 $k$ 次，当前段涂红或蓝$(0/1)$的最大正确数，可以得到转移方程：<br><a id="more"></a> </p><p>当 $j=1$ (属于当前木板第一段) 时，由上一个木板转移过来：</p><p>$dp[i][j][k][0] = max(dp[i-1][m][k-1][0],dp[i-1][m][k-1][1]) + (s[i][j] == ‘0’)$</p><p>$dp[i][j][k][1] = max(dp[i-1][m][k-1][0],dp[i-1][m][k-1][1]) + (s[i][j] == ‘1’)$</p><p>否则，由当前木板的上一段转移过来：</p><p>$dp[i][j][k][0] = max(dp[i][j-1][k][0],dp[i][j-1][k-1][1]) + (s[i][j] == ‘0’)$</p><p>$dp[i][j][k][1] = max(dp[i][j-1][k-1][0],dp[i][j-1][k][1]) + (s[i][j] == ‘1’)$</p><p>最后结果显然为 $max(dp[n][m][t][0], dp[n][m][t][1])$ 。</p><p>时间复杂度 $O(nmt)$，空间上可以使用滚动数组压维，空间复杂度为 $O(4mt)$。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int <span class="symbol">N</span> = <span class="number">55</span>;</span><br><span class="line">char s[<span class="symbol">N</span>][<span class="symbol">N</span>];</span><br><span class="line">int n, m, t, dp[<span class="number">2</span>][<span class="symbol">N</span>][<span class="symbol">N</span> * <span class="symbol">N</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  scanf(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;t);</span><br><span class="line">  for (int i = <span class="number">1</span>; i &lt;= n; i++) scanf(<span class="string">&quot;%s&quot;</span>, s[i] + <span class="number">1</span>);</span><br><span class="line">  for (int i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    for (int j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">      for (int k = <span class="number">1</span>; k &lt;= t; k++)</span><br><span class="line">        for (int l = <span class="number">0</span>; l &lt;= <span class="number">1</span>; l++) &#123;</span><br><span class="line">          if (j == <span class="number">1</span>)</span><br><span class="line">            dp[i &amp; <span class="number">1</span>][j][k][l] = max(dp[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][m][k - <span class="number">1</span>][<span class="number">0</span>], dp[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][m][k - <span class="number">1</span>][<span class="number">1</span>]) + (s[i][j] == l + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">          else</span><br><span class="line">            dp[i &amp; <span class="number">1</span>][j][k][l] = max(dp[i &amp; <span class="number">1</span>][j - <span class="number">1</span>][k][l], dp[i &amp; <span class="number">1</span>][j - <span class="number">1</span>][k - <span class="number">1</span>][l ^ <span class="number">1</span>]) + (s[i][j] == l + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">  printf(<span class="string">&quot;%d\n&quot;</span>, max(dp[n &amp; <span class="number">1</span>][m][t][<span class="number">0</span>], dp[n &amp; <span class="number">1</span>][m][t][<span class="number">1</span>]));</span><br><span class="line">  return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 背包dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：滑雪与时间胶囊（最小生成树）</title>
      <link href="2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%BB%91%E9%9B%AA%E4%B8%8E%E6%97%B6%E9%97%B4%E8%83%B6%E5%9B%8A%EF%BC%88%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89.html"/>
      <url>2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%BB%91%E9%9B%AA%E4%B8%8E%E6%97%B6%E9%97%B4%E8%83%B6%E5%9B%8A%EF%BC%88%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个 $n$ 个点 $m$ 条边图，只能从点权高的点走到低的，且可以不计路程的瞬移至之前走过的某个点，求经过最多点的最短路径。</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>求经过最多点显然直接bfs，建图的时候建高到低的单向边即可，（值得注意的是，若点权相同，则为相互可达的，需要建双向边）。然后根据bfs遍历可以走到的点，将走过的边加入边集，建一个新图出来。为了使路径最短，考虑最小生成树，但需要满足题目的条件，因此我们对新的图进行排序，以高度为第一关键字从大到小排，再以路径长度为第二关键字从小到大排，这样可以保证点最多的同时路径最短。<br><a id="more"></a> </p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, tot, cnt, hi[N], h[N], pre[N], vis[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> from, to, v, next;</span><br><span class="line">&#125; g[N], E[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">  g[tot].from = x, g[tot].to = y, g[tot].v = z, g[tot].next = h[x],</span><br><span class="line">  h[x] = tot++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">  cnt++, E[cnt].from = x, E[cnt].to = y, E[cnt].v = z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node x, Node y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (hi[x.to] == hi[y.to]) <span class="keyword">return</span> x.v &lt; y.v;</span><br><span class="line">  <span class="keyword">return</span> hi[x.to] &gt; hi[y.to];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xfind</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = x, j = x, temp;</span><br><span class="line">  <span class="keyword">while</span> (i != pre[i]) i = pre[i];</span><br><span class="line">  <span class="keyword">while</span> (i != j) &#123;</span><br><span class="line">    temp = pre[j];</span><br><span class="line">    pre[j] = i;</span><br><span class="line">    j = temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> res1 = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">  vis[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">  q.push(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = q.front();</span><br><span class="line">    q.pop();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i; i = g[i].next) &#123;</span><br><span class="line">      <span class="keyword">int</span> v = g[i].to;</span><br><span class="line">      add2(u, v, g[i].v);</span><br><span class="line">      <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">        vis[v] = <span class="literal">true</span>;</span><br><span class="line">        res1++;</span><br><span class="line">        q.push(v);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, res1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kruscal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> res2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = E[i].from, y = E[i].to;</span><br><span class="line">    <span class="keyword">int</span> fx = xfind(x), fy = xfind(y);</span><br><span class="line">    <span class="keyword">if</span> (fx != fy) &#123;</span><br><span class="line">      pre[fx] = fy;</span><br><span class="line">      res2 += E[i].v;</span><br><span class="line">      num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;hi[i]);</span><br><span class="line">    pre[i] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, z;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">    <span class="keyword">if</span> (hi[x] &gt;= hi[y]) add1(x, y, z);</span><br><span class="line">    <span class="keyword">if</span> (hi[x] &lt;= hi[y]) add1(y, x, z);</span><br><span class="line">  &#125;</span><br><span class="line">  bfs();</span><br><span class="line">  sort(E + <span class="number">1</span>, E + cnt + <span class="number">1</span>, cmp);</span><br><span class="line">  Kruscal();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：换个角度思考（树状数组）</title>
      <link href="2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%8D%A2%E4%B8%AA%E8%A7%92%E5%BA%A6%E6%80%9D%E8%80%83%EF%BC%88%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%EF%BC%89.html"/>
      <url>2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%8D%A2%E4%B8%AA%E8%A7%92%E5%BA%A6%E6%80%9D%E8%80%83%EF%BC%88%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个长度为 $(1&lt;=n&lt;=1e5)$ 的数组，$(1&lt;=q&lt;=1e5)$ 次询问查询区间 $[l,r]$ 内 $&lt;=k$ 的元素个数。</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>考虑树状数组。我们在查询区间 $&lt;=k$ 的个数时，为了更好计数，这个区间应该不包含 $&gt;k$ 的元素才行。因此我们不妨离线，将询问的 $k$ 从小到大排序，将数组也从小到大排序，这样从小到大处理询问，每次处理时只将 $&lt;=k$ 的数挂到树的对应下标上（因为询问的 $k$ 是从小到大的，因此之前树上的数一定比当前询问的 $k$ 要小），维护答案为 $query(r) - query(l-1)$。<br><a id="more"></a> </p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#define x first</span></span><br><span class="line"><span class="comment">#define y second</span></span><br><span class="line">using namespace std;</span><br><span class="line">const <span class="keyword">int</span> N = <span class="number">2</span>e5 + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">struct Node &#123;</span><br><span class="line">  <span class="keyword">int</span> l, r, v, id;</span><br><span class="line">&#125; <span class="string">q[N]</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, <span class="keyword">m</span>, c[N], res[N];</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p[N];</span><br><span class="line"></span><br><span class="line">bool cmp(Node <span class="keyword">x</span>, Node <span class="keyword">y</span>) &#123; <span class="keyword">return</span> x.v &lt; y.v; &#125;</span><br><span class="line"></span><br><span class="line">void update(<span class="keyword">int</span> <span class="keyword">x</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (; <span class="keyword">x</span> &lt;= n; <span class="keyword">x</span> += <span class="keyword">x</span> &amp; (-<span class="keyword">x</span>)) c[<span class="keyword">x</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> query(<span class="keyword">int</span> <span class="keyword">x</span>) &#123;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (; <span class="keyword">x</span> &gt;= <span class="number">1</span>; <span class="keyword">x</span> -= <span class="keyword">x</span> &amp; (-<span class="keyword">x</span>)) sum += c[<span class="keyword">x</span>];</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main() &#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; <span class="keyword">m</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    cin &gt;&gt; p[i].x;</span><br><span class="line">    p[i].y = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">sort</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="keyword">m</span>; i++) &#123;</span><br><span class="line">    cin &gt;&gt; <span class="string">q[i]</span>.l &gt;&gt; <span class="string">q[i]</span>.r &gt;&gt; <span class="string">q[i]</span>.v;</span><br><span class="line">    <span class="string">q[i]</span>.id = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">sort</span>(<span class="keyword">q</span> + <span class="number">1</span>, <span class="keyword">q</span> + <span class="keyword">m</span> + <span class="number">1</span>, cmp);</span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">pos</span> = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="keyword">m</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="string">q[i]</span>.v &gt;= p[<span class="keyword">pos</span>].x &amp;&amp; <span class="keyword">pos</span> &lt;= n) &#123;</span><br><span class="line">      update(p[<span class="keyword">pos</span>].y);</span><br><span class="line">      <span class="keyword">pos</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">    res[<span class="string">q[i]</span>.id] = query(<span class="string">q[i]</span>.r) - query(<span class="string">q[i]</span>.l - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="keyword">m</span>; i++) cout &lt;&lt; res[i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题: Best Cow Fences(二分)</title>
      <link href="2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9ABest-Cow-Fences%EF%BC%88%E4%BA%8C%E5%88%86%EF%BC%89.html"/>
      <url>2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9ABest-Cow-Fences%EF%BC%88%E4%BA%8C%E5%88%86%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个正整数数列A，求一个平均数最大的、长度不小于L的子段。</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>考虑check问题，正着枚举起点，我们需要知道每个起点所能枚举的最大值。当一个数大于当前二分的平均数时，它一定是对答案有贡献的，因此倒过来预处理每个起点能枚举到的最大值即可。时间复杂度 $O(nlogn)$。<br><a id="more"></a> </p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">ll n, k;</span><br><span class="line"><span class="keyword">double</span> a[N], sum[N], pre[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> avg)</span> </span>&#123;</span><br><span class="line">  pre[n + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (ll i = n; i &gt;= <span class="number">1</span>; i--) pre[i] = <span class="built_in">max</span>(a[i] - avg, pre[i + <span class="number">1</span>] + a[i] - avg);</span><br><span class="line">  <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt;= n - k; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sum[i + k] - sum[i] &gt;= k * avg) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (sum[i + k] - sum[i] + pre[i + k + <span class="number">1</span>] &gt;= k * avg) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;k)) &#123;</span><br><span class="line">    <span class="keyword">double</span> l = <span class="number">1e18</span> + <span class="number">7</span>, r = <span class="number">0</span>, mid;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;a[i]);</span><br><span class="line">      l = <span class="built_in">min</span>(l, a[i]);</span><br><span class="line">      r = <span class="built_in">max</span>(r, a[i]);</span><br><span class="line">      sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; <span class="number">0.0001</span>) &#123;</span><br><span class="line">      mid = (l + r) / <span class="number">2.0</span>;</span><br><span class="line">      <span class="keyword">if</span> (check(mid))</span><br><span class="line">        l = mid;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (ll)(l + <span class="number">0.5</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：Yet Another Counting Problem</title>
      <link href="2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AYet-Another-Counting-Problem.html"/>
      <url>2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AYet-Another-Counting-Problem.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给你两个数 $a$ 和 $b$，$q$ 次询问 $[l,r]$ 内满足 (($x$ mod $a$) mod $b$) != (($x$ mod $b$) mod $a$) 的 $x$ 个数。（$q&lt;=500,1&lt;=a,b&lt;=200,1&lt;=l&lt;=r&lt;=1e18$）</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>若 x % a % b != x % b % a，则(x + a $\times$ b ) % a % b != (x + $a \times b$ ) % b % a. 可以得到规律一定是以 a $\times$ b 为循环的，因此预处理前 a $\times$ b个即可。<br><a id="more"></a> </p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll t, a, b, q, l, r, sl, sr, sum[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">  <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; q;</span><br><span class="line">    <span class="keyword">int</span> p = a * b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; p; i++) sum[i] = sum[i - <span class="number">1</span>] + (i % a % b != i % b % a);</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">      l--;</span><br><span class="line">      sl = l / p * sum[p - <span class="number">1</span>] + sum[l % p];</span><br><span class="line">      sr = r / p * sum[p - <span class="number">1</span>] + sum[r % p];</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; sr - sl &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：美味菜肴</title>
      <link href="2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%BE%8E%E5%91%B3%E8%8F%9C%E8%82%B4.html"/>
      <url>2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%BE%8E%E5%91%B3%E8%8F%9C%E8%82%B4.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>$n$ 件食材（每种食材的数量可以视为无限），小明连续工作 $T$ 时间。每道菜肴的制作需要特定的一种食材以及一段时间，但是食材一旦放久就不新鲜了，菜的美味值会降低。第 $i$ 道菜肴有三个属性 $ai$，$bi$，$ci$，$ai$ 是该菜肴的美味值，$bi$ 是该菜肴所选食材不新鲜的速率，如果在第t时刻完成第i道菜则美味值为：$ai-t*bi$，完成这道菜需要 $ci$ 的时间。求在这 $T$ 时间内能做出菜肴使得总美味值的最大值。</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>首先需要贪心确定顺序，考虑只有两道菜，可以得到：$a_i−b_i∗c_i+(a_j−b_j∗(c_i+c_j))&gt;=a_j−b_j∗c_j+(a_i−b_i∗(c_i+c_j))$，化简后得到：$b_i∗c_i&gt;=b_j∗c_i$。排序后背包即可（需要降维）。</p><a id="more"></a> <h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const ll INF = <span class="number">0x3ffffffffffff</span>;</span><br><span class="line">const <span class="keyword">int</span> N = <span class="number">2</span>e5 + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">struct Node &#123;</span><br><span class="line">  ll a, b, c;</span><br><span class="line">&#125; <span class="string">q[N]</span>;</span><br><span class="line"></span><br><span class="line">ll res = -INF, <span class="keyword">s</span>[N], dp[N];</span><br><span class="line"></span><br><span class="line">bool cmp(Node <span class="keyword">x</span>, Node <span class="keyword">y</span>) &#123; <span class="keyword">return</span> x.c * <span class="keyword">s</span>[y.a] &lt; y.c * <span class="keyword">s</span>[x.a]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main() &#123;</span><br><span class="line">  <span class="keyword">int</span> n, <span class="keyword">m</span>, t;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; <span class="keyword">m</span> &gt;&gt; t;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; <span class="keyword">s</span>[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="keyword">m</span>; i++) cin &gt;&gt; <span class="string">q[i]</span>.a &gt;&gt; <span class="string">q[i]</span>.b &gt;&gt; <span class="string">q[i]</span>.c;</span><br><span class="line">  <span class="keyword">sort</span>(<span class="keyword">q</span> + <span class="number">1</span>, <span class="keyword">q</span> + <span class="keyword">m</span> + <span class="number">1</span>, cmp);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++) dp[i] = -INF;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="keyword">m</span>; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = t; j &gt;= <span class="string">q[i]</span>.c; j--)</span><br><span class="line">      dp[j] = max(dp[j], dp[j - <span class="string">q[i]</span>.c] + <span class="string">q[i]</span>.b - j * <span class="keyword">s</span>[<span class="string">q[i]</span>.a]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++) res = max(res, dp[i]);</span><br><span class="line">  cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：Game Strategy</title>
      <link href="2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AGame-Strategy.html"/>
      <url>2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AGame-Strategy.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>三个人玩游戏，每个人最开始都有 $n$ 个数，开始轮流删数，直到最后每个人只剩下一个数。第一个人想让这三个数的和（$x+y+z$）加起来尽量大，第二个想尽量小，第三个想尽量接近0。每个人都以自己的想法为策略，问最后得到的三个数的和是多少（$n&lt;=100$）。</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>不要想复杂了，其实就是直接模拟。暴力枚举三个数，因为第三个人想尽量接近 0，因此枚举 $z$ 时维护最接近 0 的解 $m1$，因为第二个人想要最小值，因此取枚举所有 $z$ 得到的解（$m1$）的最小值$m2$，然后第一个人想要最大值，所以取枚举所有 $y$ （$m2$）的最大值 $m3$。</p><a id="more"></a> <h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, a[<span class="number">105</span>], b[<span class="number">105</span>], c[<span class="number">105</span>], d[<span class="number">105</span>];</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; c[i];</span><br><span class="line">  <span class="keyword">int</span> m1 = -INF, m2, m3;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    m2 = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) d[k] = a[i] + b[j] + c[k];</span><br><span class="line">      sort(d, d + n);</span><br><span class="line">      <span class="keyword">int</span> pos = lower_bound(d, d + n, <span class="number">0</span>) - d;</span><br><span class="line">      <span class="keyword">if</span> (pos == n)</span><br><span class="line">        m3 = d[pos - <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (pos == <span class="number">0</span>)</span><br><span class="line">        m3 = d[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (d[pos] &gt; -d[pos - <span class="number">1</span>])</span><br><span class="line">          m3 = d[pos - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          m3 = d[pos];</span><br><span class="line">      &#125;</span><br><span class="line">      m2 = <span class="built_in">min</span>(m2, m3);</span><br><span class="line">    &#125;</span><br><span class="line">    m1 = <span class="built_in">max</span>(m1, m2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; m1 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博弈论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回文相关算法总结及简单变形</title>
      <link href="2020/04/%E5%9B%9E%E6%96%87%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E5%8F%8A%E7%AE%80%E5%8D%95%E5%8F%98%E5%BD%A2.html"/>
      <url>2020/04/%E5%9B%9E%E6%96%87%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E5%8F%8A%E7%AE%80%E5%8D%95%E5%8F%98%E5%BD%A2.html</url>
      
        <content type="html"><![CDATA[<h2 id="求最长回文串"><a href="#求最长回文串" class="headerlink" title="求最长回文串"></a><strong>求最长回文串</strong></h2><h3 id="解法一：中心扩散法"><a href="#解法一：中心扩散法" class="headerlink" title="解法一：中心扩散法"></a>解法一：中心扩散法</h3><p>过于傻逼，就是枚举中心点向两边拓展长度直到不相等。（时间复杂度 $O(n^2)$，空间复杂度 $O(1)$）</p><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><a id="more"></a> <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> now, x, y;</span><br><span class="line">  <span class="keyword">if</span> (type)</span><br><span class="line">    now = <span class="number">0</span>, x = pos, y = pos + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    now = <span class="number">1</span>, x = pos - <span class="number">1</span>, y = pos + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; y &lt; s.<span class="built_in">size</span>() &amp;&amp; s[x] == s[y])</span><br><span class="line">      now += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    x--, y++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s) &#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">      res = <span class="built_in">max</span>(res, <span class="built_in">max</span>(check(i, <span class="number">0</span>), check(i, <span class="number">1</span>)));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="解法二：动态规划"><a href="#解法二：动态规划" class="headerlink" title="解法二：动态规划"></a>解法二：动态规划</h3><p>$dp[i][j] = 0/1 $ 表示子串 $i~j$ 是否为回文串。</p><p>那么，容易得到：$dp[i][j] = (dp[i+1][j-1]$ &amp;&amp; $s[i]==s[j])$。</p><p>由于 $i$ 是由 $i+1$ 转移过来的，所以我们需要倒着遍历：</p><h4 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (int i = s.size() - <span class="number">1</span><span class="comment">; i &gt;= 0; i--)</span></span><br><span class="line">  for (int <span class="keyword">j </span>= i<span class="comment">; j &lt; s.size(); j++) &#123;</span></span><br><span class="line">    if (s[i] == s[<span class="keyword">j] </span>&amp;&amp; (<span class="keyword">j </span>- i &lt; <span class="number">2</span> <span class="title">||</span> dp[i + <span class="number">1</span>][<span class="keyword">j </span>- <span class="number">1</span>])) &#123;</span><br><span class="line">      dp[i][<span class="keyword">j] </span>= true;</span><br><span class="line">      res = max(res, <span class="keyword">j </span>- i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>时间复杂度 $O(n^2)$，空间复杂度 $O(n^2)$</p><h3 id="解法三：manacher"><a href="#解法三：manacher" class="headerlink" title="解法三：manacher"></a>解法三：manacher</h3><h4 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="keyword">char</span> s[N], t[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">manacher</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    t[l++] = <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line">    t[l++] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t[l++] = s[i];</span><br><span class="line">        t[l++] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t[l++] = <span class="string">&#x27;@&#x27;</span>;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>, mx = <span class="number">0</span>, index = <span class="number">0</span>, maxlength = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; l; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = mx &gt; i ? <span class="built_in">min</span>(p[<span class="number">2</span> * id - i], mx - i) : <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/// 向左右两边延伸，扩展右边界</span></span><br><span class="line">        <span class="keyword">while</span> (t[i + p[i]] == t[i - p[i]])</span><br><span class="line">            p[i]++;</span><br><span class="line">        <span class="comment">/// 如果回文子串的右边界超过了mx，则需要更新mx和id的值</span></span><br><span class="line">        <span class="keyword">if</span> (i + p[i] &gt; mx)</span><br><span class="line">        &#123;</span><br><span class="line">            mx = i + p[i];</span><br><span class="line">            id = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/// 如果回文子串的长度大于maxLength，则更新maxLength和index的值</span></span><br><span class="line">        <span class="keyword">if</span> (maxlength &lt; p[i] - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            maxlength = p[i] - <span class="number">1</span>;</span><br><span class="line">            index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start = (index - maxlength) / <span class="number">2</span>; <span class="comment">/// 记录起始位置</span></span><br><span class="line">    <span class="keyword">return</span> maxlength;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, manacher());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变形1"><a href="#变形1" class="headerlink" title="变形1"></a>变形1</h2><h3 id="求最长回文子序列"><a href="#求最长回文子序列" class="headerlink" title="求最长回文子序列"></a>求最长回文子序列</h3><h4 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h4><ul><li><p>状态</p><p>$f[i][j]$ 表示 $s$ 的第 $i$ 个字符到第 $j$ 个字符组成的子串中，最长的回文序列长度是多少。</p></li><li><p>转移方程</p><p>如果 $s$ 的第 $i$ 个字符和第 $j$ 个字符相同的话</p></li><li><p>$f[i][j] = f[i + 1][j - 1] + 2$</p><p>如果 $s$ 的第 $i$ 个字符和第 $j$ 个字符不同的话</p></li><li><p>$f[i][j] = max(f[i + 1][j], f[i][j - 1])$</p><p>然后注意遍历顺序，$i$ 从最后一个字符开始往前遍历，$j$ 从 $i + 1$ 开始往后遍历，这样可以保证每个子问题都已经算好了。</p></li><li><p>初始化<br>$f[i][i] = 1$ 单个字符的最长回文序列是 $1$</p></li><li><p>结果<br>$f[0][n - 1]$</p></li></ul><h4 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h4><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for(int i = n - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">  dp<span class="comment">[i]</span><span class="comment">[i]</span> = 1;</span><br><span class="line">  for(int j = i + 1; j &lt; n; j++) &#123;</span><br><span class="line">    if(s<span class="comment">[i]</span> == s<span class="comment">[j]</span>)</span><br><span class="line">      dp<span class="comment">[i]</span><span class="comment">[j]</span> = dp<span class="comment">[i + 1]</span><span class="comment">[j - 1]</span> + 2;</span><br><span class="line">    else</span><br><span class="line">      dp<span class="comment">[i]</span><span class="comment">[j]</span> = max(dp<span class="comment">[i + 1]</span><span class="comment">[j]</span>, dp<span class="comment">[i]</span><span class="comment">[j - 1]</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">return dp<span class="comment">[0]</span><span class="comment">[n - 1]</span>;</span><br></pre></td></tr></table></figure><h2 id="变形2"><a href="#变形2" class="headerlink" title="变形2"></a>变形2</h2><h3 id="插入最少的字符，使得字符串变成回文串。"><a href="#插入最少的字符，使得字符串变成回文串。" class="headerlink" title="插入最少的字符，使得字符串变成回文串。"></a>插入最少的字符，使得字符串变成回文串。</h3><h4 id="solution-1"><a href="#solution-1" class="headerlink" title="solution"></a>solution</h4><p>很直观的，答案就是原长度-最长回文子序列。考虑另一种区间dp的做法：</p><p>既然是区间dp，那么就是由小区间得到大区间，故最外层从小到大枚举长度，然后枚举左右端点。</p><ul><li>$dp[i][j] = min(dp[i + 1][j] + 1, dp[i][j - 1] + 1)$                     $s[i] != s[j]$</li><li>$dp[i][j] = min(dp[i + 1][j] + 1, dp[i][j - 1] + 1, dp[i + 1][j - 1])$   $s[i] == s[j]$</li></ul><h4 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h4><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for (int len = 2; len &lt;= n; len++) &#123;</span><br><span class="line">    for (int l = 0; l &lt;= n - len; l++) &#123;</span><br><span class="line">      int r = l + len - 1;</span><br><span class="line">      dp<span class="comment">[l]</span><span class="comment">[r]</span> = min(dp<span class="comment">[l + 1]</span><span class="comment">[r]</span>, dp<span class="comment">[l]</span><span class="comment">[r - 1]</span>) + 1;</span><br><span class="line">      if (s<span class="comment">[l]</span> == s<span class="comment">[r]</span>)</span><br><span class="line">        dp<span class="comment">[l]</span><span class="comment">[r]</span> = min(dp<span class="comment">[l]</span><span class="comment">[r]</span>, dp<span class="comment">[l + 1]</span><span class="comment">[r - 1]</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return dp<span class="comment">[0]</span><span class="comment">[n - 1]</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：不同子序列个数(升级版)</title>
      <link href="2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E4%B8%8D%E5%90%8C%E5%AD%90%E5%BA%8F%E5%88%97%E4%B8%AA%E6%95%B0-%E5%8D%87%E7%BA%A7%E7%89%88.html"/>
      <url>2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E4%B8%8D%E5%90%8C%E5%AD%90%E5%BA%8F%E5%88%97%E4%B8%AA%E6%95%B0-%E5%8D%87%E7%BA%A7%E7%89%88.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个长度为 $n$ 的数组，求长度为 $n-m$ 的不同子序列个数。（$1&lt;=n&lt;=1e5, m&lt;=10$）</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>$dp[i][j]$ 表示长度为 $i$，删除 $j$ 个元素的子序列个数，不考虑重复的话，有 $dp[i][j] = dp[i-1][j] + dp[i-1][j-1]$（即已经删除了 $j$  个和已经删除了 $j-1$ 个再删除这一个的情况）。<br><a id="more"></a> </p><p>考虑去重。如果是单纯求不限长度的不同子序列的去重，容易得到：$dp[i] -= dp[pre[a[i]] - 1]$  （$pre[a[i]]$ 为上一次 $a[i]$ 出现的位置），在此题中也是同理，我们需要剔除 $[pre[a[i]], i]$ 之间的元素，假设我们当前需要剔除 $j$ 个元素，那么在$pre[a[i]]-1$之前我们先需要剔除 $j-(i-pre[a[i]])$ 个元素， $dp[i][j] -= dp[pre[a[i]]-1][j-(i-pre[a[i]])]$，初始化为所有的 $dp[i][0] = 1$。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k, pre[N], dp[N][<span class="number">12</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">memset</span>(pre, <span class="number">0</span>, <span class="keyword">sizeof</span>(pre));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> x;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="built_in">min</span>(i, m); j++) &#123;</span><br><span class="line">        dp[i][j] = (dp[i - <span class="number">1</span>][j] + dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br><span class="line">        <span class="keyword">if</span> (pre[x] &amp;&amp; j - (i - pre[x]) &gt;= <span class="number">0</span>)</span><br><span class="line">          dp[i][j] = (dp[i][j] - dp[pre[x] - <span class="number">1</span>][j - (i - pre[x])] + mod) % mod;</span><br><span class="line">      &#125;</span><br><span class="line">      pre[x] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[n][m] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计数dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：子序列</title>
      <link href="2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%AD%90%E5%BA%8F%E5%88%97.html"/>
      <url>2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%AD%90%E5%BA%8F%E5%88%97.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个由n个元素组成的序列 { a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>,…, a<sub>n</sub> } ，她想知道其中有多少个子序列 { a<sub>p1</sub>, a<sub>p2</sub>, …, a<sub>pm</sub> } $(1 ≤ m ≤ n, 1 ≤ p1 &lt; p2 ,…, &lt; pm ≤ n)$，满足对于所有的 $i, j$ $(1 ≤ i &lt; j ≤ m)$, a<sub>pi</sub><sup>pj</sup> &lt; a<sub>pj</sub><sup>pi</sup>成立。</p><h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h3><p>py + dp直接冲。<br><a id="more"></a> </p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">n, <span class="keyword">mod</span> = <span class="keyword">int</span>(<span class="built_in">input</span>()), <span class="keyword">int</span>(<span class="number">1000000007</span>)</span><br><span class="line"><span class="keyword">a</span> = <span class="keyword">list</span>(<span class="keyword">map</span>(<span class="keyword">int</span>, <span class="built_in">input</span>().<span class="keyword">split</span>()))</span><br><span class="line"><span class="keyword">dp</span> = [ <span class="number">1</span> <span class="keyword">for</span> i in <span class="built_in">range</span>(n) ]</span><br><span class="line"><span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="number">0</span>, n):</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">j</span> in <span class="built_in">range</span>(i):</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">a</span>[<span class="keyword">j</span>] ** (i + <span class="number">1</span>) &lt; <span class="keyword">a</span>[i] ** (<span class="keyword">j</span> + <span class="number">1</span>)):</span><br><span class="line">            <span class="keyword">dp</span>[i] += <span class="keyword">dp</span>[<span class="keyword">j</span>]</span><br><span class="line"><span class="keyword">print</span>(sum(<span class="keyword">dp</span>) % <span class="keyword">mod</span>)</span><br></pre></td></tr></table></figure><h3 id="solution2"><a href="#solution2" class="headerlink" title="solution2"></a>solution2</h3><p>变形公式。a[ i ]<sup>j</sup> &lt; a[ j ]<sup>i</sup> $\Leftrightarrow$ j $\times$ $log(a[i]) &lt; i * log(a[j])$，即原题等价于求上升子序列的数量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">ll res, dp[<span class="number">105</span>], a[<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    dp[i] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">      <span class="keyword">if</span> (j * <span class="built_in">log</span>(a[i]) &gt; i * <span class="built_in">log</span>(a[j])) dp[i] = (dp[i] + dp[j]) % mod;</span><br><span class="line">    res = (res + dp[i]) % mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计数dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：不同子序列个数</title>
      <link href="2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E4%B8%8D%E5%90%8C%E5%AD%90%E5%BA%8F%E5%88%97%E4%B8%AA%E6%95%B0.html"/>
      <url>2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E4%B8%8D%E5%90%8C%E5%AD%90%E5%BA%8F%E5%88%97%E4%B8%AA%E6%95%B0.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个长度为 $n$ 的字符串，求不同的子序列个数。</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>很经典的一道计数dp。我们用 $dp[i]$ 表示以前 $i$ 个字符中的不同子序列个数：<br><a id="more"></a> </p><p><strong>当 $s[i]$ 之前没有出现过：$dp[i] = dp[i - 1] * 2 + 1$ ，即前 $i - 1$ 个不同子序列个数 + 前 $i - 1$ 个不同子序列与当前的 $s[i]$ 结合 + 单独一个 $s[i]$ 成为字符串。</strong></p><p><strong>当 $s[i]$ 之前出现过：$dp[i] = dp[i - 1] * 2 - dp[上一次出现的位置 - 1]$ ，因为以该字符结尾的情况我们之前已经计算过一次，因此要减去上一次计算的结果，否则会产生重复计算。</strong></p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> n, vis[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; s + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[s[i]])</span><br><span class="line">      dp[i] = (dp[i - <span class="number">1</span>] * <span class="number">2</span> - dp[vis[s[i]] - <span class="number">1</span>] + mod) % mod;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      dp[i] = (dp[i - <span class="number">1</span>] * <span class="number">2</span> + <span class="number">1</span>) % mod;</span><br><span class="line">    vis[s[i]] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; dp[n] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计数dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：K-th Number</title>
      <link href="2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AK-th-Number.html"/>
      <url>2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AK-th-Number.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个长度为 $n$ 的数组 A ，把所有长度 &gt;= $k$ 的区间中的第 $k$ 大值插入 B 数组中，求 B 数组的第 $m$ 大数。</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>这种显然二分答案题我们主要关心 $check$ 问题。<br><a id="more"></a> </p><p>如何计算第 $k$ 大数 $&gt;= mid$ 的区间个数？</p><p>假设区间 $[l, r]$ 中刚好有 $k$ 个数 $&gt;= mid$，则 $[l, r…n]$ 区间全部满足第 $k$ 大数 $&gt;= mid$。</p><p>因此考虑尺取，若当前区间满足 $k$ 个数 $=mid$，则计数 $cnt += n - r + 1$，同时移动左边界；否则移动右边界直至。。。当 $cnt &gt;= m$ 时，说明 $mid$ 过小，调整左边界，否则调整右边界。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, n, k, a[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (r &lt;= n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt == k) &#123;</span><br><span class="line">      sum += (n - r + <span class="number">1L</span>L);</span><br><span class="line">      cnt -= (a[l++] &gt;= x);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      cnt += (a[++r] &gt;= x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum &gt;= m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">  <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">1e9</span> + <span class="number">7</span>, mid;</span><br><span class="line">    <span class="keyword">while</span> (l + <span class="number">1</span> &lt; r) &#123;</span><br><span class="line">      <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (check(mid))</span><br><span class="line">        l = mid;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：逆序对</title>
      <link href="2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E9%80%86%E5%BA%8F%E5%AF%B9.html"/>
      <url>2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E9%80%86%E5%BA%8F%E5%AF%B9.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>题意很简单，求长度为n的01串逆序对数量和。( n &lt;= 1e18 )</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>任意选两个位置 $i, j$ $(i &lt; j)$，令 $a[i] = 1, a[j] = 0$，这样一定能产生逆序对，这样有 $C_n^2$ 种选法。剩下的位置随便放，有$2^{n-2}$种选法，总方案数即为答案。( 注意 1 需要特判 )<br><a id="more"></a> </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qp</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (b == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  ll ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (b) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">    a = a * a % mod;</span><br><span class="line">    b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll n, res;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  res = (((n % mod) * ((n - <span class="number">1</span>) % mod) / <span class="number">2</span> % mod) * qp(<span class="number">2</span>, n - <span class="number">2</span>) % mod);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数间参数的传递方式</title>
      <link href="2020/04/%E5%87%BD%E6%95%B0%E9%97%B4%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F.html"/>
      <url>2020/04/%E5%87%BD%E6%95%B0%E9%97%B4%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F.html</url>
      
        <content type="html"><![CDATA[<h4 id="1-值传递：将主调函数的实参值传递给被调函数的形参，形参单独分配内存。"><a href="#1-值传递：将主调函数的实参值传递给被调函数的形参，形参单独分配内存。" class="headerlink" title="1. 值传递：将主调函数的实参值传递给被调函数的形参，形参单独分配内存。"></a>1. <strong>值传递</strong>：将主调函数的实参值传递给被调函数的形参，形参单独分配内存。</h4><p>  <strong>单向数据传递机制</strong>：传递的只是实参的值，形参的改变不影响实参。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="comment">//实现形参a、b的交换</span></span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    c = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">2</span>, y = <span class="number">3</span>;</span><br><span class="line">    swap(x, y);<span class="comment">//实参x,y的值并没有交换。值传递的单向数据传递机制</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x&lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt;y&lt;&lt; <span class="built_in">endl</span>;<span class="comment">//2 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-引用传递：被调用的形参引用主调函数的实参，实现间接访问。"><a href="#2-引用传递：被调用的形参引用主调函数的实参，实现间接访问。" class="headerlink" title="2. 引用传递：被调用的形参引用主调函数的实参，实现间接访问。"></a>2. <strong>引用传递</strong>：被调用的形参引用主调函数的实参，实现间接访问。</h4><p>  <strong>双向数据传递机制</strong>：通过引用&amp;，指向同一内存，其一改变，二者都改变。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span> <span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;<span class="comment">//引用变量a、b，等效int &amp;a=x;int &amp;b=y;</span></span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    c = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">2</span>, y = <span class="number">3</span>;</span><br><span class="line">    swap(x, y);<span class="comment">//实参x,y的值被交换。a与x，b与y指向同一内存，其一改变，两者都变</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x&lt;&lt; <span class="string">&quot;和&quot;</span>&lt;&lt;y&lt;&lt; <span class="built_in">endl</span>;<span class="comment">//3和2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：关于直接和间接访问：</p><p>按照C语言的方式，定义一个变量，系统会自动为该变量分配内存，变量有两个属性：变量值和变量地址。变量地址指示该变量在内存中的存储位置，变量值为该内存中的存储内容。</p><p><strong>直接访问</strong>：直接使用变量名访问内存空间上的内容。</p><p><strong>间接访问</strong>：先从其它内存空间获得要访问的内存地址（指针），根据地址访问对应内存中的数据。</p><h4 id="3-指针传递：被调函数的形参接收主调函数实参的内存地址，间接访问。"><a href="#3-指针传递：被调函数的形参接收主调函数实参的内存地址，间接访问。" class="headerlink" title="3. 指针传递：被调函数的形参接收主调函数实参的内存地址，间接访问。"></a>3. <strong>指针传递</strong>：被调函数的形参接收主调函数实参的内存地址，间接访问。</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span> <span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span> </span>&#123;<span class="comment">//引用变量a、b，等效int *a=&amp;x;int *b=&amp;y;</span></span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    c = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">2</span>, y = <span class="number">3</span>;</span><br><span class="line">    swap(&amp;x, &amp;y);<span class="comment">//实参x,y的值被交换。实参地址传递给指针类型的形参</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x&lt;&lt; <span class="string">&quot;和&quot;</span>&lt;&lt;y&lt;&lt; <span class="built_in">endl</span>;<span class="comment">//3和2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：Treepath</title>
      <link href="2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9ATreepath.html"/>
      <url>2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9ATreepath.html</url>
      
        <content type="html"><![CDATA[<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给定一棵n个节点的树，求偶数长度路径的数量。</p><h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1:"></a>Solution1:</h3><p>考虑树的深度对距离的影响，可以发现，深度奇偶性相同的点之间的距离总是偶数。<br><a id="more"></a> </p><p>证明：我们先将深度更大的点走到和另一个点深度相同，显然需要偶数步，然后两个点同时移动到最近公共节点，可知所用的步数是相同的，加起来也是偶数。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, idx, h[N], dep[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; E[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; E[idx].to = b, E[idx].next = h[a], h[a] = idx++; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">  dep[u] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i; i = E[i].next) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = E[i].to;</span><br><span class="line">    <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">    dfs(v, u);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    add(x, y);</span><br><span class="line">    add(y, x);</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> odd = <span class="number">0</span>, even = <span class="number">0</span>, res;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[i] &amp; <span class="number">1</span>)</span><br><span class="line">      odd++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      even++;</span><br><span class="line">  &#125;</span><br><span class="line">  res = odd * (odd - <span class="number">1</span>) / <span class="number">2</span> + even * (even - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="solution2"><a href="#solution2" class="headerlink" title="solution2:"></a>solution2:</h3><p>考虑树形dp。$dp[i][0/1]$ 表示从 i 出发，长度为偶数/奇数的路径数。</p><p>从子节点到父节点状态转移：</p><p>$dp[u][1] += dp[v][0]$</p><p>$dp[u][0] += dp[v][1]$</p><p>对于 $u$ 的每一个儿子 $v$，贡献即为 $dp[u][0] \times dp[v][1] + dp[u][1] \times dp[v][0]$, dfs回溯时进行合并更新即可。</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, idx, h[N];</span><br><span class="line">ll res, dp[N][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; E[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; E[idx].to = b, E[idx].next = h[a], h[a] = idx++; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">  dp[u][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i; i = E[i].next) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = E[i].to;</span><br><span class="line">    <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">    dfs(v, u);</span><br><span class="line">    res += dp[v][<span class="number">0</span>] * dp[u][<span class="number">1</span>];</span><br><span class="line">    res += dp[v][<span class="number">1</span>] * dp[u][<span class="number">0</span>];</span><br><span class="line">    dp[u][<span class="number">0</span>] += dp[v][<span class="number">1</span>];</span><br><span class="line">    dp[u][<span class="number">1</span>] += dp[v][<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    add(x, y);</span><br><span class="line">    add(y, x);</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>关于树上统计问题一直是个人较怕的题目（虽然经常出现但几乎每次都不会做 T_T），树上问题往往离不开dfs，需要考虑父子节点的转移，必要时可以考虑树形dp。</p>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：Accumulation Degree</title>
      <link href="2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AAccumulation-Degree.html"/>
      <url>2020/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9AAccumulation-Degree.html</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一棵n个节点的树，边权值视作流量，找到一个源点使得从该点出发到所有叶子节点流量和最大。</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>我们先考虑这样一道题：指定一点使得到树上其他点的深度之和最小。<br><a id="more"></a> </p><h4 id="这显然是树的重心的性质：树中所有点到某个点的距离和中，到重心的距离和是最小的，如果有两个重心，他们的距离和一样。"><a href="#这显然是树的重心的性质：树中所有点到某个点的距离和中，到重心的距离和是最小的，如果有两个重心，他们的距离和一样。" class="headerlink" title="这显然是树的重心的性质：树中所有点到某个点的距离和中，到重心的距离和是最小的，如果有两个重心，他们的距离和一样。"></a>这显然是树的重心的性质：树中所有点到某个点的距离和中，到重心的距离和是最小的，如果有两个重心，他们的距离和一样。</h4><p>我们先假设这棵树的根为1，进行一次dfs，可以求出每个点的深度 $dep[i]$ 和子树大小 $size[i]$ ，设某点作为根深度之和为 $f$( i )，显然：$f(1)$ = $\sum_{i=1}^{n}{dep[i]}$。</p><p>当根从 $u$ 转移到子节点 $v$ 时，以 $v$ 为根的子树内所有节点 $dep$ 都减1，其余节点加1。从而得到状态转移方程：$f[v] = f[u] - size[v] + (n - size[v]) = f[u] + n - 2 * size[v]$，答案取最小值即可，时间复杂度 $O (n)$ 。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, res, idx, h[N], dep[N], <span class="built_in">size</span>[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; E[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; E[idx].to = b, E[idx].next = h[a], h[a] = idx++; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">size</span>[u] = <span class="number">1</span>;</span><br><span class="line">  dep[u] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i; i = E[i].next) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = E[i].to;</span><br><span class="line">    <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">    dfs1(v, u);</span><br><span class="line">    <span class="built_in">size</span>[u] += <span class="built_in">size</span>[v];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i; i = E[i].next) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = E[i].to;</span><br><span class="line">    <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">    f[v] = f[u] + n - <span class="number">2L</span>L * <span class="built_in">size</span>[v];</span><br><span class="line">    dfs2(v, u);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    add(x, y);</span><br><span class="line">    add(y, x);</span><br><span class="line">  &#125;</span><br><span class="line">  dep[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">  dfs1(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[<span class="number">1</span>] += dep[i];</span><br><span class="line">  dfs2(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0x3ffffffffffff</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; f[i]) &#123;</span><br><span class="line">      sum = f[i];</span><br><span class="line">      res = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在我们回过头来看这道题，可以发现思路都大同小异，只是转移方程发生了变化。</p><p>定义 $flow[i]表示以 i 为根的子树中流量的最大值$，那么，当节点从 $u$ 转移到 $v$ 时，我们可以得到：</p><ol><li>当 $v$ 为叶子结点，则 $flow[u] += flow[v]$ ；</li><li>当 $u$ 为非叶子结点，则 $flow[u] = min(flow[v], fl(u, v))$  $(fl(u, v) 即u, v两点间的流量限制)$ 。</li></ol><p>这样，根为1时的 $flow[1]$ 就求出来了。</p><p>接下来考虑根节点的转移：从以 $u$ 为根节点转移为以 $v$ 为根节点，对于根节点 $v$ 而言，唯一会产生影响的就是 $v$ 流向 $u$ 的路径，也就是对于换根后所有用到这条边的路径，都要加上这条流量的限制，则状态转移方程为：</p><ol><li>当 $u$ 为叶子节点时，$f[v] += fl(u, v)$ ;</li><li>当 $v$ 为非叶子结点时，$f[v] += min(fl(u, v), flow[u] - min(flow[v], fl(u, v)))$ 。</li></ol><p>进行两次dfs即可，时间复杂度 $O(n)$。</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, n, res, idx, h[N], d[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> to, w, next;</span><br><span class="line">&#125; E[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">  E[idx].to = b, E[idx].w = c, E[idx].next = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i; i = E[i].next) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = E[i].to, w = E[i].w;</span><br><span class="line">    <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">    dfs1(v, u);</span><br><span class="line">    <span class="keyword">if</span> (d[v] == <span class="number">1</span>)</span><br><span class="line">      f[u] += w;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      f[u] += <span class="built_in">min</span>(f[v], w);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i; i = E[i].next) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = E[i].to, w = E[i].w;</span><br><span class="line">    <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (d[u] == <span class="number">1</span>)</span><br><span class="line">      f[v] += w;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      f[v] += <span class="built_in">min</span>(w, f[u] - <span class="built_in">min</span>(f[v], w));</span><br><span class="line">    dfs2(v, u);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">  <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> x, y, z;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">      add(x, y, z);</span><br><span class="line">      add(y, x, z);</span><br><span class="line">      d[x]++;</span><br><span class="line">      d[y]++;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs1(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    dfs2(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于换根dp，一般有两个步骤：</p><ol><li>默认1为根进行dfs预处理；</li><li>从1开始，进行根的转移，计算贡献变化。</li></ol><p>对于dp而言，状态转移方程是最重要的，需要多思考，多刷题，才能累积经验，掌握要点。</p>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
