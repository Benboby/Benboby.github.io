<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Benboby&#39;s Blog</title>
  
  
  <link href="https://www.benboby.top/atom.xml" rel="self"/>
  
  <link href="https://www.benboby.top/"/>
  <updated>2021-03-06T12:58:04.370Z</updated>
  <id>https://www.benboby.top/</id>
  
  <author>
    <name>Benboby</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>继承，虚函数和多态</title>
    <link href="https://www.benboby.top/2021/02/%E7%BB%A7%E6%89%BF-%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81.html"/>
    <id>https://www.benboby.top/2021/02/%E7%BB%A7%E6%89%BF-%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81.html</id>
    <published>2021-02-12T06:03:16.000Z</published>
    <updated>2021-03-06T12:58:04.370Z</updated>
    
    <content type="html"><![CDATA[<h2 id="继承-with-virtual-function"><a href="#继承-with-virtual-function" class="headerlink" title="继承 with virtual function"></a>继承 with virtual function</h2><p><strong>构造由内而外</strong>：首先调用父类的构造函数，然后再调用自己。<br><strong>析构由外而内</strong>：首先执行自己的析构函数，然后调用父类的析构函数。</p><p>non-virtual: 你不希望重新定义（重写）它。<br>virtual: 你希望子类重新定义它，且它有默认定义。<br>pure virtual: 你希望子类一定要重新定义它，你对它没有默认定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;   <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; msg)</span></span>;   <span class="comment">// 虚函数 </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">objectID</span><span class="params">()</span> <span class="keyword">const</span></span>;   <span class="comment">// 一般成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape &#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ellipse</span>:</span> <span class="keyword">public</span> Shape &#123;...&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a> <h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据所指对象的实际类型来调用相应的函数，如果对象类型是派生类，就调用派生类的函数，如果对象类型是基类，就调用基类的函数。</p><p>虚表：虚函数表的缩写，类中含有virtual关键字修饰的方法时，编译器会自动生成虚表</p><p>虚表指针：在含有虚函数的类实例化对象时，对象地址的前四个字节存储的指向虚表的指针</p><ul><li>编译器在发现基类中有虚函数时，会自动为每个含有虚函数的类生成一份虚表，该表是一个一维数组，虚表里保存了虚函数的入口地址</li><li>编译器会在每个对象的前四个字节中保存一个虚表指针，即vptr，指向对象所属类的虚表。在构造时，根据对象的类型去初始化虚指针vptr，从而让vptr指向正确的虚表，从而在调用虚函数时，能找到正确的函数</li><li>在派生类定义对象时，程序运行会自动调用构造函数，在构造函数中创建虚表并对虚表初始化。在构造子类对象时，会先调用父类的构造函数，此时，编译器只“看到了”父类，并为父类对象初始化虚表指针，令它指向父类的虚表；当调用子类的构造函数时，为子类对象初始化虚表指针，令它指向子类的虚表</li><li>当派生类对基类的虚函数没有重写时，派生类的虚表指针指向的是基类的虚表；当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表；当派生类中有自己的虚函数时，在自己的虚表中将此虚函数地址添加在后面</li></ul><h3 id="基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间"><a href="#基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间" class="headerlink" title="基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间"></a>基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间</h3><p>首先整理一下虚函数表的特征：</p><ul><li>虚函数表是全局共享的元素，即全局仅有一个，在编译时就构造完成</li><li>虚函数表类似一个数组，类对象中存储vptr指针，指向虚函数表，即虚函数表不是函数，不是程序代码，不可能存储在代码段</li><li>虚函数表存储虚函数的地址,即虚函数表的元素是指向类成员函数的指针,而类中虚函数的个数在编译时期可以确定，即虚函数表的大小可以确定,即大小是在编译时期确定的，不必动态分配内存空间存储虚函数表，所以不在堆中</li></ul><p>根据以上特征，虚函数表类似于类中静态成员变量。静态成员变量也是全局共享，大小确定，因此最有可能存在全局数据区。</p><p>由于虚表指针vptr跟虚函数密不可分，对于有虚函数或者继承于拥有虚函数的基类，对该类进行实例化时，在构造函数执行时会对虚表指针进行初始化，当一个构造函数被调用时，它做的首要的事情之中的一个是初始化它的VPTR，并且存在对象内存布局的最前面。</p><h3 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h3><p><a href="https://blog.csdn.net/qq_17368865/article/details/79108084">单继承与多重继承下的虚函数表</a></p><p>总结来说：</p><ul><li>一般继承无虚函数覆盖：父类虚函数在前，子类在后。</li><li>一般继承有虚函数覆盖：子类虚函数直接覆盖父类虚函数被重写的虚函数，其余不变。</li><li>多重继承无虚函数覆盖：每个父类都有自己的虚表，子类虚函数被放到第一个父类的虚函数表中。</li><li>多重继承无虚函数覆盖：子类虚函数覆盖所有父类虚函数表被重写的函数，其余不变。</li></ul><h3 id="补充：inline内联函数"><a href="#补充：inline内联函数" class="headerlink" title="补充：inline内联函数"></a>补充：inline内联函数</h3><p>内联函数和普通函数的区别在于：当编译器处理调用内联函数的语句时，不会将该语句编译成函数调用的指令，而是直接将整个函数体的代码插人调用语句处，就像整个函数体在调用处被重写了一遍一样。相比之下，普通函数能够避免将相同代码重写多次的麻烦，还能减少可执行程序的体积，但也会带来程序运行时间上的开销；而内联函数省去了调用函数的时间开销。</p><p><strong>在函数调用执行过程中，首先要为在栈中的形参和局部变量分配存储空间，然后再将实参的值复制给形参，然后还要将函数的返回地址放入栈中，最后才跳转到函数内部执行。return语句返回时，还要从栈中回收形参和局部变量占有的存储空间，然后从栈中取出返回地址，跳转到该地址继续执行。</strong></p><p>如果内联函数执行的时间很长，那函数调用的时间相比起来就微不足道，使用内联函数也就没有意义了。从另一方面来说，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。因此，内联函数中的代码应该是很简单，执行起来很快的一些语句。</p><p>Google C++编码规范对于inline的使用说明：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">内联函数：</span><br><span class="line">Tip： 只有当函数只有 <span class="number">10</span> 行甚至更少时才将其定义为内联函数.</span><br><span class="line"></span><br><span class="line">定义: 当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用.</span><br><span class="line"></span><br><span class="line">优点: 当函数体比较小的时候, 内联该函数可以令目标代码更加高效. 对于存取函数以及其它函数体比较短, 性能关键的函数, 鼓励使用内联.</span><br><span class="line"></span><br><span class="line">缺点: 滥用内联将导致程序变慢. 内联可能使目标代码量或增或减, 这取决于内联函数的大小. 内联非常短小的存取函数通常会减少代码大小, 但内联一个相当大的函数将戏剧性的增加代码大小. 现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快。</span><br><span class="line"></span><br><span class="line">结论: 一个较为合理的经验准则是, 不要内联超过 <span class="number">10</span> 行的函数. 谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!</span><br><span class="line"></span><br><span class="line">另一个实用的经验准则: 内联那些包含循环或 <span class="keyword">switch</span> 语句的函数常常是得不偿失 (除非在大多数情况下, 这些循环或 <span class="keyword">switch</span> 语句从不被执行).</span><br><span class="line"></span><br><span class="line">有些函数即使声明为内联的也不一定会被编译器内联, 这点很重要; 比如虚函数和递归函数就不会被正常内联. 通常, 递归函数不应该声明成内联函数.(递归调用堆栈的展开并不像循环那么简单, 比如递归层数在编译时可能是未知的, 大多数编译器都不支持内联递归函数). 虚函数内联的主要原因则是想把它的函数体放在类定义内, 为了图个方便, 抑或是当作文档描述其行为, 比如精短的存取函数.</span><br></pre></td></tr></table></figure><br>PS：内联函数和宏定义的区别：</p><ul><li><strong>内联函数在编译时展开，宏在预编译时展开</strong></li><li>内联函数直接嵌入到目标代码中，宏是简单的做文本替换</li><li><strong>内联函数有类型检测、语法判断等功能，而宏没有</strong></li><li>内联函数是函数，宏不是</li><li>宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义</li><li>内联函数代码是被放到符号表中，使用时像宏一样展开，没有调用的开销，效率很高</li></ul><h3 id="构造函数、析构函数、虚函数可否声明为内联函数"><a href="#构造函数、析构函数、虚函数可否声明为内联函数" class="headerlink" title="构造函数、析构函数、虚函数可否声明为内联函数"></a>构造函数、析构函数、虚函数可否声明为内联函数</h3><p>将这些函数声明为内联函数，在语法上没有错误。因为inline同register一样，只是个建议，编译器并不一定真正的内联。</p><ul><li>register关键字：这个关键字请求编译器尽可能的将变量存在CPU内部寄存器中，而不是通过内存寻址访问，以提高效率</li></ul><p>首先在《Effective C++》中明确阐述：<strong>将构造函数和析构函数声明为inline是没有什么意义的</strong>，即编译器并不真正对声明为inline的构造和析构函数进行内联操作，因为<strong>编译器会在构造和析构函数中添加额外的操作（申请/释放内存，构造/析构对象等）</strong>，致使构造函数/析构函数并不像看上去的那么精简。其次，class中的函数默认是inline型的，编译器也只是有选择性的inline，将构造函数和析构函数声明为内联函数是没有什么意义的。</p><p>虚函数是通过指针或引用调用函数时，通过虚函数表来确定调用的函数，在运行时确定。内联函数是在编译时，将调用函数处插入内联函数的代码，省去了函数调用时的开销。</p><h3 id="构造函数与虚函数"><a href="#构造函数与虚函数" class="headerlink" title="构造函数与虚函数"></a>构造函数与虚函数</h3><p>构造函数不可以是虚函数。</p><ol><li>从vptr角度解释：虚函数对应一个vtable，可是这个vtable其实是存储在对象的内存空间的。 那么问题来了，如果构造函数是虚函数，就要通过vtable来调用，可是对象空间还没有实例化，也就是内存空间还没有，无法找到vtable，所以构造函数不能是虚函数。</li><li>从使用角度：虚函数主要用于在信息不全的情况下，能够使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义。 </li></ol><h3 id="析构函数与虚函数"><a href="#析构函数与虚函数" class="headerlink" title="析构函数与虚函数"></a>析构函数与虚函数</h3><p>在派生类中的析构函数常常为虚析构函数，是为了避免内存泄露。</p><p>如果不考虑虚函数的状况，给出一个基类和派生类，如果调用派生类的析构函数时，肯定会引发调用基类的析构函数，这和析构函数是不是虚函数没关系。如：[ Derive* p = new Derive(); ]</p><p>现在考虑虚函数的问题，由于使用虚函数使我们可以定义一个基类指针或引用可以直接对派生类进行操作，如：[ Base* p = new Derive(); ]，这就存在两种情况：</p><p>如果，不把基类的析构函数设置为虚函数，则在删除对象时，如果直接删除基类指针，系统就只能调用基类析构函数，而不会调用派生类构造函数。这就会导致内存泄露。</p><p>如果，把基类的析构函数设置为虚函数，则在删除对象时，直接删除基类指针，系统会调用派生类析构函数，之后此派生类析构函数会引发系统自动调用自己的基类，这就不会导致内存泄露。</p><p>所以，在写一个类时，尽量将其析构函数设置为虚函数，但析构函数默认不是虚函数。</p><p>[问] 应该把所有的类的析构函数都设置为虚函数吗？<br>[答] 不一定。使用虚函数后的类对象要比不使用虚函数的类对象占的空间多，而且在查找具体使用哪一个虚函数时，还会有时间代价。即当一个类不打算作为基类时，不用将其中的函数设置为虚函数。</p><h3 id="在构造函数和析构函数中调用虚函数"><a href="#在构造函数和析构函数中调用虚函数" class="headerlink" title="在构造函数和析构函数中调用虚函数"></a>在构造函数和析构函数中调用虚函数</h3><p>语法上没有问题，但是体现不出多态性。<br>当实例化一个子类对象时，会先调用父类构造函数，此时子类对象还没有被完全创建，被当成一个父类对象，调用的是父类的虚函数。<br>同理，析构是先析构子类，然后析构父类，若父类调用析构函数，子类已经被析构了，只能调用父类自己的虚函数。</p><h3 id="构造函数和析构函数可以调用虚函数吗，为什么"><a href="#构造函数和析构函数可以调用虚函数吗，为什么" class="headerlink" title="构造函数和析构函数可以调用虚函数吗，为什么"></a>构造函数和析构函数可以调用虚函数吗，为什么</h3><p>不提倡在构造函数和析构函数中调用虚函数。</p><ul><li>因为父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全的，故而C++不会进行动态联编</li><li>析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义。</li></ul><h3 id="动态绑定和静态绑定"><a href="#动态绑定和静态绑定" class="headerlink" title="动态绑定和静态绑定"></a>动态绑定和静态绑定</h3><p>为了支持c++的多态性，才用了动态绑定和静态绑定。</p><ul><li>对象的静态类型：<strong>对象在声明时采用的类型。是在编译期确定的。</strong></li><li>对象的动态类型：<strong>目前所指对象的类型，是在运行期决定的。</strong>对象的动态类型可以更改，但是静态类型无法更改。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span>&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B &#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B &#123;&#125;</span><br><span class="line">D* pD = <span class="keyword">new</span> D();<span class="comment">//pD的静态类型是它声明的类型D*，动态类型也是D*</span></span><br><span class="line">B* pB = pD;<span class="comment">//pB的静态类型是它声明的类型B*，动态类型是pB所指向的对象pD的类型D*</span></span><br><span class="line">C* pC = <span class="keyword">new</span> C();</span><br><span class="line">pB = pC;<span class="comment">//pB的动态类型是可以更改的，现在它的动态类型是C*</span></span><br></pre></td></tr></table></figure><ul><li>静态绑定：绑定的是对象的静态类型，某特性（比如函数）依赖于对象的静态类型，发生在编译期。</li><li>动态绑定：绑定的是对象的动态类型，某特性（比如函数）依赖于对象的动态类型，发生在运行期。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfun</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">()</span></span>;<span class="comment">//首先说明一下，这个子类重新定义了父类的no-virtual函数，这是一个不好的设计，会导致名称遮掩；这里只是为了说明动态绑定和静态绑定才这样使用。</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfun</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfun</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">D* pD = <span class="keyword">new</span> D();</span><br><span class="line">B* pB = pD;</span><br></pre></td></tr></table></figure><p>pD-&gt;DoSomething() 和 pB-&gt;DoSomething() 是no-virtual函数，它是静态绑定的，也就是编译器会在编译期根据对象的静态类型来选择函数。</p><p>pD-&gt;vfun()和pB-&gt;vfun() 是一个虚函数，它动态绑定的，也就是说它绑定的是对象的动态类型，pB和pD虽然静态类型不同，但是他们同时指向一个对象，他们的动态类型是相同的，都是D*，所以，他们的调用的是同一个函数：D::vfun()。</p><p>需要特别注意：虚函数的缺省参数是静态绑定的！！！</p><p>总结：可以认为只有虚函数才使用的是动态绑定，其他的全部是静态绑定。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;继承-with-virtual-function&quot;&gt;&lt;a href=&quot;#继承-with-virtual-function&quot; class=&quot;headerlink&quot; title=&quot;继承 with virtual function&quot;&gt;&lt;/a&gt;继承 with virtual function&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;构造由内而外&lt;/strong&gt;：首先调用父类的构造函数，然后再调用自己。&lt;br&gt;&lt;strong&gt;析构由外而内&lt;/strong&gt;：首先执行自己的析构函数，然后调用父类的析构函数。&lt;/p&gt;
&lt;p&gt;non-virtual: 你不希望重新定义（重写）它。&lt;br&gt;virtual: 你希望子类重新定义它，且它有默认定义。&lt;br&gt;pure virtual: 你希望子类一定要重新定义它，你对它没有默认定义。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Shape&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;draw&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;/span&gt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;   &lt;span class=&quot;comment&quot;&gt;// 纯虚函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;&amp;amp; msg)&lt;/span&gt;&lt;/span&gt;;   &lt;span class=&quot;comment&quot;&gt;// 虚函数 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;objectID&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt;&lt;/span&gt;;   &lt;span class=&quot;comment&quot;&gt;// 一般成员函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Rectangle&lt;/span&gt;:&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Shape &amp;#123;...&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Ellipse&lt;/span&gt;:&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Shape &amp;#123;...&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="C++" scheme="https://www.benboby.top/categories/C/"/>
    
    
    <category term="C++面向对象" scheme="https://www.benboby.top/tags/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：最多可以参加的会议数目II</title>
    <link href="https://www.benboby.top/2021/02/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%A4%9A%E5%8F%AF%E4%BB%A5%E5%8F%82%E5%8A%A0%E7%9A%84%E4%BC%9A%E8%AE%AE%E6%95%B0%E7%9B%AEII.html"/>
    <id>https://www.benboby.top/2021/02/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%A4%9A%E5%8F%AF%E4%BB%A5%E5%8F%82%E5%8A%A0%E7%9A%84%E4%BC%9A%E8%AE%AE%E6%95%B0%E7%9B%AEII.html</id>
    <published>2021-02-07T02:02:39.000Z</published>
    <updated>2021-03-04T15:25:45.802Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你一个 $a$ 数组，其中 $a[i] = [startDay_i, endDay_i, value_i]$ ，表示第 $i$ 个会议在 $startDay_i$ 天开始，第 $endDay_i$ 天结束，如果你参加这个会议，你能得到价值 $value_i$ 。同时给你一个整数 $k$ 表示你能参加的最多会议数目。</p><p>你同一时间只能参加一个会议。如果你选择参加某个会议，那么你必须 <strong>完整</strong> 地参加完这个会议。会议结束日期是包含在会议内的，也就是说你不能同时参加一个开始日期与另一个结束日期相同的两个会议。</p><p>请你返回能得到的会议价值 <strong>最大和</strong>。$(k \in [1, n], k * n \in [1, 1e6], startDay_i, endDay_i \in [1, 1e9], value_i \in[1, 1e6])$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><a id="more"></a><p>考虑动态规划。$dp[i][j]$ 表示前 $i$ 个会议刚好选 $j$ 个时，能获得的最大价值。</p><p>那么对于每个 $dp[i][j]$ 有两种情况：</p><ul><li>不参加第 $i$ 个会议，有 $dp[i][j] = dp[i - 1][j]$</li><li>参加第 $i$ 个会议，设第 $i$ 个会议开始时间为 $l$，那么我们应该是从 <strong>所有结束时间小于 $l$ 且刚好选 $j - 1$ 个会议</strong> 的那个状态转移过来。那么最好的方式就是一开始就将 $a$ 按结束时间排序，这样我们就能很快二分出来结束时间刚好（最后一个）小于 $l$ 的那个会议 $p$，有 $dp[i][j] = max(dp[i][j], dp[p][j - 1] + a[i].value)$。</li></ul><p>时间复杂度 $O(nklog_n)$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> l, r, w;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Node&amp; a) <span class="keyword">const</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> r &lt; a.r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; a, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;Node&gt; <span class="title">q</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (k + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) q[i + <span class="number">1</span>] = &#123;a[i][<span class="number">0</span>], a[i][<span class="number">1</span>], a[i][<span class="number">2</span>]&#125;;</span><br><span class="line">        sort(q + <span class="number">1</span>, q + n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>, r = i, mid;</span><br><span class="line">            <span class="keyword">while</span> (l + <span class="number">1</span> &lt; r) &#123;</span><br><span class="line">                mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (q[mid].r &lt; q[i].l) l = mid;</span><br><span class="line">                <span class="keyword">else</span> r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++) </span><br><span class="line">                dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[l][j - <span class="number">1</span>] + q[i].w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给你一个 $a$ 数组，其中 $a[i] = [startDay_i, endDay_i, value_i]$ ，表示第 $i$ 个会议在 $startDay_i$ 天开始，第 $endDay_i$ 天结束，如果你参加这个会议，你能得到价值 $value_i$ 。同时给你一个整数 $k$ 表示你能参加的最多会议数目。&lt;/p&gt;
&lt;p&gt;你同一时间只能参加一个会议。如果你选择参加某个会议，那么你必须 &lt;strong&gt;完整&lt;/strong&gt; 地参加完这个会议。会议结束日期是包含在会议内的，也就是说你不能同时参加一个开始日期与另一个结束日期相同的两个会议。&lt;/p&gt;
&lt;p&gt;请你返回能得到的会议价值 &lt;strong&gt;最大和&lt;/strong&gt;。$(k \in [1, n], k * n \in [1, 1e6], startDay_i, endDay_i \in [1, 1e9], value_i \in[1, 1e6])$&lt;/p&gt;
&lt;h2 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h2&gt;</summary>
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="动态规划" scheme="https://www.benboby.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：滑动窗口中位数</title>
    <link href="https://www.benboby.top/2021/02/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%AD%E4%BD%8D%E6%95%B0.html"/>
    <id>https://www.benboby.top/2021/02/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%AD%E4%BD%8D%E6%95%B0.html</id>
    <published>2021-02-03T05:48:11.000Z</published>
    <updated>2021-02-03T05:59:56.952Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你一个数组 nums，有一个长度为 k 的窗口从最左端滑动到最右端。窗口中有 k 个数，每次窗口向右移动 1 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。$(n, k \in [1, 100000])$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>用优先队列+延迟删除有点麻烦，可以考虑直接用 <strong>multiset</strong> 做，本质都是一样的，维护两个大小相同或差一的集合（自动排序）$l 和 r$，$l$ 维护小于等于中位数的值，$r$ 维护大于等于中位数的值，$multiset$ 的优秀特性可以在 $log$ 时间复杂度内进行增删操作。具体细节较多，时间复杂度 $O(nlog(k))$。</p><a id="more"></a><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">medianSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">double</span>&gt; l, r;</span><br><span class="line">        <span class="keyword">int</span> n = a.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k) &#123;           <span class="comment">// 需要移除之前已经加入滑动窗口的元素</span></span><br><span class="line">                <span class="keyword">if</span> (l.count(a[i - k])) l.erase(l.find(a[i - k]));</span><br><span class="line">                <span class="keyword">else</span> r.erase(r.find(a[i - k]));</span><br><span class="line">            &#125;</span><br><span class="line">            l.insert((<span class="keyword">double</span>)a[i]);</span><br><span class="line">            <span class="keyword">while</span> (l.size() &amp;&amp; r.size() &amp;&amp; *(--l.end()) &gt; *r.begin()) &#123;   <span class="comment">// 左集合的元素不可能大于右集合</span></span><br><span class="line">                l.insert(*r.begin());</span><br><span class="line">                r.insert(*(--l.end()));</span><br><span class="line">                l.erase(*(--l.end()));</span><br><span class="line">                r.erase(*r.begin());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (l.size() - <span class="number">1</span> &gt; r.size()) &#123;            <span class="comment">// 左集合元素最多只会比右集合多一（窗口大小为奇数）</span></span><br><span class="line">                r.insert(*(--l.end()));</span><br><span class="line">                l.erase(--l.end());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;         </span><br><span class="line">                <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res.push_back(*(--l.end()));</span><br><span class="line">                <span class="keyword">else</span> res.push_back((*(--l.end()) + *r.begin()) / <span class="number">2.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给你一个数组 nums，有一个长度为 k 的窗口从最左端滑动到最右端。窗口中有 k 个数，每次窗口向右移动 1 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。$(n, k \in [1, 100000])$&lt;/p&gt;
&lt;h2 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h2&gt;&lt;p&gt;用优先队列+延迟删除有点麻烦，可以考虑直接用 &lt;strong&gt;multiset&lt;/strong&gt; 做，本质都是一样的，维护两个大小相同或差一的集合（自动排序）$l 和 r$，$l$ 维护小于等于中位数的值，$r$ 维护大于等于中位数的值，$multiset$ 的优秀特性可以在 $log$ 时间复杂度内进行增删操作。具体细节较多，时间复杂度 $O(nlog(k))$。&lt;/p&gt;</summary>
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="STL" scheme="https://www.benboby.top/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>LinuxC++网络编程学习笔记</title>
    <link href="https://www.benboby.top/2021/02/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
    <id>https://www.benboby.top/2021/02/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</id>
    <published>2021-02-02T10:06:30.000Z</published>
    <updated>2021-03-07T14:42:55.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="主机字节序和网络字节序"><a href="#主机字节序和网络字节序" class="headerlink" title="主机字节序和网络字节序"></a>主机字节序和网络字节序</h2><p>字节在内存中的排列影响它实际的值，字节序分为<strong>大端序</strong>和<strong>小端序</strong>。大端序指一个整数的高位存储在内存的低地址处，小端序指一个整数的高位存储在内存的高地址处。</p><p>现代PC大多采用小端序，因此小端序又被称为<strong>主机字节序</strong>。</p><p>由于数据在两台使用不同字节序的主机之间进行传递是，接收到必然错误的解释了数据。解决的方法是：发送端总是把要发送的数据转化成大端序然后再发送，接受端明白对方传过来的数据总是采用大端序，所以接受端可以根据自身使用的字节序来决定是否对该数据进行转化。因此大端序也称为<strong>网络字节序</strong>。</p><a id="more"></a><p>Linux提供了四个函数来完成主机字节序和网络字节序之间的转化：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="comment">// 一般用于转换ip地址</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">htonl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> hostlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">ntonl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> netlong)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般用于转换端口</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">htons</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> hostshort)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> netshort)</span></span>;</span><br></pre></td></tr></table></figure><br>判断大小端：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">w</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">&#125;c;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   c.a = <span class="number">0x1234567</span>;</span><br><span class="line">   <span class="keyword">return</span> c.b == <span class="number">1</span>; <span class="comment">// 是否小端</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>解释一下原理：union联合体是共享内存的，c.a = 1 即最低位为1，其它都为0，小端模式低字节放在低地址中，所以b会被赋值为1。</p><h2 id="socket套接字"><a href="#socket套接字" class="headerlink" title="socket套接字"></a>socket套接字</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, ubt protocol)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>domain: PF_INET -&gt; IPv4, PF_INET6 -&gt; IPv6, PF_UNIX -&gt; UNIX本地协议族</li><li>type: SOCK_STREAM -&gt; TCP协议，SOCK_DGRAM -&gt; UDP协议</li><li>protocol: 一般都置位0，表示使用默认协议</li></ul><p>调用成功返回一个socket文件描述符，其实就是一个数字，这个数字具有唯一性，并且一直有效直到你close()这个数字为止；失败返回-1并设置errno。</p><p>文件描述符：unix哲学——一切皆文件，我们把socket也看成是文件描述符，用它来收发数据。send(), recv()。</p><p>一旦连接成功建立，双方的通讯就只需要通过该文件描述符即可。</p><h2 id="命名socket"><a href="#命名socket" class="headerlink" title="命名socket"></a>命名socket</h2><p>创建socket时，指定了地址族，却并未指定该地址族中的哪个具体socket地址。我们称socket与socket地址绑定称为给socket命名。服务端只有命名后，客户端才知道如何连接它。客户端通常不需要命名，采用匿名，操作系统会自动分配给它socket地址。使用的函数为bind()：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct* my_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>sockfd: socket文件描述符</li><li>my_addr: 这个地址将分配给未命名的sockfd文件描述符</li><li>addrlen: 该socket地址的长度</li></ul><p>相同的ip地址的相同端口只能被 bind() 一次，bind成功返回0，失败返回-1并设置errno。</p><p>关于bind绑定失败的情况，还需要详谈。。。</p><h2 id="监听socket"><a href="#监听socket" class="headerlink" title="监听socket"></a>监听socket</h2><p>socket被命名后，还不能被马上接受客户连接，我们需要创建一个监听队列用以存放待处理的客户连接：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure><br>listen 用于监听端口，作用于TCP连接中的服务端。</p><p>对于一个调用listen()进行监听的套接字，操作系统会给这个套接字维护两个队列：</p><ul><li>未完成队列：当服务端收到客户端第一次握手发送的SYN包时，就会在未完成队列中创建一个跟该 SYN 包对应的一项新的套接字（通常由(服务器ip + port, 客户端ip +port)组成）</li><li>已完成队列：三次握手完成后，连接变为ESTABISHED状态，从未完成队列进入已完成队列</li></ul><p>backlog的含义：已完成队列和未完成队列条目之和不能超过backlog。<br>RTT：未完成队列中任意一项在未完成队列中停留的时间，这个时间取决于客户端和服务器。对于客户端，RTT为前两次握手时间；对于服务端，RTT为后两次握手时间。</p><p>客户端的Connect()其实在第二次握手结束后已经返回了。</p><p>细节：</p><ol><li>如果两个队列之和已经达到最大上限，再有客户发送syn请求的话，这个请求会被服务器忽略；而客户端发现syn没有被回应，会重发请求包。</li><li>已完成队列中有客户端发来数据，但该套接字还未被accept函数取出，那么这个数据就会被保存在已连接的套接字的接收缓冲区中，接收的数据量取决于缓冲区有多大。</li></ol><h2 id="接受连接"><a href="#接受连接" class="headerlink" title="接受连接"></a>接受连接</h2><p>accept() 函数，从已完成连接队列中的队首取出一项（已经完成三次握手连接的客户端socket值），返回给进程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>sockfd 是执行过 listen 系统监听调用的 <strong>监听socket</strong>，只要服务端还在运行，那么它就应该一直存在（我们称已经处于ESTABISHED状态的客户端连接为 <strong>连接socket</strong>）</li><li>addr 被用于接收远端 socket 地址，该地址的长度由addrlen指出</li></ul><p>如果已完成队列为空，那么则会一直处于休眠等待状态，直到有内容时才唤醒。<br>accept返回的是对应TCP连接的套接字connfd。</p><p>如果建立连接后用户掉线，accept依然返回成功，因为它只负责从已完成队列中取出内容。</p><h2 id="发起连接"><a href="#发起连接" class="headerlink" title="发起连接"></a>发起连接</h2><p>客户端需要使用connect函数主动与服务器建立连接：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *serv_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><br>sockfd参数由socket系统调用返回一个socket，serv_addr参数是服务器监听的socket地址，addrlen则指定这个地址的长度。</p><p>connect成功时返回0。一旦成功建立连接，sockfd就唯一标识这个连接，客户端就可以通过读写sockfd来与服务器通信。失败返回-1并设置errno，常见的错误有：目的端口不存在，连接超时。</p><h2 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h2><p>关闭连接实际上就是关闭该连接对应的socket：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure><br>fd是待关闭的socket，close并非总是立即关闭一个连接，而是将fd的引用计数减一。当引用计数为0时，才最终关闭连接。<br>在多进程出现在，一次fork会使父进程中打开的socket引用计数加一，因此必须在父进程和子进程中都对该socket执行close才能将连接关闭。</p><h2 id="IO操作"><a href="#IO操作" class="headerlink" title="IO操作"></a>IO操作</h2><p>分为两个阶段：数据准备阶段，内核空间复制会用户进程缓冲区阶段。</p><p>在Unix中，一切皆文件，文件即是一串二进制流，不论是socket，FIFO，管道，终端，都是文件，对这些流进行数据收发操作即是IO操作。系统调用 read 读入数据，调用 write 写入数据。我们如何知道操作哪个流？文件描述符，即fd，而fd就是一个整数，对这个整数操作即是对文件操作。创建一个socket，返回一个文件描述符，对socket操作即是对这个描述符操作。</p><h2 id="阻塞-非阻塞"><a href="#阻塞-非阻塞" class="headerlink" title="阻塞/非阻塞"></a>阻塞/非阻塞</h2><p>阻塞IO：调用某个函数，该函数卡在这里（进入休眠状态）等待一个事情发生，然后才继续执行，这种函数一般称为阻塞函数。<br>非阻塞IO：充分利用时间片，效率更高。不断的调用accept，recvfrom函数检查有没有数据到来。</p><h2 id="同步-异步"><a href="#同步-异步" class="headerlink" title="同步/异步"></a>同步/异步</h2><p><strong>异步IO：</strong>调用一个异步I/O函数，我们要给这个函数指定一个接收缓冲区和一个回调函数。调用后，该函数会立即返回。其余判断交给操作系统，判断数据是否到来，如果到来，操作系统会把数据拷贝到你所指定的缓冲区里，然后调用回调函数通知你。</p><p><strong>异步和非阻塞的区别：</strong></p><ul><li>非阻塞I/O需要不停调用I/O函数来检查数据是否到来，一旦数据到来，就必须卡在I/O函数里把内核缓冲区复制到用户缓冲区，然后才执行结束</li><li>异步I/O只需要调用一次，然后你就可以去做别的事了，内核去帮你判断数据是否到来，最后通知你</li></ul><p><strong>同步I/O：</strong><br>select，poll，epoll都可以认为属于同步IO。</p><ul><li>首先调用select函数判断有无数据到来，没有则卡在那里</li><li>select返回之后，调用recvfrom去取数据，取数据时也会卡一下</li></ul><p>同步I/O看起来更麻烦一点，因为要调用两个函数才可以得到数据。但与阻塞式相比，优势在于I/O复用。</p><p><strong>I/O复用：</strong><br>又称为I/O多路复用，将多个socket（TCP连接）弄成一堆，select/poll/epoll等待这一堆的任何一个TCP连接有数据到来，再用具体的recvfrom去收。</p><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, struct timeval* timeout)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>nfds 指定被监听文件描述符总数，通常设置为select监听的所有文件描述符中的最大值加1，因为文件描述符是从0开始计数的。</li></ul><ol><li>创建所关注的事件描述符集合。分为三大类事件描述符集合（读事件、写事件、异常发生事件）</li><li>等待事件发生，轮询这三个事件描述符集合里的每一个事件描述符，检查是否有相应的事件发生，如果有就执行。</li></ol><h2 id="epoll技术"><a href="#epoll技术" class="headerlink" title="epoll技术"></a>epoll技术</h2><p>从Linux内核2.6开始引入，是一种典型的I/O多路复用技术，最大的特点就是支持高并发，完全没有会随着并发量提高而出现性能明显下降的情况，但是会造成一定内存消耗。</p><p>与select，poll不同的是，它使用一组函数来完成任务。epoll 把用户关心的文件描述符上的事件放在内核的一个事件表中，无需每次调用都要重复传入描述符，因此epoll需要一个额外的文件描述符，来唯一标示内核中的这个事件表，<strong>使用 epoll_create 来创建该文件描述符：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span>: </span></span><br></pre></td></tr></table></figure><br>size参数只是告诉内核事件表需要多大，还并不起作用。返回的文件描述符讲称为其它所有epoll系统调用函数的第一个参数，以指定要访问的内核事件表。</p><p>具体：创建一个eventpoll结构体对象，创建了一棵红黑树和一个双向链表，其中rbr指向该红黑树的根，rdlist指向该双向链表的头节点</p><p><strong>使用 epoll_ctl 来操作内核事件表：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br></pre></td></tr></table></figure><br>event 指定事件信息，fd为要操作的文件描述符(accept得到)，op指定操作类型：</p><ul><li>ADD，往事件表中注册fd上的事件，相当于向红黑树添加一个节点，key值为客户端连接产生的fd，如果已经存在该节点，则直接报错</li><li>MOD，修改fd上的注册事件，修改某个节点</li><li>DEL，删除fd上的注册事件，删除某个节点</li></ul><p>因此，红黑树上的节点来自于 epoll_ctl 操作。</p><p><strong>当事件发生时，我们需要通过 epoll_wait 函数来得到操作系统的通知。</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event* events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><br>双向链表中存放的是所有有事件/数据的请求，epoll_wait 遍历双向链表，把双向链表里面的数据拷贝出去，然后移除。</p><p>需要注意的是，在红黑树中的节点并不会被删除。实际上用的是一个结构体同时维护了红黑树和双向链表的节点内容：红黑树拥有指向父节点，子节点的指针，双向链表拥有指向上一个和下一个结点的指针。这种优秀的设计使得在删除双向链表的结点时并不会对红黑树产生影响，而是相互独立的，但维护的时候又可以一起维护，使得一个节点既可以作为红黑树节点，也可以作为双向链表节点，从而大大减少了内存浪费。</p><ul><li>epfd 为 epoll_create 返回的对象描述符</li><li>events指向一个数组，最大长度为 maxevents，表示此次 epoll_wait 调用最多可以收集到 maxevents 个（双向链表中）已经准备好的读写事件。</li></ul><p>什么时候内核会向双向链表中增加节点呢？</p><ul><li>客户端完成三次握手 ——&gt;  服务器需要accept()</li><li>当客户端关闭连接  ——&gt;  服务器也要调用close()关闭</li><li>客户端发送数据来  ——&gt;  服务器需要调用read(),recv()函数来收数据</li><li>当可以发送数据时  ——&gt;  服务器调用send(),write()</li></ul><h2 id="LT-和-ET-模式"><a href="#LT-和-ET-模式" class="headerlink" title="LT 和 ET 模式"></a>LT 和 ET 模式</h2><p>epoll对文件描述符的操作有两种模式：<br>LT：水平触发，低速效率较低，默认模式，如果这个事件没有被处理完，就会被一直触发<br>ET：边沿触发，高速模式，效率高，只会被触发一次，但代价是编码难度加大</p><p>为什么ET模式事件只触发一次：ET模式事件只会被扔到双向链表一次，被 epoll_wait 取出后销毁。</p><p>为什么LT模式事件会触发多次：如果事件没有处理完，就会被多次扔进双向链表。</p><p>如果收发数据包没有具体格式，可以考虑用ET模式。</p><h2 id="TCP粘包"><a href="#TCP粘包" class="headerlink" title="TCP粘包"></a>TCP粘包</h2><p>客户端粘包：短时间内多次send，客户端有 Nagle 优化算法，直接合并成一个数据包发送出去，导致粘包。因此只要关闭 Nagle 算法，就能解决客户端粘包问题。</p><p>服务端粘包：无论客户端是否粘包，都避免不了服务端都会粘包。两次recv之间需要时间，但如果这个时间内多个包来了，则这多个包可能就被第二次recv全部收走，导致一次recv就收走了所有的包。</p><p><strong>解决粘包：</strong>把几个包一个一个拆出来，能拆一个是一个。<br>如何拆包？每一个收发的数据包都遵循包头+包体的格式，包头固定【10个字节】，其中有一个变量记录整个包【包头+包体】的长度。这样就知道了包体的长度，然后只收包体长度一样多的字节即可。这样就收到一个完整的数据包。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;主机字节序和网络字节序&quot;&gt;&lt;a href=&quot;#主机字节序和网络字节序&quot; class=&quot;headerlink&quot; title=&quot;主机字节序和网络字节序&quot;&gt;&lt;/a&gt;主机字节序和网络字节序&lt;/h2&gt;&lt;p&gt;字节在内存中的排列影响它实际的值，字节序分为&lt;strong&gt;大端序&lt;/strong&gt;和&lt;strong&gt;小端序&lt;/strong&gt;。大端序指一个整数的高位存储在内存的低地址处，小端序指一个整数的高位存储在内存的高地址处。&lt;/p&gt;
&lt;p&gt;现代PC大多采用小端序，因此小端序又被称为&lt;strong&gt;主机字节序&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;由于数据在两台使用不同字节序的主机之间进行传递是，接收到必然错误的解释了数据。解决的方法是：发送端总是把要发送的数据转化成大端序然后再发送，接受端明白对方传过来的数据总是采用大端序，所以接受端可以根据自身使用的字节序来决定是否对该数据进行转化。因此大端序也称为&lt;strong&gt;网络字节序&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://www.benboby.top/categories/C/"/>
    
    
    <category term="网络编程" scheme="https://www.benboby.top/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++语言基础</title>
    <link href="https://www.benboby.top/2021/01/C-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80.html"/>
    <id>https://www.benboby.top/2021/01/C-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80.html</id>
    <published>2021-01-31T06:52:21.000Z</published>
    <updated>2021-03-07T01:40:45.247Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="39a8a7a344f7a45b03e9770311fd63ec366640621878a5614b3e6df96989edc1">88bfb973b5cd9a98289a5356073cb3e5594eb6ba137f50990b97deaa4f5157d63b171c88bd8e655090bc624df133b36ad9ad15e6810d106478bb206225a36c29bfffb124dc929dd0ca845e6ea57c1b6fe3b0cdf008f493989f4e85f69039b4a76c813ea12d04da9083127b52d23b3934aeeb03916df2878df84aa2480192523104803e4233b227fd3daa2ca063aeeace21258fa2e88c5cc1ed87a70450efdb07fdbea4026761ff928b132912e683e916dcc48fe77ead40e3e2c6eb37177e4a43a3739cb119e0dbb167744a7e029f30b7660ed893d14d032591d784e3e9af44201d45e3a430b4bc18f645cceacef51bf1288cfc02527af7e0f6bb304a669b31e5043834ea7f01a0abf0aba54da55c1861a66a1d2bd94776adbb463ead133ffe0acc243e9864158980692f22bd2b9baad06cc26b764e676286dd248669a109affec45b7614eb1cd74e324e0cc488557a9264a1e852a9c9fcd6b1a88f574a7e1ea506176abfd35bb5287bd459a5fec6ee879cfd9c93e0e24182717e650262f5d5fb7b756ff9c9da524b2a6b4958f696a6036793becd7c20fa0b939704f74daa9c549516654070aff8de7c90a7f0b0aa960ad4646c88766a76bb782cf88737a424fb6068dc2143840b2883616783bc37ed43c940a95293837451b056a430de3837e2e74358f11be7c667b7dfad55e53210b6246a079dbead8910e7b00030303ab2d8169defcd26db1e42e023724f83c2e59661a22c990953a0cf584db750cc7567263e75f2f70d6191da865a3c4330a73c3a0bda0de33ddf95da19bf30cd4d0b8934209fdca90552cb28a971e12953abf220b2ffd7f4f6afceb1ca8e0c6fd8e7428dbb8956a64921d3526d1f02385746f1b0b11eb1c87c7e9c0bab9df1f8a0fed43e93e7774c65c895c3696ac24d99d513eba682c8d415efff81f8ed34d28a02c8f138c757aed1dacf91ebcded4fcc16432d0ac334dadfe7186d053db7f69491d50317c914a2b0b3c246c163aec99f82941cc177d68b4dd1bfb73af3f8fd7e398ef83b278a3390dd97d3b199a3b10e377ea2d349b8117b5967be5d2f4b6401875c3368d7e0d9c26357c95722cd676f48a73f663384259c7ce61a1bd1d81fd270693297b3b2ab0664116d8e62f07ad858c8a7bf91449ae24b824baf2f9989bce9f826d0d84e10a8f037116b8ba835c1fa03890ab2d140d363da76e495d60828caebfc4cfdaae2aa182de448129eea1b79237a8b4478f85ad805d905d1ccfef0e4c0bbfe2f620af65d12b043cb77d9d7d0ab902bbd24f3d0ee9b1303f10af5fb3078e74f45d5fc2d206b43f5f93b9473c4f3c15e81034136d88ff68eb9ab93ebd9b49ebc5d3f1cea46afbd703934eb099b3d8efbd8bf756afed8ed4ea9fa1b3577c5550a6147534d2ccee9a5cc006b43372cbcc9ca96dd3ab60f3e35dd805984f3faf271124c10a1b8292f39895906a4671d812a3a62b3350dcfd8ece2e18df0f48d0edd39a02d3efe9cf0119423b7dee1e5cff8fdd9e5611fe8948e1cd6694c8c6765676f0a2f620c6e613eff9b703f2a744b16d41bbde675fd5ca70137b8d5a5526027b0e31308536c51ae780d3fa6a984ade92f9c96be7c85fba6e0221ad407a00be41bea25efb5354c63ed04db2871925be26925dfd275c79740e6815f6b1729dc0e236c59cab30e4e0a189dbe3446b708c1effdfc163157a2a2af62ff672e55720ff1cf239339c1d7f676a149c1f4643fefc733d8921b4afd680f9a75dd4cd65f85dda22444dc1525fe0ea7aa384ed6d3326f9be6000c3fd1c7124511e6d422569bcbf04daf6855aeff5f9b690ca87ce122eb914fb5c87f15a69d3236755aa740c07f91e1fded141d4afbfb2f5c0bc1db5a2ed2f23c03562a39f94a9cfe6c9dcb1cb0a9fdd93377f489ad26b730d96bff7319796ad172151f909c0e1465206161d535105a2266d1f23512ece5a4ac9c903e0982158bc37b0586c2a317d6e905f312fec64cad0ec6176f8dc6bc5e1f23cf4406bc949b35db4f6e1fa7659e993444db166a73250932a1a2fd4fa45e28c493244c77da3c4dca42a289d808f845f9b6981a5b9b9570aeb6639a78d4f70dcfd348056ae789b4a6175f015716a89aceb4c4ef9001f4bbb382f1ddb9f4c0ecb0a7e2dc6bef63fd4637e8cdf516ab79895dfcc487074fa0ef06e9be7cfc2165d857646abee544c96f9351aa228577219166bbb7b7ed989c1f0e5b1957e37120e8e4329f10c718a08ab710e7e30274dee0f3715cff43c0a1b743ff5d97d7313dfddac51a01a8f33c3432090899759d0f59cf6993eba8fbd3ffd9b191c7192c562918b9d935d2f558889333dbddd80961b2ef2fa39fe68e306ec8ec0ed14ed377d280299c4e521402c474dd1f02ec05d681fcb8de63b703bcb52d3718ffb8f5cd717b210488d51cb9ebe28b9ca878773e353bc0a7178d150b3be1ba3f73e5f55fbedf13357288b1e104e35f024b604098ea3b4a7434e6ced58487b35964828b900022d178bf1886055c581e2dd2a425dd6cf5fac2c30a03ab70fdc1e95901db6969f77e94799665a7951b56c18151f46c00041800f78a2dd9ad7e2f39bf8fd617d7e1f11c9175a42ddc3a4a1fdae889c27e795d536fd0cbd9c44725a391b5d2e163a0bfc86e114b89b72cbbc6ac201d28e960831a3c7c4c67c7c00d0c7534466dd862000a8f39130bb38420f2d2be18a894becfcb2048ccb60aadc76ff532101d4a1d4559dbbf59822311d228da16aa340896baf718078e01f72f7321250046ebf2e2f8451e8b3bf67315679cc624a45cfcdbedcd4c22493986f50370641ffb1e37b7e427ffe443b373a39787d6bc60df40f1c466f8fb0479effd5047246bdc5a008e3be18fd0a1a81e618530189f93a103b6b5330cee8de899209b7c670d7f0734cd407f44959be3dddb4b5868cc8bc435ecd58a4fb5b223e29185f0af25a4e0a723387065a06ad9e212e58a838948566df1b4f4266c262be805d97fb777daa52144d152eaccfe89e41eaea228ae35e2cf00ea5a7ab97488b45158ceaebd9dadd8a756626ca0548cde733dd3e83c2dff73f9ec56222e3bf7ed3915b22c827c7f7511be3bd1afe26c6b69347be090d99b79c67ba3a2232a7479ca98a8cd4c7db9036154652279c37c19f67a1ee70f944f381ea7ee5985dbbd8fda1e02bab4c4749ab400cfc496071b1667c38c7ef6b5e964188069a13fbfc6643725c5d0a010678addb49b9b542cf3397a72a8d8c334bc47c084abb675c614fbaa73e7eeb679d618a641ef8cf0d589edac887ee011fb64f7e6af6855d931c09f667dd61b3aa68d80c43c5c0d62a27aec7b4b06faf82b0304c8634148c95a68891da58e3fcabc7985777137487fa21e3ad7aef57a2cf8518d3e076ffe94b23bdd558c5314e1641713b95a4788a7b50ae7310a9b94292c2aa22b0c6318dee9c170995d5cd96896a28606b58c1c8b6273261ee3d1f0d9c5e28d12ffa1cb3f22981c827dcacaf94edc32553c8d488466ea7d0f0287d927bb8c40eb8599b7c11fd04955dce8adc1226e933672fcd6f7369c5704303feee8089c7bf56e2ce8675889da3c8375914475ce5411b6c7dad0f1cd2b6d7f76754c0de3041a13d754ee160de62e0b621b782e81677f740a7c133d0e17059e6818a8a006c18d689a28a615487e9c6a0d864e59f6a43ecba0f949940e02ab548fd4f6755f4ccdc2a2124c1c1925db50c7acc186449a1ef56de771330c32f9df61cfe01008e8a296e509f9db1befdc2339d78f30a5b03d299449be60d900c57acba695c303d6a6a3bca041218387fcdfddce3209f7528dce4d43e8b201dda1b7cb4003a0f2403fe035303e82d37b65414c2ebb0250bd2b7a22dad1785a114ebae39e6d14f7b8105ad33b59f7b3cbc2061ea54535c67d7d60db15fd38ed46f9233c913e1d2d41457e9994c21975bdfabc36e6e73897a8b53d24c38372f4faf564ed1c09d4ab67e703809fc4842c09a9f30a84cbeaf6e884b4ba22d8af611734aaea2f887ba0c97f5cb116fd685a60a6df522a6c58ba46079aff4c751a4b80ff8e7ee1248b23571ec838ebca028f67c129a1938a12f05b825252a9e95b796007308555135c6428eab5a081b24410495f7b30d86ad962795939e152bf84e37cb6de0ba64de3a39e2364ed8b134715c175c261250115d361ba9dd2a70f9f544aa7a7d1ae6dc00fac9d86e2bbe36106c2f805cc553e58ef597172b21c01ce19dc650fc954d5d6e7225695efdd4a074d7bf3ba1f58998a70d765d71373691bb5e76d2b392f0e446b205f521315f2e163c63c3d93e489f556bb0b3976feb06649b3364420bbb0d5fcaf5ed564e6fb809f382ab9d9c6af3bc9519c9ef0bd8a360c208f44c13cda0a9d21234b74735b732bea12839b04eb23e787cc1dce7c4e0f5d0eb98d17f77ffbf13bbdaa1a684d43b823edc4c0831106f0257ef193be804e72bc01474c866c9ab1da1b833689a8fdb378ac61c6d2c132f8c4155657faaea5ec2e6dcdca6a5a687f1294367bde6ed79862accd97464a1dbe4273d7a0eb229f1c98e42ace9e99ee6dfb6c39021c8c0216960aa5ea73e39be4765d338eba8b0e09c129a80b8251f8e3797276480d842df36ccf413d92cb32450d2667856699131755a222b5a34e6966c28a5a48a6f4d05e27240e04257f8e42eee59cf4c836ef446a0c0df9556f70758fd89c63f7af7ff68918939fd2ed07c8375ab24c9403b692787a2e961a6cc98520eb7123f5f154b620ca9258c0bdb5322257ef19a3706713d655410bd32469ad55fc12d5ae109d804bf957de4e4227464f034e0706cd76169c03e3b5aaec8ddfd5b7f1ceaf55f0896a165e22bf65e23044dee82bb0268ca292ce345a75e1405f8724a3c8203bec1ab5a94c0359ca15ab89ce752f99c08e8c019558815436d410c5c570742be317494d058247797b15615839935e5970147dd0d401959f3c4948e3e4677c1e0dcd06a3bf7bd1102020645e750604b4057d0802af370c1a29fd568653de102a912eb597b12fa127bd85ab3569b788c5a6ab8bcfeb82adc475bbd97af02c0e6f45218c8ddffcecd416c7699e182d161e13190d24b72f8b07e63db1b8c394c3c876896607dee3c26e677930f43875f597ba4e2ec61c90a71a13ade06f5c09d407ca3069b861625e555145b4679435ef89b0d5783ce00a1e28b44ee2008d6ba3b4ab106dff4320a0071d977cd6a59c6e23e4b53415557a2b9da6101affd018eec2502ded5f44de2aae66e8d4b4a735dffbd63b1ec62c3c872f9ca953bcfa9550bdc57976dcf1979a4a3853f9bf379511d9105552b90781b55345f8393af776d552fb8bd05f15194cc8368adf03a0d1fa8dfef07b848833f937c66514d949ffaa0beac3d8e906351b5e4f1ea5f78a69f0ab3a8479fb99ef3bb8d7fc843d5577f786fa9326cff31a8b8c04e2ba62542776c7f6965501d7eb9daa393bca1b7529c6296f24d203508e3b6c85ec37ac2bc3a34f1786e49538b2e29c74fe91cd77ef891a08e45a48a5de328693e950b01d4aa9389769c0a78bf96a64aa570687446e8eb437ae62412476eacd1f1c721b560993b7e570dee841b3207881fd40bfa19e947b3c2130f6aa19aacffa0fd0aa2f3e7cabee433e11e7f40ecbd0a68d7ccf7aac39d2768ff26895d8675027dc0325f08e0aebcd4fe9937c344233d819e9264b4733d3517f0863062bb5f27f22f545554a7d615798ce3e2dc7a25c6c54b18b90ad92e9c87fe40c05038f313c0ab2dba89ec7963d9f7274ce9f4c2f90ab86ac374c3803fdabe3d4c8f696511ecc7b160bdf0761d4e0876e0ea92d693d8377be1881c4734c9edde025e90a9861985c96c5b66eb070af5560bf595bc87b3d43ef13c0bcb653d37c324f40163248af89812280a7681866699c04e469249033a06353e6fd68027521e8220bae0b48eeeeb1646a7c874bd80d18f8542ad3b60ffccaa5d8e7a92868cfa7fc46fc0494d037f5f2b5c6c4943a80c94f7bcf51e94ffd2995f18a34ddcd0534023107639c6f95d47c8af94f7ce585eb87c85c97de3941f713f312718db0a7e53096b801e50206307f32d848cd93cc788f49303531eae28cfe03c679324d078d5987ade045657aff7a89b97d49c1d5b82c76cddde3f9c2f970b02f9a88ac6f3448c03e06e28171e7efad30f582458526304d83416f1e61ca055a518238df94cb51051ee473d2941f4fea5d1d365e3ecd6be8cf38c1e02ffe33bd818051244086b8ea413851aab14dd2981c1e04c721f6b9f174700273f9447f88d39b2f41ead066007637a62dcf16c6343206463d48acb45e64ad3ef854b5c9043f74554f032a13aae8d4e9b09e13d95135089e50c4afa6bedb71bd7b1bed76470671965e16ec93c75e3894bc7191fcab8a94d114b211dc571c3080d22ffab316c7c2b35e5f0250b72ed4b5c0abb2c843b15350f186364962a9baa514bd23474fe43c425133463585fa5ce1439d9572b813c69dcb680ff4605b03433f26e446db0988a9940b437fa9e2358f7a893dc0a421b371e65f6e98e1633cf4acd6fdef6707164ecefac6657b35f1eed81a2d9c672d87bcd4a4f6e307d75f4a1eaa2adf9c6e7057a5ba3e16674378555b00b60dea40a9e5a65710b36186f0ba4355f0425f9bbf515a77ac39fe4cadae0fcdf4cb698df1bb5a1e22ebba066f9d0ef006c184444b3d1f5ba02c44c8313378aa6865385f9b67ba91ee090ea18c105e467fbff763b176ff4ecafa5f753d306ff6c6c42c652b64d5fd7de22c0400c53bc65e1b06a1ac40a1aff0eda56f3e2338bab402ea9b00b6a2390321db9d305ea437adc9cd5c0dbbe950d93ac9c2facba722037efd7d0d80d1d9fed5c9aabb528d1386db93d767d9bf902d7075bd553efe6440dcb1696dbce95129365cbfe99edbaabb8cb35449caaa587bb1c2ea32aab55bb447aed6123ae8354685f3bc9c17dec6bbd218fa07ae073007e0ead041c784b644722ae59b1101dcb06ab9b5fa3e3dc88fbedcc72364de2802a1424d22070909805925419df962e3903c0eb3ee3fa8565ba565ecd756ce99f72ecb84b7031072f2493c41a29afa1c5d7488212732c88c6498624836ff208224c76321e9fd69f376befce892b0cddf4f4bca476faba77096786aa0690f1039973f416ccafe721023920080666e557b6c06e5513898f5d9867018efb42454aaad084b52afc3918b112ec14d5208985a633b8f2dfacba113bc8bf86f936929c1f72a82664861e2dcce6222a3d74ecce319d74dba4e8313bdd57b4a00762338c0e636f2c1d88b3290cd4fd715aea467a3930df6bf20ec4fbc788bb51b211294998551603b4e41585623563d4db4e0a5dedd668981e88b291d492adba59f48337d6d83651dab4f672ea2c4de0f34eb9ff77dc1ddadcd58734fd1d770923cfd6cdea4ef5da43164b4cf41f15e31aabc47db649528b45281206d6a7e70626cfa634bf737dc4551140c08f253e6ab20ce605e8eaf75499098d33f60a39cff92aef21225fb9857c4a0f4ec14717247e1ebc759773add04223d67256e39ec629c395571c2e062c53dbae63f0e34508f6c387c3c86157e077dce95a8c68769d048b289d027bcfc46d9c49d851e1e399b659c11a92cb2bb22a1a4438e29c2bdb88856873eaa93930bf39cf621ef9c4d7b37e5067d3738e18c2a73a54b92aac03a0cfd2395a86a2bbe0c549e9f9795bc40401e8a7df74a035c8188f9f1395188cc920f541587ded4a71f90c0c5b6f807308991aedd9043ceaea2f8a1883bae77c20de5f331e219612739e37434580bf086d13a34ec893b18d29fbd4fda3b3c075868354f4c53b740864c59725ff808b0db2b9283483bb3f66bd8f7e739a117839b12448c1da4d6aa9fd7ab78e199e40159e7238064db3b98445e045aa7e20822fae6c6624e192abc25ca27855bdf70500caf665c0296e18e7f82477d87f9739653bf8ce448e59ce203a3dfea8143d6c2b09f4ef2aa2385d2ad8d89ca9628594a668e3132320ad72abcdb3dc06f2cf1646852bba2f24e26aff45d6416c337af1324943c83addf09dded02107e5dd0a753e9d26217b48db56bffeaf0db75886f52d1bccb8790c267291ba0dfa74588b578e8521d249fbca610aa7af11f8cd6eb9f61947972990a1df3afa58482cf408f9d7794df1ea2ac8aedd97010601610e3771a12954fde88a51b3d1c2a92882ed60888f5ff81521317c071c020b1d9332dc6f9dcf7c898693663702d4416f8cea3a713d2a12055189434a9f07ba86a2d23409dfc36e8f54f72fe2e8c82c03e01ba8ac6505c7418417af7f569bd85fdb3b9bab22c33fcf6aa4f96d7b08e3ecf7f0fad9d6fd183d2f17f371d047ee547945ec5eb9516d89d6e6186199b0199ca310732a7251e8e4092054bf6f1eef5e71fd7b5c7458456fb38ed565a3a8490c70972dad552b5de839d58106344573bbd0edb6d80699cff91d316f941a3dc20a6ae3a92a0aa5d3831bfd7eb335dc56bf7a3a21503e67a0e3ef04f5d7c4afce38ef44b9a411475eb553443330ada947588b5d5da7b24b16ddc479569fb9f12f2a7b390f9b5b26c2da9860bfdcf8ce693daebc2ed7fcc1008804735834fb12ad3575737224400a6f663ed91fabc917a613463b041bd6c6fcf8ac36d4e691c832ba0d25fd42cfae65829d573c43adc576e78a49b28a14ef52f881658eddca4d741f96bcc1a949c0acdf10831694ae453abe57a55ffa8ce0824d06d16dd1e5504e835d8c464afe09b68c032dbff2623a1d4f9986913f0b73addb2dbba427a6f89204a3d9df4b9ba9f6a349efdb9b0aae955545a88ad79e1b816a6f9dbf179f02e90bfbf8bbfe0fef5112352fff37c72b20027b6940c69642c9754248281f35acfd8cedf5f255e354d47f703925ebbbbefad5cd9d0d43a7cd1436d102cb7fcc234e9e6c86369bdfa5e494ec4771b63b4a656ee53c8b8f90a20d9a0a50efe9c7a760bcc2925b5609e74cfc376b617bf817a38ca3154a946947dd5fd20429032e2a20d9f8b7831e7806352694a8a3ed0a66efae735cc5579c60b71b0e538d9d2dbce16880b6ac6fad0b2dc96c992e53b726720f284fd7e6b5fdcfdb71c12d658752dd3777548361cc29b47fc3d5e38d2d899a6330a4b4faabc01208d17ce7df22d634a752ca5fd415e3257292525949250c03df88fbdd8d69856853466c6bc9a0d0125b77560da970ba15fb5bba9054b4c25a7f84e2647f4050b32c0a50ef6087beab9d5b2e7f3378beed1f2c2b10fdacbb90bf5bf2a33cf4a38ca5610309aed407ed7f5b67c02b2b62dde717a20fa21c0c778862bfd8861339a7bcd6b7d40f8a4044ee3b3f91e9b833c3485703a416d2d0e39d6ae8425eb1d8b751e1c5f19904644db5d57b68bc4259afc82f6966b6285eff40993227da8ae7bec0b3a1a8c334c2fa7fb59608450a6600d96568a0baf5061c2830dfb50dff9032e79037bde887056b67f697ab7f67d10370009a64d214622dee0c71d6683a80774959a3ca5e1156df492b64f93c5253006eb24593162a02dfb45733573e7887915f914172eaa6711e9d22785f27aecd050d3e23a3f31c4d01e990628d5ec56d8f30335eed8ad31261afa2b74df01ead15e91d56a79f5a8403cd45f86619325c3b0a8b2bc658375f91373a508a76b606815055519518b6ce62f68f6f04985a445d39099e0009d7d483afba475cf757b8ca4fbb5c6173be4b9c2b6f1b7a032822f7edbe86d7ac2887b53cb4b8d782cefa932870e1a07bf37fc8e91679f5fb0a41c3104f12eb0878eea1b3fea2d9df3cf0dbde7b6a866be00b29e052c1b60299113a694127c94c3abbabe42dfccd22f9f5fe1863fa95665ef7a0b0a47be6064436767b8da2008c761bac270da986c0944bfedad41a437d7988144b81a5ac6a6453f151b77b62014a5fe725041a838ffbc01819d388408b2606325ba044179f3eca147b0b53e009b2cee2eb61a264e0111e89d1ac3630cf4653b598c668d1e89ff551cb255bb2d0a3a497e8c902bfbdd5556519d926749c9f8e297f1d480fc872f5287363d3eb6b1b85e8f194f2d1b5c3afac98be065c7e8b3f380448f3cb2759628910822fa4027059ab378e91662c6b098eb8e4d36398941e153c3e98d058a51d9d738fd079018fe1054895b4f9d04efc497dcfa496f82e4bc969d90ded2431d086f9a04e075845b3857efa86bcb305e92422d0c89e4b1ea596ab42bd9dbeb3e97ea5dd032a4ffe2dc738e6be71070c265a31459e4cc783897c9d62f8a8e250fd8fe7b564c965962b3139dde7fcabbc38407c45fad1ebba90d98f50c74c2b0ff2f5c7ba9a8f87ef2b72b55279bff96c6be1ee1e6093329371373ff7b17b8c8d346b5c962ba442e95a29770730d3c39f40dd857172fde0cfbdb561c37cb1accceadd116c59ec43a9590fc8f46535b232edba1fc36e7608fe641b0a9f83b6aaddbf1dc8b52e59e82a53e81a88ce0f06908eb069bea99a62326bfaba271f73e89c5b39acb9a8c64efff601616cc107c5c2a15a9070cf0b4cab8a3f3d4ec77588a1835678c616161ffea3cb9bb8a08796447ceaf570462fa760136a9b20688730d909933a344a174eb3f463caa99ca4b72f427b0ac06ae7b9ff79f713edf268650b31218e2b8f16cbf6f2548ddce78144aaaa4e12abc0768bd299c7e8ba98755c904f3ac04a964da38dc2b37ec84c59a8042dbafeb7f8280bd1242fb2e9eb151b9ce9ea7ae0ece22e76c04c4c6e8c02db07a8a7a9fe975bb3e895f4003f0e5e1948caecb88b80ec0fd291f9da7be63259ea8f7cacc870d3b405466b2a45d1f254f4d072c67df8f0d041d679bbce3a1efe0251cd882e0abafdcb1c24fc7d905e79ae819a25369a9b7f51144e5e3bea6cd61e91d470808c171c1c9f9b66a0e418b94ae0b573a70933d73a566e0e8ec7488d897fb71c52bd069a14fb00dc5e7fdc3d89941f4c9dc1d33d9c0c37d7363e02cc9c0bc970ec097acc92573872a39e99eec582c3b41500c82d8b09c49e65035ecfbf48a60015b4c7f9efdea442182eb797740c21ce57f25e2d54f82089a48881b6dc818ee30712aa4a5f5dc80d4efe47d6429c5a312a62e3fa84e7683aeb4e3c7f25073ed98093fa891f92d8bc60107b92adf59d0dfadb750f3775b9d96901ca97f6dd2e4f7b152c9d7278f0b87adff9bd83b35ca8f7627cfa3b187383157f3b0e8b233ecddef8d7ae5344743b95a2f36fef4b4a461ccca7ebe7476a61e56d8d35fcfe255ee3f4be4be97d6c7ff4ed7846d2265bc71ad7272416eb3b8baeea60ee02f08811e58b0fdc00ade9839e8de17188aaf20d3bdabb166836ef76a37fefd5967905e3592a3f4fac4d0b64f556ff613a3048f9ddb136a28f3eacb513f5f9bc49862de544267206c6bccb085d9299cd4248609c9524756c7d6aa27c7e3</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="C++" scheme="https://www.benboby.top/categories/C/"/>
    
    
    <category term="C++基础" scheme="https://www.benboby.top/tags/C-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：最小体力消耗路径</title>
    <link href="https://www.benboby.top/2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.html"/>
    <id>https://www.benboby.top/2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.html</id>
    <published>2021-01-29T01:02:03.000Z</published>
    <updated>2021-01-29T01:47:37.414Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个 $nm$ 的权值矩阵，求从左上角走到右下角。$(n, m \in [1, 100], w \in [1, 1e6])$</p><p>一条路径耗费的体力值是路径上相邻格子之间 <strong>高度差绝对值的最大值</strong> 决定的。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ol><li>二分答案：由于答案具有单调性，所以可以二分答案，然后通过 $bfs$ 进行验证。</li><li>并查集：类似于最小生成树，将所有的边都建出来，然后贪心的将当前权值最小的边加入集合，判断起点和终点是否联通即可。</li><li>最短路：将所有的边建出来，做一次起点到终点的最短路径即可。</li></ol><a id="more"></a><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仅给出第二种做法的代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 并查集模板</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; size;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="comment">// 当前连通分量数目</span></span><br><span class="line">        <span class="keyword">int</span> setCount;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        UnionFind(<span class="keyword">int</span> _n): n(_n), setCount(_n), parent(_n), size(_n, <span class="number">1</span>) &#123;</span><br><span class="line">            iota(parent.begin(), parent.end(), <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">findset</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> parent[x] == x ? x : parent[x] = findset(parent[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            x = findset(x);</span><br><span class="line">            y = findset(y);</span><br><span class="line">            <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (size[x] &lt; size[y]) &#123;</span><br><span class="line">                swap(x, y);</span><br><span class="line">            &#125;</span><br><span class="line">            parent[y] = x;</span><br><span class="line">            size[x] += size[y];</span><br><span class="line">            --setCount;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            x = findset(x);</span><br><span class="line">            y = findset(y);</span><br><span class="line">            <span class="keyword">return</span> x == y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> x, y, w;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumEffortPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = h.size(), m = h[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;Node&gt; g;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>) g.push_back(Node&#123;i * m + j, i * m + j - m, <span class="built_in">abs</span>(h[i][j] - h[i - <span class="number">1</span>][j])&#125;);</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) g.push_back(Node&#123;i * m + j, i * m + j - <span class="number">1</span>, <span class="built_in">abs</span>(h[i][j] - h[i][j - <span class="number">1</span>])&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(g.begin(), g.end(), [](Node&amp; a, Node&amp; b) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="function">UnionFind <span class="title">uf</span><span class="params">(n * m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : g) &#123;</span><br><span class="line">            uf.unite(p.x, p.y);</span><br><span class="line">            <span class="keyword">if</span> (uf.connected(<span class="number">0</span>, n * m - <span class="number">1</span>)) <span class="keyword">return</span> p.w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给定一个 $nm$ 的权值矩阵，求从左上角走到右下角。$(n, m \in [1, 100], w \in [1, 1e6])$&lt;/p&gt;
&lt;p&gt;一条路径耗费的体力值是路径上相邻格子之间 &lt;strong&gt;高度差绝对值的最大值&lt;/strong&gt; 决定的。&lt;/p&gt;
&lt;h2 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;二分答案：由于答案具有单调性，所以可以二分答案，然后通过 $bfs$ 进行验证。&lt;/li&gt;
&lt;li&gt;并查集：类似于最小生成树，将所有的边都建出来，然后贪心的将当前权值最小的边加入集合，判断起点和终点是否联通即可。&lt;/li&gt;
&lt;li&gt;最短路：将所有的边建出来，做一次起点到终点的最短路径即可。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="并查集" scheme="https://www.benboby.top/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="图论" scheme="https://www.benboby.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：解码异或后的排列</title>
    <link href="https://www.benboby.top/2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%A7%A3%E7%A0%81%E5%BC%82%E6%88%96%E5%90%8E%E7%9A%84%E6%8E%92%E5%88%97.html"/>
    <id>https://www.benboby.top/2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%A7%A3%E7%A0%81%E5%BC%82%E6%88%96%E5%90%8E%E7%9A%84%E6%8E%92%E5%88%97.html</id>
    <published>2021-01-24T01:10:06.000Z</published>
    <updated>2021-01-28T06:02:23.360Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你一个整数数组 $g$，它是前 $n$ 个正整数的排列，且 $n$ 是个 <strong>奇数</strong> 。</p><p>它被加密成另一个长度为 $n - 1$ 的整数数组 $a$ ，满足 $a[i] = g[i]$ ^ $g[i + 1]$。比方说，如果 $g = [1,3,2]$，那么 $a = [2,1]$。</p><p>给你 $a$ 数组，请你返回原始数组 $g$。题目保证答案存在且唯一。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><a id="more"></a><p>可以发现如果对 $a$ 数组做前缀异或和得到 $sum$ 数组，那么 $sum[i]$ 就表示 $g[0]$ ^ $g[i + 1]$ 的值。$n$ 恰好为奇数，因此如果将数组 $sum$ 全部异或起来，$g[0]$ 刚好为被异或偶数次而抵消，得到的结果为 $g[1]$ ^ $g[2]$ ^ … ^ $g[n]$，恰好只有 $g[0]$ 没有出现。然后将这个结果与 $1-n$ 的所有数异或，得到的就是 $g[0]$ 的值，然后递推即可。时间复杂度 $O(n)$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">decode</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.size(), sum = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">g</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) g[<span class="number">0</span>] ^= (sum ^= a[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++) g[<span class="number">0</span>] ^= i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) g[i + <span class="number">1</span>] = g[i] ^ a[i];</span><br><span class="line">        <span class="keyword">return</span> g;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给你一个整数数组 $g$，它是前 $n$ 个正整数的排列，且 $n$ 是个 &lt;strong&gt;奇数&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;它被加密成另一个长度为 $n - 1$ 的整数数组 $a$ ，满足 $a[i] = g[i]$ ^ $g[i + 1]$。比方说，如果 $g = [1,3,2]$，那么 $a = [2,1]$。&lt;/p&gt;
&lt;p&gt;给你 $a$ 数组，请你返回原始数组 $g$。题目保证答案存在且唯一。&lt;/p&gt;
&lt;h2 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h2&gt;</summary>
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="思维" scheme="https://www.benboby.top/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：最小高度树</title>
    <link href="https://www.benboby.top/2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91.html"/>
    <id>https://www.benboby.top/2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91.html</id>
    <published>2021-01-14T10:32:21.000Z</published>
    <updated>2021-01-28T06:02:23.354Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一颗树，求当树的高度最小时根的编号为多少。$(n \in [1, 2e4])$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给定一颗树，求当树的高度最小时根的编号为多少。$(n \in [1, 2e4])$&lt;/p&gt;
&lt;h2 id=&quot;Solution&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="树" scheme="https://www.benboby.top/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：交换字符串中的元素</title>
    <link href="https://www.benboby.top/2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E4%BA%A4%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0.html"/>
    <id>https://www.benboby.top/2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E4%BA%A4%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0.html</id>
    <published>2021-01-12T10:06:55.000Z</published>
    <updated>2021-01-28T06:02:23.361Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你一个字符串 $s$，以及该字符串中的一些「索引对」数组 $pairs$，其中 $pairs[i] = [a, b]$ 表示字符串中的两个索引（编号从 $0$ 开始）。</p><p>你可以 任意多次交换 在 $pairs$ 中任意一对索引处的字符。</p><p>返回在经过若干次交换后，$s$ 可以变成的按字典序最小的字符串。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><a id="more"></a><p>假设 $i$ 可以和 $j$ 交换，$j$ 可以和 $k$ 交换，那么 $i$ 就可以和 $k$ 交换，因此是具有传递关系的。因此将互相具有传递关系的索引看作一个集合，用并查集维护。然后对于每个集合，将字母从小到大排序放置即可。时间复杂度 $O(nlog(n))$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> fa[<span class="number">100005</span>], v[<span class="number">100005</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fa[x] == x ? x : fa[x] = find(fa[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">smallestStringWithSwaps</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) fa[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : pairs) &#123;</span><br><span class="line">            <span class="keyword">int</span> fx = find(p[<span class="number">0</span>]), fy = find(p[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (fx != fy) fa[fx] = fy;</span><br><span class="line">            v[p[<span class="number">0</span>]] = v[p[<span class="number">1</span>]] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; id[<span class="number">100005</span>];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; ch[<span class="number">100005</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!v[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> fx = find(i);</span><br><span class="line">            <span class="keyword">if</span> (!mp[fx]) mp[fx] = ++cnt;</span><br><span class="line">            id[mp[fx]].push_back(i);</span><br><span class="line">            ch[mp[fx]].push_back(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">            sort(ch[i].begin(), ch[i].end());</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ch[i].size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="keyword">int</span>)id[i].size(); j++) </span><br><span class="line">                s[id[i][j]] = ch[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给你一个字符串 $s$，以及该字符串中的一些「索引对」数组 $pairs$，其中 $pairs[i] = [a, b]$ 表示字符串中的两个索引（编号从 $0$ 开始）。&lt;/p&gt;
&lt;p&gt;你可以 任意多次交换 在 $pairs$ 中任意一对索引处的字符。&lt;/p&gt;
&lt;p&gt;返回在经过若干次交换后，$s$ 可以变成的按字典序最小的字符串。&lt;/p&gt;
&lt;h2 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h2&gt;</summary>
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="并查集" scheme="https://www.benboby.top/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络知识点</title>
    <link href="https://www.benboby.top/2021/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9.html"/>
    <id>https://www.benboby.top/2021/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9.html</id>
    <published>2021-01-10T10:06:30.000Z</published>
    <updated>2021-03-07T16:25:33.865Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><p><img src="http://img.benboby.top/%E6%A8%A1%E5%9E%8B%E5%B1%82%E6%AC%A11.png" alt><br>ISO七层：物理层，数据链路层，网络层，传输层，会话层，表示层，应用层。<br>TCP/IP分层模型：</p><ul><li>网络接口层，ARP地址解析协议，提供硬件间接口。</li><li>网间层，IP协议，负责数据的包装，寻址，和路由。</li><li>传输层，TCP协议提供可靠数据流传输服务，UDP协议提供不可靠的用户数据报服务。</li><li>应用层，FTP（文件传输协议），HTTP（超文本传输协议），Telent（远程终端协议）。</li></ul><h2 id="TCP首部"><a href="#TCP首部" class="headerlink" title="TCP首部"></a>TCP首部</h2><ul><li>源端口和目的端口，各2字节</li><li>序号，4字节，面向字节流传输，标识当前报文段发送数据的起始编号，接受方根据起始编号和数据大小，就可以推算出下一个应该接受报文的起始编号</li><li>确认号，4字节，下一个希望收到报文的起始编号，即表示：N之前编号的数据已经成功收到</li><li>数据偏移，4字节，数据部分离报文段起始位置有多远</li><li>保留位，6字节，暂时没用，留着以后使用</li><li>URG：说明有紧急数据，应尽快发送</li><li>ACK：建立连接后所有ACK报文必须置为1</li><li>PSH：。。。</li><li>RST：出现了严重错误，必须重新建立连接</li><li>SYN：请求连接</li><li>FIN：释放连接</li><li>窗口：发送本报文段的一方的接受窗口</li><li>检验和：检验报文的首部和数据是否发送改变</li><li>MSS：规定的最大报文长度</li></ul><a id="more"></a>    <h2 id="三次握手与四次挥手"><a href="#三次握手与四次挥手" class="headerlink" title="三次握手与四次挥手"></a>三次握手与四次挥手</h2><p><img src="http://img.benboby.top/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B1.png" alt></p><ul><li>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 SYN_Send 状态。</li><li>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。 同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。</li><li>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 establised 状态。</li><li>服务器收到 ACK 报文之后，也处于 establised 状态，此时，双方已建立起了链接。</li></ul><p><img src="http://img.benboby.top/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B1.png" alt></p><ul><li>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。</li><li>第二次握手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。</li><li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。</li><li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。 需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态</li><li>服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</li></ul><p>第2次握手传回了ACK，为什么还要传回SYN？<br>答：接收端传回发送端所发送的ACK是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。而回传SYN则是为了建立并确认从服务端到客户端的通信。</p><p>为什么连接的时候是三次握手，关闭的时候却是四次握手？<br>答：连接时，当服务端收到客户端的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文，其中 ACK 报文是用来应答的，SYN 是用来同步的。但关闭连接时，服务端收到 FIN 报文后，可能不会立即发送 FIN 报文，因为服务端可能该发送的报文还没有发完，因此只能先回复一个 ACK 报文表示确认收到了。等服务端所有报文都发送完了，才回复 FIN 信号关闭连接。故需要四次握手。</p><p>为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？<br>答：一个是当服务端没有收到ACK时，有时间重发ACK；二是经过2MSL就可以使本次连接所产生的所有报文都从网络中消失，下次连接就不会出现旧的连接请求报文。</p><p>MSL是最大报文生存时间，2MSL就是发送+回复的最大时间。如果ACK丢包了，那么一定会在2MSL之内收到服务端重发的FIN包。</p><p>为什么不能用两次握手进行连接？<br>答：客户端发出连接请求，未收到确认，于是重发，接收到确认，建立连接。但之前的连接请求却又到了服务端，服务端发送确认报文段，又建立了一次连接。</p><p>如果已经建立了连接，但是客户端突然出现故障了怎么办？<br>答：TCP还设有一个保活计时器，服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><h3 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h3><p>将数据段都当做16位整数，将这些加起来，最后取反，得到校验和。</p><p>发送方发送之前计算校验和并填充，接收方以同样的方式计算，进行比对。</p><h3 id="确认应答与序列号"><a href="#确认应答与序列号" class="headerlink" title="确认应答与序列号"></a>确认应答与序列号</h3><p>TCP对每个字节的数据都进行编号，就是序列号。接收方每次收到数据后，都会发送ACK报文以确认，报文中有相应的确认序列号，告诉发送方，下一次的数据应该从哪里开始发。</p><p>另一个作用是排序，因为数据包不一定是按序到达的，因此可以按序列号对数据包排序。</p><h3 id="TCP超时重传"><a href="#TCP超时重传" class="headerlink" title="TCP超时重传"></a>TCP超时重传</h3><p>超时重传指的是发送数据包到接收确认包之间的时间，如果超过了这个时间就会被认为丢包。（可能是数据丢包，也可能是确认报文丢包）</p><p>TCP每发送一个报文段，就会设置一次计时器。计时器设置的重传时间到了，还没有收到确认，就要重传这一报文段。</p><p>RTO：重传超时时间，<strong>发送端发送数据到重传数据</strong>的这一段等待时间<br>RTT：连接往返时间，<strong>发送端从发送TCP包接受到对应的立即响应</strong>所耗费的时间</p><p><img src="http://img.benboby.top/%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0.png" alt="RTO 和 RTT 比较示意图"></p><h2 id="ARQ协议"><a href="#ARQ协议" class="headerlink" title="ARQ协议"></a>ARQ协议</h2><p>停止等待ARQ：发完一个分组就停止，等待确认，超时就重发，确认收到再发送下一个分组。缺点是信道利用率低。</p><p>连续ARQ：维护一个发送窗口，分组内可用连续发送出去，接受方采用累计确认，对按序到达的最后一个发组发送确认，表明之前的已经全部收到了。<br>缺点： 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</p><h2 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h2><p>接受端缓冲区大小有限，发送的太快太多接受端来不及处理。</p><p>如果一个一个发数据段，等确认了再发下一个，效率就比较低。</p><p>滑动窗口是流量控制和核心，存在与TCP首部，TCP首部有个window字段，用于接受端告诉发送端自己还有多少缓冲区可以接收数据。</p><p>当window字段为0，就会停止发送数据。那什么时候可以继续发送数据？</p><p>一种可能是接收方去发一个报文去通知发送端可以继续发，但要是这个报文丢了，就会再次陷入僵局。</p><p>因此采取的策略当收到win=0的报文后，就开启一个计时器，每隔一段时间就发个测试报文测试一下，打听一下是否可以发数据了。</p><h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p>防止发送方发的太快，使得网络来不及处理，从而导致网络拥塞。</p><ol><li>慢开始：设置拥塞窗口cwnd为1，然后以指数增长（乘2），逐步发送数据。</li><li>拥塞避免：为了防止cwnd增加过快而导致网络拥塞，所以需要设置一个慢开始门限ssthresh状态变量，窗口大小增长到门限值，就改为执行拥塞避免算法，每经历过一次往返时间就使cwnd增加1。</li><li>快速重传：累计收到三个同样的确认报文，说明下一个报文还没有到达，认为拥塞发生了，立即重传该报文。</li><li>快速恢复：将当前窗口大小和门限值调整为当前窗口的一半，开始执行拥塞避免算法。</li></ol><p>流量控制和拥塞控制的区别：</p><ul><li>一个是丢包在接受端上，一个是丢包在路由器上。</li><li>一个是怕接受端来不及处理，一个怕网络拥塞，网络来不及处理</li></ul><h2 id="TCP和UDP区别"><a href="#TCP和UDP区别" class="headerlink" title="TCP和UDP区别"></a>TCP和UDP区别</h2><p>用户数据报协议 UDP（User Datagram Protocol）<br>传输控制协议 TCP（Transmission Control Protocol）</p><ul><li>TCP面向连接，UDP不需要建立连接，随时想发就发，也不会对数据报进行任何拆分，也就说明UDP是不可靠传输</li><li>UDP并不只是一对一的，有单播，多播，广播的功能</li><li>UDP面向报文，TCP面向字节流</li><li>UDP头部更小（源端口，目的端口，数据长度，校验和），只有8个字节，传输效率更高</li><li>TCP有流量控制，拥塞控制来保证安全性，UDP没有</li><li>UDP适用于事实通信（电话，直播），TCP适用于可靠传输（文件传输）</li></ul><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>HTTP（超文本传输协议），基于TCP/IP通信协议来传递数据，属于应用层的面向对象的协议。<br>特点：</p><ul><li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。</li><li>灵活：HTTP允许传输任意类型的数据对象。</li><li>无连接：无连接的含义是限制每次连接只处理一个请求。</li><li>无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传。</li><li>支持B/S及C/S模式。</li></ul><h2 id="从输入URL到页面加载发生了什么？"><a href="#从输入URL到页面加载发生了什么？" class="headerlink" title="从输入URL到页面加载发生了什么？"></a>从输入URL到页面加载发生了什么？</h2><ol><li>DNS 域名解析<br> 当你输入了 www.google.com 并按下回车后，浏览器检查输入框，发现不是 ip 地址，于是去 <strong>浏览器缓存</strong> 里面找有没有相关记录，发现没有，那就继续去 <strong>系统缓存</strong> 找，也就是系统中的 hosts 文件，还是没有，又继续去 <strong>路由器缓存</strong> 里面找，查看的是路由器映射表。接着，计算机将域名发送给 <strong>本地DNS服务器</strong>，也就是 <strong>提供本地连接的服务商</strong>，本地DNS服务器找不到的话，会将域名发送到 <strong>根域名服务器</strong>，也就是 <strong>‘.’</strong>，找不到就返回 <strong>顶级域名服务器 —— .com 的IP地址</strong>，再请求 <strong>顶级域名服务器IP</strong> 返回 <strong>二级域名服务器 —— google.com 的IP地址</strong>…直到找到对应的IP地址，然后返回给浏览器。</li><li>发起 TCP 连接（三次握手）<br> 知道IP地址后，<strong>传输层的TCP协议</strong>就可以向远端服务器发起连接请求了。</li><li>发送 HTTP 请求，接受 HTTP 响应<br> 连接上了，可以传输了。计算机需要将用户输入的地址封装成 <strong>HTTP Request 请求报文</strong>，发送到服务器，服务器收到请求后会发出应答，即响应数据。<br> HTTP请求报文格式：请求行+请求头+空行+消息体，请求行包括请求方式（GET/POST/DELETE/PUT）、请求资源路径（URL）、HTTP版本号。<br> HTTP响应报文格式：状态行+响应头+空行+消息体，状态行包括HTTP版本号、状态码、状态说明。</li><li>断开 TCP 连接（四次挥手）<br> 完成一次 HTTP 请求后，服务器并不是马上断开与客户端的连接。默认启用 <strong>持久连接</strong>，以便处理不久后到来的新请求，无需重新建立连接而增加慢启动开销，提高网络的吞吐能力。在反向代理软件 Nginx 中，持久连接超时时间默认值为 75 秒，如果 75 秒内没有新到达的请求，则断开与客户端的连接。同时，浏览器每隔 45 秒会向服务器发送 TCP keep-alive 探测包，来判断 TCP 连接状况，如果没有收到 ACK 应答，则主动断开与服务器的连接。</li><li>浏览器解析 HTML 代码，请求js，css等资源，最后进行页面渲染，显示出来。</li></ol><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>浏览器输入地址，浏览器去调用gethostbyname库函数，这个函数通过网卡给DNS服务器发送UDP请求，接收结果，然后将结果返回浏览器。</p><p>为什么是UDP？因为UDP快啊！UDP协议传输内容不能超过512字节，查询域名一般返回的内容都不会超过这么多。</p><p>但DNS还是有用到TCP的，DNS有两种类型服务器，主DNS服务器和辅助DNS服务器。当一个辅助DNS服务器启动时，需要与主DNS服务器通信，并加重数据信息，称为区域传送。</p><p>为什么是TCP？因为TCP可靠，而且传送的数据可能大于512字节。</p><h3 id="常见的状态码："><a href="#常见的状态码：" class="headerlink" title="常见的状态码："></a>常见的状态码：</h3><ul><li>1xx，表示成功发出请求正在处理</li><li>2xx，表示成功处理请求</li><li>3xx，表示需要完成请求，需要进行重定向</li><li>4xx，表示请求错误，妨碍了服务器的处理</li><li><p>5xx，表示服务器错误</p></li><li><p>200 请求被正确处理</p></li><li>301 资源被永久转移到另一个URL</li><li>302 资源被暂时转移到另一个URL</li><li>400 客户端请求有语法错误，不能被服务端识别</li><li>403 服务器收到请求，但拒绝提供服务（认证失败）</li><li>404 请求资源不存在</li><li>500 服务器执行请求发生错误</li></ul><h2 id="GET和POST区别"><a href="#GET和POST区别" class="headerlink" title="GET和POST区别"></a>GET和POST区别</h2><p>HTTP请求方法，POST和GET都是向服务器提交数据，并且都会从服务器获取数据。</p><ul><li>get通过地址栏传输，安全性较低，post通过报文传输，安全性更高一些，但也没多高，毕竟http本身就是不安全的</li><li>get长度受限于url长度，传输数据量小，post理论上没有限制</li><li>大部分情况下，get产生一个数据包，post产生两个数据包，也意味着get效率更高</li></ul><p>对于get请求，浏览器会把http head和 data 一起发送出去，服务器响应200，返回数据。<br>对于post请求，浏览器会先传http head，然后服务器响应100 continue，浏览器再发送data，服务器响应200，返回数据。</p><p>一般来说，做数据查询用get，做增删改用post（网站登陆，文件传输）。</p><p>HEAD类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头。</p><p>报文组成：</p><ul><li>对于Request：请求行，说明请求类型，要访问的资源以及HTTP版本；</li><li>对于Response：状态行，状态码，状态消息。</li><li>请求头，一些附加信息</li><li>空行，必须有</li><li>数据部分，是主体</li></ul><h2 id="浅谈HTTP中Get、Post、Put与Delete的区别"><a href="#浅谈HTTP中Get、Post、Put与Delete的区别" class="headerlink" title="浅谈HTTP中Get、Post、Put与Delete的区别"></a>浅谈HTTP中Get、Post、Put与Delete的区别</h2><p>1、GET请求会向数据库发索取数据的请求，从而来获取信息，该请求就像数据库的select操作一样，只是用来查询一下数据，不会修改、增加数据，不会影响资源的内容，即该请求不会产生副作用。无论进行多少次操作，结果都是一样的。</p><p>2、与GET不同的是，PUT请求是向服务器端发送数据的，从而改变信息，该请求就像数据库的update操作一样，用来修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。</p><p>3、POST请求同PUT请求类似，都是向服务器端发送数据的，但是该请求会改变数据的种类等资源，就像数据库的insert操作一样，会创建新的内容。几乎目前所有的提交操作都是用POST请求的。</p><p>4、DELETE请求顾名思义，就是用来删除某一个资源的，该请求就像数据库的delete操作。</p><p>就像前面所讲的一样，既然PUT和POST操作都是向服务器端发送数据的，那么两者有什么区别呢。。。POST主要作用在一个集合资源之上的（url），而PUT主要作用在一个具体资源之上的（url/xxx），通俗一下讲就是，如URL可以在客户端确定，那么可使用PUT，否则用POST。</p><h2 id="HTTP1-0、HTTP-1-1主要区别"><a href="#HTTP1-0、HTTP-1-1主要区别" class="headerlink" title="HTTP1.0、HTTP 1.1主要区别"></a>HTTP1.0、HTTP 1.1主要区别</h2><ol><li>HTTP1.1默认支持长连接，HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接。HTTP是基于TCP/IP协议的，创建一个TCP连接是需要经过三次握手的，有一定的开销，如果每次通讯都要重新建立连接的话，对性能有影响。因此最好能维持一个长连接，可以用一个长连接来发多个请求。</li><li>节约带宽，同post</li></ol><h2 id="cookie和session的作用和区别"><a href="#cookie和session的作用和区别" class="headerlink" title="cookie和session的作用和区别"></a>cookie和session的作用和区别</h2><p>Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端会把Cookie保存起来。</p><p>  当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。</p><p>Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。</p><p>  每个用户访问服务器都会建立一个session，那服务器是怎么标识用户的唯一身份呢？事实上，用户与服务器建立连接的同时，服务器会自动为其分配一个SessionId。</p><p>区别：</p><ul><li>cookie数据存放在客户的浏览器上，session数据放在服务器上。</li><li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用COOKIE</li><li>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗</li><li>将登陆信息等重要信息存放为SESSION，其他信息如果需要保留，可以放在COOKIE中</li></ul><h2 id="HTTP重定向过程"><a href="#HTTP重定向过程" class="headerlink" title="HTTP重定向过程"></a>HTTP重定向过程</h2><p>301:永久性转移<br>302:暂时性转移<br>重定向过程：客户浏览器发送http请求 ——&gt; web服务器接受后发送302状态码响应及对应新的location给客户浏览器 ——&gt; 客户浏览器发现是302响应，则自动再发送一个新的http请求，请求url是新的location地址 -&gt; 服务器根据此请求寻找资源并发送给客户。</p><h2 id="HTTP和HTTPS区别"><a href="#HTTP和HTTPS区别" class="headerlink" title="HTTP和HTTPS区别"></a>HTTP和HTTPS区别</h2><ul><li>HTTP通信使用明文,内容可能被窃听；HTTPS是具有安全性的SSL加密传输协议</li><li>HTTP不验证通信方身份，因此有可能遭遇伪装；HTTPS有验证机制</li><li>HTTP无法验证报文的完整性，所以有可能被篡改；HTTPS有完整性保护</li><li>HTTP使用80端口，HTTPS使用443端口</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;网络模型&quot;&gt;&lt;a href=&quot;#网络模型&quot; class=&quot;headerlink&quot; title=&quot;网络模型&quot;&gt;&lt;/a&gt;网络模型&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://img.benboby.top/%E6%A8%A1%E5%9E%8B%E5%B1%82%E6%AC%A11.png&quot; alt&gt;&lt;br&gt;ISO七层：物理层，数据链路层，网络层，传输层，会话层，表示层，应用层。&lt;br&gt;TCP/IP分层模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;网络接口层，ARP地址解析协议，提供硬件间接口。&lt;/li&gt;
&lt;li&gt;网间层，IP协议，负责数据的包装，寻址，和路由。&lt;/li&gt;
&lt;li&gt;传输层，TCP协议提供可靠数据流传输服务，UDP协议提供不可靠的用户数据报服务。&lt;/li&gt;
&lt;li&gt;应用层，FTP（文件传输协议），HTTP（超文本传输协议），Telent（远程终端协议）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;TCP首部&quot;&gt;&lt;a href=&quot;#TCP首部&quot; class=&quot;headerlink&quot; title=&quot;TCP首部&quot;&gt;&lt;/a&gt;TCP首部&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;源端口和目的端口，各2字节&lt;/li&gt;
&lt;li&gt;序号，4字节，面向字节流传输，标识当前报文段发送数据的起始编号，接受方根据起始编号和数据大小，就可以推算出下一个应该接受报文的起始编号&lt;/li&gt;
&lt;li&gt;确认号，4字节，下一个希望收到报文的起始编号，即表示：N之前编号的数据已经成功收到&lt;/li&gt;
&lt;li&gt;数据偏移，4字节，数据部分离报文段起始位置有多远&lt;/li&gt;
&lt;li&gt;保留位，6字节，暂时没用，留着以后使用&lt;/li&gt;
&lt;li&gt;URG：说明有紧急数据，应尽快发送&lt;/li&gt;
&lt;li&gt;ACK：建立连接后所有ACK报文必须置为1&lt;/li&gt;
&lt;li&gt;PSH：。。。&lt;/li&gt;
&lt;li&gt;RST：出现了严重错误，必须重新建立连接&lt;/li&gt;
&lt;li&gt;SYN：请求连接&lt;/li&gt;
&lt;li&gt;FIN：释放连接&lt;/li&gt;
&lt;li&gt;窗口：发送本报文段的一方的接受窗口&lt;/li&gt;
&lt;li&gt;检验和：检验报文的首部和数据是否发送改变&lt;/li&gt;
&lt;li&gt;MSS：规定的最大报文长度&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="https://www.benboby.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://www.benboby.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：货仓选址</title>
    <link href="https://www.benboby.top/2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%B4%A7%E4%BB%93%E9%80%89%E5%9D%80.html"/>
    <id>https://www.benboby.top/2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%B4%A7%E4%BB%93%E9%80%89%E5%9D%80.html</id>
    <published>2021-01-09T12:09:30.000Z</published>
    <updated>2021-01-28T06:02:23.350Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>在数轴上找到一个点，使得到其余 $n$ 个点距离之和最小。$(n \in [1, 1e5])$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>考虑绝对值不等式：<br><a id="more"></a> </p><p>当只有两个点 $a, b$ 时，有 $|a - x| + |b - x| &gt;= |a - b|$，为了满足 $|a - x| + |b - x| = |a - b|$ 关系，$x$ 必须选在 $a,b$ 两点之间。</p><p>拓展为 $n$ 个点，距离为 $|a[1] - x| + |a[2] - x| + … + |a[n - 1] - x| + |a[n] - x|$，收尾两两分组有 $(|a[1] - x| + |a[n] - x|) + (|a[2] - x| - |a[n - 2] - x| + …)$，两两应用绝对值不等式，$x$ 的位置必须满足在各个对应区间里。</p><p>得出结论：当 $n$ 为奇数时，$x$ 位置为中间那个点（因为刚好分组多出单独一个，满足最小性则必须将 $x$ 的位置选择为那个点，距离刚好为 $0$）；当 $n$ 为偶数时，$x$ 位置为中间两个点之间的任意位置都可。 </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, res, a[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    sort(a, a + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) res += <span class="built_in">abs</span>(a[i] - a[n &gt;&gt; <span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;在数轴上找到一个点，使得到其余 $n$ 个点距离之和最小。$(n \in [1, 1e5])$&lt;/p&gt;
&lt;h2 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h2&gt;&lt;p&gt;考虑绝对值不等式：&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="数学" scheme="https://www.benboby.top/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>操作系统知识点</title>
    <link href="https://www.benboby.top/2021/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9.html"/>
    <id>https://www.benboby.top/2021/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9.html</id>
    <published>2021-01-03T14:35:42.000Z</published>
    <updated>2021-03-04T13:27:55.978Z</updated>
    
    <content type="html"><![CDATA[<h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><p>并发：宏观上两个程序在同时运行，实际上是交织运行的，单个周期只运行了一个指令，用于提高效率。<br>并行：物理意义上的同时运行，如多核cpu，运行在不同的核上，互不影响。</p><h3 id="进程和线程的概念，区别，使用场景"><a href="#进程和线程的概念，区别，使用场景" class="headerlink" title="进程和线程的概念，区别，使用场景"></a>进程和线程的概念，区别，使用场景</h3><p>进程：<strong>资源分配的基本单位</strong>，实现了操作系统的并发。<br>线程：线程是进程的子任务，是<strong>CPU调度的基本单位</strong>，不拥有资源，但可以使用进程所属的资源。每个进程都有一个主线程，实际上是主线程来执行main函数中的代码。</p><p>进程在创建，撤销，切换时的开销都显著大于线程，系统要为之分配，回收，切换资源。</p><p>一个线程只属于一个进程，进程间不会相互影响，一个线程挂掉将影响整个进程挂掉。</p><p>线程并不是越多越好，每个线程都需要一个独立的堆栈空间，线程之间的切换需要保存很多中间状态，耗费程序运行时间。多线程开销远远小于多进程。</p><p>进程在同一时间只能干一件事，进程在执行过程中如果阻塞，整个进程就会挂起，然后其中有些工作并不依赖阻塞的资源，却还是卡在那里。因此引入线程，减少程序在并发时付出的时空开销。</p><a id="more"></a><h3 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a>进程间通信方式</h3><ol><li>管道<ul><li>普通管道PIPE：半双工，数据单向流动，一般申请两个，一个用于读一个用于写。只能用于有父子进程和兄弟进程之间，只存在于内存中。</li><li>命名管道FIFO：有具体的路径名，存在于文件系统中，因此可以在无关进程中交换数据。</li></ul></li><li>套接字socket：可以用于不同主机间进行通讯</li><li><p>系统IPC<br> 消息队列：消息的链接表，存放在内核中。具有写权限的进程可以向队列中添加消息，有读权限的进程可以从队列中读取信息。</p><ul><li>消息具有特定的格式和优先级，克服了信号传递信息少，管道只能承载无格式字节流已经缓冲区大小受限等特点</li><li>独立于发送和接收进程，进程终止是，消息队列及其内容不会被删除</li><li><p>可以实现消息的随机查询，不一定要先进先出地读取  </p><p>信号量：计数器，控制多进程对共享资源的访问。用于实现进程间的互斥和同步，不用于存储进程间的通信数据。一般需要结合共享内存和PV操作使用。</p><p>信号：用于通知接收进程某个事件已经发生</p><p>共享内存：使得多个进程可以访问同一块内存，不同进程可以及时看到对方进程中对共享内存的数据更新。</p></li><li>最快的IPC，进程直接对内存进行存取</li><li>多个进程可以同时操作，需要进行同步</li><li>需要同步操作，和互斥锁和信号量一起结合使用</li></ul></li></ol><h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><p>进程通信：进程间传送（大量）数据<br>进程同步：进程合作，进程间共同完成一项任务时之间的直接制约关系。<br>进程互斥：它主要源于资源共享，是进程之间的间接制约关系。每次只允许一个进程访问的资源称为<strong>临界资源</strong>，进程互斥就是保证每次只有一个进程使用临界资源。</p><h3 id="线程间通信方式"><a href="#线程间通信方式" class="headerlink" title="线程间通信方式"></a>线程间通信方式</h3><p>线程同步和进程同步的本质区别在于锁放在哪，放在私有的进程空间还是放在多进程共享的空间，并且看锁是否具备进程共享的属性。</p><ol><li>临界区：多个线程访问一个独占共享资源时，可以使用临界区对象，其它线程想访问，会被挂起，直到拥有临界区的线程放弃位置。</li><li>事件：允许一个线程在处理完之后，主动唤醒另外一个线程执行任务。</li><li>互斥量：互斥对象机制，拥有互斥对象的线程才有访问公共资源的权限。</li><li>信号量：允许多个线程在同一时刻访问同一个资源，但一般需要限制数目。</li></ol><h3 id="fork和vfork"><a href="#fork和vfork" class="headerlink" title="fork和vfork"></a>fork和vfork</h3><p>fork()创建一个子进程，返回2次，一次在子进程中返回0，一次在父进程中返回子进程的pid，<br>子进程和父进程共享内存空间，采用写时复制，即父子可以同时读取内存，但如果需要对内存进行修改的话，就会复制一份该进程单独使用。毕竟一开始就进行内存复制是很浪费效率的。</p><p>vfork创建的子进程先于父进程运行，父子进程共用数据段，但若子进程依赖父进程操作，就会产生死锁。</p><h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><ol><li>先来先服务FCFS：<br> 非枪占式，按请求顺序进行调度。容易导致长作业等待时间过长。</li><li>短作业优先SJF：<br> 非抢占式，按估计运行时间最短的顺序进行调度。如果短作业一直来，长作业容易饿死。</li><li>最短剩余时间优先SRTN：<br> 抢占式，按剩余运行时间进行调度。一个新作业来时，与当前进程的剩余时间进行比较。</li><li>时间片轮转：<br> 按FCFS分配成一个队列，每个进程轮流执行一个时间片。效率和时间片大小有很大关系。时间片太短，进程切换太频繁；时间片太长，实时性无法保证。</li><li>优先级调度<br> 给每个进程分配一个优先级，按优先级调度。为了防止低优先永远等不到，可以随着时间推移增加优先级。</li><li>多级反馈队列<br> 设计出多个队列，每个队列时间片大小都不同，时间片小的队列优先级越高。<br> 例如：一个进程先去时间片为1的队列，若出队后没有执行完，就去时间片2的队列队尾，以此类推。<br> 可以看成是时间片轮转+优先级调度结合，效率较高。</li></ol><h3 id="进程状态切换"><a href="#进程状态切换" class="headerlink" title="进程状态切换"></a>进程状态切换</h3><p>就绪态通过调度算法获得CPU时间，进入运行态；时间片用完进入就绪态，等待下一次调度。<br>运行态因确实资源（函数迟迟不返回），进入阻塞态，缺少CPU时间会使其进入就绪态。</p><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</p><p>操作系统将内存抽象成地址空间，每个程序都有自己的地址空间，这些地址空间被分成多个块，每一块称为一页。<strong>这些页被映射到物理内存，但不要求连续，也不要求所有也都在物理内存中。</strong>然后由操作系统来处理它们之间的映射关系，当程序引用不在物理内存中的页时，通过映射关系调入页面。</p><p>分段：操作系统分配给进程的内存空间中包含五个段：</p><ul><li>数据段：存放静态变量和已初始化不为0的全局变量</li><li>代码段：存放可执行文件的操作指令，只读不可写</li><li>BSS段：存放未初始化的全局变量</li><li>堆：存放动态分配的内存</li><li>栈：存放临时的局部变量和函数的参数值</li></ul><p>页的大小是固定的，由操作系统确定，仅仅是为了满足内存管理的需求；段的大小不固定，取决于当前运行的程序。</p><p>实现：</p><ol><li>足够容量的内存和外存</li><li>缺页中断：如果需执行的指令或访问的数据尚未在内存（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段调入到内存，然后继续执行程序</li><li>虚拟地址空间 ：逻辑地址到物理地址的变换。</li></ol><h3 id="分页系统地址映射"><a href="#分页系统地址映射" class="headerlink" title="分页系统地址映射"></a>分页系统地址映射</h3><p>内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（数组）存储着程序地址空间和物理内存空间的映射表。</p><p>一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。例如对于虚拟地址（0010 000000000100），前 4 位是存储页面号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。</p><p>物理地址 = 内存块号 * 页面大小 + 页内偏移量</p><h3 id="OS缺页置换算法，虚拟内存置换方式"><a href="#OS缺页置换算法，虚拟内存置换方式" class="headerlink" title="OS缺页置换算法，虚拟内存置换方式"></a>OS缺页置换算法，虚拟内存置换方式</h3><p>当访问内存中一个不存在的页时，且内存已满，就需要从内存中替换一个页。</p><ul><li>FIFO（先进先出）：置换最先进来的页面，即逗留时间最久的页面。</li><li>LFU：最不经常访问淘汰算法</li><li>LRU（最近最少访问）：置换最近一段时间内最久没被访问过的页面。</li></ul><h3 id="Linux锁机制"><a href="#Linux锁机制" class="headerlink" title="Linux锁机制"></a>Linux锁机制</h3><ol><li>互斥锁：mutex，用于保证任何时刻只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒。</li><li>读写锁：rwlock，分为读锁和写锁。允许多个线程同时读，但只能有一个线程写。写优先于读，一旦有写，则读必须等待。适用于读频率远远大于写的情况。</li><li>自旋锁：在任何时刻只能有一个线程访问对象，但是获取锁操作失败时，不会进入睡眠，而是在原地自旋，直到锁被释放。节省了线程从睡眠到被唤醒的消耗。适用于加锁时间短暂的情况下。</li></ol><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>多个进行相互等待对方资源，在得到所有资源继续运行之前，都不会释放自己已有的资源，这样造成了循环等待的现象，称为死锁。</p><p>产生死锁的的四个条件：</p><ol><li>互斥条件：一个资源每次只能被一个进程使用；</li><li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放；</li><li>不剥夺条件：进程已获得的资源，在没使用完之前，不能强行剥夺；</li><li>循环等待条件：多个进程之间形成一种互相循环等待资源的关系。</li></ol><p>防止死锁（程序运行前防止）的发生只需破坏死锁产生的四个必要条件之一即可，但开销非常之大，目前没有一个操作系统可以实现。因此最好的办法是预防，而不是解决。</p><p>而一般来说，大多数操作系统解决死锁的策略仅仅是忽略它。</p><p>预防（程序运行时防止）：银行家算法，在进行系统资源分配之前，先计算此次资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源分配给进程；否则，让进程等待。</p><p>解除：</p><ul><li>剥夺资源：从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态</li><li>撤消进程：可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态消除为止；所谓代价是指优先级、运行代价、进程的重要性和价值等。</li></ul><h3 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h3><p>由于需要限制不同程序之间的访问能力，防止获取别的内存数据进行随意读写，产生了用户态和内核态。当程序需要申请外部资源就会由用户态进入内核态。</p><p>内核态：系统程序在内核态运行。该状态下，CPU可以访问内存的所有数据，包括外围设备，例如硬盘、网卡等。</p><p>用户态：应用程序只在用户态运行。该状态下只能受限的访问内存且不允许访问外设，占用CPU的能力被剥夺，导致CPU资源可以被其他程序获得。</p><p>用户态切换内核态：</p><ol><li>系统调用：进程主动要求切换到内核态的一种方式，很多事情直接让程序去做是很危险的，于是内核态提供一些系统调用，程序通过这些系统调用让危险的事交由内核来执行。如fork，open，write，malloc等。</li><li>异常：用户态程序发生未知异常，转换到内核态处理此异常的相关程序中。如缺页异常。</li><li>中断：外围设备完成用户请求操作后，会向CPU发出中断信号，然后内核放下手头的工作去处理中断信号。如硬盘读写结束后，发出中断信号，内核态处理该信号。</li></ol><h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p>kill掉子进程，父进程会收到SIGCHILD信号，子进程变成僵尸进程。</p><p>一个子进程结束了，但父进程还活着。因为内核认为父进程可能还需要子进程的一些信息，所以就没有将他关闭。</p><p>解决掉僵尸进程方式有：重启电脑，或者把父进程kill掉。</p><p>我们应该坚决不允许僵尸进程的存在。所以对于fork行为，我们应该拦截到SIGCHILD信号，然后使用waitpid获取子进程终止状态（返回0表示获取到子进程已被关闭）。</p><p><strong>孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</strong></p><p><strong>守护进程：一般来说生存周期长，随着操作系统一起开启和关闭。与终端无关联，不会占用终端。</strong></p><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。<strong>但协程的特点在于是一个线程执行。</strong></p><p>和多线程比，协程最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。</p><p>第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;并发和并行&quot;&gt;&lt;a href=&quot;#并发和并行&quot; class=&quot;headerlink&quot; title=&quot;并发和并行&quot;&gt;&lt;/a&gt;并发和并行&lt;/h3&gt;&lt;p&gt;并发：宏观上两个程序在同时运行，实际上是交织运行的，单个周期只运行了一个指令，用于提高效率。&lt;br&gt;并行：物理意义上的同时运行，如多核cpu，运行在不同的核上，互不影响。&lt;/p&gt;
&lt;h3 id=&quot;进程和线程的概念，区别，使用场景&quot;&gt;&lt;a href=&quot;#进程和线程的概念，区别，使用场景&quot; class=&quot;headerlink&quot; title=&quot;进程和线程的概念，区别，使用场景&quot;&gt;&lt;/a&gt;进程和线程的概念，区别，使用场景&lt;/h3&gt;&lt;p&gt;进程：&lt;strong&gt;资源分配的基本单位&lt;/strong&gt;，实现了操作系统的并发。&lt;br&gt;线程：线程是进程的子任务，是&lt;strong&gt;CPU调度的基本单位&lt;/strong&gt;，不拥有资源，但可以使用进程所属的资源。每个进程都有一个主线程，实际上是主线程来执行main函数中的代码。&lt;/p&gt;
&lt;p&gt;进程在创建，撤销，切换时的开销都显著大于线程，系统要为之分配，回收，切换资源。&lt;/p&gt;
&lt;p&gt;一个线程只属于一个进程，进程间不会相互影响，一个线程挂掉将影响整个进程挂掉。&lt;/p&gt;
&lt;p&gt;线程并不是越多越好，每个线程都需要一个独立的堆栈空间，线程之间的切换需要保存很多中间状态，耗费程序运行时间。多线程开销远远小于多进程。&lt;/p&gt;
&lt;p&gt;进程在同一时间只能干一件事，进程在执行过程中如果阻塞，整个进程就会挂起，然后其中有些工作并不依赖阻塞的资源，却还是卡在那里。因此引入线程，减少程序在并发时付出的时空开销。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="https://www.benboby.top/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://www.benboby.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：按要求补齐数组</title>
    <link href="https://www.benboby.top/2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%8C%89%E8%A6%81%E6%B1%82%E8%A1%A5%E9%BD%90%E6%95%B0%E7%BB%84.html"/>
    <id>https://www.benboby.top/2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%8C%89%E8%A6%81%E6%B1%82%E8%A1%A5%E9%BD%90%E6%95%B0%E7%BB%84.html</id>
    <published>2020-12-29T05:09:57.000Z</published>
    <updated>2021-01-28T06:02:23.357Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个已排序的正整数数组 $nums$，和一个正整数 $n$ 。从 $[1, n]$ 区间内选取任意个数字补充到 $nums$ 中，使得 $[1, n]$ 区间内的任何数字都可以用 $nums$ 中某几个数字的和来表示。请输出满足上述要求的最少需要补充的数字个数。</p><h2 id="Soluiton"><a href="#Soluiton" class="headerlink" title="Soluiton"></a>Soluiton</h2><p>容易证明，对于正整数 $x$，如果区间 $[1,x−1]$ 内的所有数字都已经被覆盖，且 $x$ 在数组中，则区间 $[1,2x−1]$ 内的所有数字也都被覆盖。<br><a id="more"></a> </p><p>由此可以提出一个贪心的方案。每次找到未被数组 $nums$ 覆盖的最小的整数 $x$，在数组中补充 $x$，然后寻找下一个未被覆盖的最小的整数，重复上述步骤直到区间 $[1,n]$ 中的所有数字都被覆盖。</p><p>具体实现：</p><p>$x$ 表示当前能表示出 $[1, x - 1]$ 的所有数字，初始化为 $1$，枚举数组。</p><ul><li>若枚举到的数小等于 $x$，则加上，表示能表示出 $[1, x + num[i] - 1]$ 的所有数字，然后下标加 $1$</li><li>若枚举到的数大于 $x$，则说明 $x$ 无法被表示出来，我们需要增加一个数 $x$，然后$x$ 加上 $x$，表示能表示出 $[1, x + x - 1]$ 的所有数字</li></ul><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPatches</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, i = <span class="number">0</span>, m = a.size();</span><br><span class="line">        <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; m &amp;&amp; a[i] &lt;= x) &#123;</span><br><span class="line">                x += a[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                x *= <span class="number">2</span>;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给定一个已排序的正整数数组 $nums$，和一个正整数 $n$ 。从 $[1, n]$ 区间内选取任意个数字补充到 $nums$ 中，使得 $[1, n]$ 区间内的任何数字都可以用 $nums$ 中某几个数字的和来表示。请输出满足上述要求的最少需要补充的数字个数。&lt;/p&gt;
&lt;h2 id=&quot;Soluiton&quot;&gt;&lt;a href=&quot;#Soluiton&quot; class=&quot;headerlink&quot; title=&quot;Soluiton&quot;&gt;&lt;/a&gt;Soluiton&lt;/h2&gt;&lt;p&gt;容易证明，对于正整数 $x$，如果区间 $[1,x−1]$ 内的所有数字都已经被覆盖，且 $x$ 在数组中，则区间 $[1,2x−1]$ 内的所有数字也都被覆盖。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="贪心" scheme="https://www.benboby.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：最大矩形</title>
    <link href="https://www.benboby.top/2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2.html"/>
    <id>https://www.benboby.top/2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2.html</id>
    <published>2020-12-26T06:52:52.000Z</published>
    <updated>2021-01-28T06:02:23.348Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个仅包含 $0$ 和 $1$ 、大小为 $n * m$ 的二维二进制矩阵，找出只包含 $1$ 的最大矩形，并返回其面积。$(n, m \in [1, 200])$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>有一个子问题，求柱状图最大矩形。预先求出 $1-i$ 层的 $h[i]$ 然后利用套用子问题的模板即可，复杂度 $O(n * m)$.<br><a id="more"></a> </p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; h)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        st.push(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> n = h.size();</span><br><span class="line">        vector&lt;int&gt; l(n), r(n, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (st.top() != <span class="number">-1</span> &amp;&amp; h[st.top()] &gt;= h[i]) &#123;</span><br><span class="line">                r[st.top()] = i;</span><br><span class="line">                st.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            l[i] = st.top();</span><br><span class="line">            st.push(i); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) res = max(res, (r[i] - l[i] - <span class="number">1</span>) * h[i]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = a[<span class="number">0</span>].size(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">h</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) </span><br><span class="line">                h[j] = (a[i][j] == <span class="string">&#x27;1&#x27;</span> ? h[j] + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">            res = max(res, largestRectangleArea(h));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给定一个仅包含 $0$ 和 $1$ 、大小为 $n * m$ 的二维二进制矩阵，找出只包含 $1$ 的最大矩形，并返回其面积。$(n, m \in [1, 200])$&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;p&gt;有一个子问题，求柱状图最大矩形。预先求出 $1-i$ 层的 $h[i]$ 然后利用套用子问题的模板即可，复杂度 $O(n * m)$.&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="思维" scheme="https://www.benboby.top/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：共鸣问题</title>
    <link href="https://www.benboby.top/2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%85%B1%E9%B8%A3%E9%97%AE%E9%A2%98.html"/>
    <id>https://www.benboby.top/2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%85%B1%E9%B8%A3%E9%97%AE%E9%A2%98.html</id>
    <published>2020-12-23T13:46:43.000Z</published>
    <updated>2021-01-28T06:02:23.347Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>现在有 $n$ 个音符和 $m$ 对共鸣关系，编号为 $1-n$，每个音符自己有一个奏响时的优美程度，共鸣关系 $(x,y,z)$ 表示音符 $x$ 和 $y$ 同时奏响的额外优美程度是 $z$，同时不奏响则为 $-z$，其他情况为 $0$，求最大优美程度。$(n,m \in [1,1e5])$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对于一对共鸣关系而言，在不选的情况下收益为 $-z$，则选择一个的话，收益为 $-z + z = 0$，都选择的话为 $-z + 2z = z$。因此可以预先把每对关系的两个数都加上 $z$，刚开始我们是不选任何有联系的音符的，因此初值为 $-z$，那么选择一个数就会加上 $z$，选择两个就会加上 $2z$，满足了之前所讨论的关系。答案初始化为所有关系都不选的情况，即 $-sum(z)$，然后只要贪心的选择对答案有正贡献的值就行了。<br><a id="more"></a> </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param n int整型 </span></span><br><span class="line"><span class="comment">     * @param m int整型 </span></span><br><span class="line"><span class="comment">     * @param a int整型vector </span></span><br><span class="line"><span class="comment">     * @param b int整型vector&lt;vector&lt;&gt;&gt; </span></span><br><span class="line"><span class="comment">     * @return long长整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">wwork</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; c;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : a) c.push_back(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : b) &#123;</span><br><span class="line">            c[v[<span class="number">0</span>] - <span class="number">1</span>] += v[<span class="number">2</span>];</span><br><span class="line">            c[v[<span class="number">1</span>] - <span class="number">1</span>] += v[<span class="number">2</span>];</span><br><span class="line">            res -= v[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : c) res += max(x, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;现在有 $n$ 个音符和 $m$ 对共鸣关系，编号为 $1-n$，每个音符自己有一个奏响时的优美程度，共鸣关系 $(x,y,z)$ 表示音符 $x$ 和 $y$ 同时奏响的额外优美程度是 $z$，同时不奏响则为 $-z$，其他情况为 $0$，求最大优美程度。$(n,m \in [1,1e5])$&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;p&gt;对于一对共鸣关系而言，在不选的情况下收益为 $-z$，则选择一个的话，收益为 $-z + z = 0$，都选择的话为 $-z + 2z = z$。因此可以预先把每对关系的两个数都加上 $z$，刚开始我们是不选任何有联系的音符的，因此初值为 $-z$，那么选择一个数就会加上 $z$，选择两个就会加上 $2z$，满足了之前所讨论的关系。答案初始化为所有关系都不选的情况，即 $-sum(z)$，然后只要贪心的选择对答案有正贡献的值就行了。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="贪心" scheme="https://www.benboby.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：大逃离</title>
    <link href="https://www.benboby.top/2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%A4%A7%E9%80%83%E7%A6%BB.html"/>
    <id>https://www.benboby.top/2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%A4%A7%E9%80%83%E7%A6%BB.html</id>
    <published>2020-12-22T14:28:30.000Z</published>
    <updated>2021-01-28T06:02:23.343Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>从 $n$ 个数中任选 $k$ 个数，取得这 $k$ 个数中最大的一个数，求每个数被取得的概率。$(n, k \in [1, 2e5])$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>将数组排序后，枚举每个数被作为最大值的可能性，当第 $i$ 个数作为最大值时，其它 $k - 1$ 个一定从前 $i - 1$ 个里面选，即方案数为 $C(i - 1, k - 1)$，将其除以总方案数 $C(n, k)$ 即为被取得概率。<br><a id="more"></a> </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param n int整型 </span></span><br><span class="line"><span class="comment">     * @param k int整型 </span></span><br><span class="line"><span class="comment">     * @param Point int整型vector </span></span><br><span class="line"><span class="comment">     * @return int整型vector</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> f[<span class="number">200005</span>];</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">qp</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (b) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b &amp; <span class="number">1</span>) sum = sum * a % mod;</span><br><span class="line">            a = a * a % mod;</span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == m || m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> f[n] * qp(f[m], mod - <span class="number">2</span>) % mod * qp(f[n - m], mod - <span class="number">2</span>) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">city</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">auto</span> b = a;</span><br><span class="line">        sort(a.begin(), a.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">long</span> <span class="keyword">long</span>&gt; mp;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= <span class="number">200000</span>; ++i) &#123;</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &gt;= k) </span><br><span class="line">                mp[a[i]] = C(i, k - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = C(n, k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            g.push_back(mp[b[i]] * qp(sum, mod - <span class="number">2</span>) % mod);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> g;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;从 $n$ 个数中任选 $k$ 个数，取得这 $k$ 个数中最大的一个数，求每个数被取得的概率。$(n, k \in [1, 2e5])$&lt;/p&gt;
&lt;h2 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h2&gt;&lt;p&gt;将数组排序后，枚举每个数被作为最大值的可能性，当第 $i$ 个数作为最大值时，其它 $k - 1$ 个一定从前 $i - 1$ 个里面选，即方案数为 $C(i - 1, k - 1)$，将其除以总方案数 $C(n, k)$ 即为被取得概率。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="数学" scheme="https://www.benboby.top/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>GCC编译器和GDB调试器</title>
    <link href="https://www.benboby.top/2020/12/GCC%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8CGDB%E8%B0%83%E8%AF%95%E5%99%A8.html"/>
    <id>https://www.benboby.top/2020/12/GCC%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8CGDB%E8%B0%83%E8%AF%95%E5%99%A8.html</id>
    <published>2020-12-20T06:09:48.000Z</published>
    <updated>2021-03-01T01:27:54.568Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GCC编译器"><a href="#GCC编译器" class="headerlink" title="GCC编译器"></a>GCC编译器</h2><p>GCC 编译器支持编译 Go、Objective-C，Objective-C++，Fortran，Ada，D 和 BRIG（HSAIL）等程序。</p><p>实际使用中，使用 gcc 指令编译 C 代码，使用 g++ 指令编译 C++ 代码。</p><h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p>例如 <strong>g++ test.cpp -o test</strong> 可拆解为以下步骤：</p><a id="more"></a> <ol><li><p>预处理：处理以 # 开头的预处理命令</p> <figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># -E 选项指示编译器仅对输入文件进行预处理</span></span><br><span class="line"><span class="meta"># test.i 文件将头文件及宏定义具体内容全部展开，其余保持不变</span></span><br><span class="line">g++ -E test.cpp -o test.i    <span class="comment">// 生成.i文件</span></span><br></pre></td></tr></table></figure></li><li><p>编译：翻译成汇编文件</p> <figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># -S 编译选项告诉 g++ 在为 C++ 代码产生了汇编语言文件后停止编译</span></span><br><span class="line"><span class="meta"># g++ 产生的汇编语言文件缺省拓展名是 .s</span></span><br><span class="line"><span class="meta"># test.s 汇编语言文件内容为汇编指令</span></span><br><span class="line">g++ -S test.i -o test.s</span><br></pre></td></tr></table></figure></li><li><p>汇编：将汇编文件翻译成可重定位目标文件</p> <figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># -c 选项告诉 g++ 仅把源代码编译为机器语言的目标代码</span></span><br><span class="line"><span class="meta"># 缺省时 g++ 建立的目标代码文件有一个 .o 的拓展名</span></span><br><span class="line"><span class="meta"># test.o 为机器语言识别的二进制代码</span></span><br><span class="line">g++ -c test.s -o test.o</span><br></pre></td></tr></table></figure></li><li><p>链接：将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -o 编译选项来为将产生的可执行文件用指定的文件名</span></span><br><span class="line"><span class="comment"># test 为可执行文件</span></span><br><span class="line">g++ <span class="keyword">test</span>.o -o <span class="keyword">test</span></span><br></pre></td></tr></table></figure><h3 id="静态链接和动态链接"><a href="#静态链接和动态链接" class="headerlink" title="静态链接和动态链接"></a>静态链接和动态链接</h3><p>动态库一般都会存在/usr/lib/ 目录下；而静态库可以在任何目录下，只要你第一次链接的时候，用绝对路径去链接就行了，之后再删除，是不会影响你的生成的执行文件的。</p></li></ol><p>当然动态库和静态库可以放置到你想放的任何地方，只是动态库需要设置环境变量，而静态库链接的时候需要绝对路径。</p><p><strong>静态连接：</strong><br>源文件中包含的头文件和程序中使用到的库函数，如stdio.h中定义的printf()函数，在libc.a中找到目标文件printf.o(这里暂且不考虑printf()函数的依赖关系)，然后将这个目标文件和我们hello.o这个文件进行链接形成我们的可执行文件。</p><p>可以发现静态运行库里面的一个目标文件只包含一个函数，如libc.a里面的printf.o只有printf()函数，strlen.o里面只有strlen()函数。因为如果很多函数都放在一个目标文件中，很可能很多没用的函数都被一起链接进了输出结果中，十分浪费空间。</p><p>缺点是浪费空间，因为每一个可执行程序都需要堆关联的静态库目标文件有一份拷贝，因此同一个目标文件可能在内存里就有多次拷贝。一旦代码修改，也得重新进行编译。<br>优点就是可执行程序已经具备了这些库文件，因此运行时的速度更快。</p><p><strong>动态连接：</strong><br>简单来说就是目标文件不会在链接阶段链接，而是推迟到了运行时，检查相关目标文件是否已经存在于内存之中，即共享一份副本。</p><p>也就是生成的可执行文件并没有要链接的内容，代码运行后再去找，这时候如果动态库被删除，就无法成功运行。 </p><p>优点是空间占用更少，缺点是运行时效率降低，但一般不超过5%，因此可以忽略。</p><h3 id="g-重要编译参数"><a href="#g-重要编译参数" class="headerlink" title="g++重要编译参数"></a>g++重要编译参数</h3><ol><li><p>-g 编译带调试信息的可执行文件</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -g 选项告诉 GCC 产生能被 GNU 调试器 GDB 使用的调试信息，以调试程序。</span></span><br><span class="line"><span class="comment"># 产生带调试信息的可执行文件 test（不加则 test 不包含调试信息）</span></span><br><span class="line">g++ -g <span class="keyword">test</span>.cpp -o <span class="keyword">test</span></span><br></pre></td></tr></table></figure></li><li><p>-O[n] 优化源代码</p> <figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 所谓优化，比如省略代码中从未使用过的变量，直接将常量表达式用结果值来替代等等，这些操作会缩减目标文件所包含的代码量，提高最终生成的可执行文件的运行效率。</span></span><br><span class="line"><span class="meta"># -O 选项告诉 g++ 对源代码进行基本优化。这些操作在大多数情况下都会使程序执行的更快。-O2 选项告诉 g++ 产生尽可能小和尽可能快的代码。</span></span><br><span class="line"><span class="meta"># -O 同时减小代码长度和执行时间，效果等价为 -O1</span></span><br><span class="line"><span class="meta"># -O0 表示不做优化</span></span><br><span class="line"><span class="meta"># -O1 默认优化</span></span><br><span class="line"><span class="meta"># -O2 除了完成 -O1 的优化之外，还进行一些额外的调整工作，如指令调整等</span></span><br><span class="line"><span class="meta"># -O3 包括循环展开和其他一些与处理特性相关的优化操作</span></span><br><span class="line"><span class="meta"># 选项将使编译的速度比使用 -O 时慢，但通常产生的代码执行速度会更快</span></span><br><span class="line"><span class="meta"># 可以用如 &quot;time ./test&quot; 来查看可执行文件的运行效率，比较优化效果</span></span><br><span class="line">g++ -O2 test.cpp</span><br></pre></td></tr></table></figure></li><li><p>-l 和 -L 指定库文件 ｜ 指定库文件路径</p> <figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># -l 参数就是用来指定程序要链接的库，-l 参数紧接着就是库名</span></span><br><span class="line"><span class="meta"># 在 /lib 和 /usr/lib 和 /usr/local/lib 里的库可以直接用 -l 来进行链接</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 链接 glog库</span></span><br><span class="line">g++ -lglog test.cpp</span><br><span class="line"></span><br><span class="line"><span class="meta"># 如果库文件没放在上面三个目录里，需要使用 -L 参数指定库文件所在目录</span></span><br><span class="line"><span class="meta"># -L 参数紧接着的是库文件所在的目录名</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 链接 mytest 库，libmytest.so 在 /home/Test 目录下</span></span><br><span class="line">g++ -L/home/Test -lmytest test.cpp</span><br></pre></td></tr></table></figure></li><li><p>-I 指定头文件搜索目录</p> <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 若头文件在 /usr/<span class="keyword">include</span> 目录下一般是不需要指定的，否则就需要 -I 参数来指定了，比如头文件放在 /myinclude 目录里，否则会报错 “xxxx.<span class="keyword">h</span>: <span class="keyword">No</span> such <span class="keyword">file</span> or directory” 。</span><br><span class="line"><span class="keyword">g</span>++ -I/myinclude <span class="keyword">test</span>.cpp</span><br></pre></td></tr></table></figure></li><li><p>-Wall 打印警告信息 | -w 关闭警告信息</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印出 gcc 的警告信息</span></span><br><span class="line">g++ -Wall <span class="keyword">test</span>.cpp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭所有警告信息</span></span><br><span class="line">g++ -w <span class="keyword">test</span>.cpp</span><br></pre></td></tr></table></figure></li><li><p>-std=c++11 设置编译标准</p> <figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span> <span class="comment">使用</span> <span class="comment">c</span>++<span class="comment">11</span> <span class="comment">标准编译</span> <span class="comment">test</span><span class="string">.</span><span class="comment">cpp</span></span><br><span class="line"><span class="comment">g</span>++ <span class="literal">-</span><span class="comment">std=c</span>++<span class="comment">11</span> <span class="comment">test</span><span class="string">.</span><span class="comment">cpp</span></span><br></pre></td></tr></table></figure></li><li>-o 指定输出文件名 <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定即将产生的文件名</span></span><br><span class="line"><span class="comment"># 指定输出可执行文件名为test</span></span><br><span class="line">g++ <span class="keyword">test</span>.cpp -o <span class="keyword">test</span></span><br></pre></td></tr></table></figure></li><li><p>-D 定义宏</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 在使用gcc/g++编译的时候定义宏</span><br><span class="line"># 常用场景：</span><br><span class="line"># -DDEBUG 定义 DEBUG 宏，可能文件中有DEBUG宏部分的相关信息，用 DDEBUG 来选择开启或关闭 DEBUG</span><br><span class="line"># 举例：</span><br><span class="line"><span class="comment">// -Dname 定义宏 name，默认定义内容为字符串 “1”</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;DEBUG LOG\n&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;in\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1. 在编译的时候，使用g++ -DDEBUG main.cpp</span></span><br><span class="line"><span class="comment">// 2. 第七行代码可以被执行</span></span><br></pre></td></tr></table></figure><h2 id="GDB调试器"><a href="#GDB调试器" class="headerlink" title="GDB调试器"></a>GDB调试器</h2></li></ol><p>GDB(GNU Debugger) 是一个用来调试C/C++程序的功能强大的调试器，是 Linux 系统开发 C/C++ 最常用的调试器。</p><p>GDB主要功能：</p><ul><li>设置断点(断点可以是条件表达式)</li><li>使程序在指定的代码行上暂停执行，便于观察</li><li>单步执行程序，便于调试</li><li>查看程序中变量值的变化</li><li>动态改变程序的执行环境</li><li>分析崩溃程序产生的core文件</li></ul><p>调试开始：执行gdb [filename] ，进入gdb调试程序，其中 filename 为要调试的可执行文件名。</p><p>编译程序时需要加上 -g，之后才能用 gdb 进行调试：g++ -g main.cpp -o main<br>回车键：重复上一命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">help</span>(h)        <span class="comment"># 查看命令帮助，具体命令查询在gdb中输入help + 命令</span></span> </span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)run(r)         <span class="comment"># 重新开始运行文件（run-text：加载文本文件，run-bin：加载二进制文件）</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)start          <span class="comment"># 单步执行，运行程序，停在第一行执行语句</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)list(l)        <span class="comment"># 查看原代码（list-n,从第n行开始查看代码。list+ 函数名：查看具体函数）</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">set</span>            <span class="comment"># 设置变量的值</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)next(n)        <span class="comment"># 单步调试（逐过程，函数直接执行）</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)step(s)        <span class="comment"># 单步调试（逐语句：跳入自定义函数内部执行）</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)backtrace(bt)  <span class="comment"># 查看函数的调用的栈帧和层级关系</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)frame(f)       <span class="comment"># 切换函数的栈帧</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)info(i)        <span class="comment"># 查看函数内部局部变量的数值</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)finish         <span class="comment"># 结束当前函数，返回到函数调用点</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">continue</span>(c)    <span class="comment"># 继续运行</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">print</span>(p)       <span class="comment"># 打印值及地址</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)quit(q)        <span class="comment"># 退出gdb</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">break</span>+num(b)                 <span class="comment"># 在第num行设置断点</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)info breakpoints             <span class="comment"># 查看当前设置的所有断点</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)delete breakpoints num(d)    <span class="comment"># 删除第num个断点</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)display                      <span class="comment"># 追踪查看具体变量值</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)undisplay                    <span class="comment"># 取消追踪观察变量</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)watch                        <span class="comment"># 被设置观察点的变量发生修改时，打印显示</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)i watch                      <span class="comment"># 显示观察点</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">enable</span> breakpoints           <span class="comment"># 启用断点</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">disable</span> breakpoints          <span class="comment"># 禁用断点</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)x                            <span class="comment"># 查看内存x/20xw 显示20个单元，16进制，4字节每单元</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)run argv[1] argv[2]          <span class="comment"># 调试时命令行传参</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">set</span> follow-fork-mode child   <span class="comment"># Makefile项目管理：选择跟踪父子进程（fork()）</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;GCC编译器&quot;&gt;&lt;a href=&quot;#GCC编译器&quot; class=&quot;headerlink&quot; title=&quot;GCC编译器&quot;&gt;&lt;/a&gt;GCC编译器&lt;/h2&gt;&lt;p&gt;GCC 编译器支持编译 Go、Objective-C，Objective-C++，Fortran，Ada，D 和 BRIG（HSAIL）等程序。&lt;/p&gt;
&lt;p&gt;实际使用中，使用 gcc 指令编译 C 代码，使用 g++ 指令编译 C++ 代码。&lt;/p&gt;
&lt;h3 id=&quot;编译过程&quot;&gt;&lt;a href=&quot;#编译过程&quot; class=&quot;headerlink&quot; title=&quot;编译过程&quot;&gt;&lt;/a&gt;编译过程&lt;/h3&gt;&lt;p&gt;例如 &lt;strong&gt;g++ test.cpp -o test&lt;/strong&gt; 可拆解为以下步骤：&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://www.benboby.top/categories/C/"/>
    
    
    <category term="C++基础" scheme="https://www.benboby.top/tags/C-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：区间和的个数</title>
    <link href="https://www.benboby.top/2020/11/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%8C%BA%E9%97%B4%E5%92%8C%E7%9A%84%E4%B8%AA%E6%95%B0.html"/>
    <id>https://www.benboby.top/2020/11/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%8C%BA%E9%97%B4%E5%92%8C%E7%9A%84%E4%B8%AA%E6%95%B0.html</id>
    <published>2020-11-07T15:39:51.000Z</published>
    <updated>2021-01-28T06:02:23.355Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 $a$，返回区间和在 $[lower, upper]$ 之间的个数，包含 $lower$ 和 $upper$。<br>区间和 $S(i, j)$ 表示在 $a$ 中，位置从 $i$ 到 $j$ 的元素之和，包含 $i$ 和 $j$ $(i ≤ j)$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><a id="more"></a> <p>维护前缀和，对于每个前缀和 $sum[i]$，等价于 $sum[0…i-1]$ 里面有多少个数满足差值在 $[lower, upper]$ 之间。</p><p>$sum[i] - sum[j] = [lower, upper]$ 等价于求出现在区间 $sum[j] \in [sum[i] - upper, sum[i] - lower]$ 的数的个数，故可以用树状数组维护。</p><p>遍历前缀和数组，对于当前前缀和 $sum[i]$，满足的个数便为：$query(sum[i] - lower) - query(sum[i] - upper - 1)$，累加答案即可。</p><p>由于数很大，故需要将所有出现的数离散化。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BIT</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span>* c;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        BIT(<span class="keyword">int</span> _n) &#123;</span><br><span class="line">            n = _n;</span><br><span class="line">            c = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) c[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">                c[x]++;</span><br><span class="line">                x += lowbit(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x) &#123;</span><br><span class="line">                sum += c[x];</span><br><span class="line">                x -= lowbit(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countRangeSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> lower, <span class="keyword">int</span> upper)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> m = a.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> *sum = <span class="keyword">new</span> <span class="keyword">long</span> <span class="keyword">long</span>[m + <span class="number">1</span>];</span><br><span class="line">        sum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i) sum[i] = sum[i - <span class="number">1</span>] + a[i - <span class="number">1</span>];</span><br><span class="line">            s.insert(sum[i]);</span><br><span class="line">            s.insert(sum[i] - upper);</span><br><span class="line">            s.insert(sum[i] - lower);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">int</span> n = s.size(), idx = <span class="number">0</span>;</span><br><span class="line">        <span class="function">BIT <span class="title">bit</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : s) mp[x] = ++idx;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = mp[sum[i] - upper], r = mp[sum[i] - lower];</span><br><span class="line">            res += bit.query(r) - bit.query(l - <span class="number">1</span>);</span><br><span class="line">            bit.add(mp[sum[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个整数数组 $a$，返回区间和在 $[lower, upper]$ 之间的个数，包含 $lower$ 和 $upper$。&lt;br&gt;区间和 $S(i, j)$ 表示在 $a$ 中，位置从 $i$ 到 $j$ 的元素之和，包含 $i$ 和 $j$ $(i ≤ j)$。&lt;/p&gt;
&lt;h2 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h2&gt;</summary>
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="树状数组" scheme="https://www.benboby.top/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>C++内存管理</title>
    <link href="https://www.benboby.top/2020/11/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"/>
    <id>https://www.benboby.top/2020/11/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html</id>
    <published>2020-11-02T03:12:51.000Z</published>
    <updated>2021-02-09T09:18:32.314Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="内存管理详解"><a href="#内存管理详解" class="headerlink" title="内存管理详解"></a>内存管理详解</h3><h4 id="内存分配方式"><a href="#内存分配方式" class="headerlink" title="内存分配方式"></a>内存分配方式</h4><h5 id="分配方式简介"><a href="#分配方式简介" class="headerlink" title="分配方式简介"></a>分配方式简介</h5><p>在C++中，内存分为5个区：</p><ol><li>栈：执行函数时，函数内部局部变量存储单元在栈上创建，结束时自动释放。效率很高，但存储容量有限。</li><li>堆：由 <strong>new</strong> 分配的内存块，编译器不会自动释放，需要应用程序对应的 <strong>delete</strong> 进行释放。如果没有释放，则程序运行结束后会由操作系统自动回收。</li><li>自由存储区：由 <strong>malloc</strong> 等分配的内存块，类似堆，由 <strong>free</strong> 结束自己的生命。</li><li>全局/静态存储区：存储全局变量和静态变量。</li><li>常量存储区：存放常量，不允许修改。</li></ol><a id="more"></a> <h5 id="明确区分堆和栈"><a href="#明确区分堆和栈" class="headerlink" title="明确区分堆和栈"></a>明确区分堆和栈</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在栈内存中存放了一个指向一块堆内存的指针 p。程序会先确定在堆中分配内存的大小，然后调用 <strong>operator new</strong> 分配内存，然后返回这块内存的首地址，放入栈中。</p><p>这里并没有释放内存，因此需要 <strong>delete[] p</strong>，告诉编译器删除的是数组，然后编译器根据Cookie信息去释放内存。</p><h5 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h5><ol><li>管理方式：栈由编译器自动管理，无需手动控制；堆的释放工作由程序员控制，容易产生内存泄露。</li><li>空间大小：堆栈的内存都可以自己设定，堆内存一般不超过系统内存都是可以申请，栈内存个人测试默认值为8M。</li><li>碎片问题：对于堆而言，频繁的 <strong>new/delete</strong> 势必会造成内存空间的不连续，造成大量的碎片，使程序的效率降低；对于栈而言，则不会发生这样的情况，先进后出排列有序，以至于永远不可能有一个内存块从非栈顶位置弹出。</li><li>生长方向：对于堆而言，生长方向向上，向着内存地址增加的方向增长；对于栈而言，生长方向向下，向着内存地址减小的方向增长。</li><li>分配方式：堆都是动态分配的，没有静态分配的堆。栈有动态分配和静态分配两种，静态分配由编译器完成，比如局部变量的分配；动态分配由 <strong>alloca</strong> 函数进行分配，都由编译器进行释放。</li><li>分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持，这就决定了栈的效率比较高。堆则是 C/C++ 函数库提供的，机制比较复杂，用到许多算法的实现内存的分配。显然，堆的效率比栈要低得多。</li></ol><p>因此，更推荐尽量使用栈而不是堆。但是栈和堆相比并不灵活。如果需要分配大量内存空间，还是堆好一些。</p><h4 id="控制-C-的内存分配"><a href="#控制-C-的内存分配" class="headerlink" title="控制 C++ 的内存分配"></a>控制 C++ 的内存分配</h4><p>无论如何，一定要保守的使用内存分配。<br>一个防止堆破碎的通用方法是从不同固定大小的内存池中分配不同类型的对象。对每个类重载 <strong>new</strong> 和 <strong>delete</strong> 就提供了这样的控制。</p><h5 id="重载全局的new和delete操作"><a href="#重载全局的new和delete操作" class="headerlink" title="重载全局的new和delete操作"></a>重载全局的new和delete操作</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">void</span> *p = <span class="built_in">malloc</span>(size); </span><br><span class="line">    <span class="keyword">return</span> (p); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *p)</span></span>; </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">free</span>(p); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以对单个类的 new 和 delete 操作符重载。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *p)</span></span>; </span><br><span class="line">    <span class="comment">// .. other members here ... </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">void</span> *TestClass::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">void</span> *p = <span class="built_in">malloc</span>(size); <span class="comment">// Replace this with alternative allocator </span></span><br><span class="line">    <span class="keyword">return</span> (p); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> TestClass::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *p)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">free</span>(p); <span class="comment">// Replace this with alternative de-allocator</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="为单个类重载-new-和-delete"><a href="#为单个类重载-new-和-delete" class="headerlink" title="为单个类重载 new[] 和 delete[]"></a>为单个类重载 new[] 和 delete[]</h5><p>C++将对象数组的内存分配作为一个单独的操作，而不同于单个对象的内存分配。为了改变这种方式，同样需要重载 new[] 和 delete[]操作符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">void</span> * <span class="keyword">operator</span> <span class="keyword">new</span>[ ](<span class="keyword">size_t</span> size); </span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[ ](<span class="keyword">void</span> *p); </span><br><span class="line">    <span class="comment">// .. other members here .. </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">void</span> *TestClass::<span class="keyword">operator</span> <span class="keyword">new</span>[ ](<span class="keyword">size_t</span> size) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">void</span> *p = <span class="built_in">malloc</span>(size); </span><br><span class="line">    <span class="keyword">return</span> (p); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">void</span> TestClass::<span class="keyword">operator</span> <span class="keyword">delete</span>[ ](<span class="keyword">void</span> *p) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">free</span>(p); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    TestClass *p = <span class="keyword">new</span> TestClass[<span class="number">10</span>]; </span><br><span class="line">    <span class="comment">// ... etc ... </span></span><br><span class="line">    <span class="keyword">delete</span>[ ] p; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：对于多数 C++ 的实现，<strong>new[]</strong> 操作符中的个数参数是数组的大小加上额外的存储对象数目的一些字节。因此应该尽量避免分配对象数组，使内存分配策略简单。</p><h4 id="常见的内存错误"><a href="#常见的内存错误" class="headerlink" title="常见的内存错误"></a>常见的内存错误</h4><ol><li>内存分配未成功，却使用了它。<ul><li>如果是用 malloc 或 new 来申请内存，应该用 if(p==NULL) 或 if(p!=NULL)进行防错。</li></ul></li><li>内存分配虽然成功，但未初始化就引用它。<ul><li>无论用何种方式创建数组，都要赋初值，即便是零值。</li></ul></li><li>内存分配成功并且已经初始化，但操作越界。<ul><li>多发生在下标“多1”或“少1”。</li></ul></li><li>忘记了释放内存，造成内存泄漏。<ul><li>动态内存的申请与释放必须配对，程序中 <strong>malloc</strong> 与 <strong>free</strong> 的使用次数一定要相同，否则肯定有错误（new/delete同理）。</li></ul></li><li>释放了内存却继续使用它。<ul><li>程序过于复杂，难以分清是否释放了内存，此时应当重新设计数据结构，解决混乱。</li><li>return语句写错，不要返回指向“栈内存”的指针或引用，因为该内存在函数体结束时被自动销毁。</li><li>free或delete释放内存后，没有将指针设为NULL，导致“野指针”。</li></ul></li></ol><h4 id="指针与数组对比"><a href="#指针与数组对比" class="headerlink" title="指针与数组对比"></a>指针与数组对比</h4><p>数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。数组名对应着（<strong>而不是指向</strong>）一块内存，其地址和容量在生命周期内保持不变，只有数组的内容可以改变。</p><p>指针可以随时指向任何类型的内存块，它的特征是“可变”的，所以常用指针来操作动态内存，指针远比数组灵活，但也更危险。</p><h5 id="修改数组内容"><a href="#修改数组内容" class="headerlink" title="修改数组内容"></a>修改数组内容</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[] = “hello”; </span><br><span class="line">a[<span class="number">0</span>] = ‘X’; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"><span class="comment">// 可以拆分为 char s[] = &quot;world&quot;; char *p = str;</span></span><br><span class="line"><span class="keyword">char</span> *p = “world”; <span class="comment">// 注意 p 指向常量字符串</span></span><br><span class="line">p[<span class="number">0</span>] = ‘X’; <span class="comment">// 编译器不能发现该错误，但运行时产生[Bus error]</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h5 id="内容复制与比较"><a href="#内容复制与比较" class="headerlink" title="内容复制与比较"></a>内容复制与比较</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组… </span></span><br><span class="line"><span class="keyword">char</span> a[] = <span class="string">&quot;hello&quot;</span>; </span><br><span class="line"><span class="keyword">char</span> b[<span class="number">10</span>]; </span><br><span class="line"><span class="built_in">strcpy</span>(b, a); <span class="comment">// 不能用 b = a; </span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(b, a) == <span class="number">0</span>) <span class="comment">// 不能用 if (b == a) </span></span><br><span class="line">… </span><br><span class="line"><span class="comment">// 指针… </span></span><br><span class="line"><span class="comment">// 语句 p = a 并不能把 a 的内容复制给指针 p，而是把 a 的地址赋给了 p。</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(a); </span><br><span class="line"><span class="keyword">char</span> *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*(len+<span class="number">1</span>)); </span><br><span class="line"><span class="built_in">strcpy</span>(p, a); <span class="comment">// 不要用 p = a; </span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(p, a) == <span class="number">0</span>) <span class="comment">// 不要用 if (p == a) </span></span><br></pre></td></tr></table></figure><h5 id="计算内存容量"><a href="#计算内存容量" class="headerlink" title="计算内存容量"></a>计算内存容量</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[] = <span class="string">&quot;hello world&quot;</span>; </span><br><span class="line"><span class="keyword">char</span> *p = a; </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(a) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 12 字节</span></span><br><span class="line"><span class="comment">// sizeof(p) 等价于 sizeof(char *)，没有办法的值指针所指的内存容量，除非申请内存时就记住它</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(p) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 4 字节</span></span><br></pre></td></tr></table></figure><p>注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(<span class="keyword">char</span> a[<span class="number">100</span>])</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// 不论数组 a 的容量是多少，sizeof(a)始终等于 sizeof(char *)。</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(a) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 4 字节而不是 100 字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="指针参数如何传递内存"><a href="#指针参数如何传递内存" class="headerlink" title="指针参数如何传递内存"></a>指针参数如何传递内存</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetMemory</span><span class="params">(<span class="keyword">char</span> *p, <span class="keyword">int</span> num)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    p = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * num); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>; </span><br><span class="line">    GetMemory(str, <span class="number">100</span>); <span class="comment">// str 仍然为 NULL </span></span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello&quot;</span>); <span class="comment">// 运行错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.benboby.top/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%89%AF%E6%9C%AC.png" alt></p><p>如果函数的参数是一个指针，不要指望用该指针去申请动态内存。编译器总是要为函数的每个参数制作临时副本，指针参数 p 的副本是 _p，编译器使 _p = p。如果函数体内的程序修改了_p 的内容，就导致参数 p 的内容作相应的修改。这就是指针可以用作输出参数的原因。_p 申请了新的内存，只是把 _p 所指的内存地址改变了，但是 p 丝毫未变。所以函数 GetMemory 并不能输出任何东西。事实上，每执行一次 GetMemory 就会泄露一块内存，因为没有用 free 释放内存。</p><p>如果非得要用指针参数去申请内存，那么应该改用“指向指针的指针”:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetMemory2</span><span class="params">(<span class="keyword">char</span> **p, <span class="keyword">int</span> num)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * num); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test2</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>; </span><br><span class="line">    GetMemory2(&amp;str, <span class="number">100</span>); <span class="comment">// 注意参数是 &amp;str，而不是 str </span></span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello&quot;</span>); </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; str &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">free</span>(str); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="/2020/11/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.htm/指针的指针.png" alt></p><p>比较好的方法是 <strong>传指针的引用</strong>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetMemory</span><span class="params">(<span class="keyword">char</span> *&amp;p, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    GetMemory(str, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">free</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以用函数返回值来传递动态内存。这种方法更加简单：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">GetMemory3</span><span class="params">(<span class="keyword">int</span> num)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * num); </span><br><span class="line">    <span class="keyword">return</span> p; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test3</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>; </span><br><span class="line">    str = GetMemory3(<span class="number">100</span>); </span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello&quot;</span>); </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; str &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">free</span>(str); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在使用返回值时，千万别返回 <strong>指向“栈内存”</strong> 的指针、引用，因为该内存在函数结束时 <strong>自动消亡</strong> 了，返回的指针是个野指针了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">GetString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> p[] = <span class="string">&quot;hello world&quot;</span>; <span class="comment">//数组内容存储在栈区，函数结束时，会释放掉</span></span><br><span class="line">     <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    str = GetString();      <span class="comment">//因为非配的内存早已释放掉，此时的str是个野指针，内容是垃圾</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在函数中不定义数组，定义指针：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">GetString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> *p = <span class="string">&quot;hello world&quot;</span>; <span class="comment">//数组内容存储在静态区，函数结束时，不会释放掉</span></span><br><span class="line">     <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    str = GetString();      </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h4 id="杜绝“野指针”"><a href="#杜绝“野指针”" class="headerlink" title="杜绝“野指针”"></a>杜绝“野指针”</h4><p>“野指针”不是 NULL 指针，是指向“垃圾”内存的指针。“野指针”是很危险的，if 语句对它不起作用。出现的原因有：</p><ol><li>指针变量没有被初始化。任何指针变量刚被创建时不会自动成为 NULL 指针，它的缺省值是随机的。所以，指针变量在创建的同时应当被初始化，要么将指针设置为 NULL，要么让它指向合法的内存。</li><li>指针 p 被 free 或者 delete 之后，没有置为 NULL，让人误以为 p 是个合法的指针。</li><li>指针操作超越了变量的作用域范围。</li></ol><h4 id="有了-malloc-free-为什么还要-new-delete？"><a href="#有了-malloc-free-为什么还要-new-delete？" class="headerlink" title="有了 malloc/free 为什么还要 new/delete？"></a>有了 malloc/free 为什么还要 new/delete？</h4><p><strong>malloc 与 free</strong> 是 C++/C 语言的标准库函数，<strong>new/delete</strong> 是 C++ 的运算符。它们都可用于申请动态内存和释放内存。<br>对于非内部数据类型的对象而言，光用 <strong>malloc/free</strong> 无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于 <strong>malloc/free</strong> 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于 <strong>malloc/free</strong>。<br>而C++程序经常要调用 C 函数，而 C 程序只能用 <strong>malloc/free</strong> 管理动态内存，因此不能只用 <strong>new/delete</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">public</span> : </span><br><span class="line">    Obj(<span class="keyword">void</span>)&#123; <span class="built_in">cout</span> &lt;&lt; “Initialization” &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">    ~Obj(<span class="keyword">void</span>)&#123; <span class="built_in">cout</span> &lt;&lt; “Destroy” &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Initialize</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; “Initialization” &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Destroy</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; “Destroy” &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UseMallocFree</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Obj *a = (obj *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(obj)); <span class="comment">// 申请动态内存</span></span><br><span class="line">    a-&gt;Initialize(); <span class="comment">// 初始化</span></span><br><span class="line">    <span class="comment">//… </span></span><br><span class="line">    a-&gt;Destroy(); <span class="comment">// 清除工作</span></span><br><span class="line">    <span class="built_in">free</span>(a); <span class="comment">// 释放内存</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UseNewDelete</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Obj *a = <span class="keyword">new</span> Obj; <span class="comment">// 申请动态内存并且初始化</span></span><br><span class="line">    <span class="comment">//… </span></span><br><span class="line">    <span class="keyword">delete</span> a; <span class="comment">// 清除并且释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内存耗尽怎么办？"><a href="#内存耗尽怎么办？" class="headerlink" title="内存耗尽怎么办？"></a>内存耗尽怎么办？</h4><p>如果在申请动态内存时找不到足够大的内存块，<strong>malloc</strong> 和 <strong>new</strong> 将返回 <strong>NULL</strong> 指针，表示内存申请失败。<br>处理“内存耗尽”问题，一般可以通过判断指针是否为 <strong>NULL</strong>，是的话用 <strong>return</strong> 或 <strong>exit(1)</strong> 终止整个程序的运行，也可以自己为 <strong>new 和 molloc</strong> 设置异常处理函数。<br>如果一个函数内有多处需要申请动态内存，那么应该用 <strong>exit(1)</strong> 及时终止程序。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;内存管理&quot;&gt;&lt;a href=&quot;#内存管理&quot; class=&quot;headerlink&quot; title=&quot;内存管理&quot;&gt;&lt;/a&gt;内存管理&lt;/h2&gt;&lt;h3 id=&quot;内存管理详解&quot;&gt;&lt;a href=&quot;#内存管理详解&quot; class=&quot;headerlink&quot; title=&quot;内存管理详解&quot;&gt;&lt;/a&gt;内存管理详解&lt;/h3&gt;&lt;h4 id=&quot;内存分配方式&quot;&gt;&lt;a href=&quot;#内存分配方式&quot; class=&quot;headerlink&quot; title=&quot;内存分配方式&quot;&gt;&lt;/a&gt;内存分配方式&lt;/h4&gt;&lt;h5 id=&quot;分配方式简介&quot;&gt;&lt;a href=&quot;#分配方式简介&quot; class=&quot;headerlink&quot; title=&quot;分配方式简介&quot;&gt;&lt;/a&gt;分配方式简介&lt;/h5&gt;&lt;p&gt;在C++中，内存分为5个区：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;栈：执行函数时，函数内部局部变量存储单元在栈上创建，结束时自动释放。效率很高，但存储容量有限。&lt;/li&gt;
&lt;li&gt;堆：由 &lt;strong&gt;new&lt;/strong&gt; 分配的内存块，编译器不会自动释放，需要应用程序对应的 &lt;strong&gt;delete&lt;/strong&gt; 进行释放。如果没有释放，则程序运行结束后会由操作系统自动回收。&lt;/li&gt;
&lt;li&gt;自由存储区：由 &lt;strong&gt;malloc&lt;/strong&gt; 等分配的内存块，类似堆，由 &lt;strong&gt;free&lt;/strong&gt; 结束自己的生命。&lt;/li&gt;
&lt;li&gt;全局/静态存储区：存储全局变量和静态变量。&lt;/li&gt;
&lt;li&gt;常量存储区：存放常量，不允许修改。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="C++" scheme="https://www.benboby.top/categories/C/"/>
    
    
    <category term="C++内存管理" scheme="https://www.benboby.top/tags/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>树状数组经典题</title>
    <link href="https://www.benboby.top/2020/10/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%BB%8F%E5%85%B8%E9%A2%98.html"/>
    <id>https://www.benboby.top/2020/10/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%BB%8F%E5%85%B8%E9%A2%98.html</id>
    <published>2020-10-30T14:31:09.000Z</published>
    <updated>2021-01-28T06:02:23.341Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一个简单的整数问题"><a href="#一个简单的整数问题" class="headerlink" title="一个简单的整数问题"></a>一个简单的整数问题</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>第一类指令形如 “C-l-r-d”，表示把数列中第 $l-r$ 个数都加 $d$。</p><p>第二类指令形如 “Q-X”，表示询问数列中第 $x$ 个数的值。<br><a id="more"></a> </p><p>对于每个询问，输出一个整数表示答案。</p><p>数据范围：$(n, m \in [1, 100000])$</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>用树状数组解决动态差分问题。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">ll c[N], a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">        c[x] += y;</span><br><span class="line">        x += lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        sum += c[x];</span><br><span class="line">        x -= lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">int</span> x, y, z;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">&quot;Q&quot;</span>) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; query(x) + a[x] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">            add(x, z);</span><br><span class="line">            add(y + <span class="number">1</span>, -z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="谜一样的牛"><a href="#谜一样的牛" class="headerlink" title="谜一样的牛"></a>谜一样的牛</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定序列长度 $n$ 和 数组 $a$，$a[i]$ 表示第 $i$ 个数前面有多少个数比它小，复原原序列，原序列为 $1-n$ 的排列。$(n \in [1, 100000])$</p><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>最后一个数的大小明显是一开始就可以推断出来的，假设其大小是 $x$，接着从 $1-n$ 这 $n$ 个数字中把 $x$ 删掉，然后再看倒数第二个数，假设其前面有 $y$ 个数比它小，说明这个数是剩下的数里面第 $y + 1$ 大的数。</p><p>由此可以发现，我们可以倒推过来，第 $i$ 个数的大小便是当前还没有被选的数中第 $a[i] + 1$ 小的数。</p><p>可以使用树状数组解决，将每个位置置为 $1$ 表示未被选，$0$ 表示已被选，得到的前缀和是单调递增的，因此每次只需要二分查找满足前缀和刚好等于 $a[i] + 1$ 的位置即为当前数的大小。</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, c[N], a[N], res[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">        c[x] += y;</span><br><span class="line">        x += lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        sum += c[x];</span><br><span class="line">        x -= lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    add(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        add(i, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n + <span class="number">1</span>, mid;</span><br><span class="line">        <span class="keyword">while</span> (l + <span class="number">1</span> &lt; r) &#123;</span><br><span class="line">            mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (query(mid) &lt; a[i] + <span class="number">1</span>) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        res[i] = r;</span><br><span class="line">        add(r, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cout</span> &lt;&lt; res[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一个简单的整数问题&quot;&gt;&lt;a href=&quot;#一个简单的整数问题&quot; class=&quot;headerlink&quot; title=&quot;一个简单的整数问题&quot;&gt;&lt;/a&gt;一个简单的整数问题&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;第一类指令形如 “C-l-r-d”，表示把数列中第 $l-r$ 个数都加 $d$。&lt;/p&gt;
&lt;p&gt;第二类指令形如 “Q-X”，表示询问数列中第 $x$ 个数的值。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://www.benboby.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="树状数组" scheme="https://www.benboby.top/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
</feed>
