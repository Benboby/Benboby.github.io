<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Benboby&#39;s Blog</title>
  
  
  <link href="https://www.benboby.top/atom.xml" rel="self"/>
  
  <link href="https://www.benboby.top/"/>
  <updated>2021-02-07T02:28:48.114Z</updated>
  <id>https://www.benboby.top/</id>
  
  <author>
    <name>Benboby</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>每日一题：最多可以参加的会议数目II</title>
    <link href="https://www.benboby.top/2021/02/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%A4%9A%E5%8F%AF%E4%BB%A5%E5%8F%82%E5%8A%A0%E7%9A%84%E4%BC%9A%E8%AE%AE%E6%95%B0%E7%9B%AEII.html"/>
    <id>https://www.benboby.top/2021/02/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%A4%9A%E5%8F%AF%E4%BB%A5%E5%8F%82%E5%8A%A0%E7%9A%84%E4%BC%9A%E8%AE%AE%E6%95%B0%E7%9B%AEII.html</id>
    <published>2021-02-07T02:02:39.000Z</published>
    <updated>2021-02-07T02:28:48.114Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你一个 $a$ 数组，其中 $a[i] = [startDay_i, endDay_i, value_i]$ ，表示第 $i$ 个会议在 $startDay_i$ 天开始，第 $endDay_i$ 天结束，如果你参加这个会议，你能得到价值 $value_i$ 。同时给你一个整数 $k$ 表示你能参加的最多会议数目。</p><p>你同一时间只能参加一个会议。如果你选择参加某个会议，那么你必须 <strong>完整</strong> 地参加完这个会议。会议结束日期是包含在会议内的，也就是说你不能同时参加一个开始日期与另一个结束日期相同的两个会议。</p><p>请你返回能得到的会议价值 <strong>最大和</strong>。$(k \in [1, n], k * n \in [1, 1e6], startDay_i, endDay_i \in [1, 1e9], value_i \in[1, 1e6])$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><a id="more"></a><p>考虑动态规划。$dp[i][j]$ 表示前 $i$ 个会议刚好选 $j$ 个时，能获得的最大价值。</p><p>那么对于每个 $dp[i][j]$ 有两种情况：</p><ul><li>不参加第 $i$ 个会议，有 $dp[i][j] = dp[i - 1][j]$</li><li>参加第 $i$ 个会议，设第 $i$ 个会议开始时间为 $l$，那么我们应该是从 <strong>所有结束时间小于 $l$ 且刚好选 $j - 1$ 个会议</strong> 的那个状态转移过来。那么最好的方式就是一开始就将 $a$ 按结束时间排序，这样我们就能很快二分出来结束时间刚好（最后一个）小于 $l$ 的那个会议 $p$，有 $dp[i][j] = max(dp[i][j], dp[p][j - 1] + a[i].value)$。</li></ul><p>时间复杂度 $O(nklog_n)$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> l, r, w;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Node&amp; a) <span class="keyword">const</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> r &lt; a.r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; q[<span class="number">1000005</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; a, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (k + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) q[i + <span class="number">1</span>] = &#123;a[i][<span class="number">0</span>], a[i][<span class="number">1</span>], a[i][<span class="number">2</span>]&#125;;</span><br><span class="line">        sort(q + <span class="number">1</span>, q + n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>, r = i, mid;</span><br><span class="line">            <span class="keyword">while</span> (l + <span class="number">1</span> &lt; r) &#123;</span><br><span class="line">                mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (q[mid].r &lt; q[i].l) l = mid;</span><br><span class="line">                <span class="keyword">else</span> r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++) </span><br><span class="line">                dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[l][j - <span class="number">1</span>] + q[i].w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给你一个 $a$ 数组，其中 $a[i] = [startDay_i, endDay_i, value_i]$ ，表示第 $i$ 个会议在 $startDay_i$ 天开始，第 $endDay_i$ 天结束，如果你参加这个会议，你能得到价值 $value_i$ 。同时给你一个整数 $k$ 表示你能参加的最多会议数目。&lt;/p&gt;
&lt;p&gt;你同一时间只能参加一个会议。如果你选择参加某个会议，那么你必须 &lt;strong&gt;完整&lt;/strong&gt; 地参加完这个会议。会议结束日期是包含在会议内的，也就是说你不能同时参加一个开始日期与另一个结束日期相同的两个会议。&lt;/p&gt;
&lt;p&gt;请你返回能得到的会议价值 &lt;strong&gt;最大和&lt;/strong&gt;。$(k \in [1, n], k * n \in [1, 1e6], startDay_i, endDay_i \in [1, 1e9], value_i \in[1, 1e6])$&lt;/p&gt;
&lt;h2 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h2&gt;</summary>
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="动态规划" scheme="https://www.benboby.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：滑动窗口中位数</title>
    <link href="https://www.benboby.top/2021/02/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%AD%E4%BD%8D%E6%95%B0.html"/>
    <id>https://www.benboby.top/2021/02/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%AD%E4%BD%8D%E6%95%B0.html</id>
    <published>2021-02-03T05:48:11.000Z</published>
    <updated>2021-02-03T05:59:56.952Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你一个数组 nums，有一个长度为 k 的窗口从最左端滑动到最右端。窗口中有 k 个数，每次窗口向右移动 1 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。$(n, k \in [1, 100000])$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>用优先队列+延迟删除有点麻烦，可以考虑直接用 <strong>multiset</strong> 做，本质都是一样的，维护两个大小相同或差一的集合（自动排序）$l 和 r$，$l$ 维护小于等于中位数的值，$r$ 维护大于等于中位数的值，$multiset$ 的优秀特性可以在 $log$ 时间复杂度内进行增删操作。具体细节较多，时间复杂度 $O(nlog(k))$。</p><a id="more"></a><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">medianSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">double</span>&gt; l, r;</span><br><span class="line">        <span class="keyword">int</span> n = a.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k) &#123;           <span class="comment">// 需要移除之前已经加入滑动窗口的元素</span></span><br><span class="line">                <span class="keyword">if</span> (l.count(a[i - k])) l.erase(l.find(a[i - k]));</span><br><span class="line">                <span class="keyword">else</span> r.erase(r.find(a[i - k]));</span><br><span class="line">            &#125;</span><br><span class="line">            l.insert((<span class="keyword">double</span>)a[i]);</span><br><span class="line">            <span class="keyword">while</span> (l.size() &amp;&amp; r.size() &amp;&amp; *(--l.end()) &gt; *r.begin()) &#123;   <span class="comment">// 左集合的元素不可能大于右集合</span></span><br><span class="line">                l.insert(*r.begin());</span><br><span class="line">                r.insert(*(--l.end()));</span><br><span class="line">                l.erase(*(--l.end()));</span><br><span class="line">                r.erase(*r.begin());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (l.size() - <span class="number">1</span> &gt; r.size()) &#123;            <span class="comment">// 左集合元素最多只会比右集合多一（窗口大小为奇数）</span></span><br><span class="line">                r.insert(*(--l.end()));</span><br><span class="line">                l.erase(--l.end());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;         </span><br><span class="line">                <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res.push_back(*(--l.end()));</span><br><span class="line">                <span class="keyword">else</span> res.push_back((*(--l.end()) + *r.begin()) / <span class="number">2.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给你一个数组 nums，有一个长度为 k 的窗口从最左端滑动到最右端。窗口中有 k 个数，每次窗口向右移动 1 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。$(n, k \in [1, 100000])$&lt;/p&gt;
&lt;h2 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h2&gt;&lt;p&gt;用优先队列+延迟删除有点麻烦，可以考虑直接用 &lt;strong&gt;multiset&lt;/strong&gt; 做，本质都是一样的，维护两个大小相同或差一的集合（自动排序）$l 和 r$，$l$ 维护小于等于中位数的值，$r$ 维护大于等于中位数的值，$multiset$ 的优秀特性可以在 $log$ 时间复杂度内进行增删操作。具体细节较多，时间复杂度 $O(nlog(k))$。&lt;/p&gt;</summary>
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="STL" scheme="https://www.benboby.top/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>123456</title>
    <link href="https://www.benboby.top/2021/02/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
    <id>https://www.benboby.top/2021/02/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</id>
    <published>2021-02-02T10:06:30.000Z</published>
    <updated>2021-02-15T11:20:38.264Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="f862006da249cde4a411d7d32ddfb798e8a447b277c64c0fc1e05f6f457b9e66">88bfb973b5cd9a98289a5356073cb3e5594eb6ba137f50990b97deaa4f5157d6a3dabe6ba7139b261e731e88bf5951f014d88d0bd15817c39eea4c807d1034a17dd240dcfa03f5ba8341e7e8b2bd4f4b23b63c24afcaedee76b28bac83097fa9053e8e0bb0c6629447ece4b7360313bbf458cf0e87bf236e20082b6c2a46626cd6c500c0cd13dac0f2ab450a2a4312ab299c11c0aeda96426db73e64ce3d481ffe04c9cc9c518016285ca83b48325a211c6153bc114b58a9d9d103713e10073ca858ae70b0d56cd6a8b7471c4aa9c225161b3437fefdec3ab76edb551900ae59a7c3d40621df6d54290ba9fce16d194d9d8bb7da09e86e154bd0077842955436cb0e8cef761a6065be2bf0a33bfd51258cefde4413074919363aea385738f6ea65f2d5c384e2186ae40cb7a872939482654c8366bd195e358b518844c0bb05e7a861ede9433dc3823abeb31a62773bb424d4f6f0b3fe5af357ef052e8c1e556bb2aa62db5f79af69fba9ac79e92c82e06cd3c926985731a01f096d2c5b46f502af123deb642fc12f71ce8ac839a2130af0b48f50cbb4141d761856404ca2a18ec953892007b9a539381ba1b11b11f842a0818b8c347032e437fdb5ddf76137f56dca556233facd384fb841822de07f7a70a44d84b8e435f386c42a8dc7074585e5c84cc65bfe1cc627a67f4fc8d81940c476ef5ad6e8a912a058a9dbd66957fd72adce9ec76f19c49cb3f7934a068795250439f0a917a435dd286eac6d4f90a7a1ba83df0979a9f4451fca4d992901fd73b191617d3406a4940451f8ce3e0793487b7e2556c071256b19c471550053dbcb6139aa4e4d47d45eea054effbfda97399fdfa7cb8dfaaa55c37199670eb02958d9bc6b49159b9938902a5761bc301aae45c557b64ab491f515bf6085f673e372545b5ae3e268ecc78f964d94557ae6e510e637e45d65bef5582587f68bf284c162fefb925f41bdc6068a94e26f90f00ce3f6dcac4440a0c2f8f3b4e30c240a39324930095053c1cc0bf329e408f03ae3ac660499bb0575146fdbd3130b1f81b8003d6898270b76fc4ba17dde06af28e8607d7b484043a827cbe598cbd79b4a1364383766c71201bd7777789c1985ce83cf9d16a40cc3a53c2fb77b699f425b99c41e02d43c2cb5a6d4b6ea37e22a10126df6f07151cb8cf56f47c64b72e6ee8f1043918a6b822fd7aababc7bfd3a5a2144834fec6e38da34c6a8fd85da7b4427acb2077f39082c4225cf7263cbeb78a35bc2af70cac42f42caef3d62ec49de4fcdedec9676bf0cd28c03828c89a4b7b1659a047d6b871714eb795b126ba2ea5c5143816a7ecea7d175efac463c3d9b278084272d287b03f762f425221218176ee8b041e5d4f5760a5fb43ef05ab755529dcdbb0c040d653e55363328fd48ade42ac6654097e16355921879c25843cf2426dfbd42b7a3d4e4632e1078bf1906e55074dc6532e435236ec7817e7414a23d59f9b5ef104f5d3040f50cd8da9056c33720348d789d45dab0a25408a65fb474ecf5f4bbe10ae2b573b1498d872338b01f14eea25b40bf687ecc71811f5b643f418f4d9c94514d2433cdea0f701126d7c97a6ceed800ab6037bd64bee6a41f1fd1d4c1fbdfc8df30a9d1e2bf346b408a43bb84b0cc9a2c6f0a6806d07b7ee9a1b43c4f40059e1f2ded7bdfdb048f35fd3c17ec717aaf135b5b07d248d3ff7ecd273d8f73c26fb758a38b8a356b055bf6985817f3cf56332997138bf01f6ace7973dbd1ba25dd6d40c395d0aefdee7cbb22f682b5a9b1bf05447810482bb8e28d5db0e7716f734976177fb09ea176cde09c056c7c627d106570a3effda367f0dd7d2fbdcf48d0f566513e9e9990978400b0cab065b7111a9ef951049371c7c87652c6a31e1d08495faf5e2fecd3650cf3adee41ab0302859e4153f23310d051adb7eccf94be93b90244690aa23cf39cfccf8adc3fa7ef38c0d6eaf596f1479276a2e9063b8035450a8d528913a6f369633c02994c234cd58c8f2607c2e8d8813eb9d4a0c96e4b03d5c3cd0f0f37fb3def534af4bbbe606a1b99310984efb337594902a4a9f2903482a5e34d48011e9861da26ee1bf3d77bf415713343a1e9498d09591a92aa8dceb16e978ca5eaaa1eb0f690fa3f06ff540e156cc833db3ccdfc031419c9bc636f3a81c768795656d22bfdd365674e179ed16f5e08803b5b0d56795fb8f1da65ca6ead57424a409ef7e3719b8bc916fcf72da67d6b14f2d11ec2c6fcd26f09f16489de6f9092f09faa0c8fbf9e11461cc20e395e516566b87c5ee36344ed2e410517852badc89e5ba031516294724e30247b956f5587019538753aaa50d298a175ac5570919d54d591e18355c66794d91bc39bbcd886353267cc4ffeaef7778d36b4dfc600c6686efdd7331c99d618784ac8e1701e0f15dce852be4bae47fb4f3473c0b9a5fe8473671f0f9475b4da2628bd9f378c1d86df6dcf02f32ae7361bcb0b0a70bcabb0f4f33f1ffd4019b67798ffe82bfb8f897eed5e97ab6c6b8a6fc57e207b0600aad5f0f9f41e9a8296dd0ce54ac6bce4bac4a8594b062f905814bffa99ff2934d44f1a75c6fc36750e3a36c0b89b5f160af29b6f20dfc872153d3d4d0b413f661efffb894ba62eafca1b5bfe454546f82cd49a5b00dbc4108b0c4346d8e56e290b7763d12cc2a596873e827594652867c376303c54a245da8cb03a3b415883e7eec0e048900db8a2200320363ad9563d0a55a081cd56c93aea3587ba7cacc3c30fddedb4b644bdf66b50dcbb21062315ffe4ece08645353ec8d030611a030f603f8266d1f2122ed27df46234910b4ad1070bd684e7237be14f0ce7e5d42fb806c3a08338e76e7b816aa83429f2de022437b55cb31d25409c8e1c0831237afe4d2ece7d34ff779a469755bd4be882e7399aaad1c95be67989bb194445fa05438c59b402c0d633a6dffb06f1c607ffd383c4c9906fa1c7a5297271efe09a378c0ed6645e99a68ad662fd12c647780b038cfed7f8f77a023d0984e234e133efcc32a1bcf58dedd53e97c588303c5d0ddc6cd5c7cf8c86e17e04663b2134656ec3bd96ca8de30772060438b3623435d0bad5bd89f9e3a80ecd3b9c3d8a19a14c0e0e9d52250632f6242386c284c9d389ca30634731d310b190b5f796747ad17fc63e67e114bde1fe6a328497e568307e1b6ca2dbab2d85ceee70325efdae8ee41b439c62cc67b1857d4bc06fe54054d1daaa0a2eb0931e515a0d5fbfa9f0d27bbf2f538caf3019a26203b91a96aba167a0f4f1342f7605a59cac718902f8803f300a1100c0dfba863402a42be664bfa495be596936ce9124b0ff5f676f2bea70b3c63d6a53aeac7d63eab4668b0e641383281177689868a82bba51d91600ef99972b52f308531de97d689e77aad27f68d54449987e875ae920956b4c7710bf70295d8d76a78d295f14a74ad3b52008fa090bd8012e40e90d5a3097bde778bd6c5ade4d313a4c141b7e778e4cb140d66f5c476bb1e3f8ee680d5120fd2491fc8aab70bf9dfe9cb095f3578641251af0eca20c66ea1122dd5f5eb63482ed68295f72a0b184d05b1186a0a2996dab947513f56ca1d04a5d599ac605fc0c84b11b8f07b80f183af46b0bdbffb7fcb01a171f0072b33366fd040460369aa981a091961d7d312b61170fa96e325af236e175a26b8ec93dcb0b9fb526ed68d8349a4963b8f2682101957e8d69b2fb1070db0181b1b21093f7f9fc49dca32d26d0a7f41f3234a72d33d86587e0ffffdb7a724c5c4247e70c7bb3c5446da2753e03be1e22b1c37f0bc1479096c22551ecdedb0c1d2c428ac6b3369d4aeb82c94b1036320d5b236a7fd68b908dcecf1ce7b810759ba8028db5693135775eddd0bd5f00463c50378091a33746cbe2e6339d2341062ccbab079dbc9521e12653fdeac3a02db15bdbfd85f07b8fad70acf1c4540570859552ba2915f37bee5511314ff4610d74b9d49e41a68131609aa0ac8f65ef3e288709b2fbc383941b245c68c10ca46d4a0e4fb157e6826e84fa977a49c55555374299ee2217350e5074d3b5d21435c949be5b740db85a059f12282c06f1b232d709a22a195623e15865c0d8987c46b8160f231889eecf63044ac603044910adcdfb478a9cff955869ef778aade22315a2a945f4cd453cad274c0f3b4b8abf098d9c8a8f96965bdca0fbb24dbcd6ec54957c431b1617304b732bdb1da12366204c8ea66e35c3802e0ef61b8c2ddf8a763578571c6c1fed47fa55c64975d7c55bd296d972d5f8476cf77e317494591fc377ce62a6dcad92ed1fa061d0651b013949d9b3ae171954543dd7fcee59b137c0d95fa0c1ee9e592b2be0f32d576d361c578b4768c7fbfe6bc02fc09830ec9b66833e243f790191829053426844142b3e5e37989ae6008bf3f9ea9ab12901b9857dc1ec672fbe0590008bdb71df34308a287e674ae651e19bb82760966c8ea52a38782992bc5254594bf059603863e631b16fe4f25da9deed154881dd54d915d96dea9547a29190c6f887ee82fecf78549de9f8874ef0d9b89b5f6c44065b1e2d45e6655e6efc370a51480c3f45c7aa7023e8b49595cbbe3409b44a656b8e506492590d59b77a081191d04699ef4d39f53822bbbe0bbb367a1911c2ccf0eacbfea24c6fc0e54b8b22058e6236c1e6fb8f9383d25ced40e9cda416af77d14a835a50f0608f0670939844e39569705441c68af041078957cb90c3777899e197a7082dad18b69d74d7141f90efd173d967bcb9b58a056ec6062d3e2ff70dafb8dca4132d016d5383619eb015731b4501fd3657c990797d45a05a061a7da5c30235cd2b705b29b41a98cf3263e2ff789ba836c8994b4d589fda1eee98b0b11178c22934b673708d576b2109cbc501341d84d4523c1c25a26d773b304549fde8432527ed0ce65cb7ca1af4bd5294aec0483a11770152a2757ff059d5d25d70fde60a806b925ab51d72da4a15d9f18807cb7763b46758b936b87b060e13c3febba2de9cf68793ef7d04870a51c934e62d43dee6bd6990486ac57366b4712dee4a233bcabd58ca3d7f12b8e48f2de20138bfd5cd91ebe8d3349d62c13c264fda8af1f38dc4683398292617a7789b5a9772d306280fef0238033c4247bb15f269c928930c90c9088c2bf5848faf6eef8ee7168148e08e5a0a8bebadfb3011912fce30c82a78cd563ada248aca9ce05ca674428a013b997b1d4b7da11f2cee285732745d1b232cbccb4f2aea4676d60d7150ea0a016bb6b2b4aa793eefbc890f881ae407a3c25b9dc624f20bc2fc77d4e73fb374be9c4309e6ff9624b605f937dfd0bb658837e17e92034b2e7360f0d1f16d0c869e096653d76b92c00af78bbcbb86bd7e2318d521b65e431f012d053865ecd6c6edce8c4f49be8c5850cddc12722284ea8bf21a7de84c603c7f7ec2a260c9e9a0e6dea909ea05273c4fe0f2cff0754308336b84f218009442d36e6e143fe07f9b9d07683fd63f3ab69c75ce0a1d245887f35ca091e7cdefa83d7e49e4c9b59db65fde5c01fff8d1095834c0557b4bf79b0f448c7e6f631e77c835cf4e752591cc7191ea39524a87f54f0ae4bd14514b494291f7dbeac3f14cb344f2a7c15fd4115324e36143ff57e0e55dc8ad4bf456da64d4500e331b2f298222ce10e55e4c82f7987c564b0b996bbba4f81c38f85143704aeeedc74a6ef59ccec898a315449d7c6c08586e396b84f19dd65dd4ffdf4a92ae92ae0940b6ab5e558b04e502481492a22f6fa1ddb4e136680c232c685cdb603dbfedd3944741eb9abcb20e1ef81397fe1f62a2ac421f6e8f29bd01dc98eb231302e895781edf84873c173dc46cb7332079c8eab0fb0b7f4cbac488553446d3431b5a22040a214fb8aa7ae57c698d3806f9f50d4c5522b9246a65d4d8f55ebc9dc8bf3cb01a5b6bbfcc8897268963fb511d0a9b5ad58730f0f37ffa3b1c6c82f6aa6240cd75ec20c3d31ca0994abdc2a75730d314eee7ccf49bbcff473d7d9631eee928211df09d6636d75fec1b588982bf547eee5263f81ff420e508e12f6c139d1b08c51d4a2224ff5946c769badc1857a533eb072f4897f150b0600e9e9d34780a05553b196563bb781518441598f2928367cf21cd9dc22dc11403fc998c4aaa071961d184183224f1f57583bd63bed32974f5419e6badf2dc91ce18b2fb3fee837f23121ea531430d78212119b3f626bcac902925b4f2fe8f0af16f6a8629eb67cccf59573ba95697e7e3ace9b7e6eebca8ccd725dae049dc09a44548b2c4d53f3bdeb1d29f7ec7a80ecddeda7b49d02f4b27e66ffeddbdc99c4cf188add9375dfc7987b5cc052c0212ea004a82797c1af1daa23bc3e7634d3c133413ae35ff49d80f04efed7f411cc46f6366014946f91000c82c506d3301a09bb283dcdfd18cd7378a35ec52a99bda5b7313a039d66327ab735844dc979b3d20b628191ff26d316646f821b545deb01f52a54859ee45787a7b4c895436c2e9648fd8e968925e5c8e7ba8dd8860438ff939d2cb4902e0ec75b0ad163c1c900ae31703a637767cf7454d13d7864428ab8cc08d8bcac9d8e1ecd495572bb25ed157b069f09bd98d98a50cf773c59c76b2a31c937d662e671c71eed3b1802ae194d21f2f013d5116cd5723ab96a545923d900ba5b331045783ae2c5ca09b300de0c6d0e838312bb58ba3603f39a5d8cd7435d7ea67414442a46460cb1aea2cc8aaa6d4b86df123943d6204e786ef42112b86a2400b080a7ef93e04839095572de6cbd59c3d42f1c64c7e6d1a48abf1a7efb06c9c77ebde8b94981565d47522234ad4ffe6aa9f137efe727aeb9c8e75d44a3255e6fc3e0b26aeac59cd62112714b334b4fb127ce340cab042c59673547fb15bd0bf70fa1ac676bca6eba2cc1cab7df681736c97172051f0c9cc9728838c8f919f23d4029378d8bd5b34ff3a0c9af862e00950b82147b10b9c2a415f98eb128b6503cbf5bdf5753c8d176dcb04b51b8058fd590fbb34440336889413117871d54a39812cf30839f8bd35732617105ed6ed6dd23694d85d4940b59821116742b09f18880631b894d87bb0a7798236f2d4d53b44033b58151a7a9ef1f9787c1e50fe67c1b035cd56f20f914f03394afa3b1721b02e509cfee868ed334a22852977e423313c09b0a1b8fe005f33d111fb415a8c1ed34ec8cc4fe7b9acdfdf052174a6229a23b28ef0663e420e2b7d3468bc1761b26e5fa104fe4ea1dfb400d38d8da6b1af9b2630b81db81f1e0f79f180170b8ef67840c348ece9f90a879e255621d60890fba880e7ff7c5ff9625c8c8cc333f42ac712fee3858434f7c57827e316eacd467f710998d1a96fe443c5ce4c267bf3e84c92c541113537e81c0fabbf9bf7929e798d69a827ac8a4d2de07dba6d5bd19812e302c6ffd49d473943c1ada49d7f3dd5c870ab91599693f5093615f92a28b2abc4ba9d73c84f8fe91c34d7bcae12ecccd6cf22007e85056da47e826369a42c88889c9f4c7099acf1f5cd4d8ce2fa708d849b49aeae3b36503d9ae63f85a91841d138702ad3e9aab9212d390b872e18ccd856125a09bf203957705a1ad2342d8a09d0540c1da220bd63f36d78a3f4e97cc5ba3fd9cfeebcad4ff767846b1f15dc052175f52dd5d8e5ae04dd9e7005f5b087762901f64bc6edae67d74a94e4703acc10cbd727e212a064e981e840e6fea5b745a2af631be43847dd915856e69a51da6710fec49a2e828a042ea2269a4c25aa111f7b541c78777399253b32956da518bf2f8a0c605dd54072adadd92ab6970b0e6bfb7719f81fca560433dfe365ae2d72cc72f2d3ea42f8e1a612d3f213d5f13975212f2bfefc77e4515e39691c476d9f626861234c2af89767afe6de31529e570f453bd6672392c0e598340ef21faab10d28cc2c96dfa4b219bca9ef6011ce6e5eb81774bc3a40ef1e14141283a1c2ae6ecc4d8f214204811be8db985e0d756c4da5522b47cdf7f9f2e9a0a1c9824e9d1539ae7788860ed795496d7156111adb3b3eed6e4b6da5f41a91946deb634539dca74291c200b2d29a222239233ab609dc6d452b0367b48401b1ec11df8a2ed0c216afe216ba1a3fa11f2c4b0c1f43a20f78ff54bd6106149b1c54d9e917e912ce87cdace7f3d26db25971245557726a8b1a55782aa2f8f6e9785b6b113acf911fe31677ec7b32553d939a07286268071cd470785991d8bd914f86de61f985cafba7941d1637736d511d17407559a930e743cd84831b9850e52273845f6aa83727fe45ccb872dd303018e5b61ffcbc1c536a4b4d3e628be9d8f84f63441488a45acbd397fd58ef02bce4e84f5dad78855704a39ed5809b569a0d18407e5739b6d0acdee778853fdf6b4dcf465c317f0f41148606e0635f09e4cb7e3ef8ea0833e7eff49f2e48e1b6dd1a5769594721e9ff31b611b6be93d9f13f82ff4a5703a5c81297a893afabc60c0a94a5e56f91e8523b304cb4ab9f6f1a977a6e553962892e8e1c960577353a39f6303f2193cbe4770b0c5984903242ba0e36f6cefa3d49711d44ddeae99c5f3fbb54adce07d660809e731f06dd502190f3c9429852fe823486e77425650efd8e641b2ac6d475100d434e6e82da9bda40f62d51b081e3fd25091510f66157fb60e21172d8c139401fdf788b8f6219fc2d79f14ae6eba3c4f89c2d02d4c50e05ec1eedac29504e5854c6a0ad9f9cc00c1d78886ca461859d570fb773ad5bc7c63b7b496ca22984541e4289d464a0167b9d8b50168150da3b2290ab6df96d6c89231574fb92dfd0d299645b7ca83145f8fd338e0e0892d0f7e4eb66db302f9e2706b2e2b4c1e49b8110fd133b149011bb28023b04f5fa9b5ec4714166a31ca67af53196d922059b385e4a5c7ce5f02b51de64df7ea8d7ac130b6424ff4d2b73575ce292f3cec484afc528dea481e02f8ddaed76a99c16f61bfde65c26888bf7a4b0a9d81afc1b63984150600c5ee012ce0689c9685109202533de86b9913849e3a0b3cf8a04aecb68840d9b33d7a496a2dc5c2058d7204a4aa81171d5b14e9739f2dcec3f54bdfbe93f7574a48b8e91e90af44b97c0dc49b54f527715b4e8641b231f79eb12c64240570357161fe713a7f3e26e7f758c3ff2de258ae0e2e176e8d2670053df8c81ff4e5995b9410237c224a1c44f462d7325deb4cd18a2a32e810ee909a5c78a45a891c22e00c66e66f0acaf40dd39b68cc14e703eb3e5ac603de7cebfc107108931920ea18142f198c13e7704b5e829bf1bbbc92f5f8afddac121082172387c941d1fd8d03c6fae60d73eac03bcc26150d8f046fc6b62a1493b620bf014e10cb548ed746137ecbd0976baa20846fc68586c510f86c5d25e4bbfcef46205c71ac63ef53de06b760ea4771d40d9daa63a4c94718b425412be56974542023a0032e51af3402ffafd27ec1b4b09c8c34d40cf47492ae1dacc1f56e15a73a90d4421f52c73a3f0eff391171d47ca6e9aa4d645e2797ef33bddb1d46cd879f9695e63a597c0da0a466d2be3454454fff0e207167c9d146989b2b0b8a2c580ed86db3664e65e4991d8fe1011ad19c275ba5f10204235d3757d835b70733241008edbda5b1397c2e4c54a1f4bcb042e47ca9131dad2610a52c9746e212c731e33b04119b54e3f550e2cfbba6ec0c366f5282d150e7a9f24049aaed53d8fc04993bdbea9e30fe1bbf18b0d076acc6fdc8744646944c8c2457f58baf58592dbc878905ce3fd936159993ae2a54ced0022eb7eae4f2bb4f468a3ad7acf8cdb5186568255cc30e7936668d1e71e2d8c934d684601dc7917fa159fa4a1cb6fbe8b579f1d4d7cf9953a31fface3e7bd8e09602b7d52ac3cd431853eadab2a463c8ade005788a015b7d03b761500eb957bfc12c5b0eed9ad76897e7436529f63213a0b867e751dc8c3ab458e1cb37cdd2ec204fd52241e1d6a1d9421227d9089b9b5ac32efaafd2ae7462d38d7c419eb5d1885761a311883c2862ed1337f7f4bcceb5e6900002ad07fbeb558fbd9888fc9cab82bef19d037a5b1d4d2d10cc381b1b8d1796e9cf222fb90200504f212751a73ee9e1c9a155c9202ce6e3b7ec7687c16f2cb791e1b5aa3bfebbc6f4ae9a1681220447c518933212c2d5a6fd4f0e97ce61bfe2f81dcdcf4f1051be58d6fefcff7e513a9b8a77851ab49bb4e37cb1e7fdc48dad1079c5416a53d2d969c88c7549b243e805036e3d82cd06f72d9fea0e146a5211ceb53c067581590deef6ef86ddebf43d4a1f099695d2768ff8a75895e51e3f4f27f49667a7bea4dcfe4b5255d95442a5fae0d35b4fc003fa46f940d33bc6ef557ba3365682099eb881a4fb15b57e7e6647eb4cfd56599f563ffe774b7e8b28f925da0bfa8f3c965d26c2e896dd36dd769612acbc94042275e7624db6630a781485149484ae568a1c29ff03eec02cbd7f77365ca448e1f4aac03d40588d81b9958e891c6e3f78083fe8d02af4e983b5238b0f554db1d94f0d06167428c887aedb7921de5de1a0bb4d88d2421b05652cfcc09369e82749e721e883c25127dae02d9501187638c30e2c41cfb477bf5f7fae293fbc555dd982bb2a73ec89cc45eac8560705c0d795460a592941b1eb5ea6e7fd8dcde047caffe4ec02902367d21bdfb51e1acf6816dc0abe3f2c9a2646808ed5401e16c69b34ea68d1c1f9a33af444667551d19e3664c006e3b9d7cf92ff6d1582279116cf070c6613c12b6675c7e3accb0052cae38dc3d69a9f1adc24c2362e3694914bfa8970f033ecac5b4ec61f0e0cf850612a81691287e758e4ac65b2f84ba5b08d326e9bc9c0e0a64e45053e69bb13900ddec1dd5a6b59d74e78452d3a3a638796657cd467d7a8820df5f75ec3346d64e33ec15261ef977875753cdc4d6c70cd06b8f2df61770d32dcc70eaaedef4cc8f119f63be03552fa321e054cbf812fe52490a5e8a9b74606f9f35d86e942ffe053795ee92684bfc7dac7af0654dbe5a411cfc90935d2afb6e71bdd835a788c53448f66d86612be2d59621a99b5fc526841a5d645c45b1c821bcff1753ac107ab32d1099876c65a27c5ce3584d61045c6d419559e317a126e4e7f72baf922ff1efa759ab4ee6cc5c63d24b04d8d61a90f086c1a2f91a5c25d0d7d9331c8c67bd091aedb0a4ad720f121939a3f3c54cb66d256c21bd29b61da004e0492011eed2d0ae43d18480f8adf3e708cc5e5524c035ffd0e483fd03d5b0a9c62782e2e01b2e04c14a6c112bac7416a3cff75aa7999a15701ea455932bd98f00fcb56d9734b22ccb683f82c952af6f03aa60c9a895abf4077e24a52eb3607a1a70d95c2347eb5595761da2fedcc28418024e3b4814d7227bbb45e455c345b2846f3165ec0f621700ec612a417fcfbd755720293c7fc8d6915b49ed46992d7ed8a4ad9d1562db6e9a7e887fdc4c4ffec35d6fdd3efa8da7e4aa4eb2c47452071a03aed35923433198104c0fc525452b10e9cb746506a2fac8aebb4471c9fc99da384a07ab66d2e1b96485ccbbf11c94a7ab75bfa040053e0d7a1be8bf2be4c2686c75190484d82b7d6585a5c209ea270f330b92c6328a74826493918bcad7697d2a83960e9dd74af1f9c39e9af5c1c14de846d9a624fafe45b76ee06854d6620e32b26159cab6326c7501ebbddbc263df899d10bfb8b960e05d75b124b9ba04437173b73aeab4e88debd74570873bf4d4b2f43a6f76441a07c314638dc384abdf1693903ca44def36c132e7b4793ad07d86b684eb43e214feb32e437894265f85ee7db731eeaecd0c6f2085f350e1a1170643b2a2ce5f663850b0df43ea17c39f2dbbb51a65d749ef87e975817c5b39bbd73c06e36c514a59a3b5b609e8360c7a750a753f429de40b7ebe45f2935655fd9c271086751883f796fc1a6fedc5f1e331541f913b228b44e6dda9d2398a06af2349b5b37910bb4f1e9907dcaf1f359aea064dfc9e38d4cbf58bab4d19b37313b70fd4930d6145aa692c57fb404497c206d818dea578a54839b83cbcdac82c8db14847921343d9a0e14a2e3c35f3ea822bfa6653043335e888c43941380ff5b53e6e1a275121433d1092301658602ab6d47b338df7469f6f897a4b3340cb2a6a3237d38e4effc04b9b5e08d691f56a24f701785fa0f825cf8c307936aa53b54d02c317e43085547b701288377e5bc3a36ace59eb194a75f5ba03f9a74320fa8269c2a976472dcff09b385fae4a794e3c7582aad9a6cc0e3ead61f300383c921cfbb5f6d962e5712a9b0681fcc187233e5d7b708d5f5a8200b28279dd6cbdd802d90323454ec6e39da688a5d806fd73aa685d08bd9122b3e3432a6f02dfab08392fd949e4d32f7865a7ec8e9730b498ce1d18f8ddb80f721bcc3302a7b2cd615e4a1a7c3507410cc3f96afdcee5e7cf7c91e1e0edc961904647e2e11c6e9a35c1f400c969d0407b9bc85bb263df75a43dd34ad137dac675cdbc0a3cda11d649083d853510118cdae4c7b31c8d29a9b351636a8be22fe5e69c2c090565de33f7b08da4a2bf9e55e191faccdf24a0c132489b774654f9ffebf776260f77999ff8917076c41c139af50654b68e5d6b5363967f892e1c4aa475090ab935fe72725a1c9b9a48b3899ac8d801a22859e9854c04166bc80f5909b95089b4192be909459dffcf9fdf005759113a0cea51d0fe82b6a430d0f0ee0baf3b554489f0bb051db8bf7daa39c6ae7c3094858630be4806e2ff1293e43884260f39c0f559e5aa94f217982c5751901788875105f389f27ba6e0208b70f28fac8eafdfb90246e27ce9b9d8c99bf7662ddb3709ba10c73bb10fd781944b0f780da62544979a789cdf8580199757e5e22a48e23a0622d3d93d7ec60b707b52af4574dbf36d894ff50b7e6f2bde232a0c8dcc10daf4083f13a58b942021c5fd0b1bcc5d8018fd86935524a372037007793244c9fb613ef0eb72760bd1188dda95d372f37981320c80b66f11c155d2d79ea2c29161335ec23e717deaeb768facdd4a8e245882b1737a2ea563e726062e56ee2983b7ef26303838b6d3cbbeacbd9b5a5a65913bb587b5b43ecee7661fc5fa486e150949b85d929cc18005fbdc9a3d97c715d4f03345dd1a83c8fc2df6bac1b32112521cea549ca6eefbac58fef0d043e872d2b011063098b1c47e7a28e2f7e69c17f6498d018cc6664a9491f86870b5067b128e746c1d720c8c1623718667cb5bafd832de49673f8f3e84234cb509283e730bd37a6890698fefc96121a9ce8540ae3238fa2612ba0c83e02204ff86b80fee6bed78262ad3a9a8dfe10938ac2f2003a52fcf5fb8fbd86c7d5f1a8908f790c79e1a43abb909489eb303e6e88d7e55fd70d02f3af16771b9dcee983145d838079d4c60c50417b445936ea2b154f4e5a9f943ed829a31b0d5d7a06c379340b311473d98bb4479b18625627a867ebca638b2daf30795d4ad64ca2ef5b4fe07a7738de83a4105ba0673f16246db9d2534582e9df358357587d25a4bba4feafae80bf05fc2a96f0c2da182eecb17b654c1767dc3805eae14c99b7fbfb25b46f0587c90f79e03a26bd10a06fbc887041737dabc660cfd247d99df128852409fdabaf8048ce3f5bf1e838920b8ff5cb07c84d1b356e31ec83ae19b9567f336ea1038478228a0b647b61988868cef42cb3f95d3fa1529da3b428f165563393ea8b1c40b9843fa9abed93917cf1493344d212a49baa3a181b7194d9711435ec2a6a50f1888abfb46b664412efd496063c93a10679ab2f895a952f71a880fb3f8bde4517105a318f4bcbe54bb9ce82a705182511831a3b80b12a57d74338e139c835c7cccdd29474d944e81817346678e6912cdefcc7ee15645df9663607fa723a71a0007b7d1d5188739094876c4a1d439028ca411ce8c2d792db2c2a0f267482e26971f476eb40fc53f1e6cd615ad7535f097139254ba4ea7b950be47ae393f92124f2c48e72c5d579eaceeedceacd8bf9770aa7fffa6576d21f67741cfdf8437373180e26394727d9a0f4ea5f44c15e8c21758d888864833d100a7e673ba11c131f31975646aaa45d58818403078d616596f73e324848b7b29d06f8651cf6de028bb4f7a714a857e31b1a98aaf4198640a1f8a70ba4cb11d03dea5d705a92c77c8795a36a752bc6772ed384b20e866025b35d22184c7769469c3002210bafd7e3080237b5369efc104c814ff3755d2701396e454364fcd7f9181c63030f868b766eea8bb052084cf3aa00a8699209b4c8350972808fe6d6d262ac778ae1b8a9e8eb7f76f8ec44b891340417f3c69c0390cc01e189fe30c20ea2a85b1fb871d8ff50099edecd0fe1d5d9d917f055b5a8cab371bff903a476b3e3e7f9d7b7d33918cc16a815d2fd53b1e931dec8b18a93cb283f9a3a31a89570f4b79d92587dec7bbbcc4b9446945103df20ad53ff9ce3d3588df77406a8b18d6f66cf444f9eabe7372805ad9ec20155ed5d053e7e47a6a5d003fa8b892831aebda141bc0fb8a40abf94f26d9e7d6a6392de6557650a7cb7b1f3d9c5156497634baeeaab1e796a59b2c36c69e764e973c31dba47f28dd55b1758c4c652df8c5c0955f001ee82b4911e29b3c1a778536848923ad43b116abc675b82d4c4ef27740954dd4cb2b9639ebe9c434a360b7fe39ad3e1bb3333c9c0f82e174f3b12303896abdb893c9a5c8a78d61b5dc54597aabedede06cd13ecbd6ee64c4a9244b32d78b844426359eda014ddcbad3bf751b8cd89e37b065fa97bff9c5abd463e7d923e308b50dadab39dbca9cd3bb8aff92ab1be2de2c836ccdcd3f0975f6bc52d47b5bc76cdad13d538cf3bb81aec28fa835ece6c79152a6e01a591880d128bf083e9c44321976ac7c1d9f385365d995c9656011e7387fab44f50a88425358a5f606553d3cf840c0ed39da72bdcacbd8629290bc7168f569c5fea2c540ee587a1468caec26f5dda816f4cc5b2e83ddcdd6dc92d52b9ddd5595c3175780873fa767e161aa336233b3cfcdc2f901f8577cf772d6c017be483d12405e6c26d9a6670453f25c9ffc4661860d3247e43ce2ef40e98b9cf94e183b1b7779478d2a5c2dbcba3c7a25452b4ca3b2ce7cd2b9e0e12395fd82642ba448b0e122c7e61d42a1bd3e3fe2e93457e372c18bfecef689303476b467ac1a82be141e01dcb1df2919dc5357defd7cf281a0fb7684808058b1e9734c4af995358228391f5f7d31608b6d51d486c101778f8a54e51832e766b6721d3d84d0d9b4021e30f4e476768069b6a07ab6226802de1bc32e108e0b7937002763d8ed27749dd817cb97b67cc371b8eb20e2790392a13a176a78b71b87b5719365643a4ee35bb8512380a3d2330b8d7e5d58dd45eb15cb31ee9f59109af105e43a5cf102a59b482381ac0997b79ba8c32c3d98fd083a52751b95d603fa8021b4e8f97d8f09bb50aba4f62c4e3bc5c537476fbf6579d3baf21ab3456564ce718beacc6a341c5205a8c99341ffbde7558a528252e686cc07b27a02a015f913c5251d58d206d75a10ea250269338d55802712b8104235bcba5ddae1360aa6ae21cf30e33a992b9d7a007d9d565841e95c40e730348788ee1f542e99a40c6b24099e41da00fc2b535c38e9042724d2bb77e60217fac4ac6359155fd2c071123df88b3bed6b9dce54761b9d9ce926c046b63d3b534b1b9ea4ea84e3f27bb71f99d1c38c5b9b3c506e8b413dc1bae723feceef8bd243369869404116161f1d64b678e7dd2b2a3824be370654ff9c686f73affd0b525f873746ba939d41f6d30aaa03b9cab73a2a92427618562b78671ca71e7c7554c6c1dc6c187face673fd769339273bea8664a4a6698f62967adc0447641ca307487a7894e8b854eca6303d8e864e9d7a3806072709743218af87faed3a327940097fecb20f6da03496a4b2b4b674fd7a58cec024b207cd8408c691a27f7cbd2e76474ed369ba9cebd66f457f1706c13cac7486b94428fcfe960b810f7c3c74802372049958512fe4e803186d770c571d3aa06f6d0bf7458e5a4f195fa3ccfa07ce88fbaa47f8bc86fd71f1b5b6dc6bfc7141687fce05583750f9c4150efa1357bcd0b18d87aec5df1da593b553b2188d67579b80e3ec6f6ee73ed65d498a3839b1c9996ddaf7d0b842c8d94abd66f6798c4c12515110d7ffcefdd627b61c07389c964d1ac4be9e60d0b17c1e7c42d1686f04dd03b66a4140570bf98d6587692d53d025468869d6407ed7169d71776df62bea7503e83b9a055d425ed0868808ec7c6ec7a0b56f9f859263cd67faeff9ac8f27bdc18491c55707452b413d1bf144ed76357a2646583c93ea3320bbd9c21180a20a32fdf5af4f4d59c5a406a3411ccf7315a62f4149dd8f24bc8e212e97dd5bcd2293dfd09037eaefc39fdf8e483cba48d907adb2a2e75e9e3f23076a5db4c468dbd367fa8a493b429762e4c64adcf898bafabfb48e008622e8485474ce7897c88ec62b4d6950f5de368ad55f0b823d2b9ce62018cd3484289a8494e58976913f6dd3ee7edb82a5689cd637144a2d6c9bfba6140e614dcd88db4261731f7e5482e341a9d5c724b801fd7563a34feb4fa4dcb9c1a9bd4cf0f32021962da2d0ccde458a523de454f11d5e2857c30371609870d7c4f7b917d4a4147348777a24b3370ac4477e8607313f93bf13b4af20e06c4c0e206ab0fd09a840b3a6bb4920b90e51837ff823c54ef3306406be0e2288c20e9e97ffae62ee9c595975e7a143fadd36ac122475e0271fac2a29e4e9f9705515829fdd747dda1e6cec5ea67739aa0048905b021d80a8af75332d5caace73b3dfbc2fb6f8d76122295cd09f820a99877870115cf2418b15c0ee7d3921cc198bf98200cf6a222fce9930788c37f7f8414fea25d6e9e19a61960951595d50bc4470a9bbadcb951391eda7c753770bc736d9b064992e1127ebf338157d143017826b657dbe2206bf7273487c3a21fc3ef65d0f908e2c85d5479188207bae3e1d645de9e846dd3da2ab1b3463d7906992bb2034dddf1bccc756c4ddaffaa4c09fafb7e0c9cc65913baf8c58aadc12a0c643b62dd56316a33ad3454cb8dea5b32cf6edcb97957eb7bb161462cb78697d11ed437357e3ad9b98152e9630b19bb0ffa19f25e78910dd7610f91b4d0d4809c7072dd427fe5f507d35f3e28cfbedf108d679603883b44af524c6673a76581229528ab4d1cdc516d0ded66d0256c9abec937f93ec235964474d135c12eab6ee6cdf33531925e52248de19f114ebaa6cf25bf622c33ba496ecb93bd42810e44c508604894d3ea5fc34221926e1c25fccc22eb443c68a0219b0718956e87a27c716ec83dc924bdddc2d242154ba5eec266173d18442b565ea8c4a5577e6b5f8bc911938cae94cb92a7c6117cdc3f02e1e3148c41f08c7aa9b6a8d4dc918bca1a5b532a6fda6d6a50bb3666a51d3a09742f14804b8023f50227af23f6039edf7684c4d23e64a007f34a9100cd26eec30b81798226e6b12c3316bf2d4f251e498b06c07993b3b1ccb468e699ec6dc52790882c6892060e4bd7719fb2865f698df5c1fbd07c6bded2e6639bf3d686e3b4fb6d9230a0f228fd658e19c4678a1a4fd02aa6d61cd9f353c319f4bfb40c4ddf822add95a835b07922f03a364c38c0a1d68b844363dc685cda0d5086cc51385397e3ec9c808793eb7208eb565ebdb09ce4c47534b52d387c35e5605ddbf0ae89f309a2cda7bb4cfa26cf51279930847b96a391e019b3f7418a4c8ecdc08b98d0420e301a38bf0631c348e2f1187e4f552668678645b0e8d6e5382c63b01f7a1db90f431d820475b2e08f92dc348dba6482521f98e89580b27c322cb52e7ebe95d02899d7265ea545225106c792bb54615003ece3b8c06ec3d05fc345e8a5c1c6cbfa9181b624af9c4ae559b6ee709f885823574c84e57fd9f93d24e1d6f46aa196c751102c34e02b90cd42d8d579b5f4d3f4d8f59af45fef005f3aaff21dacb2c0420e0aad6fca52539364464cf6da0e93a4b676b7d1d1afbf14366b23ec8c1d7dbae61faecf2bd46f1d7daceae53c7010f488114b5ea379281a25799bec4a0bcd83a87c64599c497b3d92b8abf4744d21810b3f3c756ae3f3fa561c2c67a8d5e6b0ba65a45e5b322d09e755b9fd521c9c42c234562439b766dc66ee11b7bdedf5574388096757815e6a971e3463e72dd0bd2539846e3844c0d1b9928b7151a5bb7eef5742b7493924ad1d0b39795ea1deb6fb1f7e79b1adf8e2eda21d5793a114d8d4d1445bd15affc1601c7b82ff9cfb4d1ac2ac08233acc1e4c3d8827fdbe3168fde7805d1621402c859ab31e05bd0867b1544e5e8ca82063c9e1ad799f6b5b189c8b96bfddd8f5d567afc3cca0ea050f7793be02dd3416ca1d627eba1350e65d3d10c5c2f2e8c52b4f200ce55b31372d2a941984729807ec40a2c0adc89d9ae225879f5a1d6e1211b1d039aacf2d6a5239915943b4d7bb81ecb4484fdedf7b16a02b16100ca09077b3b03980f75f3e76c0b20da6098e826334a4b1bbd5e0c476fc46991eb308a85deb6c4d6988db01062dcfe57fc063ea76f7f5dddb38bf3c5a81f695f1c8c60b363f8fae0e59225ec8a689be0a6b9033c00fbf304d8d5e0b7c3ad44ce0fa807e49e79dba4e3bc53239820fb73ba78a99bc7faeed72556c0737d6136c4fa4977d1a45820454da23454d5d511c5a67f9931359fb911d3283ec4455376d869a6fd255b387cd14f04b655915170f872168a85870369dabeeca4b37b818a4b1c5cf54c2e44c87e0666c56d7a179a085221859ade720f8ba1caa844a8e645b58ccd6d8b6afa0199c34a56c75fc130e9dc960cd6269311d1c38914154729565f0670c5cce09b6f023cb1a77974e59891beaf5599e785889c17d53ff0b29763bdd9838ead6b11759a29695800f7a9cc2a1c341f5f680a2cff13f24d1dd17d2177ecd8c8a5554326fe1ea8dab5f2629072a1c62cbe127f447c53adf5a63ae3464f4d7ec198b059184fc48266b636e155e197be9e2f9c0085c76e49d278d140d44207a5b7f5f8bc7d167b7dab6af5c83bc810263f4ee42a6299f8032584c1864a655efa88f1b925afd8647b320d9d9151730921ba1583452b06fc5c839db4c6c7547b2bf2f88224676e1081fa2cb805ce4cc4d76cedc03c2502d269499ebce81f442921dff1ce9cf2cc95e7cab7e5929c82a5f515e44129f76003ed6ed32464c03c41408f4138b7c4e2c46ab5d79baefa69673a68695c7e94d90acd9ac787408dd6de0764ea62b501236946224b5b8b1b6b3e57848a2e8323891528012c9abf839e40fc0011adb5b132037a85f4fd018e8889cd5e4b207f9c496325e8202a7060381122268c19dc0466b35b0b9099a1e9ccb220846fb7edc12fb1e382a335668c4191160b955f07f9363b4cd90f118b16fb9c691c3fed920416a920e6f4222267997ad9c7ead88883eb0e8066ac0c34e13fc8aa073484bce98275ff2ad4625bb2bc68e22286464798ac02ccee71cead2bf11bbe54e6f19ad0ba129b898727414c7f5bd020edc36bcd15fe46e5b33a12a31b89014fa7f15908a867bd51e6b4e3c1e03faac45c380af91e5d9759e2e1253788bf65ad080a278d55f5a896216788fcb78caeee96b9b5841bb785f04b8ea89c4b5d036771f5a326b52b516157eb2d8fe66ad6c78665b53661a205273155e719069b2961838e90b5ed5c2e208f32c6f7fe956f05709f755380a8c30abb587196d47c9a46c35533824008004d7589b448f9eda438c8abb938ba5101215f867fcf4b96262cbea44c558f884419831c5fd62da60330228a951154a2aad39f20f4891a6307d47403f0b121056254eb4c56d6f3e6cd16c59d3c1689514243cd6451c0ed3df1ded32d9f7f212da2d06b3728f8a1e74f7d627bd3a74dbf24e1f9884daf8096ab4a173aa6f9c37770a23ede4bf9e5a22b95e416bc3d4a356e7e68e2ad7e0b9812284eda26b4a94c37890fec843c9c5511edbf83b2e3f89b9b507cf85fd0149627b6621421f98acf1866ccbfe3cfb7e966c434029f919c054516dbe3be9d660a543c80e617b7fafe2dd22a600bddda55ec558fc287c8a42054e125116819a691f2688a6d28cf4c4312ffbba241afe7b0faac13f754c34f340b8e10bea168a2c52c1af331df5312e6a04584b3b1c23fb6aececb130bd528ce29c820842358db473cd023a5447532efce9f1e42ae786ba7e890957ded306676dd9638145b9b228c85d510cef58e85d7fbdfe9c8fd3ec4da939ef4d53805305f0b72152b3e44f2697ebdac528d936c698eb2eabb2829f784dbefd75adf3a80bb22be7bee3c59448fd517564c1a8dfd2486c46fd0c39014a17a585b841a04a7453de999e4ab830f06d6356db32a0f6c7778453eeaf0c1b320c3bc63647689f90739f59b37fccc73dc62eb749e9d8e0a027719e4cb63bf17faa46c7d0a584fae1a12beb6960ece21cb7e71fa31156783e780c2aebca205ead7945946021f87468eba1b60c935f20a0b363f1a5f0be3c00c400e45613e31f3186b5f544d380221233749dade9f30df3c70a0ba5cde59f14fb3707231e727e524a9fd100c2417648c9e1b0377b74fce10fade72a0bb374b2e36efa3ba84aa5bb852b1133cfa38dc6e5d3480a77ba77bfce5f51f2a616d4a328721ce5a55be67b12225675144465148a77868707c5509b23031ef72bb5186cb0ae23528043241e816e4e91157d89e4810d575ccc6a92f2237780aeb6d132bf565f3c65fd425ca204508ff4b66350981aa469e33edd241ed99074e7ec56f6b00390299b2f65d7d385f58a2169c02f8ccd2f11d78d4581ff62320cbfa6b323fad2ab4ca35659768641470585c74b358a527a8393c84ed919935e0c0803836556f033c03e20af108b2a03b6511b84edeebed895019e9c974b6c8e0e28d6a2aae5a84676207dd78c8150d2142c51326b13a3ad6da773a4841e0cda50c22354a57e71f6da4ff2222c3e2469435171f6ba178222105435a8acb7ac083f40c2aa440b49d53ca06c3e552d062f7191f8fb9cff7516cdc411d1c443a6c672cb8d78f887a4f9c89015902a230f62cc176b8c267c5500a656a9d1befd9ed9e0303e5c28be0da0294ef2661fabdc99f99a7e95ca1ecf3c7f46d689dbd28fd43f32f8d6d9c4534d05f791c729b12087fa229f8358bd859c4839b1aa821b2d3838ee435f38f8d93082c980099c6a921ebc70fe8d8dc9175bd418c1df03bacf064df073ecd2d22928efdc3b4c1b6353c92452f19e4df278d0c52556cf53228ae80ad96b767fc6d335336ba4ef88d796445ff3e4d0c2631d7605224e7cd934ca2df24376a9ad5f3c16d8acf5d462039c4c07dba57fab5126a9fa40a1f616def3cc08837844a69c7af8a5f8f84636c7d7333df1bf6ad091d829615de6cefd93c77ee5f3c3b6dcad90a4db8f91d6c78fb120069d059bd894c0ce06e0741fb0a64b345a65ae4ef6ac393e6929b3c746c384f2551fcb3e7f38c7cc188575ac70665957a65f2983b274a7d265f37b3fea905b26f27c7487905a58ac06a5064189a2e638faadea07aaa4b6136295c1a6fd0c90e6ab1a26999af1a9eedf514896a77c778ec9267f3b923189f9afdc9fee5361b998be0db8490f3a7a489c3c0e3e68987b02b63678ae3b90b9062b280190db4661c97a0fcc22587bd8f4183fb16cae12563c2745dd04e596a5719eed0e57f915213e7eb02f36b534e82247768c5f544b5159bcc807258be0b0f44d3bbf920cfedcda573a1574cc57c7822a249aa69cfc349e7b6de60132496e83a02d3ee98dd066a6cf0782ceaaa4671408bb2a4e58f948eeef5e9127717f675788f404fd89a9d21368fc2b6ecddc625f2cf085dd7454fefc811dfc09bbaaa80239ea7d2091a8d7cbd29d7a89fbff0c6c97f9c2ef8854baa0ae5e7c0be6de716e995fd724cdf114c2de44767b4b0fdc83a88ecf615c6ab4551664967cb877756245b2eea3bc46ff0908ed959ea2eec3907e85acf846aa1ce88231832de61f58749c869d2485c833679676eb5d0372c1323d30e8ee799cd31f10e7a0580ea02156e6300ee3af29cbaadf3640ad196c7f26c0aa6b09188815255706de17389ecd589a24e6ec7ac9fe32038f01527d78c72b1f747cd9c32c079ad3c72827011560506a0ba3cbe60dc29ae4618a252d65c0483788f71664f16949ca7a267d1ad4ed5e19cf5b644f414c87fdef9619c35b038957bb6577516a891ca3133a27d4abedf6c9691e498ea3bcbbd2715b7ab06600155a5d974b27390f8ef0661bda4733509d6220a5f229e55ebaa1325ddf4c87bf8037361eb9a704b8660e4d07c72ef149a22379254b80b4da02f023a2cecff6422ba3b928a749c19dead34ce353d28755177c835d68b019bb69dfe9766211413b4d824a51f532da5e7734b399de3d91e403fc61baaa2d3961176047fbb5d557feef9ecbf928e05985cac57b39c2aa0971f020ea478917c99b570305b8685f62b50eb194d084e3d7b468766ae6c7c09f9d1fb0bb506f4562e3e4fb1672eb11acd5b7d015cb249060b8c399ec3d449928684c1fa95040517a7212fac189c6f4f34980892b1c0f19eaa8140a728417b8d0b737bb199a56ea4dcc7a94ed8243604c592584517881962d7e74d5abe1b7c56abaf44196267b06eb36ef25a5eb4d167427588decf6e21bd7b6eb964d93545cef6ab89d7a8bb1469618ec6b0c874522fb85fd824870661de5fb5e7778f78ce73e104ebc5d4e29663b093d1ef65e7580eeaca070ca37280096d98489e9517fcd1256b3179c637497a03e209a8bfb544d009440f05cf68fe50cd646379fda5268ea05fc5b2a4cd6e04fcd5c58978dbcc828fa4697369dbfd2407a9e89f94d19cbcf25d8a368e2b04bef933ee5e117506d68689bd43c98beb7ec21b3f145d3840e0488e34e09b6e6e9f7810099021130349b5803acf66f9f8bdd1c8e10694a555b5587eff6a6b1c01bd06133a22cee117365342794a77e210a2371c21314399fee208d17a0f78bd6df48533407102939010311dbf44e6f17684b0523c5abe27790f84a388c13563131f3c429f26ff2b8f24b34ce9ab99ad1549a6981a6c372be4714b56051ba3fa5cb78ce70374c7ef1711d395f03c0d34b118f31fe168d33115be78633f068ef16d25603354faee84a003b6965a2e0feb5b70963319e85f3c10d83a777ab444289d6a674e03e48f3fd78a88a752f10055a3bd95dec2f19f4d1d7821611acbb841fec8b4b329fdb9a83cf55aaebd8a1f71ade6367e00a83d075f88653682b5669bfe0c3a305d0c1c1809ba26de055e985bcd4513efe206c67b2832caf18abc77a66f2d46fb0363cd65304ab1e5878e239db1ee16abe218ae3d9fafe5f779faf7b1a360df38d0dfd449042c88257adaac1daec4f371fe2c603fa659a25dbe3594e4b75c16c832916a29ac31b67b3dd277fe6bbc5749b1cc1e40db60d6892de309de3f6d549711d465bdb0263fa762cbfaf8be74485a849db4fdfb40eba71fa76fffd9bfb73e4551aa7eb5b4560b3676a1abd95cfa327416f204719ea1d2f9638bdd4f1ab695e7b197d76450cdeda70bf7618c8dc36fa5776b64f7475c67ac701a793057d0b4e8ad2ba8e116f9f9833442bc635773d79c3537b762b7048e72bfa1870e61a87cc4a0bec5c5e531b9e085af8e116abbfb21c6c1049aaf14519206d934998c33ad33ff9263b357c4b056cf25ea9d69430b53708a67b9b1f53dfb32d23b25228dddcfca01026a9528e921ff18c1ec2e1fe2a005f807daeb3054c548676522586745938fa0de8b628e24baa407927f796e365ccf8080008c5a7d7c2a0df9e7783dd083587de9317a3bfa219038eb7a30f1977245a662920d187258957259821a83961300077fef49743a7495843628256b5c97689b3148ce5a6ddbf4d27532f85677b16121fb4906f5ed2c93ce5124cf89a3f6e620c6a8bb6458a372ed7411233c7e7b6eff0f35ccbeda457771373fb30edb8c0d9c5ad526c016dcb2cb4a47dcdf4f87373ec2014235eb7c66cc05e07b1d4e804d6b0bb0012e2193ce54853143a376688e3ecd780932d0a025e87f7b47424e8316c2d1eb49edf8c088f8de18261141438921ace8f4f3788e909e9bb6a4873cd1ea1232d02166c5751984b178df67b94405320792ee805939170ee1ccc4a831b4c7d8a96ed18a8fb5c7efee288dd695cf2e20a63a4989a520b985609c2db3450d2255d6dfe0a5ae810d96c5347aa80325c112a1d0f52e0b806567f882e5ffd25fd72024b3a0dfa9902474693e76663a2afb50a028fe764d8e094cfe43749fc230e69c38b20d6554e4317feacfc113410264efe2e498a1bf327f48cabbd1580839a3766bccf347bab2c04af8e0a26272c0a27f6e1cbe1c193a1aff6e9900b0502b989ffc4aedef83bdc010746b875c14f30a2a99a72e6bc98a8fb087eb6a68ba4598efb9a6c66420efa6df10190541e65169b39fceb803d48b370b6ec254949f126c83b4bb8c03efa15635cb26123d6619a5214dbde01236dafd0d38a0782e68a67afd3f441e9a0feb9f0e235a4480476e2c4a08604abbdf2e157c639592c67fd6bd06f33bdf3217e780eb5c1da132be577f5256220cc1f15c874665a880b9b3d1579926cebdba2b4e1fd87f52d33cafcebc375aa41b9b8fe9f73299285ebf1dd3e1d72afb77fa45f088c957a295c39a6d452d02f203b1a04ac8597985a9c4eff52e9cf5db48052ad2eff916cfc133a01ace41ac5a28a7322f9584b0291ad9e79b479e97cadb27ff68a3c02d09fef2db3d51d896484222ddd179949dd5ab23fc612af51d019715ef0d074ea0eae5e45d1b75a1024877fda079a48c59acd0f8d411996ce84fce9612d4e3947fe06b49a09226b366c69e52c6d4e19d7ad9ff1e8f0478abaa2e662f7a1c1a469f232652ec003ebbda3028e434af7da10ae1d2c839ebd092278f4a7d14f98aeecc336ed83d6d694c09d1d5b112089f026d49ad88ca958ef874703b5c6c9a15b182a137b25274753ab094046f9f641e9173b21491aff7cdde64104c51c50a98b627998a9f289e694481ca010d5b027c13b4cd003c39a23a40a88c78f44cf5b4ed52f9af77d515ffa016c4d7ecb308eb963a65be37bca291a5f62300e7044c7a1e635b5ee32bd212603fd4b444c4a6766d80bf1d6986948bec286ea3e01a7e4a563b8d2adf63fe4409d06b36e98179069b94451af4c6ec0e45a1800e18980e65b88bbe534482f0cbf7b60649e8893588140951d4429761fb5c19e1e99e550c81466a85ac7c253052a3ca0e17b38fb3175e429856109718a840fd454f333deb04dea4c388282c41c5b7d96b08213b78f30d53fd80f74becaeb119050506f033d711f5726c6bf5669df16116942c0619fb5e0bc9651a0cb47132e17fb522bb22c45b48c06a21b31eab39f90836be1d74ac10317858bfa604e2569c6ae47f354757586f9f05ee7cbdecbf817395dd5ccb805e865a3743290847e3024be3f179089d3bef074aa2038cbc7717bcc397760f57e483ec95990c4015cfec4ea818e6cace491971df7540a231e2fbc566b900dd6eb34f31b40078600a23d429688f124ecdbdd9b8acb09c00bdaff72e0b1257facee235cbc1e284497821925e44264be707058943bda8ddf7b4463de32c28ec27f20a473fde2271bcd9e17b023f8f3e1ed3a93b3a07c1e17e556eb0302b9f257e19f2e98d2a7f6d553562c2c5dfd52fccc0011dae8f97feee1a1f24cfb8259ab099626f558497a323c34ed3632afbbe959985493c7a44fc672fdb504e188f85ed0bc36bca83e397e7badfeea5fd3d561dcde7f53691f5f11d5744d29d1aa369564ef63d90cc646da20ac7ecf3d373a854962dea0afeeaeca79ac952ce2b6ff535bbde437d0df1dc80a49ee1946a19837097ceaced1f43532dd761946fea767bfeb32916cf9522e0114dfdab850ce207e58c22679a855e9c80b0219ce05aa7b4770d22ebdff567128bca1a6271a4d8887fa325daf813d71e6c509f7aff2873b8b53b03622904b0d33baf0b92dddf6ec6fcf2c237658f8d7ebdfb3e8976b31628310dd29f42414704b08ef0263e2ce54331bd5f6300c626668c73a5a723b191f3a82553da53fd5d5c3e384fe1e65aa78fa7970574150b5b80a1f307de74ad972225806a78e758c4459252371b6c95010ed4ded764752790a50ea2870909a2ec481b846797031b7e6f46c62e341420318c8bdb22396a0f2ae3f59b80649c8f7c093ccc50d60ec3136ce20e3859151840bd13ff9bc6055dfca22926e185cd2b9f36319b8265a0feb325eda94265c9dad3c699edb6253dd0af1c2df0861f5bee814d200b9dfe3f64b92a602cb2f316c34850daa0b8ca86ac142be01aa6ed97422ec49d9be0de020175909cd62bd1fbbe8336edc0171a1349ad9d64e9a76cfff0f3fe95c4282ab32c4c48d526ac2cf777ec0816694e9ad8173de4568ef996d2f8b8f9e388f410c9d9b0fb45cb1af5f1a21bfaccbff3823af40f15f809e9fd4b19e7a366a59b6b13c57fa62e34075956cc632fda10f4866d8deb0ce56136fe38ebc225964460f6015ae530ceacf9139e3afd1817129ee74b927a8ff5308af090c0da3bbf485b5d70a42b11505dfa61179e0b08384847d8e453b50ce286c679cf429a1fa6153b3dc7b78fe62ae47ea1fd7f9d6eba2a32ee450d7f7afe54c91ec2b7662ba51c7c0ce05497109543297816a31337db0322a3eef0668974c65f270444948f3cfb9ad8d4b4d7c331626cee66e04f054428b4dd197ce1a688ce7f9df36899068eb9e33abfb69a6c3007ce011571812a550f426fa708907101da9467b6057ce06744c30a14572257f0046128308467f7a6a3de1c6dc87a50b4366df1d81c157f46cac911186cb288ba3627e5b697f86ca26b291856775b40c035043c33918efc7fd39c353f39bb71603d4c3eff8eff28723a5a81b78d0c88cebddf18bb9884c389b22aec04900a6b9c5f3fda15c31011c9aba37c115b8f2ed849d293f3e0e3a9bbdb587dbd63ca9e8c7ba1e1780c48ec5ff9bdb3af8983a3ce43311f6df9c57e4775b274655daadb9ac75e50dd42cd5fa9d42488de3735a80c0e149188f56f448c41bcb66359d73096c5a48a85ce2a71ec1d590f59c57ac66767bc732279d56a4ac8dc459ba195994c1386ff6d3d67b26479c8f26521b9abe430490cdd0f6993de89ec7758990b30ae38ab3d381f151918d9669d0cef07198947b4c8b475eb79e04772609468b34d95d09366ebb5f294e7283dc197ad45649b6127e822f004a5e086c9380f23210b73981c66f98bb65010eefacca0dcc3880a2a015dca687fb2a42a7a67cd0253aad141ee29daf2189aa7c15dbd09edc68c4d4793a8bea87094e8e555d751d9937280b759da043ab68a1cbad738ea6db48c0b308bdf103dbf861a07e84ca8bb832dbadc2df34ac06887bf62af1bb39e6f69f86b6e915796d25bf396735a276c52ea92fb91b8917394eb700752df76410e3fe557334f60b48c5bb9d65a271f0905e8ff1994e016dbc68a35b26624c0468a8618b8407b1b9df38ab1b9705cd62081b0bd9f694f53d22acb527a7324a69202f5e401e841364ca17e25f76d4b22c37e2c8785f6d7808033e24478f835a8ff259a75ffc05aa643533ceb507eff9dcd5c899b5dd42949fcd3c51c6c538c8abb95a62d6149eedfb5f8f9c5628c842b62e752e277a60028dcb452cbaa4842e86abbadbe3d6a37f6cf38fc07c3cba4093ffa47e4ecbca2403009b5dcde63c6f0246471c9f5615ef2c1bb923957a5ce5221775cf78ae2f347ac667947e3094b11f555242036ce6af91a63e4143bb266f273d32377c1c79b541063e9866fb9c5a3d6329b5e6194bc51043eaaa4773ae5ba2a47d5b6a923a6ea18bbf8a69a3f88e7b0e6b77db9dc36c3abcd112744e76ae7b8a29300e5b967490716a36d2dea98b1e3bfa28b634f7083b910ed8754ff0df1bb8df1cfe71c529621a560bf487dc362bf74e7ba3baabeacd280d65d83fb74f499e114d734d2cef1f2a67fff530e5ff631f874a80bdea4b7730f705d01b9bafe43caf66a18bbc59887997e68f2e97e559e19d3bbef69ae85984fd09f649e83c458b6cf37cf3abbdd84ed27b49f4199f61c9c5ea2136578aac304ae4e6eac678d550a5ce7e2e95496ab979fc813c387d23cb3723cfbc5b753a031b9f0ec0d3278b8755aa072a380af9ca672224f4faf0777bef9549737f28a522cab0d8a896606527aec30aba7a46ddd3946a10cdda46cd676e100bf4489336a032766270708aebe63033f6cad4feba49affa93328961de37cdc5206ab1f7819946275dbf5b01c496fe797c6caa1ab8f4569f7ee887bfc84c047ecfb482d2f7a794fbd0d970989ea0cb9ce5f804389f6db49e08cc51ecba41cc15d9c57317c1bc0e2416f69b6dd0f9f708a07bc8bd0b3a2f2738fd12aed5950967bd6471e41ac229378616b2bd8a08891ce2cdb21a0331d0b67bbd76a5444b9b6fcfbee37844c495de3a759cb15ce5b745c2fb453cbbbf9ef5521551deda19d26b71fcb59455260527a684479da47e716c6a7a64c32fe00bbea00016dd53089668ecf73ce3563edfcc7298d93d114613a02c2f744833524a0a437248404bc355dc6649eea73c8e3d7437db6e2b2e421ecb4cad439c6ba0549d47cf49c28e642d2a998cc70fcb4a3630e244f21938b2b4ce80d212c6e9be72675f5d43d2a22aefad4cbcbb0bad28d594f9fe3f20c27d2e244246152431fe75822ce4245cb5cd4662837fb517411d6e1a5fbf69f431f4c69bb2f4ebee96a6106997721f64a32f205a53b8e63232e37bccb81a9c6397c2bfca28c3c1ae3ea18506d93c422bf2c712da0eb7211846ba63e18e43b25970127a523a217e41d6d366b540f833a613974171769612d1b87fa86e3fe2524bd39afb96f605d777eec9db3f6c448080a3211da4dd7d6a5188f737828a73959e7f35c56c342305db568998358b1127ea0635426e6dcc33081cd4f9f51fd95518fad106c46069cdf3feaf8fc5b8bd3392239c7fab462f4ffea1c006da21004f2730a987058ed29e2251e82a78e2067f3039a3876a3d45a0110852a937f9e346b77de85607da01dd7bdcfca436223c3b818b98bf1f08eb9a676496efcb66cfa611fe93f2e68c98d07be7a9c00424161cc65e77c071d54dd77bbaae35dd4020de444887947b7414597d26054d3ece9d94750a273deffcbb8e0d15fc51a81152f4a13b3e4b901d1762654b25ac3212f527e79566995c7d39f32d7d2bfd1bb0dd1ae54453291eccd7e8fdda953cd3826fe6bfbd6bccbc3f1133a087a1a90e257bbce40acfa39f2c7f82ddbc08d1337b1084053af2081be9f892ccecb47eb3fefa371d64f23b9792d545208eb0a8a3b9640136fabe7acaa75dd9697f6a2baa2d55b09abcd5ce9cdc95c2d9633cb5041cbcd1b366599bb7451460c83a904b728763b0a429e083871d2aeced5cd8e191cf2b769bb6818c04a0cdc8120e214070944e8e18e494c50c876ae41ff7380eb4696e838c0ad9dc1c41a3bde06fb8e8edbf53c048bfd87f30feffedf2bce2fee8d5dc3688080cbb78523f5f4cfe947ec4d6e1b4c97139c69c905</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="123" scheme="https://www.benboby.top/categories/123/"/>
    
    
    <category term="123" scheme="https://www.benboby.top/tags/123/"/>
    
  </entry>
  
  <entry>
    <title>C++语言基础</title>
    <link href="https://www.benboby.top/2021/01/C-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80.html"/>
    <id>https://www.benboby.top/2021/01/C-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80.html</id>
    <published>2021-01-31T06:52:21.000Z</published>
    <updated>2021-02-16T04:51:09.041Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="97134e09d1699e40cf4a2e9425fce21c65c8ce28be9d5d727f8bdf9baebd4b03">88bfb973b5cd9a98289a5356073cb3e561ba3d32e73d841574e69103b5f1f9aae2192abafa0de617f739417117b3ab5755edde64286664e6b44b8ddd2328ea294dedbdfe4c55bea61dd2a36d0922b59307517dffde5ac89cc3d1eb061ff9e4b7124352d64862212dd5dc603f4f1ee74da0f0d03d14c992d19b6ddff40dab7f53b5820f126b6c7f61dd13a11aff5176cc</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="C++" scheme="https://www.benboby.top/categories/C/"/>
    
    
    <category term="C++基础" scheme="https://www.benboby.top/tags/C-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：最小体力消耗路径</title>
    <link href="https://www.benboby.top/2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.html"/>
    <id>https://www.benboby.top/2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.html</id>
    <published>2021-01-29T01:02:03.000Z</published>
    <updated>2021-01-29T01:47:37.414Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个 $nm$ 的权值矩阵，求从左上角走到右下角。$(n, m \in [1, 100], w \in [1, 1e6])$</p><p>一条路径耗费的体力值是路径上相邻格子之间 <strong>高度差绝对值的最大值</strong> 决定的。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ol><li>二分答案：由于答案具有单调性，所以可以二分答案，然后通过 $bfs$ 进行验证。</li><li>并查集：类似于最小生成树，将所有的边都建出来，然后贪心的将当前权值最小的边加入集合，判断起点和终点是否联通即可。</li><li>最短路：将所有的边建出来，做一次起点到终点的最短路径即可。</li></ol><a id="more"></a><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仅给出第二种做法的代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 并查集模板</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; size;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="comment">// 当前连通分量数目</span></span><br><span class="line">        <span class="keyword">int</span> setCount;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        UnionFind(<span class="keyword">int</span> _n): n(_n), setCount(_n), parent(_n), size(_n, <span class="number">1</span>) &#123;</span><br><span class="line">            iota(parent.begin(), parent.end(), <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">findset</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> parent[x] == x ? x : parent[x] = findset(parent[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            x = findset(x);</span><br><span class="line">            y = findset(y);</span><br><span class="line">            <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (size[x] &lt; size[y]) &#123;</span><br><span class="line">                swap(x, y);</span><br><span class="line">            &#125;</span><br><span class="line">            parent[y] = x;</span><br><span class="line">            size[x] += size[y];</span><br><span class="line">            --setCount;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            x = findset(x);</span><br><span class="line">            y = findset(y);</span><br><span class="line">            <span class="keyword">return</span> x == y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> x, y, w;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumEffortPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = h.size(), m = h[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;Node&gt; g;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>) g.push_back(Node&#123;i * m + j, i * m + j - m, <span class="built_in">abs</span>(h[i][j] - h[i - <span class="number">1</span>][j])&#125;);</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) g.push_back(Node&#123;i * m + j, i * m + j - <span class="number">1</span>, <span class="built_in">abs</span>(h[i][j] - h[i][j - <span class="number">1</span>])&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(g.begin(), g.end(), [](Node&amp; a, Node&amp; b) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="function">UnionFind <span class="title">uf</span><span class="params">(n * m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : g) &#123;</span><br><span class="line">            uf.unite(p.x, p.y);</span><br><span class="line">            <span class="keyword">if</span> (uf.connected(<span class="number">0</span>, n * m - <span class="number">1</span>)) <span class="keyword">return</span> p.w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给定一个 $nm$ 的权值矩阵，求从左上角走到右下角。$(n, m \in [1, 100], w \in [1, 1e6])$&lt;/p&gt;
&lt;p&gt;一条路径耗费的体力值是路径上相邻格子之间 &lt;strong&gt;高度差绝对值的最大值&lt;/strong&gt; 决定的。&lt;/p&gt;
&lt;h2 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;二分答案：由于答案具有单调性，所以可以二分答案，然后通过 $bfs$ 进行验证。&lt;/li&gt;
&lt;li&gt;并查集：类似于最小生成树，将所有的边都建出来，然后贪心的将当前权值最小的边加入集合，判断起点和终点是否联通即可。&lt;/li&gt;
&lt;li&gt;最短路：将所有的边建出来，做一次起点到终点的最短路径即可。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="并查集" scheme="https://www.benboby.top/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="图论" scheme="https://www.benboby.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：解码异或后的排列</title>
    <link href="https://www.benboby.top/2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%A7%A3%E7%A0%81%E5%BC%82%E6%88%96%E5%90%8E%E7%9A%84%E6%8E%92%E5%88%97.html"/>
    <id>https://www.benboby.top/2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%A7%A3%E7%A0%81%E5%BC%82%E6%88%96%E5%90%8E%E7%9A%84%E6%8E%92%E5%88%97.html</id>
    <published>2021-01-24T01:10:06.000Z</published>
    <updated>2021-01-28T06:02:23.360Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你一个整数数组 $g$，它是前 $n$ 个正整数的排列，且 $n$ 是个 <strong>奇数</strong> 。</p><p>它被加密成另一个长度为 $n - 1$ 的整数数组 $a$ ，满足 $a[i] = g[i]$ ^ $g[i + 1]$。比方说，如果 $g = [1,3,2]$，那么 $a = [2,1]$。</p><p>给你 $a$ 数组，请你返回原始数组 $g$。题目保证答案存在且唯一。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><a id="more"></a><p>可以发现如果对 $a$ 数组做前缀异或和得到 $sum$ 数组，那么 $sum[i]$ 就表示 $g[0]$ ^ $g[i + 1]$ 的值。$n$ 恰好为奇数，因此如果将数组 $sum$ 全部异或起来，$g[0]$ 刚好为被异或偶数次而抵消，得到的结果为 $g[1]$ ^ $g[2]$ ^ … ^ $g[n]$，恰好只有 $g[0]$ 没有出现。然后将这个结果与 $1-n$ 的所有数异或，得到的就是 $g[0]$ 的值，然后递推即可。时间复杂度 $O(n)$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">decode</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.size(), sum = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">g</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) g[<span class="number">0</span>] ^= (sum ^= a[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++) g[<span class="number">0</span>] ^= i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) g[i + <span class="number">1</span>] = g[i] ^ a[i];</span><br><span class="line">        <span class="keyword">return</span> g;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给你一个整数数组 $g$，它是前 $n$ 个正整数的排列，且 $n$ 是个 &lt;strong&gt;奇数&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;它被加密成另一个长度为 $n - 1$ 的整数数组 $a$ ，满足 $a[i] = g[i]$ ^ $g[i + 1]$。比方说，如果 $g = [1,3,2]$，那么 $a = [2,1]$。&lt;/p&gt;
&lt;p&gt;给你 $a$ 数组，请你返回原始数组 $g$。题目保证答案存在且唯一。&lt;/p&gt;
&lt;h2 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h2&gt;</summary>
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="思维" scheme="https://www.benboby.top/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：最小高度树</title>
    <link href="https://www.benboby.top/2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91.html"/>
    <id>https://www.benboby.top/2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91.html</id>
    <published>2021-01-14T10:32:21.000Z</published>
    <updated>2021-01-28T06:02:23.354Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一颗树，求当树的高度最小时根的编号为多少。$(n \in [1, 2e4])$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给定一颗树，求当树的高度最小时根的编号为多少。$(n \in [1, 2e4])$&lt;/p&gt;
&lt;h2 id=&quot;Solution&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="树" scheme="https://www.benboby.top/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：交换字符串中的元素</title>
    <link href="https://www.benboby.top/2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E4%BA%A4%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0.html"/>
    <id>https://www.benboby.top/2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E4%BA%A4%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0.html</id>
    <published>2021-01-12T10:06:55.000Z</published>
    <updated>2021-01-28T06:02:23.361Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你一个字符串 $s$，以及该字符串中的一些「索引对」数组 $pairs$，其中 $pairs[i] = [a, b]$ 表示字符串中的两个索引（编号从 $0$ 开始）。</p><p>你可以 任意多次交换 在 $pairs$ 中任意一对索引处的字符。</p><p>返回在经过若干次交换后，$s$ 可以变成的按字典序最小的字符串。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><a id="more"></a><p>假设 $i$ 可以和 $j$ 交换，$j$ 可以和 $k$ 交换，那么 $i$ 就可以和 $k$ 交换，因此是具有传递关系的。因此将互相具有传递关系的索引看作一个集合，用并查集维护。然后对于每个集合，将字母从小到大排序放置即可。时间复杂度 $O(nlog(n))$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> fa[<span class="number">100005</span>], v[<span class="number">100005</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fa[x] == x ? x : fa[x] = find(fa[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">smallestStringWithSwaps</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) fa[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : pairs) &#123;</span><br><span class="line">            <span class="keyword">int</span> fx = find(p[<span class="number">0</span>]), fy = find(p[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (fx != fy) fa[fx] = fy;</span><br><span class="line">            v[p[<span class="number">0</span>]] = v[p[<span class="number">1</span>]] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; id[<span class="number">100005</span>];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; ch[<span class="number">100005</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!v[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> fx = find(i);</span><br><span class="line">            <span class="keyword">if</span> (!mp[fx]) mp[fx] = ++cnt;</span><br><span class="line">            id[mp[fx]].push_back(i);</span><br><span class="line">            ch[mp[fx]].push_back(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">            sort(ch[i].begin(), ch[i].end());</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ch[i].size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="keyword">int</span>)id[i].size(); j++) </span><br><span class="line">                s[id[i][j]] = ch[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给你一个字符串 $s$，以及该字符串中的一些「索引对」数组 $pairs$，其中 $pairs[i] = [a, b]$ 表示字符串中的两个索引（编号从 $0$ 开始）。&lt;/p&gt;
&lt;p&gt;你可以 任意多次交换 在 $pairs$ 中任意一对索引处的字符。&lt;/p&gt;
&lt;p&gt;返回在经过若干次交换后，$s$ 可以变成的按字典序最小的字符串。&lt;/p&gt;
&lt;h2 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h2&gt;</summary>
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="并查集" scheme="https://www.benboby.top/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP学习笔记</title>
    <link href="https://www.benboby.top/2021/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9.html"/>
    <id>https://www.benboby.top/2021/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9.html</id>
    <published>2021-01-10T10:06:30.000Z</published>
    <updated>2021-02-11T15:54:13.073Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><p>ISO七层：物理层，数据链路层，网络层，传输层，会话层，表示层，应用层。<br>TCP/IP分层模型：</p><ul><li>网络接口层，ARP地址解析协议，提供硬件间接口。</li><li>网间层，IP协议，负责数据的包装，寻址，和路由。</li><li>传输层，TCP协议提供可靠数据流传输服务，UDP协议提供不可靠的用户数据报服务。</li><li>应用层，FTP（文件传输协议），HTTP（超文本传输协议），Telent（远程终端协议）。</li></ul><h3 id="TCP与UDP区别"><a href="#TCP与UDP区别" class="headerlink" title="TCP与UDP区别"></a>TCP与UDP区别</h3><h3 id="TCP超时重传"><a href="#TCP超时重传" class="headerlink" title="TCP超时重传"></a>TCP超时重传</h3><p>出现以下情况，TCP就会超时重传：</p><ul><li>数据包中途丢失</li><li>数据包顺利到达，ACK报文中途丢失</li><li>数据包到达对端，但对端未响应ACK或被对端丢失</li></ul><p>TCP每发送一个报文段，就会设置一次计时器。计时器设置的重传时间到了，还没有收到确认，就要重传这一报文段，称为“超时重传”。</p><p>RTO：重传超时时间，<strong>发送端发送数据到重传数据</strong>的这一段等待时间<br>RTT：连接往返时间，<strong>发送端从发送TCP包接受到对应的立即响应</strong>所耗费的时间</p><p><img src="http://img.benboby.top/%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0.png" alt="RTO 和 RTT 比较示意图"></p><h2 id="三次握手与四次挥手"><a href="#三次握手与四次挥手" class="headerlink" title="三次握手与四次挥手"></a>三次握手与四次挥手</h2><p><strong>简单示意图</strong><br><img src="http://img.benboby.top/三次握手.png" alt="三次握手"></p><ul><li>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 SYN_Send 状态。</li><li>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。 同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。</li><li>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 establised 状态。</li><li><p>服务器收到 ACK 报文之后，也处于 establised 状态，此时，双方已建立起了链接。</p><p>  因此三次握手可以确认双发收发功能都正常，缺一不可。</p></li></ul><p><img src="http://img.benboby.top/四次挥手.png" alt="四次挥手"></p><p>[问]：为什么要传回 SYN：接收端告诉发送端，我接收到的信息确实就是你所发送的信号。<br>[问]：为啥还要传 ACK：SYN 只能证明发送端到接受端的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来验证。</p><ul><li>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。</li><li>第二次握手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。</li><li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。</li><li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。 需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态</li><li>服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</li></ul><p>[问]：为什么连接的时候是三次握手，关闭的时候却是四次握手？<br>答：连接时，当服务端收到客户端的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文，其中 ACK 报文是用来应答的，SYN 是用来同步的。但关闭连接时，服务端收到 FIN 报文后，可能不会立即发送 FIN 报文，因为服务端可能该发送的报文还没有发完，因此只能先回复一个 ACK 报文表示确认收到了。等服务端所有报文都发送完了，才回复 FIN 信号关闭连接。故需要四次握手。</p><p>[问]：为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</p><p>答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p><p>[问]：为什么不能用两次握手进行连接？<br>答：考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发送了确认应答分组。按照两次握手的协定，S 认为连接已经成功地建立了，可以开始发送数据分组。可是，如果这个应答分组丢失了，C 就不知道 S 是否已准备好，C 就会怀疑 S 是否收到自己的连接请求分组。在这种情况下，C 认为连接还未建立成功，将忽略 S 发来的任何数据分组，只等待连接确认应答分组。而 S 在发出的分组超时后，重复发送同样的分组。这样就形成了<strong>死锁</strong>。</p><p>[问]：如果已经建立了连接，但是客户端突然出现故障了怎么办？<br>答：TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><p><img src="http://img.benboby.top/字段含义.png" alt></p><h2 id="从输入URL到页面加载发生了什么？"><a href="#从输入URL到页面加载发生了什么？" class="headerlink" title="从输入URL到页面加载发生了什么？"></a>从输入URL到页面加载发生了什么？</h2><ol><li>DNS 域名解析<br> 当你输入了 www.google.com 并按下回车后，浏览器检查输入框，发现不是 ip 地址，于是去 <strong>浏览器缓存</strong> 里面找有没有相关记录，发现没有，那就继续去 <strong>系统缓存</strong> 找，也就是系统中的 hosts 文件，还是没有，又继续去 <strong>路由器缓存</strong> 里面找，查看的是路由器映射表。接着，计算机将域名发送给 <strong>本地DNS服务器</strong>，也就是 <strong>提供本地连接的服务商</strong>，本地DNS服务器找不到的话，会将域名发送到 <strong>根域名服务器</strong>，也就是 <strong>‘.’</strong>，找不到就返回 <strong>顶级域名服务器 —— .com 的IP地址</strong>，再请求 <strong>顶级域名服务器IP</strong> 返回 <strong>二级域名服务器 —— google.com 的IP地址</strong>…直到找到对应的IP地址，然后返回给浏览器。</li><li>发起 TCP 连接（三次握手）<br> 知道IP地址后，<strong>传输层的TCP协议</strong>就可以向远端服务器发起连接请求了。</li><li>发送 HTTP 请求，接受 HTTP 响应<br> 连接上了，可以传输了。计算机需要将用户输入的地址封装成 <strong>HTTP Request 请求报文</strong>，发送到服务器，服务器收到请求后会发出应答，即响应数据。<br> HTTP请求报文格式：请求行+请求头+空行+消息体，请求行包括请求方式（GET/POST/DELETE/PUT）、请求资源路径（URL）、HTTP版本号。<br> HTTP响应报文格式：状态行+响应头+空行+消息体，状态行包括HTTP版本号、状态码、状态说明。<br>   常见的状态码：<ul><li>200 响应成功</li><li>302 跳转</li><li>400 客户端请求有语法错误，不能被服务端识别</li><li>403 服务器收到请求，但拒绝提供服务（认证失败）</li><li>404 请求资源不存在</li><li>500 服务器内部错误</li></ul></li><li>断开 TCP 连接（四次挥手）<br> 完成一次 HTTP 请求后，服务器并不是马上断开与客户端的连接。默认启用 <strong>持久连接</strong>，以便处理不久后到来的新请求，无需重新建立连接而增加慢启动开销，提高网络的吞吐能力。在反向代理软件 Nginx 中，持久连接超时时间默认值为 75 秒，如果 75 秒内没有新到达的请求，则断开与客户端的连接。同时，浏览器每隔 45 秒会向服务器发送 TCP keep-alive 探测包，来判断 TCP 连接状况，如果没有收到 ACK 应答，则主动断开与服务器的连接。</li><li>浏览器解析 HTML 代码，请求js，css等资源，最后进行页面渲染，显示出来</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;TCP协议&quot;&gt;&lt;a href=&quot;#TCP协议&quot; class=&quot;headerlink&quot; title=&quot;TCP协议&quot;&gt;&lt;/a&gt;TCP协议&lt;/h2&gt;&lt;h3 id=&quot;网络模型&quot;&gt;&lt;a href=&quot;#网络模型&quot; class=&quot;headerlink&quot; title=&quot;网络模型&quot;</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://www.benboby.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="TCP/IP" scheme="https://www.benboby.top/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：货仓选址</title>
    <link href="https://www.benboby.top/2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%B4%A7%E4%BB%93%E9%80%89%E5%9D%80.html"/>
    <id>https://www.benboby.top/2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%B4%A7%E4%BB%93%E9%80%89%E5%9D%80.html</id>
    <published>2021-01-09T12:09:30.000Z</published>
    <updated>2021-01-28T06:02:23.350Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>在数轴上找到一个点，使得到其余 $n$ 个点距离之和最小。$(n \in [1, 1e5])$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>考虑绝对值不等式：<br><a id="more"></a> </p><p>当只有两个点 $a, b$ 时，有 $|a - x| + |b - x| &gt;= |a - b|$，为了满足 $|a - x| + |b - x| = |a - b|$ 关系，$x$ 必须选在 $a,b$ 两点之间。</p><p>拓展为 $n$ 个点，距离为 $|a[1] - x| + |a[2] - x| + … + |a[n - 1] - x| + |a[n] - x|$，收尾两两分组有 $(|a[1] - x| + |a[n] - x|) + (|a[2] - x| - |a[n - 2] - x| + …)$，两两应用绝对值不等式，$x$ 的位置必须满足在各个对应区间里。</p><p>得出结论：当 $n$ 为奇数时，$x$ 位置为中间那个点（因为刚好分组多出单独一个，满足最小性则必须将 $x$ 的位置选择为那个点，距离刚好为 $0$）；当 $n$ 为偶数时，$x$ 位置为中间两个点之间的任意位置都可。 </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, res, a[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    sort(a, a + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) res += <span class="built_in">abs</span>(a[i] - a[n &gt;&gt; <span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;在数轴上找到一个点，使得到其余 $n$ 个点距离之和最小。$(n \in [1, 1e5])$&lt;/p&gt;
&lt;h2 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h2&gt;&lt;p&gt;考虑绝对值不等式：&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="数学" scheme="https://www.benboby.top/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：按要求补齐数组</title>
    <link href="https://www.benboby.top/2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%8C%89%E8%A6%81%E6%B1%82%E8%A1%A5%E9%BD%90%E6%95%B0%E7%BB%84.html"/>
    <id>https://www.benboby.top/2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%8C%89%E8%A6%81%E6%B1%82%E8%A1%A5%E9%BD%90%E6%95%B0%E7%BB%84.html</id>
    <published>2020-12-29T05:09:57.000Z</published>
    <updated>2021-01-28T06:02:23.357Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个已排序的正整数数组 $nums$，和一个正整数 $n$ 。从 $[1, n]$ 区间内选取任意个数字补充到 $nums$ 中，使得 $[1, n]$ 区间内的任何数字都可以用 $nums$ 中某几个数字的和来表示。请输出满足上述要求的最少需要补充的数字个数。</p><h2 id="Soluiton"><a href="#Soluiton" class="headerlink" title="Soluiton"></a>Soluiton</h2><p>容易证明，对于正整数 $x$，如果区间 $[1,x−1]$ 内的所有数字都已经被覆盖，且 $x$ 在数组中，则区间 $[1,2x−1]$ 内的所有数字也都被覆盖。<br><a id="more"></a> </p><p>由此可以提出一个贪心的方案。每次找到未被数组 $nums$ 覆盖的最小的整数 $x$，在数组中补充 $x$，然后寻找下一个未被覆盖的最小的整数，重复上述步骤直到区间 $[1,n]$ 中的所有数字都被覆盖。</p><p>具体实现：</p><p>$x$ 表示当前能表示出 $[1, x - 1]$ 的所有数字，初始化为 $1$，枚举数组。</p><ul><li>若枚举到的数小等于 $x$，则加上，表示能表示出 $[1, x + num[i] - 1]$ 的所有数字，然后下标加 $1$</li><li>若枚举到的数大于 $x$，则说明 $x$ 无法被表示出来，我们需要增加一个数 $x$，然后$x$ 加上 $x$，表示能表示出 $[1, x + x - 1]$ 的所有数字</li></ul><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPatches</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, i = <span class="number">0</span>, m = a.size();</span><br><span class="line">        <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; m &amp;&amp; a[i] &lt;= x) &#123;</span><br><span class="line">                x += a[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                x *= <span class="number">2</span>;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给定一个已排序的正整数数组 $nums$，和一个正整数 $n$ 。从 $[1, n]$ 区间内选取任意个数字补充到 $nums$ 中，使得 $[1, n]$ 区间内的任何数字都可以用 $nums$ 中某几个数字的和来表示。请输出满足上述要求的最少需要补充的数字个数。&lt;/p&gt;
&lt;h2 id=&quot;Soluiton&quot;&gt;&lt;a href=&quot;#Soluiton&quot; class=&quot;headerlink&quot; title=&quot;Soluiton&quot;&gt;&lt;/a&gt;Soluiton&lt;/h2&gt;&lt;p&gt;容易证明，对于正整数 $x$，如果区间 $[1,x−1]$ 内的所有数字都已经被覆盖，且 $x$ 在数组中，则区间 $[1,2x−1]$ 内的所有数字也都被覆盖。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="贪心" scheme="https://www.benboby.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：最大矩形</title>
    <link href="https://www.benboby.top/2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2.html"/>
    <id>https://www.benboby.top/2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2.html</id>
    <published>2020-12-26T06:52:52.000Z</published>
    <updated>2021-01-28T06:02:23.348Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个仅包含 $0$ 和 $1$ 、大小为 $n * m$ 的二维二进制矩阵，找出只包含 $1$ 的最大矩形，并返回其面积。$(n, m \in [1, 200])$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>有一个子问题，求柱状图最大矩形。预先求出 $1-i$ 层的 $h[i]$ 然后利用套用子问题的模板即可，复杂度 $O(n * m)$.<br><a id="more"></a> </p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; h)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        st.push(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> n = h.size();</span><br><span class="line">        vector&lt;int&gt; l(n), r(n, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (st.top() != <span class="number">-1</span> &amp;&amp; h[st.top()] &gt;= h[i]) &#123;</span><br><span class="line">                r[st.top()] = i;</span><br><span class="line">                st.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            l[i] = st.top();</span><br><span class="line">            st.push(i); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) res = max(res, (r[i] - l[i] - <span class="number">1</span>) * h[i]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = a[<span class="number">0</span>].size(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">h</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) </span><br><span class="line">                h[j] = (a[i][j] == <span class="string">&#x27;1&#x27;</span> ? h[j] + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">            res = max(res, largestRectangleArea(h));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给定一个仅包含 $0$ 和 $1$ 、大小为 $n * m$ 的二维二进制矩阵，找出只包含 $1$ 的最大矩形，并返回其面积。$(n, m \in [1, 200])$&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;p&gt;有一个子问题，求柱状图最大矩形。预先求出 $1-i$ 层的 $h[i]$ 然后利用套用子问题的模板即可，复杂度 $O(n * m)$.&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="思维" scheme="https://www.benboby.top/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：共鸣问题</title>
    <link href="https://www.benboby.top/2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%85%B1%E9%B8%A3%E9%97%AE%E9%A2%98.html"/>
    <id>https://www.benboby.top/2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%85%B1%E9%B8%A3%E9%97%AE%E9%A2%98.html</id>
    <published>2020-12-23T13:46:43.000Z</published>
    <updated>2021-01-28T06:02:23.347Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>现在有 $n$ 个音符和 $m$ 对共鸣关系，编号为 $1-n$，每个音符自己有一个奏响时的优美程度，共鸣关系 $(x,y,z)$ 表示音符 $x$ 和 $y$ 同时奏响的额外优美程度是 $z$，同时不奏响则为 $-z$，其他情况为 $0$，求最大优美程度。$(n,m \in [1,1e5])$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对于一对共鸣关系而言，在不选的情况下收益为 $-z$，则选择一个的话，收益为 $-z + z = 0$，都选择的话为 $-z + 2z = z$。因此可以预先把每对关系的两个数都加上 $z$，刚开始我们是不选任何有联系的音符的，因此初值为 $-z$，那么选择一个数就会加上 $z$，选择两个就会加上 $2z$，满足了之前所讨论的关系。答案初始化为所有关系都不选的情况，即 $-sum(z)$，然后只要贪心的选择对答案有正贡献的值就行了。<br><a id="more"></a> </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param n int整型 </span></span><br><span class="line"><span class="comment">     * @param m int整型 </span></span><br><span class="line"><span class="comment">     * @param a int整型vector </span></span><br><span class="line"><span class="comment">     * @param b int整型vector&lt;vector&lt;&gt;&gt; </span></span><br><span class="line"><span class="comment">     * @return long长整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">wwork</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; c;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : a) c.push_back(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : b) &#123;</span><br><span class="line">            c[v[<span class="number">0</span>] - <span class="number">1</span>] += v[<span class="number">2</span>];</span><br><span class="line">            c[v[<span class="number">1</span>] - <span class="number">1</span>] += v[<span class="number">2</span>];</span><br><span class="line">            res -= v[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : c) res += max(x, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;现在有 $n$ 个音符和 $m$ 对共鸣关系，编号为 $1-n$，每个音符自己有一个奏响时的优美程度，共鸣关系 $(x,y,z)$ 表示音符 $x$ 和 $y$ 同时奏响的额外优美程度是 $z$，同时不奏响则为 $-z$，其他情况为 $0$，求最大优美程度。$(n,m \in [1,1e5])$&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;p&gt;对于一对共鸣关系而言，在不选的情况下收益为 $-z$，则选择一个的话，收益为 $-z + z = 0$，都选择的话为 $-z + 2z = z$。因此可以预先把每对关系的两个数都加上 $z$，刚开始我们是不选任何有联系的音符的，因此初值为 $-z$，那么选择一个数就会加上 $z$，选择两个就会加上 $2z$，满足了之前所讨论的关系。答案初始化为所有关系都不选的情况，即 $-sum(z)$，然后只要贪心的选择对答案有正贡献的值就行了。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="贪心" scheme="https://www.benboby.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：大逃离</title>
    <link href="https://www.benboby.top/2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%A4%A7%E9%80%83%E7%A6%BB.html"/>
    <id>https://www.benboby.top/2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%A4%A7%E9%80%83%E7%A6%BB.html</id>
    <published>2020-12-22T14:28:30.000Z</published>
    <updated>2021-01-28T06:02:23.343Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>从 $n$ 个数中任选 $k$ 个数，取得这 $k$ 个数中最大的一个数，求每个数被取得的概率。$(n, k \in [1, 2e5])$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>将数组排序后，枚举每个数被作为最大值的可能性，当第 $i$ 个数作为最大值时，其它 $k - 1$ 个一定从前 $i - 1$ 个里面选，即方案数为 $C(i - 1, k - 1)$，将其除以总方案数 $C(n, k)$ 即为被取得概率。<br><a id="more"></a> </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param n int整型 </span></span><br><span class="line"><span class="comment">     * @param k int整型 </span></span><br><span class="line"><span class="comment">     * @param Point int整型vector </span></span><br><span class="line"><span class="comment">     * @return int整型vector</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> f[<span class="number">200005</span>];</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">qp</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (b) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b &amp; <span class="number">1</span>) sum = sum * a % mod;</span><br><span class="line">            a = a * a % mod;</span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == m || m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> f[n] * qp(f[m], mod - <span class="number">2</span>) % mod * qp(f[n - m], mod - <span class="number">2</span>) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">city</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">auto</span> b = a;</span><br><span class="line">        sort(a.begin(), a.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">long</span> <span class="keyword">long</span>&gt; mp;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= <span class="number">200000</span>; ++i) &#123;</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &gt;= k) </span><br><span class="line">                mp[a[i]] = C(i, k - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = C(n, k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            g.push_back(mp[b[i]] * qp(sum, mod - <span class="number">2</span>) % mod);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> g;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;从 $n$ 个数中任选 $k$ 个数，取得这 $k$ 个数中最大的一个数，求每个数被取得的概率。$(n, k \in [1, 2e5])$&lt;/p&gt;
&lt;h2 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h2&gt;&lt;p&gt;将数组排序后，枚举每个数被作为最大值的可能性，当第 $i$ 个数作为最大值时，其它 $k - 1$ 个一定从前 $i - 1$ 个里面选，即方案数为 $C(i - 1, k - 1)$，将其除以总方案数 $C(n, k)$ 即为被取得概率。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="数学" scheme="https://www.benboby.top/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>GCC编译器和GDB调试器</title>
    <link href="https://www.benboby.top/2020/12/GCC%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8CGDB%E8%B0%83%E8%AF%95%E5%99%A8.html"/>
    <id>https://www.benboby.top/2020/12/GCC%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8CGDB%E8%B0%83%E8%AF%95%E5%99%A8.html</id>
    <published>2020-12-20T06:09:48.000Z</published>
    <updated>2021-01-31T06:51:45.883Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GCC编译器"><a href="#GCC编译器" class="headerlink" title="GCC编译器"></a>GCC编译器</h2><p>GCC 编译器支持编译 Go、Objective-C，Objective-C++，Fortran，Ada，D 和 BRIG（HSAIL）等程序。</p><p>实际使用中，使用 gcc 指令编译 C 代码，使用 g++ 指令编译 C++ 代码。</p><h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p>例如 <strong>g++ test.cpp -o test</strong> 可拆解为以下步骤：</p><a id="more"></a> <ol><li><p>预处理</p> <figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># -E 选项指示编译器仅对输入文件进行预处理</span></span><br><span class="line"><span class="meta"># test.i 文件将头文件及宏定义具体内容全部展开，其余保持不变</span></span><br><span class="line">g++ -E test.cpp -o test.i    <span class="comment">// 生成.i文件</span></span><br></pre></td></tr></table></figure></li><li><p>编译</p> <figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># -S 编译选项告诉 g++ 在为 C++ 代码产生了汇编语言文件后停止编译</span></span><br><span class="line"><span class="meta"># g++ 产生的汇编语言文件缺省拓展名是 .s</span></span><br><span class="line"><span class="meta"># test.s 汇编语言文件内容为汇编指令</span></span><br><span class="line">g++ -S test.i -o test.s</span><br></pre></td></tr></table></figure></li><li><p>汇编</p> <figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># -c 选项告诉 g++ 仅把源代码编译为机器语言的目标代码</span></span><br><span class="line"><span class="meta"># 缺省时 g++ 建立的目标代码文件有一个 .o 的拓展名</span></span><br><span class="line"><span class="meta"># test.o 为机器语言识别的二进制代码</span></span><br><span class="line">g++ -c test.s -o test.o</span><br></pre></td></tr></table></figure></li><li><p>链接</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -o 编译选项来为将产生的可执行文件用指定的文件名</span></span><br><span class="line"><span class="comment"># test 为可执行文件</span></span><br><span class="line">g++ <span class="keyword">test</span>.o -o <span class="keyword">test</span></span><br></pre></td></tr></table></figure><h3 id="g-重要编译参数"><a href="#g-重要编译参数" class="headerlink" title="g++重要编译参数"></a>g++重要编译参数</h3></li><li><p>-g 编译带调试信息的可执行文件</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -g 选项告诉 GCC 产生能被 GNU 调试器 GDB 使用的调试信息，以调试程序。</span></span><br><span class="line"><span class="comment"># 产生带调试信息的可执行文件 test（不加则 test 不包含调试信息）</span></span><br><span class="line">g++ -g <span class="keyword">test</span>.cpp -o <span class="keyword">test</span></span><br></pre></td></tr></table></figure></li><li><p>-O[n] 优化源代码</p> <figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 所谓优化，比如省略代码中从未使用过的变量，直接将常量表达式用结果值来替代等等，这些操作会缩减目标文件所包含的代码量，提高最终生成的可执行文件的运行效率。</span></span><br><span class="line"><span class="meta"># -O 选项告诉 g++ 对源代码进行基本优化。这些操作在大多数情况下都会使程序执行的更快。-O2 选项告诉 g++ 产生尽可能小和尽可能快的代码。</span></span><br><span class="line"><span class="meta"># -O 同时减小代码长度和执行时间，效果等价为 -O1</span></span><br><span class="line"><span class="meta"># -O0 表示不做优化</span></span><br><span class="line"><span class="meta"># -O1 默认优化</span></span><br><span class="line"><span class="meta"># -O2 除了完成 -O1 的优化之外，还进行一些额外的调整工作，如指令调整等</span></span><br><span class="line"><span class="meta"># -O3 包括循环展开和其他一些与处理特性相关的优化操作</span></span><br><span class="line"><span class="meta"># 选项将使编译的速度比使用 -O 时慢，但通常产生的代码执行速度会更快</span></span><br><span class="line"><span class="meta"># 可以用如 &quot;time ./test&quot; 来查看可执行文件的运行效率，比较优化效果</span></span><br><span class="line">g++ -O2 test.cpp</span><br></pre></td></tr></table></figure></li><li><p>-l 和 -L 指定库文件 ｜ 指定库文件路径</p> <figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># -l 参数就是用来指定程序要链接的库，-l 参数紧接着就是库名</span></span><br><span class="line"><span class="meta"># 在 /lib 和 /usr/lib 和 /usr/local/lib 里的库可以直接用 -l 来进行链接</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 链接 glog库</span></span><br><span class="line">g++ -lglog test.cpp</span><br><span class="line"></span><br><span class="line"><span class="meta"># 如果库文件没放在上面三个目录里，需要使用 -L 参数指定库文件所在目录</span></span><br><span class="line"><span class="meta"># -L 参数紧接着的是库文件所在的目录名</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 链接 mytest 库，libmytest.so 在 /home/Test 目录下</span></span><br><span class="line">g++ -L/home/Test -lmytest test.cpp</span><br></pre></td></tr></table></figure></li><li><p>-I 指定头文件搜索目录</p> <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 若头文件在 /usr/<span class="keyword">include</span> 目录下一般是不需要指定的，否则就需要 -I 参数来指定了，比如头文件放在 /myinclude 目录里，否则会报错 “xxxx.<span class="keyword">h</span>: <span class="keyword">No</span> such <span class="keyword">file</span> or directory” 。</span><br><span class="line"><span class="keyword">g</span>++ -I/myinclude <span class="keyword">test</span>.cpp</span><br></pre></td></tr></table></figure></li><li><p>-Wall 打印警告信息 | -w 关闭警告信息</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印出 gcc 的警告信息</span></span><br><span class="line">g++ -Wall <span class="keyword">test</span>.cpp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭所有警告信息</span></span><br><span class="line">g++ -w <span class="keyword">test</span>.cpp</span><br></pre></td></tr></table></figure></li><li><p>-std=c++11 设置编译标准</p> <figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span> <span class="comment">使用</span> <span class="comment">c</span>++<span class="comment">11</span> <span class="comment">标准编译</span> <span class="comment">test</span><span class="string">.</span><span class="comment">cpp</span></span><br><span class="line"><span class="comment">g</span>++ <span class="literal">-</span><span class="comment">std=c</span>++<span class="comment">11</span> <span class="comment">test</span><span class="string">.</span><span class="comment">cpp</span></span><br></pre></td></tr></table></figure></li><li>-o 指定输出文件名 <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定即将产生的文件名</span></span><br><span class="line"><span class="comment"># 指定输出可执行文件名为test</span></span><br><span class="line">g++ <span class="keyword">test</span>.cpp -o <span class="keyword">test</span></span><br></pre></td></tr></table></figure></li><li><p>-D 定义宏</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 在使用gcc/g++编译的时候定义宏</span><br><span class="line"># 常用场景：</span><br><span class="line"># -DDEBUG 定义 DEBUG 宏，可能文件中有DEBUG宏部分的相关信息，用 DDEBUG 来选择开启或关闭 DEBUG</span><br><span class="line"># 举例：</span><br><span class="line"><span class="comment">// -Dname 定义宏 name，默认定义内容为字符串 “1”</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;DEBUG LOG\n&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;in\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1. 在编译的时候，使用g++ -DDEBUG main.cpp</span></span><br><span class="line"><span class="comment">// 2. 第七行代码可以被执行</span></span><br></pre></td></tr></table></figure><h2 id="GDB调试器"><a href="#GDB调试器" class="headerlink" title="GDB调试器"></a>GDB调试器</h2></li></ol><p>GDB(GNU Debugger) 是一个用来调试C/C++程序的功能强大的调试器，是 Linux 系统开发 C/C++ 最常用的调试器。</p><p>GDB主要功能：</p><ul><li>设置断点(断点可以是条件表达式)</li><li>使程序在指定的代码行上暂停执行，便于观察</li><li>单步执行程序，便于调试</li><li>查看程序中变量值的变化</li><li>动态改变程序的执行环境</li><li>分析崩溃程序产生的core文件</li></ul><p>调试开始：执行gdb [filename] ，进入gdb调试程序，其中 filename 为要调试的可执行文件名。</p><p>编译程序时需要加上 -g，之后才能用 gdb 进行调试：g++ -g main.cpp -o main<br>回车键：重复上一命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">help</span>(h)        <span class="comment"># 查看命令帮助，具体命令查询在gdb中输入help + 命令</span></span> </span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)run(r)         <span class="comment"># 重新开始运行文件（run-text：加载文本文件，run-bin：加载二进制文件）</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)start          <span class="comment"># 单步执行，运行程序，停在第一行执行语句</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)list(l)        <span class="comment"># 查看原代码（list-n,从第n行开始查看代码。list+ 函数名：查看具体函数）</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">set</span>            <span class="comment"># 设置变量的值</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)next(n)        <span class="comment"># 单步调试（逐过程，函数直接执行）</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)step(s)        <span class="comment"># 单步调试（逐语句：跳入自定义函数内部执行）</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)backtrace(bt)  <span class="comment"># 查看函数的调用的栈帧和层级关系</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)frame(f)       <span class="comment"># 切换函数的栈帧</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)info(i)        <span class="comment"># 查看函数内部局部变量的数值</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)finish         <span class="comment"># 结束当前函数，返回到函数调用点</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">continue</span>(c)    <span class="comment"># 继续运行</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">print</span>(p)       <span class="comment"># 打印值及地址</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)quit(q)        <span class="comment"># 退出gdb</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">break</span>+num(b)                 <span class="comment"># 在第num行设置断点</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)info breakpoints             <span class="comment"># 查看当前设置的所有断点</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)delete breakpoints num(d)    <span class="comment"># 删除第num个断点</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)display                      <span class="comment"># 追踪查看具体变量值</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)undisplay                    <span class="comment"># 取消追踪观察变量</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)watch                        <span class="comment"># 被设置观察点的变量发生修改时，打印显示</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)i watch                      <span class="comment"># 显示观察点</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">enable</span> breakpoints           <span class="comment"># 启用断点</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">disable</span> breakpoints          <span class="comment"># 禁用断点</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)x                            <span class="comment"># 查看内存x/20xw 显示20个单元，16进制，4字节每单元</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)run argv[1] argv[2]          <span class="comment"># 调试时命令行传参</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">set</span> follow-fork-mode child   <span class="comment"># Makefile项目管理：选择跟踪父子进程（fork()）</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;GCC编译器&quot;&gt;&lt;a href=&quot;#GCC编译器&quot; class=&quot;headerlink&quot; title=&quot;GCC编译器&quot;&gt;&lt;/a&gt;GCC编译器&lt;/h2&gt;&lt;p&gt;GCC 编译器支持编译 Go、Objective-C，Objective-C++，Fortran，Ada，D 和 BRIG（HSAIL）等程序。&lt;/p&gt;
&lt;p&gt;实际使用中，使用 gcc 指令编译 C 代码，使用 g++ 指令编译 C++ 代码。&lt;/p&gt;
&lt;h3 id=&quot;编译过程&quot;&gt;&lt;a href=&quot;#编译过程&quot; class=&quot;headerlink&quot; title=&quot;编译过程&quot;&gt;&lt;/a&gt;编译过程&lt;/h3&gt;&lt;p&gt;例如 &lt;strong&gt;g++ test.cpp -o test&lt;/strong&gt; 可拆解为以下步骤：&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://www.benboby.top/categories/C/"/>
    
    
    <category term="C++基础" scheme="https://www.benboby.top/tags/C-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：区间和的个数</title>
    <link href="https://www.benboby.top/2020/11/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%8C%BA%E9%97%B4%E5%92%8C%E7%9A%84%E4%B8%AA%E6%95%B0.html"/>
    <id>https://www.benboby.top/2020/11/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%8C%BA%E9%97%B4%E5%92%8C%E7%9A%84%E4%B8%AA%E6%95%B0.html</id>
    <published>2020-11-07T15:39:51.000Z</published>
    <updated>2021-01-28T06:02:23.355Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 $a$，返回区间和在 $[lower, upper]$ 之间的个数，包含 $lower$ 和 $upper$。<br>区间和 $S(i, j)$ 表示在 $a$ 中，位置从 $i$ 到 $j$ 的元素之和，包含 $i$ 和 $j$ $(i ≤ j)$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><a id="more"></a> <p>维护前缀和，对于每个前缀和 $sum[i]$，等价于 $sum[0…i-1]$ 里面有多少个数满足差值在 $[lower, upper]$ 之间。</p><p>$sum[i] - sum[j] = [lower, upper]$ 等价于求出现在区间 $sum[j] \in [sum[i] - upper, sum[i] - lower]$ 的数的个数，故可以用树状数组维护。</p><p>遍历前缀和数组，对于当前前缀和 $sum[i]$，满足的个数便为：$query(sum[i] - lower) - query(sum[i] - upper - 1)$，累加答案即可。</p><p>由于数很大，故需要将所有出现的数离散化。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BIT</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span>* c;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        BIT(<span class="keyword">int</span> _n) &#123;</span><br><span class="line">            n = _n;</span><br><span class="line">            c = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) c[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">                c[x]++;</span><br><span class="line">                x += lowbit(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x) &#123;</span><br><span class="line">                sum += c[x];</span><br><span class="line">                x -= lowbit(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countRangeSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> lower, <span class="keyword">int</span> upper)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> m = a.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> *sum = <span class="keyword">new</span> <span class="keyword">long</span> <span class="keyword">long</span>[m + <span class="number">1</span>];</span><br><span class="line">        sum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i) sum[i] = sum[i - <span class="number">1</span>] + a[i - <span class="number">1</span>];</span><br><span class="line">            s.insert(sum[i]);</span><br><span class="line">            s.insert(sum[i] - upper);</span><br><span class="line">            s.insert(sum[i] - lower);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">int</span> n = s.size(), idx = <span class="number">0</span>;</span><br><span class="line">        <span class="function">BIT <span class="title">bit</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : s) mp[x] = ++idx;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = mp[sum[i] - upper], r = mp[sum[i] - lower];</span><br><span class="line">            res += bit.query(r) - bit.query(l - <span class="number">1</span>);</span><br><span class="line">            bit.add(mp[sum[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个整数数组 $a$，返回区间和在 $[lower, upper]$ 之间的个数，包含 $lower$ 和 $upper$。&lt;br&gt;区间和 $S(i, j)$ 表示在 $a$ 中，位置从 $i$ 到 $j$ 的元素之和，包含 $i$ 和 $j$ $(i ≤ j)$。&lt;/p&gt;
&lt;h2 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h2&gt;</summary>
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="树状数组" scheme="https://www.benboby.top/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>C++内存管理</title>
    <link href="https://www.benboby.top/2020/11/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"/>
    <id>https://www.benboby.top/2020/11/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html</id>
    <published>2020-11-02T03:12:51.000Z</published>
    <updated>2021-02-09T09:18:32.314Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="内存管理详解"><a href="#内存管理详解" class="headerlink" title="内存管理详解"></a>内存管理详解</h3><h4 id="内存分配方式"><a href="#内存分配方式" class="headerlink" title="内存分配方式"></a>内存分配方式</h4><h5 id="分配方式简介"><a href="#分配方式简介" class="headerlink" title="分配方式简介"></a>分配方式简介</h5><p>在C++中，内存分为5个区：</p><ol><li>栈：执行函数时，函数内部局部变量存储单元在栈上创建，结束时自动释放。效率很高，但存储容量有限。</li><li>堆：由 <strong>new</strong> 分配的内存块，编译器不会自动释放，需要应用程序对应的 <strong>delete</strong> 进行释放。如果没有释放，则程序运行结束后会由操作系统自动回收。</li><li>自由存储区：由 <strong>malloc</strong> 等分配的内存块，类似堆，由 <strong>free</strong> 结束自己的生命。</li><li>全局/静态存储区：存储全局变量和静态变量。</li><li>常量存储区：存放常量，不允许修改。</li></ol><a id="more"></a> <h5 id="明确区分堆和栈"><a href="#明确区分堆和栈" class="headerlink" title="明确区分堆和栈"></a>明确区分堆和栈</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在栈内存中存放了一个指向一块堆内存的指针 p。程序会先确定在堆中分配内存的大小，然后调用 <strong>operator new</strong> 分配内存，然后返回这块内存的首地址，放入栈中。</p><p>这里并没有释放内存，因此需要 <strong>delete[] p</strong>，告诉编译器删除的是数组，然后编译器根据Cookie信息去释放内存。</p><h5 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h5><ol><li>管理方式：栈由编译器自动管理，无需手动控制；堆的释放工作由程序员控制，容易产生内存泄露。</li><li>空间大小：堆栈的内存都可以自己设定，堆内存一般不超过系统内存都是可以申请，栈内存个人测试默认值为8M。</li><li>碎片问题：对于堆而言，频繁的 <strong>new/delete</strong> 势必会造成内存空间的不连续，造成大量的碎片，使程序的效率降低；对于栈而言，则不会发生这样的情况，先进后出排列有序，以至于永远不可能有一个内存块从非栈顶位置弹出。</li><li>生长方向：对于堆而言，生长方向向上，向着内存地址增加的方向增长；对于栈而言，生长方向向下，向着内存地址减小的方向增长。</li><li>分配方式：堆都是动态分配的，没有静态分配的堆。栈有动态分配和静态分配两种，静态分配由编译器完成，比如局部变量的分配；动态分配由 <strong>alloca</strong> 函数进行分配，都由编译器进行释放。</li><li>分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持，这就决定了栈的效率比较高。堆则是 C/C++ 函数库提供的，机制比较复杂，用到许多算法的实现内存的分配。显然，堆的效率比栈要低得多。</li></ol><p>因此，更推荐尽量使用栈而不是堆。但是栈和堆相比并不灵活。如果需要分配大量内存空间，还是堆好一些。</p><h4 id="控制-C-的内存分配"><a href="#控制-C-的内存分配" class="headerlink" title="控制 C++ 的内存分配"></a>控制 C++ 的内存分配</h4><p>无论如何，一定要保守的使用内存分配。<br>一个防止堆破碎的通用方法是从不同固定大小的内存池中分配不同类型的对象。对每个类重载 <strong>new</strong> 和 <strong>delete</strong> 就提供了这样的控制。</p><h5 id="重载全局的new和delete操作"><a href="#重载全局的new和delete操作" class="headerlink" title="重载全局的new和delete操作"></a>重载全局的new和delete操作</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">void</span> *p = <span class="built_in">malloc</span>(size); </span><br><span class="line">    <span class="keyword">return</span> (p); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *p)</span></span>; </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">free</span>(p); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以对单个类的 new 和 delete 操作符重载。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *p)</span></span>; </span><br><span class="line">    <span class="comment">// .. other members here ... </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">void</span> *TestClass::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">void</span> *p = <span class="built_in">malloc</span>(size); <span class="comment">// Replace this with alternative allocator </span></span><br><span class="line">    <span class="keyword">return</span> (p); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> TestClass::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *p)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">free</span>(p); <span class="comment">// Replace this with alternative de-allocator</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="为单个类重载-new-和-delete"><a href="#为单个类重载-new-和-delete" class="headerlink" title="为单个类重载 new[] 和 delete[]"></a>为单个类重载 new[] 和 delete[]</h5><p>C++将对象数组的内存分配作为一个单独的操作，而不同于单个对象的内存分配。为了改变这种方式，同样需要重载 new[] 和 delete[]操作符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">void</span> * <span class="keyword">operator</span> <span class="keyword">new</span>[ ](<span class="keyword">size_t</span> size); </span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[ ](<span class="keyword">void</span> *p); </span><br><span class="line">    <span class="comment">// .. other members here .. </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">void</span> *TestClass::<span class="keyword">operator</span> <span class="keyword">new</span>[ ](<span class="keyword">size_t</span> size) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">void</span> *p = <span class="built_in">malloc</span>(size); </span><br><span class="line">    <span class="keyword">return</span> (p); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">void</span> TestClass::<span class="keyword">operator</span> <span class="keyword">delete</span>[ ](<span class="keyword">void</span> *p) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">free</span>(p); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    TestClass *p = <span class="keyword">new</span> TestClass[<span class="number">10</span>]; </span><br><span class="line">    <span class="comment">// ... etc ... </span></span><br><span class="line">    <span class="keyword">delete</span>[ ] p; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：对于多数 C++ 的实现，<strong>new[]</strong> 操作符中的个数参数是数组的大小加上额外的存储对象数目的一些字节。因此应该尽量避免分配对象数组，使内存分配策略简单。</p><h4 id="常见的内存错误"><a href="#常见的内存错误" class="headerlink" title="常见的内存错误"></a>常见的内存错误</h4><ol><li>内存分配未成功，却使用了它。<ul><li>如果是用 malloc 或 new 来申请内存，应该用 if(p==NULL) 或 if(p!=NULL)进行防错。</li></ul></li><li>内存分配虽然成功，但未初始化就引用它。<ul><li>无论用何种方式创建数组，都要赋初值，即便是零值。</li></ul></li><li>内存分配成功并且已经初始化，但操作越界。<ul><li>多发生在下标“多1”或“少1”。</li></ul></li><li>忘记了释放内存，造成内存泄漏。<ul><li>动态内存的申请与释放必须配对，程序中 <strong>malloc</strong> 与 <strong>free</strong> 的使用次数一定要相同，否则肯定有错误（new/delete同理）。</li></ul></li><li>释放了内存却继续使用它。<ul><li>程序过于复杂，难以分清是否释放了内存，此时应当重新设计数据结构，解决混乱。</li><li>return语句写错，不要返回指向“栈内存”的指针或引用，因为该内存在函数体结束时被自动销毁。</li><li>free或delete释放内存后，没有将指针设为NULL，导致“野指针”。</li></ul></li></ol><h4 id="指针与数组对比"><a href="#指针与数组对比" class="headerlink" title="指针与数组对比"></a>指针与数组对比</h4><p>数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。数组名对应着（<strong>而不是指向</strong>）一块内存，其地址和容量在生命周期内保持不变，只有数组的内容可以改变。</p><p>指针可以随时指向任何类型的内存块，它的特征是“可变”的，所以常用指针来操作动态内存，指针远比数组灵活，但也更危险。</p><h5 id="修改数组内容"><a href="#修改数组内容" class="headerlink" title="修改数组内容"></a>修改数组内容</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[] = “hello”; </span><br><span class="line">a[<span class="number">0</span>] = ‘X’; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"><span class="comment">// 可以拆分为 char s[] = &quot;world&quot;; char *p = str;</span></span><br><span class="line"><span class="keyword">char</span> *p = “world”; <span class="comment">// 注意 p 指向常量字符串</span></span><br><span class="line">p[<span class="number">0</span>] = ‘X’; <span class="comment">// 编译器不能发现该错误，但运行时产生[Bus error]</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h5 id="内容复制与比较"><a href="#内容复制与比较" class="headerlink" title="内容复制与比较"></a>内容复制与比较</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组… </span></span><br><span class="line"><span class="keyword">char</span> a[] = <span class="string">&quot;hello&quot;</span>; </span><br><span class="line"><span class="keyword">char</span> b[<span class="number">10</span>]; </span><br><span class="line"><span class="built_in">strcpy</span>(b, a); <span class="comment">// 不能用 b = a; </span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(b, a) == <span class="number">0</span>) <span class="comment">// 不能用 if (b == a) </span></span><br><span class="line">… </span><br><span class="line"><span class="comment">// 指针… </span></span><br><span class="line"><span class="comment">// 语句 p = a 并不能把 a 的内容复制给指针 p，而是把 a 的地址赋给了 p。</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(a); </span><br><span class="line"><span class="keyword">char</span> *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*(len+<span class="number">1</span>)); </span><br><span class="line"><span class="built_in">strcpy</span>(p, a); <span class="comment">// 不要用 p = a; </span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(p, a) == <span class="number">0</span>) <span class="comment">// 不要用 if (p == a) </span></span><br></pre></td></tr></table></figure><h5 id="计算内存容量"><a href="#计算内存容量" class="headerlink" title="计算内存容量"></a>计算内存容量</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[] = <span class="string">&quot;hello world&quot;</span>; </span><br><span class="line"><span class="keyword">char</span> *p = a; </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(a) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 12 字节</span></span><br><span class="line"><span class="comment">// sizeof(p) 等价于 sizeof(char *)，没有办法的值指针所指的内存容量，除非申请内存时就记住它</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(p) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 4 字节</span></span><br></pre></td></tr></table></figure><p>注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(<span class="keyword">char</span> a[<span class="number">100</span>])</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// 不论数组 a 的容量是多少，sizeof(a)始终等于 sizeof(char *)。</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(a) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 4 字节而不是 100 字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="指针参数如何传递内存"><a href="#指针参数如何传递内存" class="headerlink" title="指针参数如何传递内存"></a>指针参数如何传递内存</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetMemory</span><span class="params">(<span class="keyword">char</span> *p, <span class="keyword">int</span> num)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    p = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * num); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>; </span><br><span class="line">    GetMemory(str, <span class="number">100</span>); <span class="comment">// str 仍然为 NULL </span></span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello&quot;</span>); <span class="comment">// 运行错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.benboby.top/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%89%AF%E6%9C%AC.png" alt></p><p>如果函数的参数是一个指针，不要指望用该指针去申请动态内存。编译器总是要为函数的每个参数制作临时副本，指针参数 p 的副本是 _p，编译器使 _p = p。如果函数体内的程序修改了_p 的内容，就导致参数 p 的内容作相应的修改。这就是指针可以用作输出参数的原因。_p 申请了新的内存，只是把 _p 所指的内存地址改变了，但是 p 丝毫未变。所以函数 GetMemory 并不能输出任何东西。事实上，每执行一次 GetMemory 就会泄露一块内存，因为没有用 free 释放内存。</p><p>如果非得要用指针参数去申请内存，那么应该改用“指向指针的指针”:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetMemory2</span><span class="params">(<span class="keyword">char</span> **p, <span class="keyword">int</span> num)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * num); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test2</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>; </span><br><span class="line">    GetMemory2(&amp;str, <span class="number">100</span>); <span class="comment">// 注意参数是 &amp;str，而不是 str </span></span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello&quot;</span>); </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; str &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">free</span>(str); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="/2020/11/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.htm/指针的指针.png" alt></p><p>比较好的方法是 <strong>传指针的引用</strong>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetMemory</span><span class="params">(<span class="keyword">char</span> *&amp;p, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    GetMemory(str, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">free</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以用函数返回值来传递动态内存。这种方法更加简单：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">GetMemory3</span><span class="params">(<span class="keyword">int</span> num)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * num); </span><br><span class="line">    <span class="keyword">return</span> p; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test3</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>; </span><br><span class="line">    str = GetMemory3(<span class="number">100</span>); </span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello&quot;</span>); </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; str &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">free</span>(str); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在使用返回值时，千万别返回 <strong>指向“栈内存”</strong> 的指针、引用，因为该内存在函数结束时 <strong>自动消亡</strong> 了，返回的指针是个野指针了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">GetString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> p[] = <span class="string">&quot;hello world&quot;</span>; <span class="comment">//数组内容存储在栈区，函数结束时，会释放掉</span></span><br><span class="line">     <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    str = GetString();      <span class="comment">//因为非配的内存早已释放掉，此时的str是个野指针，内容是垃圾</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在函数中不定义数组，定义指针：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">GetString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> *p = <span class="string">&quot;hello world&quot;</span>; <span class="comment">//数组内容存储在静态区，函数结束时，不会释放掉</span></span><br><span class="line">     <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    str = GetString();      </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h4 id="杜绝“野指针”"><a href="#杜绝“野指针”" class="headerlink" title="杜绝“野指针”"></a>杜绝“野指针”</h4><p>“野指针”不是 NULL 指针，是指向“垃圾”内存的指针。“野指针”是很危险的，if 语句对它不起作用。出现的原因有：</p><ol><li>指针变量没有被初始化。任何指针变量刚被创建时不会自动成为 NULL 指针，它的缺省值是随机的。所以，指针变量在创建的同时应当被初始化，要么将指针设置为 NULL，要么让它指向合法的内存。</li><li>指针 p 被 free 或者 delete 之后，没有置为 NULL，让人误以为 p 是个合法的指针。</li><li>指针操作超越了变量的作用域范围。</li></ol><h4 id="有了-malloc-free-为什么还要-new-delete？"><a href="#有了-malloc-free-为什么还要-new-delete？" class="headerlink" title="有了 malloc/free 为什么还要 new/delete？"></a>有了 malloc/free 为什么还要 new/delete？</h4><p><strong>malloc 与 free</strong> 是 C++/C 语言的标准库函数，<strong>new/delete</strong> 是 C++ 的运算符。它们都可用于申请动态内存和释放内存。<br>对于非内部数据类型的对象而言，光用 <strong>malloc/free</strong> 无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于 <strong>malloc/free</strong> 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于 <strong>malloc/free</strong>。<br>而C++程序经常要调用 C 函数，而 C 程序只能用 <strong>malloc/free</strong> 管理动态内存，因此不能只用 <strong>new/delete</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">public</span> : </span><br><span class="line">    Obj(<span class="keyword">void</span>)&#123; <span class="built_in">cout</span> &lt;&lt; “Initialization” &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">    ~Obj(<span class="keyword">void</span>)&#123; <span class="built_in">cout</span> &lt;&lt; “Destroy” &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Initialize</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; “Initialization” &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Destroy</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; “Destroy” &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UseMallocFree</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Obj *a = (obj *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(obj)); <span class="comment">// 申请动态内存</span></span><br><span class="line">    a-&gt;Initialize(); <span class="comment">// 初始化</span></span><br><span class="line">    <span class="comment">//… </span></span><br><span class="line">    a-&gt;Destroy(); <span class="comment">// 清除工作</span></span><br><span class="line">    <span class="built_in">free</span>(a); <span class="comment">// 释放内存</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UseNewDelete</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Obj *a = <span class="keyword">new</span> Obj; <span class="comment">// 申请动态内存并且初始化</span></span><br><span class="line">    <span class="comment">//… </span></span><br><span class="line">    <span class="keyword">delete</span> a; <span class="comment">// 清除并且释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内存耗尽怎么办？"><a href="#内存耗尽怎么办？" class="headerlink" title="内存耗尽怎么办？"></a>内存耗尽怎么办？</h4><p>如果在申请动态内存时找不到足够大的内存块，<strong>malloc</strong> 和 <strong>new</strong> 将返回 <strong>NULL</strong> 指针，表示内存申请失败。<br>处理“内存耗尽”问题，一般可以通过判断指针是否为 <strong>NULL</strong>，是的话用 <strong>return</strong> 或 <strong>exit(1)</strong> 终止整个程序的运行，也可以自己为 <strong>new 和 molloc</strong> 设置异常处理函数。<br>如果一个函数内有多处需要申请动态内存，那么应该用 <strong>exit(1)</strong> 及时终止程序。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;内存管理&quot;&gt;&lt;a href=&quot;#内存管理&quot; class=&quot;headerlink&quot; title=&quot;内存管理&quot;&gt;&lt;/a&gt;内存管理&lt;/h2&gt;&lt;h3 id=&quot;内存管理详解&quot;&gt;&lt;a href=&quot;#内存管理详解&quot; class=&quot;headerlink&quot; title=&quot;内存管理详解&quot;&gt;&lt;/a&gt;内存管理详解&lt;/h3&gt;&lt;h4 id=&quot;内存分配方式&quot;&gt;&lt;a href=&quot;#内存分配方式&quot; class=&quot;headerlink&quot; title=&quot;内存分配方式&quot;&gt;&lt;/a&gt;内存分配方式&lt;/h4&gt;&lt;h5 id=&quot;分配方式简介&quot;&gt;&lt;a href=&quot;#分配方式简介&quot; class=&quot;headerlink&quot; title=&quot;分配方式简介&quot;&gt;&lt;/a&gt;分配方式简介&lt;/h5&gt;&lt;p&gt;在C++中，内存分为5个区：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;栈：执行函数时，函数内部局部变量存储单元在栈上创建，结束时自动释放。效率很高，但存储容量有限。&lt;/li&gt;
&lt;li&gt;堆：由 &lt;strong&gt;new&lt;/strong&gt; 分配的内存块，编译器不会自动释放，需要应用程序对应的 &lt;strong&gt;delete&lt;/strong&gt; 进行释放。如果没有释放，则程序运行结束后会由操作系统自动回收。&lt;/li&gt;
&lt;li&gt;自由存储区：由 &lt;strong&gt;malloc&lt;/strong&gt; 等分配的内存块，类似堆，由 &lt;strong&gt;free&lt;/strong&gt; 结束自己的生命。&lt;/li&gt;
&lt;li&gt;全局/静态存储区：存储全局变量和静态变量。&lt;/li&gt;
&lt;li&gt;常量存储区：存放常量，不允许修改。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="C++" scheme="https://www.benboby.top/categories/C/"/>
    
    
    <category term="C++内存管理" scheme="https://www.benboby.top/tags/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>树状数组经典题</title>
    <link href="https://www.benboby.top/2020/10/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%BB%8F%E5%85%B8%E9%A2%98.html"/>
    <id>https://www.benboby.top/2020/10/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%BB%8F%E5%85%B8%E9%A2%98.html</id>
    <published>2020-10-30T14:31:09.000Z</published>
    <updated>2021-01-28T06:02:23.341Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一个简单的整数问题"><a href="#一个简单的整数问题" class="headerlink" title="一个简单的整数问题"></a>一个简单的整数问题</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>第一类指令形如 “C-l-r-d”，表示把数列中第 $l-r$ 个数都加 $d$。</p><p>第二类指令形如 “Q-X”，表示询问数列中第 $x$ 个数的值。<br><a id="more"></a> </p><p>对于每个询问，输出一个整数表示答案。</p><p>数据范围：$(n, m \in [1, 100000])$</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>用树状数组解决动态差分问题。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">ll c[N], a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">        c[x] += y;</span><br><span class="line">        x += lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        sum += c[x];</span><br><span class="line">        x -= lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">int</span> x, y, z;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">&quot;Q&quot;</span>) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; query(x) + a[x] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">            add(x, z);</span><br><span class="line">            add(y + <span class="number">1</span>, -z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="谜一样的牛"><a href="#谜一样的牛" class="headerlink" title="谜一样的牛"></a>谜一样的牛</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定序列长度 $n$ 和 数组 $a$，$a[i]$ 表示第 $i$ 个数前面有多少个数比它小，复原原序列，原序列为 $1-n$ 的排列。$(n \in [1, 100000])$</p><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>最后一个数的大小明显是一开始就可以推断出来的，假设其大小是 $x$，接着从 $1-n$ 这 $n$ 个数字中把 $x$ 删掉，然后再看倒数第二个数，假设其前面有 $y$ 个数比它小，说明这个数是剩下的数里面第 $y + 1$ 大的数。</p><p>由此可以发现，我们可以倒推过来，第 $i$ 个数的大小便是当前还没有被选的数中第 $a[i] + 1$ 小的数。</p><p>可以使用树状数组解决，将每个位置置为 $1$ 表示未被选，$0$ 表示已被选，得到的前缀和是单调递增的，因此每次只需要二分查找满足前缀和刚好等于 $a[i] + 1$ 的位置即为当前数的大小。</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, c[N], a[N], res[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">        c[x] += y;</span><br><span class="line">        x += lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        sum += c[x];</span><br><span class="line">        x -= lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    add(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        add(i, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n + <span class="number">1</span>, mid;</span><br><span class="line">        <span class="keyword">while</span> (l + <span class="number">1</span> &lt; r) &#123;</span><br><span class="line">            mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (query(mid) &lt; a[i] + <span class="number">1</span>) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        res[i] = r;</span><br><span class="line">        add(r, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cout</span> &lt;&lt; res[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一个简单的整数问题&quot;&gt;&lt;a href=&quot;#一个简单的整数问题&quot; class=&quot;headerlink&quot; title=&quot;一个简单的整数问题&quot;&gt;&lt;/a&gt;一个简单的整数问题&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;第一类指令形如 “C-l-r-d”，表示把数列中第 $l-r$ 个数都加 $d$。&lt;/p&gt;
&lt;p&gt;第二类指令形如 “Q-X”，表示询问数列中第 $x$ 个数的值。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://www.benboby.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="树状数组" scheme="https://www.benboby.top/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>并查集拓展</title>
    <link href="https://www.benboby.top/2020/10/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%8B%93%E5%B1%95.html"/>
    <id>https://www.benboby.top/2020/10/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%8B%93%E5%B1%95.html</id>
    <published>2020-10-29T10:45:57.000Z</published>
    <updated>2021-01-28T06:02:23.325Z</updated>
    
    <content type="html"><![CDATA[<h2 id="边带权"><a href="#边带权" class="headerlink" title="边带权"></a>边带权</h2><h3 id="银河英雄传说"><a href="#银河英雄传说" class="headerlink" title="银河英雄传说"></a>银河英雄传说</h3><p>有 $T$ 条指令，每条指令格式为以下两种之一：</p><ol><li><p>$M-i-j$，表示让第 $i$ 号战舰所在列的全部战舰保持原有顺序，接在第 $j$ 号战舰所在列的尾部。</p><a id="more"></a> </li><li><p>$C-i-j$，表示询问第 $i$ 号战舰与第 $j$ 号战舰当前是否处于同一列中，如果在同一列中，它们之间间隔了多少艘战舰。</p></li></ol><p>数据范围：$N≤30000, T≤500000$</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>维护数组 $dp$ 表示 $i$ 到 $root$ 的距离，那么查询的答案便是 $abs(dp[a] - dp[b]) - 1$。</p><p>当 $a$ 向 $b$ 连一条边时，有 $fa[a] = b$，此时根结点 $a$ 的深度会增加 $b$ 的集合大小，因此我们需要一个 $sz$ 数组维护集合大小。</p><p>同时在进行路径压缩时，对于未更新的结点也要一同更新深度。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[N], sz[N], fa[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != fa[x]) &#123;</span><br><span class="line">        <span class="keyword">int</span> root = find(fa[x]);</span><br><span class="line">        dp[x] += dp[fa[x]];</span><br><span class="line">        fa[x] = root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t, a, b;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">30000</span>; i++) &#123;</span><br><span class="line">        dp[i] = <span class="number">0</span>;</span><br><span class="line">        sz[i] = <span class="number">1</span>;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">int</span> pa = find(a), pb = find(b);</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">&quot;M&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pa != pb) &#123;</span><br><span class="line">                fa[pa] = pb;</span><br><span class="line">                dp[pa] = sz[pb];</span><br><span class="line">                sz[pb] += sz[pa];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (pa != pb) <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; max(<span class="built_in">abs</span>(dp[a] - dp[b]) - <span class="number">1</span>, <span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓展域"><a href="#拓展域" class="headerlink" title="拓展域"></a>拓展域</h2><h3 id="食物链"><a href="#食物链" class="headerlink" title="食物链"></a>食物链</h3><p>动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。</p><ol><li><p>$1-X-Y$，表示 $X$ 和 $Y$ 是同类。</p></li><li><p>$2-X-Y$，表示 $X$ 吃 $Y$。</p></li></ol><p>判断有多少句假话。$(1≤N≤50000,0≤K≤100000)$</p><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>$1-n$ 表示动物 $i$ 的同类，$n+1-2n$ 表示动物 $i$ 的猎物，$2n+1 - 3n$ 表示动物 $i$ 的天敌。</p><p>对于操作1: 查询 $x$ 和 $y$ 的天敌域，猎物域是不是在一个集合，是则累加答案，否则进行合并。</p><p>对于操作2: 查询 $x$ 和 $y$ 的同类域，猎物域是不是在一个集合，是则累加答案，否则进行合并。</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">1000005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != fa[x]) </span><br><span class="line">        fa[x] = find(fa[x]);</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    a = find(a), b = find(b);</span><br><span class="line">    <span class="keyword">if</span> (a != b) fa[a] = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k, a, b, c, res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;  i &lt;= n * <span class="number">3</span>; i++) fa[i] = i;</span><br><span class="line">    <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; c &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; n || b &gt; n) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (find(a) == find(b + n) || find(a) == find(b + <span class="number">2</span> * n)) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/// a和b是同类，a和b的猎物也是同类，a和b的天敌也是同类</span></span><br><span class="line">                join(a, b);</span><br><span class="line">                join(a + n, b + n);</span><br><span class="line">                join(a + <span class="number">2</span> * n, b + <span class="number">2</span> * n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (a == b || find(a) == find(b) || find(a) == find(b + n)) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/// a的猎物是b， b的天敌是a，b的猎物是a的天敌</span></span><br><span class="line">                join(a, b + <span class="number">2</span> * n);</span><br><span class="line">                join(a + n, b);</span><br><span class="line">                join(a + <span class="number">2</span> * n, b + n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="奇偶游戏"><a href="#奇偶游戏" class="headerlink" title="奇偶游戏"></a>奇偶游戏</h3><p>给你 $m$ 个询问，每一个询问给出一个区间的左右端点和区间中的 $1$ 的数量的奇偶性，输出不出现矛盾的最大的 $k$ 值，即 $1-k$ 无矛盾，$1- k + 1$ 矛盾。$(N≤10^9,M≤10000)$</p><h3 id="Solution1（边带权）"><a href="#Solution1（边带权）" class="headerlink" title="Solution1（边带权）"></a>Solution1（边带权）</h3><ol><li>我们可以用 $sum$ 数组表示序列 S 的前缀和,那么会得到以下性质.</li></ol><p>$s[l~r]$ 有偶数个 $1$，等价于 $sum[l-1]$ 与 $sum[r]$ 奇偶性相同 $(1+0=1,0+0=0,1是奇数,0是偶数)$<br>$s[l~r]$ 有奇数个 $1$，等价于 $sum[l-1]$ 与 $sum[r]$ 奇偶性不同 $(1+1=0,0+1=0,1是奇数,0是偶数)$</p><ol><li><p>根据传递性，可以使用边带权，边权 $d[x] = 0$，表示 $x$ 与 $f[x]$ 的奇偶性相同; 为 $1$，表示 $x$ 与 $fa[x]$ 的奇偶性不同,在路径压缩的过程中,对 $x$ 到树根路径的所有边权做异或$(xor)$。</p></li><li><p>对于每个问题, 设离散化后 $l - 1$ 和 $r$ 的值分别是 $x$ 和 $y$ , 设 $c$ 表示当前问题的回答($c = 0$ 表示偶数个, $c = 1$ 表示奇数个)</p></li></ol><p>若 $x$ 和 $y$ 在一个集合中, 直接判断 $d[x] xor d[y]$ 是否等于 $c$，若不等于,则矛盾，直接输出结果。</p><p>若 $x$ 和 $y$ 不在一个集合中，说明无法判断，此时合并两个集合，得到俩个的树根 $p$ 和 $q$, $d[x]$ 与 $d[y]$ 分别表示 $x - p$ 与 $y - q$ 之间所有边权的 “xor” 和，$p - q$ 之间的边权为 $d[p]$, 显然, 路径 $x - y$ 由 $x - p$, $p - q$, $q - y$ 组成，所以 $x$ 与 $y$ 的奇偶性关系 $c = d[x] (xor) d[y] (xor) d[p]$，得到 $d[p] = d[x] (xor) d[y] (xor) c$。</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[N], d[N];</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">&#125; q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != fa[x]) &#123;</span><br><span class="line">        <span class="keyword">int</span> root = find(fa[x]);</span><br><span class="line">        d[x] ^= d[fa[x]];</span><br><span class="line">        fa[x] = root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L, n, a, b, pa, pb;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; L &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; q[i].a &gt;&gt; q[i].b &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;e&#x27;</span>) q[i].c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> q[i].c = <span class="number">1</span>;</span><br><span class="line">        g.push_back(q[i].a - <span class="number">1</span>);</span><br><span class="line">        g.push_back(q[i].b);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(g.begin(), g.end());</span><br><span class="line">    g.erase(unique(g.begin(), g.end()), g.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= (<span class="keyword">int</span>)g.size(); i++) &#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">        mp[g[i - <span class="number">1</span>]] = i;</span><br><span class="line">        d[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= n; i++) &#123;</span><br><span class="line">        a = mp[q[i].a - <span class="number">1</span>], b = mp[q[i].b];</span><br><span class="line">        pa = find(a), pb = find(b);</span><br><span class="line">        <span class="keyword">if</span> (pa != pb) &#123;</span><br><span class="line">            fa[pa] = pb;</span><br><span class="line">            d[pa] ^= d[a] ^ d[b] ^ q[i].c;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (d[a] ^ d[b] != q[i].c) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i - <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Solution2（拓展域）"><a href="#Solution2（拓展域）" class="headerlink" title="Solution2（拓展域）"></a>Solution2（拓展域）</h3><p>$1 - n$ 表示 $sum[i]$ 为奇，$n + 1 - 2 * n$ 表示 $sum[i]$ 为偶。</p><p>当查询区间为奇数时：判断 $a$ 的奇数域是否与 $b$ 的奇数域同在一个集合，是则矛盾，否则合并 $a$ 的奇数域与 $b$ 的偶数域，$a$ 的偶数域与 $b$ 的奇数域。</p><p>当查询区间为偶数时：判断 $a$ 的奇数域是否与 $b$ 的偶数域同在一个集合，是则矛盾，否则合并 $a,b$ 的奇数域和偶数域。</p><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">&#125; q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != fa[x]) </span><br><span class="line">        fa[x] = find(fa[x]);</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x = find(x), y = find(y);</span><br><span class="line">    <span class="keyword">if</span> (x != y) fa[x] = y;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L, m, n, a, b;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; L &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; q[i].a &gt;&gt; q[i].b &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">&quot;even&quot;</span>) q[i].c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> q[i].c = <span class="number">1</span>;</span><br><span class="line">        g.push_back(q[i].a - <span class="number">1</span>);</span><br><span class="line">        g.push_back(q[i].b);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(g.begin(), g.end());</span><br><span class="line">    g.erase(unique(g.begin(), g.end()), g.end());</span><br><span class="line">    n = g.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        mp[g[i - <span class="number">1</span>]] = i;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">        fa[i + n] = i + n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= m; i++) &#123;</span><br><span class="line">        a = mp[q[i].a - <span class="number">1</span>], b = mp[q[i].b];</span><br><span class="line">        <span class="keyword">if</span> (q[i].c) &#123;</span><br><span class="line">            <span class="keyword">if</span> (find(a) == find(b) || find(a + n) == find(b + n)) <span class="keyword">break</span>;</span><br><span class="line">            join(a, b + n); <span class="comment">// 合并a的奇数域和b的偶数域</span></span><br><span class="line">            join(a + n, b); <span class="comment">// 合并a的偶数域和a的奇数域</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (find(a) == find(b + n) || find(a + n) == find(b)) <span class="keyword">break</span>;</span><br><span class="line">            join(a, b);     <span class="comment">// 合并a的奇数域和b的奇数域</span></span><br><span class="line">            join(a + n, b + n);  <span class="comment">// 合并a的偶数域和b的偶数域</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i - <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反向并查集"><a href="#反向并查集" class="headerlink" title="反向并查集"></a>反向并查集</h2><h3 id="星球大战"><a href="#星球大战" class="headerlink" title="星球大战"></a>星球大战</h3><p>求每次拆边后的连通块个数。$(m \in [1, 2e5], n \in [1, 2*m])$</p><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>拆边很难维护集合数量，考虑离线后反过来建图。这样便相当于每次增加增加一条边，查询两个点是否为同一个集合即可知道集合数量是否减少。</p><h3 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k, pre[N], b[N], vis[N];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = x, j = x;</span><br><span class="line">  <span class="keyword">while</span> (i != pre[i])</span><br><span class="line">    i = pre[i];</span><br><span class="line">  <span class="keyword">while</span> (i != j) &#123;</span><br><span class="line">    <span class="keyword">int</span> temp = pre[j];</span><br><span class="line">    pre[j] = i;</span><br><span class="line">    j = temp;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> fx = find(x), fy = find(y);</span><br><span class="line">  <span class="keyword">if</span> (fx != fy) &#123;</span><br><span class="line">    pre[fx] = fy;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    pre[i] = i;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    g[x].push_back(y);</span><br><span class="line">    g[y].push_back(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">    vis[b[i]] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> res = n - k;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; g[i].size(); j++) &#123;</span><br><span class="line">      <span class="keyword">int</span> x = g[i][j];</span><br><span class="line">      <span class="keyword">if</span> (!vis[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (join(i, x)) res--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  b[k + <span class="number">1</span>] = res;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">    res++;</span><br><span class="line">    vis[b[i]] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; g[b[i]].size(); j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!vis[g[b[i]][j]] &amp;&amp; join(b[i], g[b[i]][j])) </span><br><span class="line">        res--;</span><br><span class="line">    &#125;</span><br><span class="line">    b[i] = res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k + <span class="number">1</span>; i++) </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Total-Eclipse"><a href="#Total-Eclipse" class="headerlink" title="Total Eclipse"></a>Total Eclipse</h3><p>给你 $n$ 个节点 $m$ 条边的图，每个点有一个权值，你现在要做的操作是选择一个连通图，并将其中的每一个点的权值都减一，问你最少需要多少次才能将所有的点都变为0。$(1≤n≤100000, 1≤m≤200000)$</p><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>贪心地想，每次必然是选择权值最小的点，然后联通的边都减少该权值，但这样很难维护，因此可以考虑反向。</p><p>每次选择权值最大的点，然后这个点需要减少到和次小的点一样的权值，即减少的权值为和次小点权值之差。由于一次可以减少一个联通块，因此我们只需要乘以当前点联通块个数即可。</p><h3 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, n, m, pre[N], vis[N];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> w;</span><br><span class="line">  <span class="keyword">int</span> id;</span><br><span class="line">&#125; q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node x, Node y)</span> </span>&#123; <span class="keyword">return</span> x.w &gt; y.w; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = x, j = x;</span><br><span class="line">  <span class="keyword">while</span> (i != pre[i]) i = pre[i];</span><br><span class="line">  <span class="keyword">while</span> (j != i) &#123;</span><br><span class="line">    <span class="keyword">int</span> temp = pre[j];</span><br><span class="line">    pre[j] = i;</span><br><span class="line">    j = temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> fx = find(x), fy = find(y);</span><br><span class="line">  <span class="keyword">if</span> (fx != fy) &#123;</span><br><span class="line">    pre[fx] = fy;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">  <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;q[i].w);</span><br><span class="line">      q[i].id = i;</span><br><span class="line">      pre[i] = i;</span><br><span class="line">      g[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> u, v;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">      g[u].push_back(v);</span><br><span class="line">      g[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> cnt = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + n + <span class="number">1</span>, cmp);</span><br><span class="line">    q[n + <span class="number">1</span>].w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      cnt++;</span><br><span class="line">      vis[q[i].id] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> x : g[q[i].id]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[x] &amp;&amp; join(x, q[i].id)) cnt--;</span><br><span class="line">      &#125;</span><br><span class="line">      res += cnt * (q[i].w - q[i + <span class="number">1</span>].w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;边带权&quot;&gt;&lt;a href=&quot;#边带权&quot; class=&quot;headerlink&quot; title=&quot;边带权&quot;&gt;&lt;/a&gt;边带权&lt;/h2&gt;&lt;h3 id=&quot;银河英雄传说&quot;&gt;&lt;a href=&quot;#银河英雄传说&quot; class=&quot;headerlink&quot; title=&quot;银河英雄传说&quot;&gt;&lt;/a&gt;银河英雄传说&lt;/h3&gt;&lt;p&gt;有 $T$ 条指令，每条指令格式为以下两种之一：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;$M-i-j$，表示让第 $i$ 号战舰所在列的全部战舰保持原有顺序，接在第 $j$ 号战舰所在列的尾部。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://www.benboby.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="并查集" scheme="https://www.benboby.top/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：编辑距离</title>
    <link href="https://www.benboby.top/2020/10/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.html"/>
    <id>https://www.benboby.top/2020/10/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.html</id>
    <published>2020-10-12T04:56:27.000Z</published>
    <updated>2021-01-28T06:02:23.349Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两个单词 $a$ 和 $b$，请你计算出将 $a$ 转换成 $b$ 所使用的最少操作数。</p><p>你可以对一个单词进行如下三种操作：</p><ol><li>插入一个字符<a id="more"></a> </li><li>删除一个字符</li><li>替换一个字符</li></ol><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>$dp[i][j]$ 表示 $a$ 的前 $i$ 个字母和 $b$ 的前 $j$ 个字母匹配的最少操作次数。</p><p>可以从三种状态转移过来：</p><p>$dp[i][j] = dp[i - 1][j] + 1$    在 $b[j]$ 后面插入一个字符 $a[i]$</p><p>$dp[i][j] = dp[i][j - 1] + 1$    在 $a[i]$ 后面插入一个字符 $b[j]$</p><p>$dp[i][j] = dp[i - 1][j - 1] + (a[i - 1] != b[j - 1])$    修改一个字符</p><p>选择最小的操作步数进行转移即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.size();</span><br><span class="line">        <span class="keyword">int</span> m = b.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">            dp[<span class="number">0</span>][i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = dp[i - <span class="number">1</span>][j] + <span class="number">1</span>;   <span class="comment">// 在 b[j] 后面插入一个字符 a[i]</span></span><br><span class="line">                <span class="keyword">int</span> y = dp[i][j - <span class="number">1</span>] + <span class="number">1</span>;   <span class="comment">// 在 a[i] 后面插入一个字符 b[j]</span></span><br><span class="line">                <span class="keyword">int</span> z = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + (a[i - <span class="number">1</span>] != b[j - <span class="number">1</span>]);   <span class="comment">// 修改一个字符</span></span><br><span class="line">                dp[i][j] = min(&#123;x, y, z&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你两个单词 $a$ 和 $b$，请你计算出将 $a$ 转换成 $b$ 所使用的最少操作数。&lt;/p&gt;
&lt;p&gt;你可以对一个单词进行如下三种操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;插入一个字符&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="动态规划" scheme="https://www.benboby.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
</feed>
