<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Benboby&#39;s Blog</title>
  
  
  <link href="https://www.benboby.top/atom.xml" rel="self"/>
  
  <link href="https://www.benboby.top/"/>
  <updated>2021-02-17T13:45:03.761Z</updated>
  <id>https://www.benboby.top/</id>
  
  <author>
    <name>Benboby</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>继承，虚函数和多态</title>
    <link href="https://www.benboby.top/2021/02/%E7%BB%A7%E6%89%BF-%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81.html"/>
    <id>https://www.benboby.top/2021/02/%E7%BB%A7%E6%89%BF-%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81.html</id>
    <published>2021-02-12T06:03:16.000Z</published>
    <updated>2021-02-17T13:45:03.761Z</updated>
    
    <content type="html"><![CDATA[<h2 id="继承-with-virtual-function"><a href="#继承-with-virtual-function" class="headerlink" title="继承 with virtual function"></a>继承 with virtual function</h2><p><strong>构造由内而外</strong>：首先调用父类的构造函数，然后再调用自己。<br><strong>析构由外而内</strong>：首先执行自己的析构函数，然后调用父类的析构函数。</p><p>non-virtual: 你不希望重新定义（重写）它。<br>virtual: 你希望子类重新定义它，且它有默认定义。<br>pure virtual: 你希望子类一定要重新定义它，你对它没有默认定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;   <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; msg)</span></span>;   <span class="comment">// 虚函数 </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">objectID</span><span class="params">()</span> <span class="keyword">const</span></span>;   <span class="comment">// 一般成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape &#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ellipse</span>:</span> <span class="keyword">public</span> Shape &#123;...&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a> <h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据所指对象的实际类型来调用相应的函数，如果对象类型是派生类，就调用派生类的函数，如果对象类型是基类，就调用基类的函数。</p><p>虚表：虚函数表的缩写，类中含有virtual关键字修饰的方法时，编译器会自动生成虚表</p><p>虚表指针：在含有虚函数的类实例化对象时，对象地址的前四个字节存储的指向虚表的指针</p><ul><li>编译器在发现基类中有虚函数时，会自动为每个含有虚函数的类生成一份虚表，该表是一个一维数组，虚表里保存了虚函数的入口地址</li><li>编译器会在每个对象的前四个字节中保存一个虚表指针，即vptr，指向对象所属类的虚表。在构造时，根据对象的类型去初始化虚指针vptr，从而让vptr指向正确的虚表，从而在调用虚函数时，能找到正确的函数</li><li>在派生类定义对象时，程序运行会自动调用构造函数，在构造函数中创建虚表并对虚表初始化。在构造子类对象时，会先调用父类的构造函数，此时，编译器只“看到了”父类，并为父类对象初始化虚表指针，令它指向父类的虚表；当调用子类的构造函数时，为子类对象初始化虚表指针，令它指向子类的虚表</li><li>当派生类对基类的虚函数没有重写时，派生类的虚表指针指向的是基类的虚表；当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表；当派生类中有自己的虚函数时，在自己的虚表中将此虚函数地址添加在后面</li></ul><h3 id="基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间"><a href="#基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间" class="headerlink" title="基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间"></a>基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间</h3><p>首先整理一下虚函数表的特征：</p><ul><li>虚函数表是全局共享的元素，即全局仅有一个，在编译时就构造完成</li><li>虚函数表类似一个数组，类对象中存储vptr指针，指向虚函数表，即虚函数表不是函数，不是程序代码，不可能存储在代码段</li><li>虚函数表存储虚函数的地址,即虚函数表的元素是指向类成员函数的指针,而类中虚函数的个数在编译时期可以确定，即虚函数表的大小可以确定,即大小是在编译时期确定的，不必动态分配内存空间存储虚函数表，所以不在堆中</li></ul><p>根据以上特征，虚函数表类似于类中静态成员变量。静态成员变量也是全局共享，大小确定，因此最有可能存在全局数据区。</p><p>由于虚表指针vptr跟虚函数密不可分，对于有虚函数或者继承于拥有虚函数的基类，对该类进行实例化时，在构造函数执行时会对虚表指针进行初始化，当一个构造函数被调用时，它做的首要的事情之中的一个是初始化它的VPTR，并且存在对象内存布局的最前面。</p><h3 id="补充：inline内联函数"><a href="#补充：inline内联函数" class="headerlink" title="补充：inline内联函数"></a>补充：inline内联函数</h3><p>内联函数和普通函数的区别在于：当编译器处理调用内联函数的语句时，不会将该语句编译成函数调用的指令，而是直接将整个函数体的代码插人调用语句处，就像整个函数体在调用处被重写了一遍一样。相比之下，普通函数能够避免将相同代码重写多次的麻烦，还能减少可执行程序的体积，但也会带来程序运行时间上的开销；而内联函数省去了调用函数的时间开销。</p><p><strong>在函数调用执行过程中，首先要为在栈中的形参和局部变量分配存储空间，然后再将实参的值复制给形参，然后还要将函数的返回地址放入栈中，最后才跳转到函数内部执行。return语句返回时，还要从栈中回收形参和局部变量占有的存储空间，然后从栈中取出返回地址，跳转到该地址继续执行。</strong></p><p>如果内联函数执行的时间很长，那函数调用的时间相比起来就微不足道，使用内联函数也就没有意义了。从另一方面来说，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。因此，内联函数中的代码应该是很简单，执行起来很快的一些语句。</p><p>Google C++编码规范对于inline的使用说明：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">内联函数：</span><br><span class="line">Tip： 只有当函数只有 <span class="number">10</span> 行甚至更少时才将其定义为内联函数.</span><br><span class="line"></span><br><span class="line">定义: 当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用.</span><br><span class="line"></span><br><span class="line">优点: 当函数体比较小的时候, 内联该函数可以令目标代码更加高效. 对于存取函数以及其它函数体比较短, 性能关键的函数, 鼓励使用内联.</span><br><span class="line"></span><br><span class="line">缺点: 滥用内联将导致程序变慢. 内联可能使目标代码量或增或减, 这取决于内联函数的大小. 内联非常短小的存取函数通常会减少代码大小, 但内联一个相当大的函数将戏剧性的增加代码大小. 现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快。</span><br><span class="line"></span><br><span class="line">结论: 一个较为合理的经验准则是, 不要内联超过 <span class="number">10</span> 行的函数. 谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!</span><br><span class="line"></span><br><span class="line">另一个实用的经验准则: 内联那些包含循环或 <span class="keyword">switch</span> 语句的函数常常是得不偿失 (除非在大多数情况下, 这些循环或 <span class="keyword">switch</span> 语句从不被执行).</span><br><span class="line"></span><br><span class="line">有些函数即使声明为内联的也不一定会被编译器内联, 这点很重要; 比如虚函数和递归函数就不会被正常内联. 通常, 递归函数不应该声明成内联函数.(递归调用堆栈的展开并不像循环那么简单, 比如递归层数在编译时可能是未知的, 大多数编译器都不支持内联递归函数). 虚函数内联的主要原因则是想把它的函数体放在类定义内, 为了图个方便, 抑或是当作文档描述其行为, 比如精短的存取函数.</span><br></pre></td></tr></table></figure><br>PS：内联函数和宏定义的区别：</p><ul><li><strong>内联函数在编译时展开，宏在预编译时展开</strong></li><li>内联函数直接嵌入到目标代码中，宏是简单的做文本替换</li><li><strong>内联函数有类型检测、语法判断等功能，而宏没有</strong></li><li>内联函数是函数，宏不是</li><li>宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义</li><li>内联函数代码是被放到符号表中，使用时像宏一样展开，没有调用的开销，效率很高</li></ul><h3 id="构造函数、析构函数、虚函数可否声明为内联函数"><a href="#构造函数、析构函数、虚函数可否声明为内联函数" class="headerlink" title="构造函数、析构函数、虚函数可否声明为内联函数"></a>构造函数、析构函数、虚函数可否声明为内联函数</h3><p>将这些函数声明为内联函数，在语法上没有错误。因为inline同register一样，只是个建议，编译器并不一定真正的内联。</p><ul><li>register关键字：这个关键字请求编译器尽可能的将变量存在CPU内部寄存器中，而不是通过内存寻址访问，以提高效率</li></ul><p>首先在《Effective C++》中明确阐述：<strong>将构造函数和析构函数声明为inline是没有什么意义的</strong>，即编译器并不真正对声明为inline的构造和析构函数进行内联操作，因为<strong>编译器会在构造和析构函数中添加额外的操作（申请/释放内存，构造/析构对象等）</strong>，致使构造函数/析构函数并不像看上去的那么精简。其次，class中的函数默认是inline型的，编译器也只是有选择性的inline，将构造函数和析构函数声明为内联函数是没有什么意义的。</p><p>虚函数是通过指针或引用调用函数时，通过虚函数表来确定调用的函数，在运行时确定。内联函数是在编译时，将调用函数处插入内联函数的代码，省去了函数调用时的开销。</p><p>表面上看，虚函数不能为内联函数。但如果虚函数在编译期就能够确定要调用哪个函数时，就能够内联。也就是用对象本身去调用虚函数时，会内联展开，当然前提是函数并不复杂的情况下。</p><h3 id="构造函数与虚函数"><a href="#构造函数与虚函数" class="headerlink" title="构造函数与虚函数"></a>构造函数与虚函数</h3><p>构造函数不可以是虚函数。</p><ol><li>从vptr角度解释：虚函数对应一个vtable，可是这个vtable其实是存储在对象的内存空间的。 那么问题来了，如果构造函数是虚函数，就要通过vtable来调用，可是对象空间还没有实例化，也就是内存空间还没有，无法找到vtable，所以构造函数不能是虚函数。</li><li>从使用角度：虚函数主要用于在信息不全的情况下，能够使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义。 </li></ol><h3 id="析构函数与虚函数"><a href="#析构函数与虚函数" class="headerlink" title="析构函数与虚函数"></a>析构函数与虚函数</h3><p>在派生类中的析构函数常常为虚析构函数，是为了避免内存泄露。</p><p>如果不考虑虚函数的状况，给出一个基类和派生类，如果调用派生类的析构函数时，肯定会引发调用基类的析构函数，这和析构函数是不是虚函数没关系。如：[ Derive* p = new Derive(); ]</p><p>现在考虑虚函数的问题，由于使用虚函数使我们可以定义一个基类指针或引用可以直接对派生类进行操作，如：[ Base* p = new Derive(); ]，这就存在两种情况：</p><p>如果，不把基类的析构函数设置为虚函数，则在删除对象时，如果直接删除基类指针，系统就只能调用基类析构函数，而不会调用派生类构造函数。这就会导致内存泄露。</p><p>如果，把基类的析构函数设置为虚函数，则在删除对象时，直接删除基类指针，系统会调用派生类析构函数，之后此派生类析构函数会引发系统自动调用自己的基类，这就不会导致内存泄露。</p><p>所以，在写一个类时，尽量将其析构函数设置为虚函数，但析构函数默认不是虚函数。</p><p>[问] 应该把所有的类的析构函数都设置为虚函数吗？<br>[答] 不一定。使用虚函数后的类对象要比不使用虚函数的类对象占的空间多，而且在查找具体使用哪一个虚函数时，还会有时间代价。即当一个类不打算作为基类时，不用将其中的函数设置为虚函数。</p><h3 id="构造函数和析构函数可以调用虚函数吗，为什么"><a href="#构造函数和析构函数可以调用虚函数吗，为什么" class="headerlink" title="构造函数和析构函数可以调用虚函数吗，为什么"></a>构造函数和析构函数可以调用虚函数吗，为什么</h3><p>不提倡在构造函数和析构函数中调用虚函数。</p><ul><li>因为父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全的，故而C++不会进行动态联编</li><li>析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义。</li></ul><h3 id="动态绑定和静态绑定"><a href="#动态绑定和静态绑定" class="headerlink" title="动态绑定和静态绑定"></a>动态绑定和静态绑定</h3><p>为了支持c++的多态性，才用了动态绑定和静态绑定。</p><ul><li>对象的静态类型：<strong>对象在声明时采用的类型。是在编译期确定的。</strong></li><li>对象的动态类型：<strong>目前所指对象的类型，是在运行期决定的。</strong>对象的动态类型可以更改，但是静态类型无法更改。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span>&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B &#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B &#123;&#125;</span><br><span class="line">D* pD = <span class="keyword">new</span> D();<span class="comment">//pD的静态类型是它声明的类型D*，动态类型也是D*</span></span><br><span class="line">B* pB = pD;<span class="comment">//pB的静态类型是它声明的类型B*，动态类型是pB所指向的对象pD的类型D*</span></span><br><span class="line">C* pC = <span class="keyword">new</span> C();</span><br><span class="line">pB = pC;<span class="comment">//pB的动态类型是可以更改的，现在它的动态类型是C*</span></span><br></pre></td></tr></table></figure><ul><li>静态绑定：绑定的是对象的静态类型，某特性（比如函数）依赖于对象的静态类型，发生在编译期。</li><li>动态绑定：绑定的是对象的动态类型，某特性（比如函数）依赖于对象的动态类型，发生在运行期。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfun</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">()</span></span>;<span class="comment">//首先说明一下，这个子类重新定义了父类的no-virtual函数，这是一个不好的设计，会导致名称遮掩；这里只是为了说明动态绑定和静态绑定才这样使用。</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfun</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfun</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">D* pD = <span class="keyword">new</span> D();</span><br><span class="line">B* pB = pD;</span><br></pre></td></tr></table></figure><p>pD-&gt;DoSomething() 和 pB-&gt;DoSomething() 是no-virtual函数，它是静态绑定的，也就是编译器会在编译期根据对象的静态类型来选择函数。</p><p>pD-&gt;vfun()和pB-&gt;vfun() 是一个虚函数，它动态绑定的，也就是说它绑定的是对象的动态类型，pB和pD虽然静态类型不同，但是他们同时指向一个对象，他们的动态类型是相同的，都是D*，所以，他们的调用的是同一个函数：D::vfun()。</p><p>需要特别注意：虚函数的缺省参数是静态绑定的！！！</p><p>总结：可以认为只有虚函数才使用的是动态绑定，其他的全部是静态绑定。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;继承-with-virtual-function&quot;&gt;&lt;a href=&quot;#继承-with-virtual-function&quot; class=&quot;headerlink&quot; title=&quot;继承 with virtual function&quot;&gt;&lt;/a&gt;继承 with virtual function&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;构造由内而外&lt;/strong&gt;：首先调用父类的构造函数，然后再调用自己。&lt;br&gt;&lt;strong&gt;析构由外而内&lt;/strong&gt;：首先执行自己的析构函数，然后调用父类的析构函数。&lt;/p&gt;
&lt;p&gt;non-virtual: 你不希望重新定义（重写）它。&lt;br&gt;virtual: 你希望子类重新定义它，且它有默认定义。&lt;br&gt;pure virtual: 你希望子类一定要重新定义它，你对它没有默认定义。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Shape&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;draw&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;/span&gt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;   &lt;span class=&quot;comment&quot;&gt;// 纯虚函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;&amp;amp; msg)&lt;/span&gt;&lt;/span&gt;;   &lt;span class=&quot;comment&quot;&gt;// 虚函数 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;objectID&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt;&lt;/span&gt;;   &lt;span class=&quot;comment&quot;&gt;// 一般成员函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Rectangle&lt;/span&gt;:&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Shape &amp;#123;...&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Ellipse&lt;/span&gt;:&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Shape &amp;#123;...&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="C++" scheme="https://www.benboby.top/categories/C/"/>
    
    
    <category term="C++面向对象" scheme="https://www.benboby.top/tags/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：最多可以参加的会议数目II</title>
    <link href="https://www.benboby.top/2021/02/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%A4%9A%E5%8F%AF%E4%BB%A5%E5%8F%82%E5%8A%A0%E7%9A%84%E4%BC%9A%E8%AE%AE%E6%95%B0%E7%9B%AEII.html"/>
    <id>https://www.benboby.top/2021/02/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%A4%9A%E5%8F%AF%E4%BB%A5%E5%8F%82%E5%8A%A0%E7%9A%84%E4%BC%9A%E8%AE%AE%E6%95%B0%E7%9B%AEII.html</id>
    <published>2021-02-07T02:02:39.000Z</published>
    <updated>2021-02-07T02:28:48.114Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你一个 $a$ 数组，其中 $a[i] = [startDay_i, endDay_i, value_i]$ ，表示第 $i$ 个会议在 $startDay_i$ 天开始，第 $endDay_i$ 天结束，如果你参加这个会议，你能得到价值 $value_i$ 。同时给你一个整数 $k$ 表示你能参加的最多会议数目。</p><p>你同一时间只能参加一个会议。如果你选择参加某个会议，那么你必须 <strong>完整</strong> 地参加完这个会议。会议结束日期是包含在会议内的，也就是说你不能同时参加一个开始日期与另一个结束日期相同的两个会议。</p><p>请你返回能得到的会议价值 <strong>最大和</strong>。$(k \in [1, n], k * n \in [1, 1e6], startDay_i, endDay_i \in [1, 1e9], value_i \in[1, 1e6])$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><a id="more"></a><p>考虑动态规划。$dp[i][j]$ 表示前 $i$ 个会议刚好选 $j$ 个时，能获得的最大价值。</p><p>那么对于每个 $dp[i][j]$ 有两种情况：</p><ul><li>不参加第 $i$ 个会议，有 $dp[i][j] = dp[i - 1][j]$</li><li>参加第 $i$ 个会议，设第 $i$ 个会议开始时间为 $l$，那么我们应该是从 <strong>所有结束时间小于 $l$ 且刚好选 $j - 1$ 个会议</strong> 的那个状态转移过来。那么最好的方式就是一开始就将 $a$ 按结束时间排序，这样我们就能很快二分出来结束时间刚好（最后一个）小于 $l$ 的那个会议 $p$，有 $dp[i][j] = max(dp[i][j], dp[p][j - 1] + a[i].value)$。</li></ul><p>时间复杂度 $O(nklog_n)$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> l, r, w;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Node&amp; a) <span class="keyword">const</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> r &lt; a.r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; q[<span class="number">1000005</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; a, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (k + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) q[i + <span class="number">1</span>] = &#123;a[i][<span class="number">0</span>], a[i][<span class="number">1</span>], a[i][<span class="number">2</span>]&#125;;</span><br><span class="line">        sort(q + <span class="number">1</span>, q + n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>, r = i, mid;</span><br><span class="line">            <span class="keyword">while</span> (l + <span class="number">1</span> &lt; r) &#123;</span><br><span class="line">                mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (q[mid].r &lt; q[i].l) l = mid;</span><br><span class="line">                <span class="keyword">else</span> r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++) </span><br><span class="line">                dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[l][j - <span class="number">1</span>] + q[i].w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给你一个 $a$ 数组，其中 $a[i] = [startDay_i, endDay_i, value_i]$ ，表示第 $i$ 个会议在 $startDay_i$ 天开始，第 $endDay_i$ 天结束，如果你参加这个会议，你能得到价值 $value_i$ 。同时给你一个整数 $k$ 表示你能参加的最多会议数目。&lt;/p&gt;
&lt;p&gt;你同一时间只能参加一个会议。如果你选择参加某个会议，那么你必须 &lt;strong&gt;完整&lt;/strong&gt; 地参加完这个会议。会议结束日期是包含在会议内的，也就是说你不能同时参加一个开始日期与另一个结束日期相同的两个会议。&lt;/p&gt;
&lt;p&gt;请你返回能得到的会议价值 &lt;strong&gt;最大和&lt;/strong&gt;。$(k \in [1, n], k * n \in [1, 1e6], startDay_i, endDay_i \in [1, 1e9], value_i \in[1, 1e6])$&lt;/p&gt;
&lt;h2 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h2&gt;</summary>
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="动态规划" scheme="https://www.benboby.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>STL学习</title>
    <link href="https://www.benboby.top/2021/02/STL.html"/>
    <id>https://www.benboby.top/2021/02/STL.html</id>
    <published>2021-02-05T14:35:42.000Z</published>
    <updated>2021-02-23T03:45:26.845Z</updated>
    
    <content type="html"><![CDATA[<h2 id="STL的两级空间配置器"><a href="#STL的两级空间配置器" class="headerlink" title="STL的两级空间配置器"></a>STL的两级空间配置器</h2><p>为什么需要二级空间配置器？</p><ul><li>我们知道动态开辟内存时，要在堆上申请，但若是我们需要频繁的在堆开辟释放内存，则就会在堆上造成很多外部碎片，浪费了内存空间</li><li>每次都要进行调用malloc、free函数等操作，使空间就会增加一些附加信息，降低了空间利用率</li><li>随着外部碎片增多，内存分配器在找不到合适内存情况下需要合并空闲块，浪费了时间，大大降低了效率<br>于是就设置了二级空间配置器，当开辟内存&lt;=128bytes时，即视为开辟小块内存，则调用二级空间配置器。</li></ul><h3 id="一级配置器"><a href="#一级配置器" class="headerlink" title="一级配置器"></a>一级配置器</h3><p>重要的函数就是allocate、deallocate、reallocate。<br>一级空间配置器是以malloc()，free()，realloc()等C函数执行实际的内存配置。</p><ol><li>直接allocate分配内存，其实就是malloc来分配内存，成功则直接返回，失败就调用处理函数</li><li>如果用户自定义了内存分配失败的处理函数就调用，没有的话就返回异常</li><li>如果自定义了处理函数就进行处理，完事再继续分配试试</li></ol><h3 id="二级配置器"><a href="#二级配置器" class="headerlink" title="二级配置器"></a>二级配置器</h3><ol><li>维护16条链表，分别是0-15号链表，最小8字节，以8字节逐渐递增，最大128字节，你传入一个字节参数，表示你需要多大的内存，会自动帮你校对到第几号链表（如需要13bytes空间，我们会给它分配16bytes大小），在找到第你个链表后查看链表是否为空，如果不为空直接从对应的free_list中拔出，将已经拨出的指针向后移动一位。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;STL的两级空间配置器&quot;&gt;&lt;a href=&quot;#STL的两级空间配置器&quot; class=&quot;headerlink&quot; title=&quot;STL的两级空间配置器&quot;&gt;&lt;/a&gt;STL的两级空间配置器&lt;/h2&gt;&lt;p&gt;为什么需要二级空间配置器？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们知道动态开</summary>
      
    
    
    
    <category term="C++" scheme="https://www.benboby.top/categories/C/"/>
    
    
    <category term="C++基础" scheme="https://www.benboby.top/tags/C-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>操作系统知识点</title>
    <link href="https://www.benboby.top/2021/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9.html"/>
    <id>https://www.benboby.top/2021/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9.html</id>
    <published>2021-02-03T14:35:42.000Z</published>
    <updated>2021-02-25T15:36:31.146Z</updated>
    
    <content type="html"><![CDATA[<h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><p>并发：宏观上两个程序在同时运行，实际上是交织运行的，单个周期只运行了一个指令，用于提高效率。<br>并行：物理意义上的同时运行，如多核cpu，运行在不同的核上，互不影响。</p><h3 id="进程和线程的概念，区别，使用场景"><a href="#进程和线程的概念，区别，使用场景" class="headerlink" title="进程和线程的概念，区别，使用场景"></a>进程和线程的概念，区别，使用场景</h3><p>进程：资源分配的基本单位，实现了操作系统的并发。<br>线程：线程是进程的子任务，是CPU调度的基本单位，不拥有资源，但可以使用进程所属的资源。每个进程都有一个主线程，实际上是主线程来执行main函数中的代码。</p><p>一个线程只属于一个进程，进程间不会相互影响，一个线程挂掉将影响整个进程挂掉。</p><p>线程并不是越多越好，每个线程都需要一个独立的堆栈空间，线程之间的切换需要保存很多中间状态，耗费程序运行时间。多线程开销远远小于多进程。</p><p>进程在同一时间只能干一件事，进程在执行过程中如果阻塞，整个进程就会挂起，然后其中有些工作并不依赖阻塞的资源，却还是卡在那里。因此引入线程，减少程序在并发时付出的时空开销。</p><a id="more"></a><h3 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a>进程间通信方式</h3><ol><li>管道<ul><li>普通管道PIPE：半双工，数据单向流动，一般申请两个，一个用于读一个用于写。只能用于有父子进程和兄弟进程之间，只存在于内存中。</li><li>命名管道FIFO：有具体的路径名，存在于文件系统中，因此可以在无关进程中交换数据。</li></ul></li><li>套接字socket：可以用于不同主机间进行通讯</li><li><p>系统IPC<br> 消息队列：消息的链接表，存放在内核中。具有写权限的进程可以向队列中添加消息，有读权限的进程可以从队列中读取信息。</p><ul><li>消息具有特定的格式和优先级，克服了信号传递信息少，管道只能承载无格式字节流已经缓冲区大小受限等特点</li><li>独立于发送和接收进程，进程终止是，消息队列及其内容不会被删除</li><li><p>可以实现消息的随机查询，不一定要先进先出地读取  </p><p>信号量：计数器，控制多进程对共享资源的访问。用于实现进程间的互斥和同步，不用于存储进程间的通信数据。一般需要结合共享内存和PV操作使用。</p><p>信号：用于通知接收进程某个事件已经发生</p><p>共享内存：使得多个进程可以访问同一块内存，不同进程可以及时看到对方进程中对共享内存的数据更新。</p></li><li>最快的IPC，进程直接对内存进行存取</li><li>多个进程可以同时操作，需要进行同步</li><li>需要同步操作，和互斥锁和信号量一起结合使用</li></ul></li></ol><h3 id="线程间通信方式"><a href="#线程间通信方式" class="headerlink" title="线程间通信方式"></a>线程间通信方式</h3><ol><li>临界区：多个线程访问一个独占共享资源时，可以使用临界区对象，其它线程想访问，会被挂起，直到拥有临界区的线程放弃位置。</li><li>事件：允许一个线程在处理完之后，主动唤醒另外一个线程执行任务。</li><li>互斥量：互斥对象机制，拥有互斥对象的线程才有访问公共资源的权限。</li><li>信号量：允许多个线程在同一时刻访问同一个资源，但一般需要限制数目。</li></ol><h3 id="物理内存和虚拟内存"><a href="#物理内存和虚拟内存" class="headerlink" title="物理内存和虚拟内存"></a>物理内存和虚拟内存</h3><p>早期的计算机程序是直接运行在物理内存的，但这种直接访问内存的方式影响到内存安全性问题，已经内存使用率的降低。</p><p>于是考虑在其中添加一层中间层 ——— 虚拟内存，使得程序通过虚拟内存去间接访问物理内存。只要系统处理好其中的映射关系，就可以达到物理内存地址隔离的效果，保证数据安全性。</p><p>操作系统分配给进程的内存空间中包含五个段：</p><ul><li>数据段：存放静态变量和已初始化不为0的全局变量</li><li>代码段：存放可执行文件的操作指令，只读不可写</li><li>BSS段：存放未初始化的全局变量</li><li>堆：存放动态分配的内存</li><li>栈：存放临时的局部变量和函数的参数值</li></ul><p>分段技术可以解决什么问题？<br>假设A虚拟空间地址为0-99，对应物理地址600-699；B虚拟空间地址为100-199，对应物理空间地址300-399。如果操作了地址150，此时150是虚拟的，也就在操作系统的控制中，操作系统可以阻止这次操作，保证了内存安全性，体现出隔离性。</p><p>但这样并没有解决空间利用率低的问题，于是又提出了分页的概念。分页其实就是把段再进行细分，每一小块被称为帧。</p><p>分段方法中，程序会被直接加载到虚拟内存，而分页则是把单位分成了页，虚拟地址的页去映射物理地址的页，从而提高了物理内存的使用率。</p><p>虚拟内存和物理内存的映射是通过页表实现的，页表实际上是一个数组，每个进程都有一个页表。</p><h3 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h3><p>malloc()等内存分配函数只是建立了进程虚拟地址空间，没有分配虚拟内存对应的物理内存。当进程访问这些没有建立映射的虚拟内存时，会触发缺页中断。即要访问的页面不在内存时，会产生一次缺页中断，操作系统根据页表的外存地址在外存中找到所缺的一页，将其调入内存。</p><h3 id="fork和vfork"><a href="#fork和vfork" class="headerlink" title="fork和vfork"></a>fork和vfork</h3><p>fork()创建一个子进程，返回值小于0表示创建失败，子进程返回0，父进程返回子进程pid。<br>子进程和父进程共用页面，采用写时复制，即当子进程需要修改页面时才对页面进行复制，因为一开始就直接对父进程整体资源进行复制是很耗费时间的。</p><p>vfork创建的子进程先于父进程运行，父子进程共用数据段，但若子进程依赖父进程操作，就会产生死锁。</p><h3 id="多线程和多进程的不同"><a href="#多线程和多进程的不同" class="headerlink" title="多线程和多进程的不同"></a>多线程和多进程的不同</h3><p>使用场景：</p><ul><li>需要频繁创建销毁的优先使用线程；因为对进程来说创建和销毁一个进程代价是很大的。</li></ul><h3 id="OS缺页置换算法"><a href="#OS缺页置换算法" class="headerlink" title="OS缺页置换算法"></a>OS缺页置换算法</h3><p>当访问内存中一个不存在的页时，且内存已满，就需要从内存中替换一个页。</p><ul><li>FIFO（先进先出）：置换最先进来的页面，即逗留时间最久的页面。</li><li>LRU（最近最少访问）：置换最近一段时间内最久没被访问过的页面。</li></ul><h3 id="虚拟内存置换方式"><a href="#虚拟内存置换方式" class="headerlink" title="虚拟内存置换方式"></a>虚拟内存置换方式</h3><ul><li>FIFO：先进先出算法</li><li>LFU：最不经常访问淘汰算法</li><li>LRU：最近最少使用算法，还有LRU-K，LRU-2。</li></ul><h3 id="Linux锁机制"><a href="#Linux锁机制" class="headerlink" title="Linux锁机制"></a>Linux锁机制</h3><ol><li>互斥锁：mutex，用于保证任何时刻只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒。</li><li>读写锁：rwlock，分为读锁和写锁。允许多个线程同时读，但只能有一个线程写。写优先于读，一旦有写，则读必须等待。适用于读频率远远大于写的情况。</li><li>自旋锁：在任何时刻只能有一个线程访问对象，但是获取锁操作失败时，不会进入睡眠，而是在原地自旋，直到锁被释放。节省了线程从睡眠到被唤醒的消耗。适用于加锁时间短暂的情况下。</li></ol><h3 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h3><p>内核态：运行操作系统程序，内核态<br>用户态：运行用户程序，非特权指令</p><p>用户态 —&gt; 内核态：申请外部资源（如读取文件，申请堆内存）：系统调用，中断，异常。</p><h3 id="僵尸进程，守护进程"><a href="#僵尸进程，守护进程" class="headerlink" title="僵尸进程，守护进程"></a>僵尸进程，守护进程</h3><h3 id="多线程同步，锁机制"><a href="#多线程同步，锁机制" class="headerlink" title="多线程同步，锁机制"></a>多线程同步，锁机制</h3>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;并发和并行&quot;&gt;&lt;a href=&quot;#并发和并行&quot; class=&quot;headerlink&quot; title=&quot;并发和并行&quot;&gt;&lt;/a&gt;并发和并行&lt;/h3&gt;&lt;p&gt;并发：宏观上两个程序在同时运行，实际上是交织运行的，单个周期只运行了一个指令，用于提高效率。&lt;br&gt;并行：物理意义上的同时运行，如多核cpu，运行在不同的核上，互不影响。&lt;/p&gt;
&lt;h3 id=&quot;进程和线程的概念，区别，使用场景&quot;&gt;&lt;a href=&quot;#进程和线程的概念，区别，使用场景&quot; class=&quot;headerlink&quot; title=&quot;进程和线程的概念，区别，使用场景&quot;&gt;&lt;/a&gt;进程和线程的概念，区别，使用场景&lt;/h3&gt;&lt;p&gt;进程：资源分配的基本单位，实现了操作系统的并发。&lt;br&gt;线程：线程是进程的子任务，是CPU调度的基本单位，不拥有资源，但可以使用进程所属的资源。每个进程都有一个主线程，实际上是主线程来执行main函数中的代码。&lt;/p&gt;
&lt;p&gt;一个线程只属于一个进程，进程间不会相互影响，一个线程挂掉将影响整个进程挂掉。&lt;/p&gt;
&lt;p&gt;线程并不是越多越好，每个线程都需要一个独立的堆栈空间，线程之间的切换需要保存很多中间状态，耗费程序运行时间。多线程开销远远小于多进程。&lt;/p&gt;
&lt;p&gt;进程在同一时间只能干一件事，进程在执行过程中如果阻塞，整个进程就会挂起，然后其中有些工作并不依赖阻塞的资源，却还是卡在那里。因此引入线程，减少程序在并发时付出的时空开销。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="https://www.benboby.top/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://www.benboby.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：滑动窗口中位数</title>
    <link href="https://www.benboby.top/2021/02/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%AD%E4%BD%8D%E6%95%B0.html"/>
    <id>https://www.benboby.top/2021/02/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%AD%E4%BD%8D%E6%95%B0.html</id>
    <published>2021-02-03T05:48:11.000Z</published>
    <updated>2021-02-03T05:59:56.952Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你一个数组 nums，有一个长度为 k 的窗口从最左端滑动到最右端。窗口中有 k 个数，每次窗口向右移动 1 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。$(n, k \in [1, 100000])$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>用优先队列+延迟删除有点麻烦，可以考虑直接用 <strong>multiset</strong> 做，本质都是一样的，维护两个大小相同或差一的集合（自动排序）$l 和 r$，$l$ 维护小于等于中位数的值，$r$ 维护大于等于中位数的值，$multiset$ 的优秀特性可以在 $log$ 时间复杂度内进行增删操作。具体细节较多，时间复杂度 $O(nlog(k))$。</p><a id="more"></a><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">medianSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">double</span>&gt; l, r;</span><br><span class="line">        <span class="keyword">int</span> n = a.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k) &#123;           <span class="comment">// 需要移除之前已经加入滑动窗口的元素</span></span><br><span class="line">                <span class="keyword">if</span> (l.count(a[i - k])) l.erase(l.find(a[i - k]));</span><br><span class="line">                <span class="keyword">else</span> r.erase(r.find(a[i - k]));</span><br><span class="line">            &#125;</span><br><span class="line">            l.insert((<span class="keyword">double</span>)a[i]);</span><br><span class="line">            <span class="keyword">while</span> (l.size() &amp;&amp; r.size() &amp;&amp; *(--l.end()) &gt; *r.begin()) &#123;   <span class="comment">// 左集合的元素不可能大于右集合</span></span><br><span class="line">                l.insert(*r.begin());</span><br><span class="line">                r.insert(*(--l.end()));</span><br><span class="line">                l.erase(*(--l.end()));</span><br><span class="line">                r.erase(*r.begin());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (l.size() - <span class="number">1</span> &gt; r.size()) &#123;            <span class="comment">// 左集合元素最多只会比右集合多一（窗口大小为奇数）</span></span><br><span class="line">                r.insert(*(--l.end()));</span><br><span class="line">                l.erase(--l.end());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;         </span><br><span class="line">                <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res.push_back(*(--l.end()));</span><br><span class="line">                <span class="keyword">else</span> res.push_back((*(--l.end()) + *r.begin()) / <span class="number">2.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给你一个数组 nums，有一个长度为 k 的窗口从最左端滑动到最右端。窗口中有 k 个数，每次窗口向右移动 1 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。$(n, k \in [1, 100000])$&lt;/p&gt;
&lt;h2 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h2&gt;&lt;p&gt;用优先队列+延迟删除有点麻烦，可以考虑直接用 &lt;strong&gt;multiset&lt;/strong&gt; 做，本质都是一样的，维护两个大小相同或差一的集合（自动排序）$l 和 r$，$l$ 维护小于等于中位数的值，$r$ 维护大于等于中位数的值，$multiset$ 的优秀特性可以在 $log$ 时间复杂度内进行增删操作。具体细节较多，时间复杂度 $O(nlog(k))$。&lt;/p&gt;</summary>
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="STL" scheme="https://www.benboby.top/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>LinuxC++网络编程学习笔记</title>
    <link href="https://www.benboby.top/2021/02/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
    <id>https://www.benboby.top/2021/02/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</id>
    <published>2021-02-02T10:06:30.000Z</published>
    <updated>2021-02-24T11:10:17.241Z</updated>
    
    <content type="html"><![CDATA[<h2 id="主机字节序和网络字节序"><a href="#主机字节序和网络字节序" class="headerlink" title="主机字节序和网络字节序"></a>主机字节序和网络字节序</h2><p>字节在内存中的排列影响它实际的值，字节序分为<strong>大端序</strong>和<strong>小端序</strong>。大端序指一个整数的高位存储在内存的低地址处，小端序指一个整数的高位存储在内存的高地址处。</p><p>现代PC大多采用小端序，因此小端序又被称为<strong>主机字节序</strong>。</p><p>由于数据在两台使用不同字节序的主机之间进行传递是，接收到必然错误的解释了数据。解决的方法是：发送端总是把要发送的数据转化成大端序然后再发送，接受端明白对方传过来的数据总是采用大端序，所以接受端可以根据自身使用的字节序来决定是否对该数据进行转化。因此大端序也称为<strong>网络字节序</strong>。</p><a id="more"></a><p>Linux提供了四个函数来完成主机字节序和网络字节序之间的转化：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="comment">// 一般用于转换ip地址</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">htonl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> hostlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">ntonl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> netlong)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般用于转换端口</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">htons</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> hostshort)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> netshort)</span></span>;</span><br></pre></td></tr></table></figure></p><h2 id="socket套接字"><a href="#socket套接字" class="headerlink" title="socket套接字"></a>socket套接字</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, ubt protocol)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>domain: PF_INET -&gt; IPv4, PF_INET6 -&gt; IPv6, PF_UNIX -&gt; UNIX本地协议族</li><li>type: SOCK_STREAM -&gt; TCP协议，SOCK_DGRAM -&gt; UDP协议</li><li>protocol: 一般都置位0，表示使用默认协议</li></ul><p>调用成功返回一个socket文件描述符，其实就是一个数字，这个数字具有唯一性，并且一直有效直到你close()这个数字为止；失败返回-1并设置errno。</p><p>文件描述符：unix哲学——一切皆文件，我们把socket也看成是文件描述符，用它来收发数据。send(), recv()。</p><p>一旦连接成功建立，双方的通讯就只需要通过该文件描述符即可。</p><h2 id="命名socket"><a href="#命名socket" class="headerlink" title="命名socket"></a>命名socket</h2><p>创建socket时，指定了地址族，却并未指定该地址族中的哪个具体socket地址。我们称socket与socket地址绑定称为给socket命名。服务端只有命名后，客户端才知道如何连接它。客户端通常不需要命名，采用匿名，操作系统会自动分配给它socket地址。使用的函数为bind()：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct* my_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>sockfd: socket文件描述符</li><li>my_addr: 这个地址将分配给未命名的sockfd文件描述符</li><li>addrlen: 该socket地址的长度</li></ul><p>相同的ip地址的相同端口只能被 bind() 一次，bind成功返回0，失败返回-1并设置errno。</p><p>关于bind绑定失败的情况，还需要详谈。。。</p><h2 id="监听socket"><a href="#监听socket" class="headerlink" title="监听socket"></a>监听socket</h2><p>socket被命名后，还不能被马上接受客户连接，我们需要创建一个监听队列用以存放待处理的客户连接：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure><br>listen 用于监听端口，作用于TCP连接中的服务端。</p><p>对于一个调用listen()进行监听的套接字，操作系统会给这个套接字维护两个队列：</p><ul><li>未完成队列：当服务端收到客户端第一次握手发送的SYN包时，就会在未完成队列中创建一个跟该 SYN 包对应的一项新的套接字（通常由(服务器ip + port, 客户端ip +port)组成）</li><li>已完成队列：三次握手完成后，连接变为ESTABISHED状态，从未完成队列进入已完成队列</li></ul><p>backlog的含义：已完成队列和未完成队列条目之和不能超过backlog。<br>RTT：未完成队列中任意一项在未完成队列中停留的时间，这个时间取决于客户端和服务器。对于客户端，RTT为前两次握手时间；对于服务端，RTT为后两次握手时间。</p><p>客户端的Connect()其实在第二次握手结束后已经返回了。</p><p>细节：</p><ol><li>如果两个队列之和已经达到最大上限，再有客户发送syn请求的话，这个请求会被服务器忽略；而客户端发现syn没有被回应，会重发请求包。</li><li>已完成队列中有客户端发来数据，但该套接字还未被accept函数取出，那么这个数据就会被保存在已连接的套接字的接收缓冲区中，接收的数据量取决于缓冲区有多大。</li></ol><h2 id="接受连接"><a href="#接受连接" class="headerlink" title="接受连接"></a>接受连接</h2><p>accept() 函数，从已完成连接队列中的队首取出一项（已经完成三次握手连接的客户端socket值），返回给进程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>sockfd 是执行过 listen 系统监听调用的 <strong>监听socket</strong>，只要服务端还在运行，那么它就应该一直存在（我们称已经处于ESTABISHED状态的客户端连接为 <strong>连接socket</strong>）</li><li>addr 被用于接收远端 socket 地址，该地址的长度由addrlen指出</li></ul><p>如果已完成队列为空，那么则会一直处于休眠等待状态，直到有内容时才唤醒。<br>accept返回的是对应TCP连接的套接字connfd。</p><p>如果建立连接后用户掉线，accept依然返回成功，因为它只负责从已完成队列中取出内容。</p><h2 id="发起连接"><a href="#发起连接" class="headerlink" title="发起连接"></a>发起连接</h2><p>客户端需要使用connect函数主动与服务器建立连接：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *serv_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><br>sockfd参数由socket系统调用返回一个socket，serv_addr参数是服务器监听的socket地址，addrlen则指定这个地址的长度。</p><p>connect成功时返回0。一旦成功建立连接，sockfd就唯一标识这个连接，客户端就可以通过读写sockfd来与服务器通信。失败返回-1并设置errno，常见的错误有：目的端口不存在，连接超时。</p><h2 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h2><p>关闭连接实际上就是关闭该连接对应的socket：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure><br>fd是待关闭的socket，close并非总是立即关闭一个连接，而是将fd的引用计数减一。当引用计数为0时，才最终关闭连接。<br>在多进程出现在，一次fork会使父进程中打开的socket引用计数加一，因此必须在父进程和子进程中都对该socket执行close才能将连接关闭。</p><h2 id="IO操作"><a href="#IO操作" class="headerlink" title="IO操作"></a>IO操作</h2><p>在Unix中，一切皆文件，文件即是一串二进制流，不论是socket，FIFO，管道，终端，都是文件，对这些流进行数据收发操作即是IO操作。系统调用 read 读入数据，调用 write 写入数据。我们如何知道操作哪个流？文件描述符，即fd，而fd就是一个整数，对这个整数操作即是对文件操作。创建一个socket，返回一个文件描述符，对socket操作即是对这个描述符操作。</p><h2 id="阻塞-非阻塞"><a href="#阻塞-非阻塞" class="headerlink" title="阻塞/非阻塞"></a>阻塞/非阻塞</h2><p>阻塞IO：调用某个函数，该函数卡在这里（进入休眠状态）等待一个事情发生，然后才继续执行，这种函数一般称为阻塞函数。<br>非阻塞IO：充分利用时间片，效率更高。不断的调用accept，recvfrom函数检查有没有数据到来。</p><h2 id="同步-异步"><a href="#同步-异步" class="headerlink" title="同步/异步"></a>同步/异步</h2><p><strong>异步IO：</strong>调用一个异步I/O函数，我们要给这个函数指定一个接收缓冲区和一个回调函数。调用后，该函数会立即返回。其余判断交给操作系统，判断数据是否到来，如果到来，操作系统会把数据拷贝到你所指定的缓冲区里，然后调用回调函数通知你。</p><p><strong>异步和非阻塞的区别：</strong></p><ul><li>非阻塞I/O需要不停调用I/O函数来检查数据是否到来，一旦数据到来，就必须卡在I/O函数里把内核缓冲区复制到用户缓冲区，然后才执行结束</li><li>异步I/O只需要调用一次，然后你就可以去做别的事了，内核去帮你判断数据是否到来，最后通知你</li></ul><p><strong>同步I/O：</strong><br>select，poll，epoll都可以认为属于同步IO。</p><ul><li>首先调用select函数判断有无数据到来，没有则卡在那里</li><li>select返回之后，调用recvfrom去取数据，取数据时也会卡一下</li></ul><p>同步I/O看起来更麻烦一点，因为要调用两个函数才可以得到数据。但与阻塞式相比，优势在于I/O复用。</p><p><strong>I/O复用：</strong><br>又称为I/O多路复用，将多个socket（TCP连接）弄成一堆，select等待这一堆的任何一个TCP连接有数据到来，再用具体的recvfrom去收。</p><h2 id="select-API"><a href="#select-API" class="headerlink" title="select API"></a>select API</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, struct timeval* timeout)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>nfds 指定被监听文件描述符总数，通常设置为select监听的所有文件描述符中的最大值加1，因为文件描述符是从0开始计数的。</li></ul><h2 id="epoll技术"><a href="#epoll技术" class="headerlink" title="epoll技术"></a>epoll技术</h2><p>从Linux内核2.6开始引入，是一种典型的I/O多路复用技术，最大的特点就是支持高并发，完全没有会随着并发量提高而出现性能明显下降的情况，但是会造成一定内存消耗。</p><p>与select，poll不同的是，它使用一组函数来完成任务。epoll 把用户关心的都文件描述符上的事件放在内核的一个事件表中，无需每次调用都要重复传入描述符，因此epoll需要一个额外的文件描述符，来唯一标示内核中的这个事件表，<strong>使用 epoll_create 来创建该文件描述符：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span>: </span></span><br></pre></td></tr></table></figure><br>size参数只是告诉内核事件表需要多大，还并不起作用。返回的文件描述符讲称为其它所有epoll系统调用函数的第一个参数，以指定要访问的内核事件表。</p><p>具体：创建一个eventpoll结构体对象，创建了一棵红黑树和一个双向链表，其中rbr指向该红黑树的根，rdlist指向该双向链表的头节点</p><p><strong>使用 epoll_ctl 来操作内核事件表：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br></pre></td></tr></table></figure><br>event 指定事件信息，fd为要操作的文件描述符(accept得到)，op指定操作类型：</p><ul><li>ADD，往事件表中注册fd上的事件，相当于向红黑树添加一个节点，key值为客户端连接产生的fd，如果已经存在该节点，则直接报错</li><li>MOD，修改fd上的注册事件，修改某个节点</li><li>DEL，删除fd上的注册事件，删除某个节点</li></ul><p>因此，红黑树上的节点来自于 epoll_ctl 操作。</p><p><strong>当事件发生时，我们需要通过 epoll_wait 函数来得到操作系统的通知。</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event* events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><br>双向链表中存放的是所有有事件/数据的请求，epoll_wait 遍历双向链表，把双向链表里面的数据拷贝出去，然后移除。</p><p>需要注意的是，在红黑树中的节点并不会被删除。实际上用的是一个结构体同时维护了红黑树和双向链表的节点内容：红黑树拥有指向父节点，子节点的指针，双向链表拥有指向上一个和下一个结点的指针。这种优秀的设计使得在删除双向链表的结点时并不会对红黑树产生影响，而是相互独立的，但维护的时候又可以一起维护，使得一个节点既可以作为红黑树节点，也可以作为双向链表节点，从而大大减少了内存浪费。</p><ul><li>epfd 为 epoll_create 返回的对象描述符</li><li>events指向一个数组，最大长度为 maxevents，表示此次 epoll_wait 调用最多可以收集到 maxevents 个（双向链表中）已经准备好的读写事件。</li></ul><p>什么时候内核会向双向链表中增加节点呢？</p><ul><li>客户端完成三次握手 ——&gt;  服务器需要accept()</li><li>当客户端关闭连接  ——&gt;  服务器也要调用close()关闭</li><li>客户端发送数据来  ——&gt;  服务器需要调用read(),recv()函数来收数据</li><li>当可以发送数据时  ——&gt;  服务器调用send(),write()</li></ul><h2 id="LT-和-ET-模式"><a href="#LT-和-ET-模式" class="headerlink" title="LT 和 ET 模式"></a>LT 和 ET 模式</h2><p>epoll对文件描述符的操作有两种模式：<br>LT：水平触发，低速效率较低，默认模式，如果这个事件没有被处理完，就会被一直触发<br>ET：边沿触发，高速模式，效率高，只会被触发一次，但代价是编码难度加大</p><p>为什么ET模式事件只触发一次：ET模式事件只会被扔到双向链表一次，被 epoll_wait 取出后销毁。</p><p>为什么LT模式事件会触发多次：如果事件没有处理完，就会被多次扔进双向链表。</p><p>如果收发数据包没有具体格式，可以考虑用ET模式。</p><h2 id="TCP粘包，缺包"><a href="#TCP粘包，缺包" class="headerlink" title="TCP粘包，缺包"></a>TCP粘包，缺包</h2><p>客户端粘包：短时间内多次send，客户端有 Nagle 优化算法，直接合并成一个数据包发送出去，导致粘包。因此只要关闭 Nagle 算法，就能解决客户端粘包问题。</p><p>服务端粘包：无论客户端是否粘包，都避免不了服务端都会粘包。两次recv之间需要时间，但如果这个时间内多个包来了，则这多个包可能就被第二次recv全部收走，导致一次recv就收走了所有的包。</p><p><strong>解决粘包：</strong>把几个包一个一个拆出来，能拆一个是一个。<br>如何拆包？每一个收发的数据包都遵循包头+包体的格式，包头固定【10个字节】，其中有一个变量记录整个包【包头+包体】的长度。这样就知道了包体的长度，然后只收包体长度一样多的字节即可。这样就收到一个完整的数据包。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;主机字节序和网络字节序&quot;&gt;&lt;a href=&quot;#主机字节序和网络字节序&quot; class=&quot;headerlink&quot; title=&quot;主机字节序和网络字节序&quot;&gt;&lt;/a&gt;主机字节序和网络字节序&lt;/h2&gt;&lt;p&gt;字节在内存中的排列影响它实际的值，字节序分为&lt;strong&gt;大端序&lt;/strong&gt;和&lt;strong&gt;小端序&lt;/strong&gt;。大端序指一个整数的高位存储在内存的低地址处，小端序指一个整数的高位存储在内存的高地址处。&lt;/p&gt;
&lt;p&gt;现代PC大多采用小端序，因此小端序又被称为&lt;strong&gt;主机字节序&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;由于数据在两台使用不同字节序的主机之间进行传递是，接收到必然错误的解释了数据。解决的方法是：发送端总是把要发送的数据转化成大端序然后再发送，接受端明白对方传过来的数据总是采用大端序，所以接受端可以根据自身使用的字节序来决定是否对该数据进行转化。因此大端序也称为&lt;strong&gt;网络字节序&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://www.benboby.top/categories/C/"/>
    
    
    <category term="网络编程" scheme="https://www.benboby.top/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++语言基础</title>
    <link href="https://www.benboby.top/2021/01/C-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80.html"/>
    <id>https://www.benboby.top/2021/01/C-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80.html</id>
    <published>2021-01-31T06:52:21.000Z</published>
    <updated>2021-02-18T06:21:44.284Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="d12a3ad50e4f21a2da702ea776bb581d4a7c4377146174b96e224e36e8bd005e">88bfb973b5cd9a98289a5356073cb3e561ba3d32e73d841574e69103b5f1f9aa0c598a741ff12e1904e95cf8d09e492f2918890f88ae3ce3e9904e4d8036138fe4bf2f0ecc47f1df3a7d4b3fb3ad0885888c8eeebe9d6d45e034be6c8cf2e12e9751ef0ec2cb5c17db40ee54c8386f1d14a3b9e3f8bd00751bca74638367f91b7e0134158f5c7856100a74abd7cae4945775999b7d9f4709d7eaf9b226b79b8b1c4e83f17081ec0351649e6e76c5064ca80344c3fbb12fac550e96f7c77de1fd1dfb2dc9136440940227e2dd88322017afe20c193c2492bb78257d8d772b6ef306186739405997f2a8b00a3673ad77c15c4eb641fc6ef73bdd3ac6c482b1bfc6ee23b18f8fe1623b89669c7724beb8141865d8a82a478b434546b53d6a79131a43c1dcebfdd75068f81a0e51d359b6c93cb58ba9dffed56e8d9be85a207dd3ce4a58682cc4b5e4f186371e43dd78b87bfd62bbfc664c21eb0daf9deb2e4978a73a8d67d2928e15280bd61cf7d9ba69f521a438e924e214e1dfdf059b8262321fea6aaa9c0467d6f8ce311ce17fa061a71ce16b34aa3e3f188f65d15700a9b28c0acfd055bbc818ec0140962ebf841ccff58c260a9217c05876bba9599db7c42b9c399514e4008acd06765c91257ff4d2f73d37b559c17be6f6b3315db13f29503ea6d90e448c302bcfc56114f349ca629bf327f3493d7f6c486fa45d2381a862e188134a26a01d6bcd0e374f9d346ecbbdd8161a415b1c341b505de3ff12f02935410e4136ed7fd64e8a8fd3834ba32a8ec1a64f6564a19254453b76d953ae63bb88cfd6279df4f088452b996c43427bd80d98eda6f0ec0767e3de9b7b8c348530209987c707fa71386909f7fd6f4e5453dd1223a95d2c121f0b3834a13f0d381fcb861a285f5d3585ae961b243acbb538aceec04207f4c29ec43c53500d2d844b657ae7e607e83ebc273d261e90f613d30d67c93b7d60942cfccfc057a1fc1098b4d80bccc6e1b67c07cb6e1310c9939dbd61f9f8e45bddfce4981996d6752f11fb68db43c3909a62517f6d7bde47fbd525bb2c411dbee497809f3e5a988f74ca204eb44821a7058fde8921fbcb0323a99699b5a942b70964e51b8fbc7cfedaae7a75c816d33a2bb2a72effc3b800c79a789fd93389a15c8d4ba9c608450e0646a7f423120a5c6abd2dae447daaa4b0e401ea4e0a02ab55c6620280b5bb32d28322c87d3a77b7253a8614ec3b6e8337f4d81e6321528d99196ec032b337626a945f58d3f586c682ac03aea0c93f2aafe1f7544a92e6cbfc194a1795fb9b4e386b563c4f0a2a2c86b5da9f5295bfede296a0dd33d69676492aca241ed8190e2a2ba91b4ba544b0988e2669bd04d73ade05baa7a5f2ab28e80d01e18c07afb4530f47d285f44b861b9efe63a214adfbcc68705b160c6bb562e411cbc527dafbfe2a7f63eaaaa4a65710a35f63a32254a8dd311a7ca56e53686b75ef7bf3fa9113dbbd3d561b6248f615328ce5569d177ab63fc2364a8983237ee0e2bab5f7bf1fbc7f34a85d839ed0b2936542d4ffedd869a6ccaa0a16849189ac28a9f3c3380b3157553b3b71b1f5533ba8bc66791d163b6374d2795ab6ca730763e0a7f939918ebb0458cfa8af8cb8d5b8a5d675afd53602bd8b30756f9440460071aafae981b7b9c5b94636f429a5de0d9a648a7b61a54ef790c4dbdb6776a0de8166b975447beb894e81d1e9ee6038d24e32bd98d32a9dbd08f4af46e7cb9e99a5e59d9f58e25e7aaff9567671a1ecc7fb0095e7c6c55f46498053fccce7ed5d4e1e917dae6348e50207591684bfddc02e253e2a31858ffd059d9c7affa3fd5e8986d1603b279a732c006d91e8fd0f58770aae8c3de6f1d3ecd74871a6d4fda56b7e713bb916043b8187683438984dde49bfabce50beef60758f46ec7359d05813827dfb18022df8fa4d0d41c4f7f838750467dc7ef189ce4d70af120fe4a7bbcb1341152dc5a5d0eab14d2d5050942ea837a58aa86b96ce8968b6f8203deced4c18eff07020ff65d8b64cf0e099016956eecce87ff5a9e286f352dbdf1c0fa402f5f8e0a77dfca3f5c7c2e1de2c04c712668dc0677c528dff8d94f61cd68ffb5db8373ae85a7313a35ea38c614638fb2917173b015252aefe1e93a4cbda2b65c12a6493ca0a546e5a41db5350116aaed4f1c624c5ec222a82939dfe6639e1d0cbcbc94a3db4126d3d15c3ddbdf061f32412e5879ddf73c057f505850ab4f3b3a7c66381598e4e1cb49884ef69ec1227b85e787171ec37f4e556f1dba2cfe06becc68ff9e87e779306df4b914fe8150b9fd17cbfd055e30a9de45b7534230ac7d9c30de212529ac3bc10878509a6a61d10ace607844c73d2f2e55a5ad4d3d15f7b95cc019fc34531105ea1df1305334c665c3cfe24a76b319cedcb9405d7d80c33130b40560500f0b30d154e336e2de5b3e6b318af0fbe0a67eb21ea2cc2577235be615c900d316c49bbf2989eec1da2a09f7a354c0c1b862b9549c5d5c08127eefc7787c93cefef0d5b8a5076ab53a6c570961546553f668bc171b62e03a6e34a1bdb64d36451876c941c85da7ad12eafe2b9a32508672e37132121340ab993b931a532a101b8d774b765d5789bf4dcd5e2c2c272e547cfbbc3c30cfbb8c1e6079b65d20e5466cf60724b7fc021cba710189c56c3328895e73aa5b83d5c21e24767023ee2b5796f347ef1348b803fdeb348a4f2750c94b127c66a83b9befee000668803acdb760e31bc206fbeb24bf48476227215ca208a32ceb7b43aa5984e8334f70932dadeddf28f47680836e2f9fb1af3e22c543c2ff46793e7084ef06c3eb05883b60fc40c9922b7d7b994320a47ce47fbe04b1429cbdc5b20a7e3ac67250a052f8d0a8580893111fbd765cb1dc3ca39f36939f97c61d7f680f4253f3f98833222f85c0726e0696c7099762b468e7a7a3b531489256e224a677b2f36a73eabbcdf62475a0370a22785931a67bfa5ed19dd16929cbc2355e25beacc4f186c02cd0ec92aab8712c782d49cf661be95fecaa69ccc55a6f343ebc4e42dd5bc7852425f57762fa24f6b346a4e7480ff4ec4f954ac69fc606b0a4bcb3a0c045e71bb889103cce5a3aa1cf3eee5f9edcbadf78b07fe171bf233627bdaaa9c075d16bdb43411a5a9449aa0ce6738e4c21ca02e4c794d3d91fea0bb5821b8629a5e8098c359eeb6794bac46c5aaf85bf6261cf8059cd0718f3ec22c9392f3f20361cf886b4964b4878638827c63f9225dcfe5ca33dbefc4bdc88c40f7e8340b99ff156285e3cad94f7f0968e0df1729a5c8c4bbade7fed6f9a806e56d53ce25d17588f275ee26ad1cdcf9de606aae45f7f8ab25368d6c1fa4dada1e4ef62315468cddf6a273edba47d1b79bb46900241ac98bfac3894e98e92ba803cd4d908b32774b6adf94cbc2ae31cee306debcbd046b083cf93e7d117f7be2e6746591e1766c1e45f8368a49e87736774495d126f5e6b93a327661a88db25aff11581eaaef85304cd529ddb88b7cbe8bcf68465ee7d876e0b5ccd4eaaa955b3b05b6d90712f82dc9aa84e0c93e6c31617bb9923790e723c8b2711dd57d57ed217edaf63f69fc2d023ea330c33bccad2423d669d5ca6a56cb79cc412e4277e1a3453412b589c85ed92c274a68038d796dca82ed3cfb7192a7ca9bf8f4121980bd92d21168ee42594c8b24812c207fb729b5217b4b0ee7b5547bf6fa3c171d3664cd9d60dfdc6ac3903e4d1bb555872b0f388e97c88984c80d09d21ba4e47cefd4b1de032d56cc38d6e74ac18b87861b2b1b493b209979e6baeace9a814a04a0a45353be964cb0a6f07ce72306e943dc7bdbf30fede74ecbe49ead3866b4b92e1b8e18b8ec21e9f88d4bf382ffaefca7ac3a25ebdcfac5d3a6ab0b65283994883ad9369a6ac8dd29e1434e9b3f73c71586cc4736f731619d96d3221446239b7719f00b75d8705ee96a67e2a48d377859ae1d3157e18215e816cc2d3ae428802e77116771919c1b58730131a0e01c66e6c3c68fe393e9531ff8c1a72aa06af7a45652b6c229fc24aa4ccab5407c85ef6c9d3354e7dcafe485fef60068b05b2672b1dae4ad20e33d1fe2fca39d64c080f1bf87a31f198d5966284a6b782d0abe2a7513707d6e537d9b1350aac50b9472398f8c77c6061e2b4d076a45cd68a555a97aa60c1a99394805fa397869b6a9dbeb06a7b120278e2ee5e7fac39c53b101f2803d45d4f344603d1f0abd17d5a828fa2d5236adf7aa17bd9b7b2288fc12bfef121985f9af9a4eab7f6b5a5d62916c163190e08dee90e84f1183a29d4163eba584da0469de3ade4b0eb8fea702fc480dd7a72cf66f28a1424943aefb6ed9ad2e75e81bca48ce9fbd9c794669733507ce363b74f3a2ddd563da4758f52236b91b7e04ac92dc1e714e3c65b28b80aa8396db41f14f256f4d0b73ad99d5efa84d206db9cf4e57784a2f5caf5f083c1bb867afa75b336a643ce13c589a4fa18a9abf0c88bb9b461ffdc795648bcc68bd02ba8a131471a2489cfcbfde22d275aaca642627d65d8edd8e6046a231eb3a3852121e3432520e4067df314afc8d6987563342e5b1fe1ea886681b04efddf90d26e35c9b7b13949118bf385e656f52cba9f87ac17f5cbe984be42bc1e2b380e3255384a4b761fe2ad91f8ac6959df3456683ce4dbf949206ad973152f1885c98069117a48adba3b208b903fb7c93d7767098568d96debb6732f16c8708e66e2b4fc3546b7ddc2aa8dcd6a4e4698d8f777f085028d0d97324c2d2f951976e112bb38eebf720c2278ffbab29b3fd3dce8259d3063fe4a9804a0eb664639551defc8b665ab03a2060dd340a502365ecfca7a120de84dc36f872a0f30dfb08f8993376f448839293ce58fe7f58d89622a7c845495d68f0e6d900a58d931730a668ec5d4a466f9b4a8533d7c648aefd900cbbe72a2cedaac7de3bbd6177122f76548c8cad15010da3312bbaa95eb8ba43e558c8b512840fb85026de1596099a4be73a9cdb051193531fdfd27d90eb6716b8acace7c21bb42f2ba8da01138e38a02c142df2d28d681935ee3bdece3d396e5e9af65f8abb33ab9327128eef935a92b0838785bebf321738149eefdb6d6598e8a5670a9fd2e4ce80dcaeb4f8261e9352f9ad3f302bfbcae6f28ab894e78ffcc2ff2df05bd27fc69778a26eacb2df98beb94f1c04da9aad6524e27aec7f8f60c5b072e16f9563b654bcef01a562bd2ede97c0857600ae0712dfc0e5849585797297c3a0f84fbb2ac9c9e1913a1c6f8ae3bea0712ca0246cdbb5535fa83c61bd231b9997f72a9086702f2dc8d52c82ba74c59522467e79a8a98fc69717dc2829beb1cca398564c340ab9360da43d6662b7a0dccb8dbc7a9747cbffc99c2a1c3021c7ae3aa7a9b2b2cfd0ea7346ed234f28c427b4fbaba332be62bdd8749cfa3149a0eb2b039e2ba2f0eb9d9e3c11cf0a812586358ae95e76577860a068ecef9783b3ba1a5ddd2e082160961127e526b20a4deb34790a93ad4b7869e2b1b54a482efc1986685759c703e153ee62e691f055df3ada8751210d253ff2d8628c6de83df0955a378bce692f1d96a8316fb21de513664370294752d32a7adeb36299bc20bb6113d569203b8c8bdfcd7b9841fbb09b041b4e923da1c492547b10278871820dc67b3f27e0fca68ab1fd227fef0e4a619e6dfc28d733ea91ff19e27210e922f959d3f20f20781e3d7c5ab52fd9d431e9d97aed9bf046bf91e40cbb3fa57b8a0730e6978becc7590dca0b4849418d6cbaadf5171d25b5af9d005579706d211c4ae706b830ee371ce6217717378dee62eb290a3ec5f27004f242c838dbeb56f5b9ee8fa1df431f8f052f2d15a248e5a4fa828333d99df53ea3c4035fc39dd5196d780081adc1a2ccd1ec53ed7fbc8abdb3af2de3ea5ddfd79f16e2a2e5c770b1afba39fd4c1a461260124cc90b45e588d4f71ab05eda2d271d2078e1dabe0413f8c4c8238550bdd9c72a48fd6d42975a7c2d184fecf00a999a75690cd2d023de5250c76e48c5d26d65b7817a19b1fa917325e0ded1e6ba5aa23c6cb8d9f8ae4a15a7afdb696a0168cc77f6a6ce1350cf13a954639b0eb8ebaac24dc686e29d0e63938224e5f1566cf052c512c02d6760b0209045650970d005fdce7d20f7f94bea15c20bf0a273f85b4716227a4c0d048b700b4d0f46857fd4b82e5ede569769361d46e76021a8e6275bdae190efed93dc01c8f091404c6dbcf55f204ca84a5e535ad0fee456e7879300db99166feb507498a78238812fd65884cfff299f26b45b9705f9a9bd00e841b30bb471f95c82237470bbeb333bba9b6c8b29cfce5e9cdd1ce6bb4d5302ea20d80501627154b5bfc5a6807361e2b7d98e70b3a857559d6f096ab95f793f8cdf138ffc0e918266ef2815976f9efea29a23941939712c6078da7731a82e2247c683f5f2b80fa76bb172212cfb0f12091ea22826557802586c8b41752ab7b6f3537de8ee820819fb209e9bb96def39e86dc1cbb52194f44a31eb7211cd32eb587a3dfd1ab0821c7e9e25a3c694d612757731ccefd8ebb248c17f854938639e3ca78750a1e94158d643ada472e3c754a6a4a342e8764c488c663a93900b638580b545e8526944e1a223fb5d93f82036cb6b41559f7cd0ce2c08297c8636e1c0248fd3e5631c44a1bae2f285431304e3786cecdc5581020826a995c9e9bca1cf994f24f84544c185e052680ab4cbc5cb79c06dd0c0f0ca968f212f6594fc7172fc455da808e5878c3562ea2b488cedb2440c1fd2a6ff3f699f277af7e889c804f887f6defaffbc8a7ce452608422332a4cc957c39055a3335cf1e8fedeedd17bab7945f5de27cc842e5e9d9d473a0d079d249a93a5c56c74e40ef657e88b2eaeafd99ad7bfeb9c8d5a50c76884a0551dcf81d3782ba2b143d11be3deaa77a6d29c15e512fc31c5c51264666d3f6468887666f338bfb83ee4be738ec5979fa7668e60c521662b9bf540d10c2e44cf308845dc3d6d269dfebf326fbd40c9f56136f3ccc90156b9ee59590dbf9eb8bf3fde9bee99dfcc4ce9ef4345daa98189e8f47ffea32092ec99de49551d50b4678499f62b2d53291ad27dde6c0da44eba6bbb92f477a3807b740c7a8882fd85c6cbfae8e32d77229320dc2869a798223737550021d3e6cac981cc788710970a777f00f2d5179a15af7f7d867c748f1d090a2f78e28d36674559edaabc7bd9a313bd636c87d070d413eff79c7c3dbd2c3a35418ea5222b8c2710f7d9c9072f79cd0dd3f84f8ad77b02b23f34ae352184650d64872a733ec0e675c1422201c73c07dddbc51c6807339ebdaf449c2c8f6ae191bbcbb49da16ff8b0e6b2fab377a34f5e62bb4abd1f78a469f8dd58ef605342dad5ffa87584fbf654639f6d0e960a9692438c70b583b603ebd6825765dd5d60b7d2f53a6900bf5be65bfbfb3d0dcfc67205d20d1e6af7e8992cb609e40cd5e6481657091a015a0cc0ea51bb67776bcbb2fc1eca1b00a65456380e235476300322b515d0367b3337f2d6cadf48a62c8e67a3ab523d5378e696ca33969bd87876021fed9b51fdb93af9b5ce57d08bfded9377d28779eb59b4673e7250361a9ecc9907126cbe33f11080fdde61a8e75578dc7c62c40641ca57190feb81fd50ea66fd0875725f1404493f0371bc512b7771988414a5ddf7ffcb5d4339c9d0b0d563b1ce7453c53a16696103af147a827182365708fb779198de2db5af3a3e824fd9ab15c170ab182efe10690d161af4ed63c26016158978ecf955124211f81b1d5b54dbcd134bd9a06909feea208f22b52b4c2649905b5e053a33c2269724df1aa9c27018f2ff7b31b5b08b07c9628098adc4751e63b232a068a3f60bee3e877cf81c3448aa4cd64c8f87aa9279cc9ee4e2c38d28b1a12d37fe1a975bf3578e5523b892a1ad7ec1f8d13d6db99797a4cd4f86e69d188f8e7d52c1a19664730e0639c5099dc7858e304313ab795a9e67735c6805cacde9471310b8f7d57288b670ce26690c88b6da1bd4e94c685afa401bc40931ef325edceee9625f43ccb3ab13dee322b3e2ef2fb73551e86ac5c286dfb15f3ecd7a398f9c6faf1c395098a2a730f5fad2930b2329418262dd692f4cc68935dfc86b82a5ba76c17d49f28a9888da628fdc21c8ff93eccf9967d62f0897f391e08ea252eaf2abf18e79b69541876bb990a8a1eec6337a73ce1b2029e2d8f5f597c1ef053123aa780858d9b0fcdbc262118f0c886c300012e348ae541003f4e08f31afe87d73556ebbdad3049a74bfdd2762f61c76c91e94b6a5e4af56cfa678dfbb48bd0bea28d8e05124b0557ed289c24f4e6cdd6dd3518a7e09cdf24b28d7fba4c47e26236e3af689c58e80b3e9ce674a6ce43b87f0e4ca423079e061a55a6c7d71aa899b56b4fe1f348ab8e7e63f204c4c9f0b582b0ab3a23aeab06da94fa6bf693828fd288b198715feee2788cf3a938ed94dfa59aacef5f01f0a81a3a5b3e805613e4424245d75d0441c9ba23ed93ec23ecc2c35907c28456b9b91f1f4db640227e25fa2bafec23bdb7df99a6c42ec2b3d0819cabecc5e44ce6bd583b6eab4d0bf315ef9464e4e2583ea23f2da455d3e1922ecd3a029a17c331a7cbe72ff81c5249a5a7bb20414c1bb008db377e524bcb1ab59e435e881cb47321c7f837769999b8fa470eda890113cd7697dcf13fac48828759a377c43f7016a5ed94a78da0d4f4e96fc07ccb05ad8d94fdf3816c0232295b87e8952c431d401181957a78ef4f62cfd6d62bf67823d34cc2d31d2759e0e462dce04ded949f5d01434ee49e472f92747069996127188d4e49f2482b36252c276128beb377990731ef646de242768a0a0d11d85bac2b84403461f18a19896fb2757cfd3c52a8e6f886e72bd5fb64a8d6f7919f300de5b6d7d4e94ec9dfc291b1084dbd7efa356b5991b9d0bdb68b1f6e4d5b1d3712b5d85cf07720a7482b034c092143ad67149e0c2d52e3c802c89d927e9e8f250f169f6a375f5f53a2cc117c5d28cf772af4c3efcb99275ea7ab98333596c07c879a4aac8e4202454b9acaedc06c12e5730fef7fe02be9b9d82215ab1be2870c95d4b7286ce3b9194b2ece76856ef687361d8a74f301bf5b56bb93bb286d98534f5e070623f6a65af81ecf6ad9d015a3a6a1919ad8b2997f5de19341dc145e42645084634c1ed487fcb020bfded2aa65911533aafec95b20fd09d47c14625536dd02a9fcefbc3c7117c40b48a7ff75d45bee794b551eb1b1db36895f94add3f9a887149008b21767358b4ce194d3e58da89374956f205371a1595df389151151e32dcce83e9da9852d0be084acdacf76142c5cb18791e92586c1ba42027424919bf69507480327ab1aecd8b6806163e3e0d7e91bdd1a5beef1ae9442310539055db434974da088c21948cd96d483fc43118a079c07f69f21ce881e6385c65f12af2de2459c709be58922226510d1346fc7f5f0d72b0565a3e53fbab95e477eaa721eddea77fc2cfe09f3e435c2b5b0e9d66cdde23753149bd36ab96553869430d491efa40d5a5c7575b74447f1b9abaa8b93dd955581fc061ad3cf26d2e7e0c6a0f288f49fd75a6134288360949a1cbd7a73b1ac5bd2c709fff6c5f857b653b6e84a3133c0cf05e6ef3354ed8bda569668a640e26b543b46990f79ee1b2f9221bd487f13379a5e9f28aeb5ec1d66890e5b40ad8ead9d60c9064d769d20ccd47434d673342e5f0372bf740617b2ec62e0f63511a968ad10c10571087b9300079855cb1de5f8147e97a7b90535f2dc8510690f3ed5c781525c3b7c5b22c9e852cd4105960e4fa03b47d98a9adf2b59b91f82fe90458b94ecce7eb5f1c548d32afd15f604a0356463cb887f5ed2050ae3cbf290045c2e387c1906ce4f880b27c14804795ab36e2e6b2d047ee1d18a69f2f1235f77dc043899452acb0dde3a1cde756fe2354ed87687b5c0580d30341b2ce1c99a293d265acd9dfdfb5382d33b740fa0c6ce47db2b412bed16bec86e100dfbeebe9f1760b51a41611b9760c72419ebd11aca9d9852d04f778221e42a8cbab3ececc1db5a8f2704db7f48a0e2d2284354a50332bc3b9bb6e2bbb445cd183fa44cb27aaa0b0b09cb73149e2abd67eebd683ab5fd5bcfb77c4b8381cdab09f50650354cdce7aa3a89fad1e716c76aa9db8073bb32ee2d8bd740fb778ab08afbaa3e5e207014b9081ada88823462d01d723acd6eb25ce30678a671eb4059631870eda8341328c7617cfa8c8837cb8ce351fca30b54890f5284ea248e9a220735b2448a0d3f918dbc588d5c58cf26d3a100d1a348137287024628e097e901a0cf582ae921d20898a64d9d8681a2273923cd691a4538d57c9f23c874afb11fad3316483ecaefd772ed4c8ccc2b60e252d563bde90ca445f7cd6c2740ba382e74a2bab18b9430a2bc531eb95bc9758552611df7c6ffd04b7d12a295d4559623d948cece3cb11d17ed5fec95b4829d5622791151fa8aaec8b313e9fd3c4b50331708c44b67aebd482bf7e3c2505b6a20df91c31dc58fffcb283c184ed596f0f9e0dc9318d55dbed190d91e2f527495c8c4c12d132da256bfa02e06e7b5a3eecd085ba1f8d7875482de8e117019da6d02bbd04a943780c0611366c11fd8ea052767b04723c08672143ce4e7fa0128c476eb93194f1cbc08fafac1247ea9e50d14f1349b66b1a61cc781404cf5db6fa9e0eeb65be8db75e289ac93f7a370f91cb440bd9706a461bfb1f1038ac9e68379071dbc6aa609039ea7811b28b8c646360fece85b0e0db04a0144af39ec854e06103c425eb5368f8cdb7d97bcf38c5d3bf5bca5dd1138c41485cd14b9ad7ec4ae5c10cd131d592f73e9ae0720cb1af75dd3e5e6a824442db61d97f64758d0c86f24dbb58b129a219a7f0ae57a8cf7bcf9be0d5148e26add50a589a271d0a01ea4d3ef9c35db38039f872b38fef9ce3f34031e50ad271357833c4d48bfdfbc2d64065d7fd99e13ea96c65ef70602f2aede2d22ee3159611dffc385abf51b971bc3b23e950d6d89d3a5b40e76a192d45660b99f0c493691c15f2874e0856c0c0d7d3619ea54d4e12341701ce9178a2dd90f9ac2277802ac18a4b354183d5a31d9395442b7c4b55cc3576060ba465ff496046a9e97a7990e2b9a9d23a9660f7955bc13339b945c07923429c7bd47641a38f21a000d19ded411e38fea7a26fba25736cd20d96346eb2da5e6b76922dab708ad0100c86877186d3bef240965d346de7a4ec6d44157e3afff5b6286fd483b1ec78073eda89c3d65cc0ab721c0cceae3caa84b5fd9b36be31ffd82c2da6885af322c920122f6a5ea8ca098319c2a740474dcb05732412001501ee9b4fe1d17807c6e894f450498682346d3bea62ca2406d3bc154f90a300dbe7987e380125a4f94394dd7daa4802640f671eba0e8293e5fb38557e1775e0a8ac99dec86965786098410ce3284174cfb313a866513d501ac8ea253392831f3162aa50d1f999821b4ea56d549c3edb0597bec77c43e83ea112781c81b8204e187c2e1337e58a98d8c94bd21821a5963c0b0f0e1f259edbcab5fe5eda0242b5b46591aded32d105e4dc163c3fd8d0096f7a17b41436984f42f57f736a01cb93a3b071f1d819983a7176de3e426efa5b5f800d53668344dc7705430615e76f822bae383f3e95a681234a2a7b701e78bebe81a678834104af35dd2b0be0167f515ae2245470d09405a85cd6865bc316bb617789063083a6aabf709ea5cf02a5c1c0886df84889d0324464cb232b97eef20362485e6ead15457b68b92158720902d9d25708ab590a3698814d2ec4d9d6393601a090a60fc1d1f4891a02f8cceaa8fa84f7e65aa4daaa7d26e0ed2cbd587e819907be21472f0372704b4835233ac457437303518c32a81ca3ce56ab59992766ab6f408cfad2f7ab717e3eb8687b704150156b130a133b7e6aa95eb4610844a3434639f7661e6b79059745e154832c936646ab1dc50ce65c04f3737d2c0c4fc5718e78f6144a73b126fdd3dac6d45fcbdbcfa8b7199aeff1096c9f2889f8282ffdf469f316f25b84886fe4201cd54cf7e28923b7054883a722b7e539a30deb9a08b051226df4e7582110f8bde334147fd09bfbc54ab8d2ca6bb65a0a5b42e0eb61bdeb9f57ad920cf4299b709358a9160d4d5d676477c1923eec9ee703aa41f1fcab715201760b592e598897da20f416bbcf4b5a20a8034d0cc60df9143317bc5db8b6d38380787fcc54c11fdfdbc5feb866169f8abb575b495c030bd1c87e0581502cdb7afafe9094197826a02803be62dda9ec1646f325e83b05fedb9312274b8260ae5ac7f390297b252800f94b30c5d646520b555d25f3d991065fa462fb5a1dcfa6d6b55faaa12ffcc831eba2d03119e51c8d9b12c055c35305f9d4d900b8b564efc3421afcbe74ab380616351d3b0cac3921c27a245728acb148f5956d95ec34c6bb898a1787613e3b28e45324908bbdca2a6f3d087c06cf66a1477306ec8e1209ee05d3b6a6f01d2ac7adfdcf658c98cf958f85b6fe706ea625d707f66eec1faa11cbc1b8faf16480fb77c827d9d73e9c6b641ed3b2dc59a4bc6bfb063ff0b504b240e81a694c49fb7c54e1e9f53ec2259502da20784be92239319e5572c2ca10e4fef249a90a394c93c61f3a707741aa8ba37817dbfdc23c93530fd974e32a942b5aef860e88c84c979c6605c870afefc20d5e44b83820dac595303d0a66b27b75e18d939353cdddb2ff1ddbc1fc5886162b7c53ab2d5e217f2742a9b561ffec030351978ef7dfac5d98bc5e43a1fd864c5429b2e0e007b892eab5641d198b0a7f9d49f89d3b1715f5e03b490876e872d25575e50ae852e09022d9106247c962bed52cd3580b600b83fea1cadb00643a27ec276b66ae634da85f0de52d39e63b3bb2e8b82b680308cd0dd340f3f96f801db2fa7dc52c471e4461400d280ecadc912a642d5768840b6ad32870902c8eac88659fdc76de8dd70367c135c242ca525ab38b0d60e5e6004b30d0d6359d004d0530183b38539f39e0b4ad577dd8315424f54422c51b1f6c932c83b65b3864b17352a348f2a12978ad2e376d7d3d6da1b7d939d9ebe0ffd9c5add6c9d6a5b6bf6ab52dbada3a3e8e5cccb686a8cf6373450943871c92cfc986de7b5c66a597581fdc3f3a02bea08ad0093a2081a54f78b2e06959acc55a5536403b54f2b299dbd4b6aeb34e042c09f2075b1d5118ec2b6afb1debb39e7232adf8a7b07aa5ea291175992cf97a4279856d63ce1e471f07698389b02c8d025c84ea806469b2e35659c7c2deedc60d6434a41d2315bbac9aca21c6d6b3a6121686b7dec91dbc759c26e2f15a3b3ea43591db7c8fdff3c13e868b8dc2a38fa8a715a9a649f116be42c4ffc7d3b6d472d43940640a475f5aa09d71742a1460791266388d3a11f83b26a38af57bf2b72c5bfbba62eef056b391c9a1a6151815e4f26468c20a485f88b45e471d6662dad4b750373f3df7cfb1b5bb7b8881cd95c0437d76f055e39e9843ac5487dfdf6edbf85da3168f4241cbddf9dcfb857766e5233214fb4f3f65398fdc70a55e3c217b71fa51b10cd207124dfb54c25344a969b8e25fb90b992a59bcd0e2a68a36ea8883a4fed59fd72c433e5ed347161f1a11949b54fd6cfccf1ccc7414f352ce73f30ac75260f9a7325c821a6e11c2066695e0d827ce9cbe2be6b130036c7c3cc847b60e15be2ec103aeaabc7f3dd61a4854897741cff45e3ea630a44c6ade97f213df90d5cc955ff6a85109c77632ac4245d103cf303389c92f28e21d1d9674874cb67a512533eeb3852608a0adeb240eb46f52ebe6ea407158b7ff93f73a8be5b0116526ebc185196f00e975df8364d749e744eb765eea6dc18498335b1902b06ffd2b660d2b00d1dd9399b61bea98fd415e0e06203a23d3ad949ee7a4f3b5fd4362d24511fc74640a25b61c2191205eff0102b4cc3ae601a93827fe561ee68a6cf785d992746ad8c4139395bbd5ac8c5e9aa8872c5de2d64d3dd20eb76abef82b3fe30411445b4dfbfc1ec67c9fcb302229b7164e8685daa2206f7876748da893f64ad7b4d7920bc81ed5867a921e21514f0aa10b4a068c2d1bbb8f87452799bd3277a5725fe14083886c2702984dee05b412d529a6301e22c7f66a895189dcb98e82c12db1a01293324eded79e9798cfb04c9e4aa575fdb501cdbcb0644cb7844ab4e7aa433b2193db775eeddf7083afb02ebee5127d087568294c6e856b3fc34487fdb63ccf982b85acf52e166ad415639f6529258643000601208c4d7cc4f4d84e454e70bf3ad71a5572d471eea72f0cde5631b642261e6d14edba24874c9a894836d0b83b6043ef0bcb3912d3b7f23f72c1a0915bbda65af25f624367fa8c6fc8a53413c65c734f5ebcbfefeb3b30c81d63e43eeb0a140002327cc65708a6618415e883613f06685316a35bdfbe39d2629a67442c6e4a857425dabb06abdbef83bfa11498ff78133deb72ff8077a709112b458ecc8bd1e615712b405038741c4b097f00678129ae88fa4b70225402424bef7307116673b5e245fa52490c313bd2d284cd34514b8438a75c1fc881d925ea521ea4c233714244f1c35048fda9c3419d3e8d7b1a1a7c0413dfbecca2ec47309274ddd67750735297f4bb28674be7714a786ee6113b6f7add04e93e29aa0a30572cffdd4f6ef6297098feb6925168ea74875ceb93c7a9f3efb6ab0d6952985cfda823860c5040356d282dfd93607f782ab8d2ae443692f4c7554d2d578efe3c837c8c7d7843b00b0257e5ddd0f06b85e1ffa82a83adf0aac5688d15db641a77bfc3ac5743d1693cf305aa3ffc7c51fc6bbe4d35246bb7d11696f4485daeaba4919faf69887a04a2cd3916b6a4dcbbd890c8cd2b57442a6e9de667ffe7f2dde75b179fa5c7cc055f16c288c84eaec534dcec5ce3252ee56dae3ca63a6b5e55c91ade7064690f1a5a996206fdca7179b30d19bd19c7198624278b7d9b4dd622916878da1f7c464dbb674c71093825315f5398638d81e39ce20bb8726eb0558e5579ba6e0a2ca6cae912f081cf85d4b5bd04b45d8e802587acc5722297773c77081c301043c04c24f3d6224f167a163c18dc97166eabce83b61e97e716eadfcece141262d3961c6496c1365bd5da619c08dfa5eb2f503df53d3517bbcdc146d39937174e17db168c3e028f50c0f0b0c4bd0ba4c0df6b58b809fee5cd9ed5f0cd32fa3189d6e21127e33cb47450a27b31e2060e6f681bfc00110cb192c6a327f434ed7fab42bb5563bfe330bf1265b0bbaf6236b64f6a71a51d974f63ef843ab2f9dc84c9e515bbc86f48849eac692c19d671ae457e6619f5406b6d71f85af9e680a465e42a236e76d5fbe82a466115bfecea9fd830c6cc95bc50aa4cea600ef88891f5db989cc5851a3f6e7a88f5dadd8ad33fb0fd0029f17450c53406b91e2ae596be9e02369cfa62da8d1b9c82ac53936afc9ad07f1728c03f656d4315bd8d937d975b3d284299262f5a9e85eafb94dc607b9bf6b0bd986a3237b9b4af378eb214be888b8c8cf0677c30546e0e534f246821d7aa17bca59c78a17e993c4eb799179ac6ac6675398eb152e6e420aaf83107f845b7ffdf3615c244a8fa5142f09b6ba9d8311f69bb21896db49ab763be40679d70377aacab8ccf0d59c96105b7c41d3a0382e256d02ef4ec263ed68ab90279707127fdba9661cee7e7debdfcef8e46d74a71c9dbda850b77ebe8c92826877edf34e4bfaa1be4857bc796aeda71b59421a5819d75ea7bd5f89025b892a20ef454e38dcd07668087d7a5353966b3bbfe87720dd2cbeacbf08217ea6f5443036ba5810419ff3d0a4765256bd1b7f846b891c02af5745afe669a0afb77e6bb734f4785630c83046d3ef6cc3a69d575e8f5fd7589114156c6c17ec76508f99039c13a6667a05c78e418fe8228d52ca7f28411290d0a5c1a6ad6df9f620a021c269ec970a625548ab74155782e7ba1b9e0c6258f47593366142d0d37c7d8d518ce6f7671e0cce44255084eac8c23d56659567a85146c21f295b161883faf3b81386db45d5d20904cf6e8465254e6fa58d45da26dee7ef720ceab869e34f30a13a42493c019773f9cfbdc0788e8c2be3838fe82e0ce0b71a9d96c0869d162d4c88c3821909b73cd046ddb6c3062fc0d1c6fbc7d1e17ec090d8ded22b564b5110e46589563bbb53605d4e05c1b5f70c88bb97cac64a4c818baee3aef8e5c9b7427fa869271d2d23c3b867863245d4fc4af9507b6677fffa6c99157e6ce64486220956fb1fd689ec882971144a2d4f83b3d43a784274ce7a7088d0f045da698336514b413ddf7660bf1f78c5c719dc9ca268daef8efd9c2f60a771b1f7e98349d7f4487611639e6041aa217bbfe35691aa869ccd81c9f2908c85a24feea8c2dd0452d7b6d800e2790d97390ebaf4905127b40d0f94b38ec7763c86af49c4003a68c52f381a4103903214bfcd80ce333fec1a66dea4b8d5dad77371882b43e3438200979bd3e6eb2eeaa71c8a2e4da388fb6</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="C++" scheme="https://www.benboby.top/categories/C/"/>
    
    
    <category term="C++基础" scheme="https://www.benboby.top/tags/C-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：最小体力消耗路径</title>
    <link href="https://www.benboby.top/2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.html"/>
    <id>https://www.benboby.top/2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.html</id>
    <published>2021-01-29T01:02:03.000Z</published>
    <updated>2021-01-29T01:47:37.414Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个 $nm$ 的权值矩阵，求从左上角走到右下角。$(n, m \in [1, 100], w \in [1, 1e6])$</p><p>一条路径耗费的体力值是路径上相邻格子之间 <strong>高度差绝对值的最大值</strong> 决定的。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ol><li>二分答案：由于答案具有单调性，所以可以二分答案，然后通过 $bfs$ 进行验证。</li><li>并查集：类似于最小生成树，将所有的边都建出来，然后贪心的将当前权值最小的边加入集合，判断起点和终点是否联通即可。</li><li>最短路：将所有的边建出来，做一次起点到终点的最短路径即可。</li></ol><a id="more"></a><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仅给出第二种做法的代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 并查集模板</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; size;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="comment">// 当前连通分量数目</span></span><br><span class="line">        <span class="keyword">int</span> setCount;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        UnionFind(<span class="keyword">int</span> _n): n(_n), setCount(_n), parent(_n), size(_n, <span class="number">1</span>) &#123;</span><br><span class="line">            iota(parent.begin(), parent.end(), <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">findset</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> parent[x] == x ? x : parent[x] = findset(parent[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            x = findset(x);</span><br><span class="line">            y = findset(y);</span><br><span class="line">            <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (size[x] &lt; size[y]) &#123;</span><br><span class="line">                swap(x, y);</span><br><span class="line">            &#125;</span><br><span class="line">            parent[y] = x;</span><br><span class="line">            size[x] += size[y];</span><br><span class="line">            --setCount;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            x = findset(x);</span><br><span class="line">            y = findset(y);</span><br><span class="line">            <span class="keyword">return</span> x == y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> x, y, w;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumEffortPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = h.size(), m = h[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;Node&gt; g;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>) g.push_back(Node&#123;i * m + j, i * m + j - m, <span class="built_in">abs</span>(h[i][j] - h[i - <span class="number">1</span>][j])&#125;);</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) g.push_back(Node&#123;i * m + j, i * m + j - <span class="number">1</span>, <span class="built_in">abs</span>(h[i][j] - h[i][j - <span class="number">1</span>])&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(g.begin(), g.end(), [](Node&amp; a, Node&amp; b) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="function">UnionFind <span class="title">uf</span><span class="params">(n * m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : g) &#123;</span><br><span class="line">            uf.unite(p.x, p.y);</span><br><span class="line">            <span class="keyword">if</span> (uf.connected(<span class="number">0</span>, n * m - <span class="number">1</span>)) <span class="keyword">return</span> p.w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给定一个 $nm$ 的权值矩阵，求从左上角走到右下角。$(n, m \in [1, 100], w \in [1, 1e6])$&lt;/p&gt;
&lt;p&gt;一条路径耗费的体力值是路径上相邻格子之间 &lt;strong&gt;高度差绝对值的最大值&lt;/strong&gt; 决定的。&lt;/p&gt;
&lt;h2 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;二分答案：由于答案具有单调性，所以可以二分答案，然后通过 $bfs$ 进行验证。&lt;/li&gt;
&lt;li&gt;并查集：类似于最小生成树，将所有的边都建出来，然后贪心的将当前权值最小的边加入集合，判断起点和终点是否联通即可。&lt;/li&gt;
&lt;li&gt;最短路：将所有的边建出来，做一次起点到终点的最短路径即可。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="并查集" scheme="https://www.benboby.top/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="图论" scheme="https://www.benboby.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：解码异或后的排列</title>
    <link href="https://www.benboby.top/2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%A7%A3%E7%A0%81%E5%BC%82%E6%88%96%E5%90%8E%E7%9A%84%E6%8E%92%E5%88%97.html"/>
    <id>https://www.benboby.top/2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%A7%A3%E7%A0%81%E5%BC%82%E6%88%96%E5%90%8E%E7%9A%84%E6%8E%92%E5%88%97.html</id>
    <published>2021-01-24T01:10:06.000Z</published>
    <updated>2021-01-28T06:02:23.360Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你一个整数数组 $g$，它是前 $n$ 个正整数的排列，且 $n$ 是个 <strong>奇数</strong> 。</p><p>它被加密成另一个长度为 $n - 1$ 的整数数组 $a$ ，满足 $a[i] = g[i]$ ^ $g[i + 1]$。比方说，如果 $g = [1,3,2]$，那么 $a = [2,1]$。</p><p>给你 $a$ 数组，请你返回原始数组 $g$。题目保证答案存在且唯一。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><a id="more"></a><p>可以发现如果对 $a$ 数组做前缀异或和得到 $sum$ 数组，那么 $sum[i]$ 就表示 $g[0]$ ^ $g[i + 1]$ 的值。$n$ 恰好为奇数，因此如果将数组 $sum$ 全部异或起来，$g[0]$ 刚好为被异或偶数次而抵消，得到的结果为 $g[1]$ ^ $g[2]$ ^ … ^ $g[n]$，恰好只有 $g[0]$ 没有出现。然后将这个结果与 $1-n$ 的所有数异或，得到的就是 $g[0]$ 的值，然后递推即可。时间复杂度 $O(n)$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">decode</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.size(), sum = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">g</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) g[<span class="number">0</span>] ^= (sum ^= a[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++) g[<span class="number">0</span>] ^= i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) g[i + <span class="number">1</span>] = g[i] ^ a[i];</span><br><span class="line">        <span class="keyword">return</span> g;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给你一个整数数组 $g$，它是前 $n$ 个正整数的排列，且 $n$ 是个 &lt;strong&gt;奇数&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;它被加密成另一个长度为 $n - 1$ 的整数数组 $a$ ，满足 $a[i] = g[i]$ ^ $g[i + 1]$。比方说，如果 $g = [1,3,2]$，那么 $a = [2,1]$。&lt;/p&gt;
&lt;p&gt;给你 $a$ 数组，请你返回原始数组 $g$。题目保证答案存在且唯一。&lt;/p&gt;
&lt;h2 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h2&gt;</summary>
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="思维" scheme="https://www.benboby.top/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：最小高度树</title>
    <link href="https://www.benboby.top/2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91.html"/>
    <id>https://www.benboby.top/2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91.html</id>
    <published>2021-01-14T10:32:21.000Z</published>
    <updated>2021-01-28T06:02:23.354Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一颗树，求当树的高度最小时根的编号为多少。$(n \in [1, 2e4])$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给定一颗树，求当树的高度最小时根的编号为多少。$(n \in [1, 2e4])$&lt;/p&gt;
&lt;h2 id=&quot;Solution&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="树" scheme="https://www.benboby.top/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：交换字符串中的元素</title>
    <link href="https://www.benboby.top/2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E4%BA%A4%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0.html"/>
    <id>https://www.benboby.top/2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E4%BA%A4%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0.html</id>
    <published>2021-01-12T10:06:55.000Z</published>
    <updated>2021-01-28T06:02:23.361Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你一个字符串 $s$，以及该字符串中的一些「索引对」数组 $pairs$，其中 $pairs[i] = [a, b]$ 表示字符串中的两个索引（编号从 $0$ 开始）。</p><p>你可以 任意多次交换 在 $pairs$ 中任意一对索引处的字符。</p><p>返回在经过若干次交换后，$s$ 可以变成的按字典序最小的字符串。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><a id="more"></a><p>假设 $i$ 可以和 $j$ 交换，$j$ 可以和 $k$ 交换，那么 $i$ 就可以和 $k$ 交换，因此是具有传递关系的。因此将互相具有传递关系的索引看作一个集合，用并查集维护。然后对于每个集合，将字母从小到大排序放置即可。时间复杂度 $O(nlog(n))$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> fa[<span class="number">100005</span>], v[<span class="number">100005</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fa[x] == x ? x : fa[x] = find(fa[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">smallestStringWithSwaps</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) fa[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : pairs) &#123;</span><br><span class="line">            <span class="keyword">int</span> fx = find(p[<span class="number">0</span>]), fy = find(p[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (fx != fy) fa[fx] = fy;</span><br><span class="line">            v[p[<span class="number">0</span>]] = v[p[<span class="number">1</span>]] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; id[<span class="number">100005</span>];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; ch[<span class="number">100005</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!v[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> fx = find(i);</span><br><span class="line">            <span class="keyword">if</span> (!mp[fx]) mp[fx] = ++cnt;</span><br><span class="line">            id[mp[fx]].push_back(i);</span><br><span class="line">            ch[mp[fx]].push_back(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">            sort(ch[i].begin(), ch[i].end());</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ch[i].size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="keyword">int</span>)id[i].size(); j++) </span><br><span class="line">                s[id[i][j]] = ch[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给你一个字符串 $s$，以及该字符串中的一些「索引对」数组 $pairs$，其中 $pairs[i] = [a, b]$ 表示字符串中的两个索引（编号从 $0$ 开始）。&lt;/p&gt;
&lt;p&gt;你可以 任意多次交换 在 $pairs$ 中任意一对索引处的字符。&lt;/p&gt;
&lt;p&gt;返回在经过若干次交换后，$s$ 可以变成的按字典序最小的字符串。&lt;/p&gt;
&lt;h2 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h2&gt;</summary>
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="并查集" scheme="https://www.benboby.top/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP学习笔记</title>
    <link href="https://www.benboby.top/2021/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9.html"/>
    <id>https://www.benboby.top/2021/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9.html</id>
    <published>2021-01-10T10:06:30.000Z</published>
    <updated>2021-02-11T15:54:13.073Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><p>ISO七层：物理层，数据链路层，网络层，传输层，会话层，表示层，应用层。<br>TCP/IP分层模型：</p><ul><li>网络接口层，ARP地址解析协议，提供硬件间接口。</li><li>网间层，IP协议，负责数据的包装，寻址，和路由。</li><li>传输层，TCP协议提供可靠数据流传输服务，UDP协议提供不可靠的用户数据报服务。</li><li>应用层，FTP（文件传输协议），HTTP（超文本传输协议），Telent（远程终端协议）。</li></ul><h3 id="TCP与UDP区别"><a href="#TCP与UDP区别" class="headerlink" title="TCP与UDP区别"></a>TCP与UDP区别</h3><h3 id="TCP超时重传"><a href="#TCP超时重传" class="headerlink" title="TCP超时重传"></a>TCP超时重传</h3><p>出现以下情况，TCP就会超时重传：</p><ul><li>数据包中途丢失</li><li>数据包顺利到达，ACK报文中途丢失</li><li>数据包到达对端，但对端未响应ACK或被对端丢失</li></ul><p>TCP每发送一个报文段，就会设置一次计时器。计时器设置的重传时间到了，还没有收到确认，就要重传这一报文段，称为“超时重传”。</p><p>RTO：重传超时时间，<strong>发送端发送数据到重传数据</strong>的这一段等待时间<br>RTT：连接往返时间，<strong>发送端从发送TCP包接受到对应的立即响应</strong>所耗费的时间</p><p><img src="http://img.benboby.top/%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0.png" alt="RTO 和 RTT 比较示意图"></p><h2 id="三次握手与四次挥手"><a href="#三次握手与四次挥手" class="headerlink" title="三次握手与四次挥手"></a>三次握手与四次挥手</h2><p><strong>简单示意图</strong><br><img src="http://img.benboby.top/三次握手.png" alt="三次握手"></p><ul><li>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 SYN_Send 状态。</li><li>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。 同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。</li><li>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 establised 状态。</li><li><p>服务器收到 ACK 报文之后，也处于 establised 状态，此时，双方已建立起了链接。</p><p>  因此三次握手可以确认双发收发功能都正常，缺一不可。</p></li></ul><p><img src="http://img.benboby.top/四次挥手.png" alt="四次挥手"></p><p>[问]：为什么要传回 SYN：接收端告诉发送端，我接收到的信息确实就是你所发送的信号。<br>[问]：为啥还要传 ACK：SYN 只能证明发送端到接受端的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来验证。</p><ul><li>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。</li><li>第二次握手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。</li><li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。</li><li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。 需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态</li><li>服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</li></ul><p>[问]：为什么连接的时候是三次握手，关闭的时候却是四次握手？<br>答：连接时，当服务端收到客户端的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文，其中 ACK 报文是用来应答的，SYN 是用来同步的。但关闭连接时，服务端收到 FIN 报文后，可能不会立即发送 FIN 报文，因为服务端可能该发送的报文还没有发完，因此只能先回复一个 ACK 报文表示确认收到了。等服务端所有报文都发送完了，才回复 FIN 信号关闭连接。故需要四次握手。</p><p>[问]：为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</p><p>答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p><p>[问]：为什么不能用两次握手进行连接？<br>答：考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发送了确认应答分组。按照两次握手的协定，S 认为连接已经成功地建立了，可以开始发送数据分组。可是，如果这个应答分组丢失了，C 就不知道 S 是否已准备好，C 就会怀疑 S 是否收到自己的连接请求分组。在这种情况下，C 认为连接还未建立成功，将忽略 S 发来的任何数据分组，只等待连接确认应答分组。而 S 在发出的分组超时后，重复发送同样的分组。这样就形成了<strong>死锁</strong>。</p><p>[问]：如果已经建立了连接，但是客户端突然出现故障了怎么办？<br>答：TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><p><img src="http://img.benboby.top/字段含义.png" alt></p><h2 id="从输入URL到页面加载发生了什么？"><a href="#从输入URL到页面加载发生了什么？" class="headerlink" title="从输入URL到页面加载发生了什么？"></a>从输入URL到页面加载发生了什么？</h2><ol><li>DNS 域名解析<br> 当你输入了 www.google.com 并按下回车后，浏览器检查输入框，发现不是 ip 地址，于是去 <strong>浏览器缓存</strong> 里面找有没有相关记录，发现没有，那就继续去 <strong>系统缓存</strong> 找，也就是系统中的 hosts 文件，还是没有，又继续去 <strong>路由器缓存</strong> 里面找，查看的是路由器映射表。接着，计算机将域名发送给 <strong>本地DNS服务器</strong>，也就是 <strong>提供本地连接的服务商</strong>，本地DNS服务器找不到的话，会将域名发送到 <strong>根域名服务器</strong>，也就是 <strong>‘.’</strong>，找不到就返回 <strong>顶级域名服务器 —— .com 的IP地址</strong>，再请求 <strong>顶级域名服务器IP</strong> 返回 <strong>二级域名服务器 —— google.com 的IP地址</strong>…直到找到对应的IP地址，然后返回给浏览器。</li><li>发起 TCP 连接（三次握手）<br> 知道IP地址后，<strong>传输层的TCP协议</strong>就可以向远端服务器发起连接请求了。</li><li>发送 HTTP 请求，接受 HTTP 响应<br> 连接上了，可以传输了。计算机需要将用户输入的地址封装成 <strong>HTTP Request 请求报文</strong>，发送到服务器，服务器收到请求后会发出应答，即响应数据。<br> HTTP请求报文格式：请求行+请求头+空行+消息体，请求行包括请求方式（GET/POST/DELETE/PUT）、请求资源路径（URL）、HTTP版本号。<br> HTTP响应报文格式：状态行+响应头+空行+消息体，状态行包括HTTP版本号、状态码、状态说明。<br>   常见的状态码：<ul><li>200 响应成功</li><li>302 跳转</li><li>400 客户端请求有语法错误，不能被服务端识别</li><li>403 服务器收到请求，但拒绝提供服务（认证失败）</li><li>404 请求资源不存在</li><li>500 服务器内部错误</li></ul></li><li>断开 TCP 连接（四次挥手）<br> 完成一次 HTTP 请求后，服务器并不是马上断开与客户端的连接。默认启用 <strong>持久连接</strong>，以便处理不久后到来的新请求，无需重新建立连接而增加慢启动开销，提高网络的吞吐能力。在反向代理软件 Nginx 中，持久连接超时时间默认值为 75 秒，如果 75 秒内没有新到达的请求，则断开与客户端的连接。同时，浏览器每隔 45 秒会向服务器发送 TCP keep-alive 探测包，来判断 TCP 连接状况，如果没有收到 ACK 应答，则主动断开与服务器的连接。</li><li>浏览器解析 HTML 代码，请求js，css等资源，最后进行页面渲染，显示出来</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;TCP协议&quot;&gt;&lt;a href=&quot;#TCP协议&quot; class=&quot;headerlink&quot; title=&quot;TCP协议&quot;&gt;&lt;/a&gt;TCP协议&lt;/h2&gt;&lt;h3 id=&quot;网络模型&quot;&gt;&lt;a href=&quot;#网络模型&quot; class=&quot;headerlink&quot; title=&quot;网络模型&quot;</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://www.benboby.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="TCP/IP" scheme="https://www.benboby.top/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：货仓选址</title>
    <link href="https://www.benboby.top/2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%B4%A7%E4%BB%93%E9%80%89%E5%9D%80.html"/>
    <id>https://www.benboby.top/2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%B4%A7%E4%BB%93%E9%80%89%E5%9D%80.html</id>
    <published>2021-01-09T12:09:30.000Z</published>
    <updated>2021-01-28T06:02:23.350Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>在数轴上找到一个点，使得到其余 $n$ 个点距离之和最小。$(n \in [1, 1e5])$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>考虑绝对值不等式：<br><a id="more"></a> </p><p>当只有两个点 $a, b$ 时，有 $|a - x| + |b - x| &gt;= |a - b|$，为了满足 $|a - x| + |b - x| = |a - b|$ 关系，$x$ 必须选在 $a,b$ 两点之间。</p><p>拓展为 $n$ 个点，距离为 $|a[1] - x| + |a[2] - x| + … + |a[n - 1] - x| + |a[n] - x|$，收尾两两分组有 $(|a[1] - x| + |a[n] - x|) + (|a[2] - x| - |a[n - 2] - x| + …)$，两两应用绝对值不等式，$x$ 的位置必须满足在各个对应区间里。</p><p>得出结论：当 $n$ 为奇数时，$x$ 位置为中间那个点（因为刚好分组多出单独一个，满足最小性则必须将 $x$ 的位置选择为那个点，距离刚好为 $0$）；当 $n$ 为偶数时，$x$ 位置为中间两个点之间的任意位置都可。 </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, res, a[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    sort(a, a + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) res += <span class="built_in">abs</span>(a[i] - a[n &gt;&gt; <span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;在数轴上找到一个点，使得到其余 $n$ 个点距离之和最小。$(n \in [1, 1e5])$&lt;/p&gt;
&lt;h2 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h2&gt;&lt;p&gt;考虑绝对值不等式：&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="数学" scheme="https://www.benboby.top/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：按要求补齐数组</title>
    <link href="https://www.benboby.top/2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%8C%89%E8%A6%81%E6%B1%82%E8%A1%A5%E9%BD%90%E6%95%B0%E7%BB%84.html"/>
    <id>https://www.benboby.top/2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%8C%89%E8%A6%81%E6%B1%82%E8%A1%A5%E9%BD%90%E6%95%B0%E7%BB%84.html</id>
    <published>2020-12-29T05:09:57.000Z</published>
    <updated>2021-01-28T06:02:23.357Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个已排序的正整数数组 $nums$，和一个正整数 $n$ 。从 $[1, n]$ 区间内选取任意个数字补充到 $nums$ 中，使得 $[1, n]$ 区间内的任何数字都可以用 $nums$ 中某几个数字的和来表示。请输出满足上述要求的最少需要补充的数字个数。</p><h2 id="Soluiton"><a href="#Soluiton" class="headerlink" title="Soluiton"></a>Soluiton</h2><p>容易证明，对于正整数 $x$，如果区间 $[1,x−1]$ 内的所有数字都已经被覆盖，且 $x$ 在数组中，则区间 $[1,2x−1]$ 内的所有数字也都被覆盖。<br><a id="more"></a> </p><p>由此可以提出一个贪心的方案。每次找到未被数组 $nums$ 覆盖的最小的整数 $x$，在数组中补充 $x$，然后寻找下一个未被覆盖的最小的整数，重复上述步骤直到区间 $[1,n]$ 中的所有数字都被覆盖。</p><p>具体实现：</p><p>$x$ 表示当前能表示出 $[1, x - 1]$ 的所有数字，初始化为 $1$，枚举数组。</p><ul><li>若枚举到的数小等于 $x$，则加上，表示能表示出 $[1, x + num[i] - 1]$ 的所有数字，然后下标加 $1$</li><li>若枚举到的数大于 $x$，则说明 $x$ 无法被表示出来，我们需要增加一个数 $x$，然后$x$ 加上 $x$，表示能表示出 $[1, x + x - 1]$ 的所有数字</li></ul><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPatches</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, i = <span class="number">0</span>, m = a.size();</span><br><span class="line">        <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; m &amp;&amp; a[i] &lt;= x) &#123;</span><br><span class="line">                x += a[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                x *= <span class="number">2</span>;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给定一个已排序的正整数数组 $nums$，和一个正整数 $n$ 。从 $[1, n]$ 区间内选取任意个数字补充到 $nums$ 中，使得 $[1, n]$ 区间内的任何数字都可以用 $nums$ 中某几个数字的和来表示。请输出满足上述要求的最少需要补充的数字个数。&lt;/p&gt;
&lt;h2 id=&quot;Soluiton&quot;&gt;&lt;a href=&quot;#Soluiton&quot; class=&quot;headerlink&quot; title=&quot;Soluiton&quot;&gt;&lt;/a&gt;Soluiton&lt;/h2&gt;&lt;p&gt;容易证明，对于正整数 $x$，如果区间 $[1,x−1]$ 内的所有数字都已经被覆盖，且 $x$ 在数组中，则区间 $[1,2x−1]$ 内的所有数字也都被覆盖。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="贪心" scheme="https://www.benboby.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：最大矩形</title>
    <link href="https://www.benboby.top/2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2.html"/>
    <id>https://www.benboby.top/2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2.html</id>
    <published>2020-12-26T06:52:52.000Z</published>
    <updated>2021-01-28T06:02:23.348Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个仅包含 $0$ 和 $1$ 、大小为 $n * m$ 的二维二进制矩阵，找出只包含 $1$ 的最大矩形，并返回其面积。$(n, m \in [1, 200])$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>有一个子问题，求柱状图最大矩形。预先求出 $1-i$ 层的 $h[i]$ 然后利用套用子问题的模板即可，复杂度 $O(n * m)$.<br><a id="more"></a> </p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; h)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        st.push(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> n = h.size();</span><br><span class="line">        vector&lt;int&gt; l(n), r(n, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (st.top() != <span class="number">-1</span> &amp;&amp; h[st.top()] &gt;= h[i]) &#123;</span><br><span class="line">                r[st.top()] = i;</span><br><span class="line">                st.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            l[i] = st.top();</span><br><span class="line">            st.push(i); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) res = max(res, (r[i] - l[i] - <span class="number">1</span>) * h[i]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = a[<span class="number">0</span>].size(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">h</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) </span><br><span class="line">                h[j] = (a[i][j] == <span class="string">&#x27;1&#x27;</span> ? h[j] + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">            res = max(res, largestRectangleArea(h));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给定一个仅包含 $0$ 和 $1$ 、大小为 $n * m$ 的二维二进制矩阵，找出只包含 $1$ 的最大矩形，并返回其面积。$(n, m \in [1, 200])$&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;p&gt;有一个子问题，求柱状图最大矩形。预先求出 $1-i$ 层的 $h[i]$ 然后利用套用子问题的模板即可，复杂度 $O(n * m)$.&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="思维" scheme="https://www.benboby.top/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：共鸣问题</title>
    <link href="https://www.benboby.top/2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%85%B1%E9%B8%A3%E9%97%AE%E9%A2%98.html"/>
    <id>https://www.benboby.top/2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%85%B1%E9%B8%A3%E9%97%AE%E9%A2%98.html</id>
    <published>2020-12-23T13:46:43.000Z</published>
    <updated>2021-01-28T06:02:23.347Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>现在有 $n$ 个音符和 $m$ 对共鸣关系，编号为 $1-n$，每个音符自己有一个奏响时的优美程度，共鸣关系 $(x,y,z)$ 表示音符 $x$ 和 $y$ 同时奏响的额外优美程度是 $z$，同时不奏响则为 $-z$，其他情况为 $0$，求最大优美程度。$(n,m \in [1,1e5])$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对于一对共鸣关系而言，在不选的情况下收益为 $-z$，则选择一个的话，收益为 $-z + z = 0$，都选择的话为 $-z + 2z = z$。因此可以预先把每对关系的两个数都加上 $z$，刚开始我们是不选任何有联系的音符的，因此初值为 $-z$，那么选择一个数就会加上 $z$，选择两个就会加上 $2z$，满足了之前所讨论的关系。答案初始化为所有关系都不选的情况，即 $-sum(z)$，然后只要贪心的选择对答案有正贡献的值就行了。<br><a id="more"></a> </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param n int整型 </span></span><br><span class="line"><span class="comment">     * @param m int整型 </span></span><br><span class="line"><span class="comment">     * @param a int整型vector </span></span><br><span class="line"><span class="comment">     * @param b int整型vector&lt;vector&lt;&gt;&gt; </span></span><br><span class="line"><span class="comment">     * @return long长整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">wwork</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; c;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : a) c.push_back(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : b) &#123;</span><br><span class="line">            c[v[<span class="number">0</span>] - <span class="number">1</span>] += v[<span class="number">2</span>];</span><br><span class="line">            c[v[<span class="number">1</span>] - <span class="number">1</span>] += v[<span class="number">2</span>];</span><br><span class="line">            res -= v[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : c) res += max(x, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;现在有 $n$ 个音符和 $m$ 对共鸣关系，编号为 $1-n$，每个音符自己有一个奏响时的优美程度，共鸣关系 $(x,y,z)$ 表示音符 $x$ 和 $y$ 同时奏响的额外优美程度是 $z$，同时不奏响则为 $-z$，其他情况为 $0$，求最大优美程度。$(n,m \in [1,1e5])$&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;p&gt;对于一对共鸣关系而言，在不选的情况下收益为 $-z$，则选择一个的话，收益为 $-z + z = 0$，都选择的话为 $-z + 2z = z$。因此可以预先把每对关系的两个数都加上 $z$，刚开始我们是不选任何有联系的音符的，因此初值为 $-z$，那么选择一个数就会加上 $z$，选择两个就会加上 $2z$，满足了之前所讨论的关系。答案初始化为所有关系都不选的情况，即 $-sum(z)$，然后只要贪心的选择对答案有正贡献的值就行了。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="贪心" scheme="https://www.benboby.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：大逃离</title>
    <link href="https://www.benboby.top/2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%A4%A7%E9%80%83%E7%A6%BB.html"/>
    <id>https://www.benboby.top/2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%A4%A7%E9%80%83%E7%A6%BB.html</id>
    <published>2020-12-22T14:28:30.000Z</published>
    <updated>2021-01-28T06:02:23.343Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>从 $n$ 个数中任选 $k$ 个数，取得这 $k$ 个数中最大的一个数，求每个数被取得的概率。$(n, k \in [1, 2e5])$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>将数组排序后，枚举每个数被作为最大值的可能性，当第 $i$ 个数作为最大值时，其它 $k - 1$ 个一定从前 $i - 1$ 个里面选，即方案数为 $C(i - 1, k - 1)$，将其除以总方案数 $C(n, k)$ 即为被取得概率。<br><a id="more"></a> </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param n int整型 </span></span><br><span class="line"><span class="comment">     * @param k int整型 </span></span><br><span class="line"><span class="comment">     * @param Point int整型vector </span></span><br><span class="line"><span class="comment">     * @return int整型vector</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> f[<span class="number">200005</span>];</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">qp</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (b) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b &amp; <span class="number">1</span>) sum = sum * a % mod;</span><br><span class="line">            a = a * a % mod;</span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == m || m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> f[n] * qp(f[m], mod - <span class="number">2</span>) % mod * qp(f[n - m], mod - <span class="number">2</span>) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">city</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">auto</span> b = a;</span><br><span class="line">        sort(a.begin(), a.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">long</span> <span class="keyword">long</span>&gt; mp;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= <span class="number">200000</span>; ++i) &#123;</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &gt;= k) </span><br><span class="line">                mp[a[i]] = C(i, k - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = C(n, k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            g.push_back(mp[b[i]] * qp(sum, mod - <span class="number">2</span>) % mod);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> g;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;从 $n$ 个数中任选 $k$ 个数，取得这 $k$ 个数中最大的一个数，求每个数被取得的概率。$(n, k \in [1, 2e5])$&lt;/p&gt;
&lt;h2 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h2&gt;&lt;p&gt;将数组排序后，枚举每个数被作为最大值的可能性，当第 $i$ 个数作为最大值时，其它 $k - 1$ 个一定从前 $i - 1$ 个里面选，即方案数为 $C(i - 1, k - 1)$，将其除以总方案数 $C(n, k)$ 即为被取得概率。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="数学" scheme="https://www.benboby.top/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>GCC编译器和GDB调试器</title>
    <link href="https://www.benboby.top/2020/12/GCC%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8CGDB%E8%B0%83%E8%AF%95%E5%99%A8.html"/>
    <id>https://www.benboby.top/2020/12/GCC%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8CGDB%E8%B0%83%E8%AF%95%E5%99%A8.html</id>
    <published>2020-12-20T06:09:48.000Z</published>
    <updated>2021-01-31T06:51:45.883Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GCC编译器"><a href="#GCC编译器" class="headerlink" title="GCC编译器"></a>GCC编译器</h2><p>GCC 编译器支持编译 Go、Objective-C，Objective-C++，Fortran，Ada，D 和 BRIG（HSAIL）等程序。</p><p>实际使用中，使用 gcc 指令编译 C 代码，使用 g++ 指令编译 C++ 代码。</p><h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p>例如 <strong>g++ test.cpp -o test</strong> 可拆解为以下步骤：</p><a id="more"></a> <ol><li><p>预处理</p> <figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># -E 选项指示编译器仅对输入文件进行预处理</span></span><br><span class="line"><span class="meta"># test.i 文件将头文件及宏定义具体内容全部展开，其余保持不变</span></span><br><span class="line">g++ -E test.cpp -o test.i    <span class="comment">// 生成.i文件</span></span><br></pre></td></tr></table></figure></li><li><p>编译</p> <figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># -S 编译选项告诉 g++ 在为 C++ 代码产生了汇编语言文件后停止编译</span></span><br><span class="line"><span class="meta"># g++ 产生的汇编语言文件缺省拓展名是 .s</span></span><br><span class="line"><span class="meta"># test.s 汇编语言文件内容为汇编指令</span></span><br><span class="line">g++ -S test.i -o test.s</span><br></pre></td></tr></table></figure></li><li><p>汇编</p> <figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># -c 选项告诉 g++ 仅把源代码编译为机器语言的目标代码</span></span><br><span class="line"><span class="meta"># 缺省时 g++ 建立的目标代码文件有一个 .o 的拓展名</span></span><br><span class="line"><span class="meta"># test.o 为机器语言识别的二进制代码</span></span><br><span class="line">g++ -c test.s -o test.o</span><br></pre></td></tr></table></figure></li><li><p>链接</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -o 编译选项来为将产生的可执行文件用指定的文件名</span></span><br><span class="line"><span class="comment"># test 为可执行文件</span></span><br><span class="line">g++ <span class="keyword">test</span>.o -o <span class="keyword">test</span></span><br></pre></td></tr></table></figure><h3 id="g-重要编译参数"><a href="#g-重要编译参数" class="headerlink" title="g++重要编译参数"></a>g++重要编译参数</h3></li><li><p>-g 编译带调试信息的可执行文件</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -g 选项告诉 GCC 产生能被 GNU 调试器 GDB 使用的调试信息，以调试程序。</span></span><br><span class="line"><span class="comment"># 产生带调试信息的可执行文件 test（不加则 test 不包含调试信息）</span></span><br><span class="line">g++ -g <span class="keyword">test</span>.cpp -o <span class="keyword">test</span></span><br></pre></td></tr></table></figure></li><li><p>-O[n] 优化源代码</p> <figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 所谓优化，比如省略代码中从未使用过的变量，直接将常量表达式用结果值来替代等等，这些操作会缩减目标文件所包含的代码量，提高最终生成的可执行文件的运行效率。</span></span><br><span class="line"><span class="meta"># -O 选项告诉 g++ 对源代码进行基本优化。这些操作在大多数情况下都会使程序执行的更快。-O2 选项告诉 g++ 产生尽可能小和尽可能快的代码。</span></span><br><span class="line"><span class="meta"># -O 同时减小代码长度和执行时间，效果等价为 -O1</span></span><br><span class="line"><span class="meta"># -O0 表示不做优化</span></span><br><span class="line"><span class="meta"># -O1 默认优化</span></span><br><span class="line"><span class="meta"># -O2 除了完成 -O1 的优化之外，还进行一些额外的调整工作，如指令调整等</span></span><br><span class="line"><span class="meta"># -O3 包括循环展开和其他一些与处理特性相关的优化操作</span></span><br><span class="line"><span class="meta"># 选项将使编译的速度比使用 -O 时慢，但通常产生的代码执行速度会更快</span></span><br><span class="line"><span class="meta"># 可以用如 &quot;time ./test&quot; 来查看可执行文件的运行效率，比较优化效果</span></span><br><span class="line">g++ -O2 test.cpp</span><br></pre></td></tr></table></figure></li><li><p>-l 和 -L 指定库文件 ｜ 指定库文件路径</p> <figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># -l 参数就是用来指定程序要链接的库，-l 参数紧接着就是库名</span></span><br><span class="line"><span class="meta"># 在 /lib 和 /usr/lib 和 /usr/local/lib 里的库可以直接用 -l 来进行链接</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 链接 glog库</span></span><br><span class="line">g++ -lglog test.cpp</span><br><span class="line"></span><br><span class="line"><span class="meta"># 如果库文件没放在上面三个目录里，需要使用 -L 参数指定库文件所在目录</span></span><br><span class="line"><span class="meta"># -L 参数紧接着的是库文件所在的目录名</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 链接 mytest 库，libmytest.so 在 /home/Test 目录下</span></span><br><span class="line">g++ -L/home/Test -lmytest test.cpp</span><br></pre></td></tr></table></figure></li><li><p>-I 指定头文件搜索目录</p> <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 若头文件在 /usr/<span class="keyword">include</span> 目录下一般是不需要指定的，否则就需要 -I 参数来指定了，比如头文件放在 /myinclude 目录里，否则会报错 “xxxx.<span class="keyword">h</span>: <span class="keyword">No</span> such <span class="keyword">file</span> or directory” 。</span><br><span class="line"><span class="keyword">g</span>++ -I/myinclude <span class="keyword">test</span>.cpp</span><br></pre></td></tr></table></figure></li><li><p>-Wall 打印警告信息 | -w 关闭警告信息</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印出 gcc 的警告信息</span></span><br><span class="line">g++ -Wall <span class="keyword">test</span>.cpp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭所有警告信息</span></span><br><span class="line">g++ -w <span class="keyword">test</span>.cpp</span><br></pre></td></tr></table></figure></li><li><p>-std=c++11 设置编译标准</p> <figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span> <span class="comment">使用</span> <span class="comment">c</span>++<span class="comment">11</span> <span class="comment">标准编译</span> <span class="comment">test</span><span class="string">.</span><span class="comment">cpp</span></span><br><span class="line"><span class="comment">g</span>++ <span class="literal">-</span><span class="comment">std=c</span>++<span class="comment">11</span> <span class="comment">test</span><span class="string">.</span><span class="comment">cpp</span></span><br></pre></td></tr></table></figure></li><li>-o 指定输出文件名 <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定即将产生的文件名</span></span><br><span class="line"><span class="comment"># 指定输出可执行文件名为test</span></span><br><span class="line">g++ <span class="keyword">test</span>.cpp -o <span class="keyword">test</span></span><br></pre></td></tr></table></figure></li><li><p>-D 定义宏</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 在使用gcc/g++编译的时候定义宏</span><br><span class="line"># 常用场景：</span><br><span class="line"># -DDEBUG 定义 DEBUG 宏，可能文件中有DEBUG宏部分的相关信息，用 DDEBUG 来选择开启或关闭 DEBUG</span><br><span class="line"># 举例：</span><br><span class="line"><span class="comment">// -Dname 定义宏 name，默认定义内容为字符串 “1”</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;DEBUG LOG\n&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;in\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1. 在编译的时候，使用g++ -DDEBUG main.cpp</span></span><br><span class="line"><span class="comment">// 2. 第七行代码可以被执行</span></span><br></pre></td></tr></table></figure><h2 id="GDB调试器"><a href="#GDB调试器" class="headerlink" title="GDB调试器"></a>GDB调试器</h2></li></ol><p>GDB(GNU Debugger) 是一个用来调试C/C++程序的功能强大的调试器，是 Linux 系统开发 C/C++ 最常用的调试器。</p><p>GDB主要功能：</p><ul><li>设置断点(断点可以是条件表达式)</li><li>使程序在指定的代码行上暂停执行，便于观察</li><li>单步执行程序，便于调试</li><li>查看程序中变量值的变化</li><li>动态改变程序的执行环境</li><li>分析崩溃程序产生的core文件</li></ul><p>调试开始：执行gdb [filename] ，进入gdb调试程序，其中 filename 为要调试的可执行文件名。</p><p>编译程序时需要加上 -g，之后才能用 gdb 进行调试：g++ -g main.cpp -o main<br>回车键：重复上一命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">help</span>(h)        <span class="comment"># 查看命令帮助，具体命令查询在gdb中输入help + 命令</span></span> </span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)run(r)         <span class="comment"># 重新开始运行文件（run-text：加载文本文件，run-bin：加载二进制文件）</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)start          <span class="comment"># 单步执行，运行程序，停在第一行执行语句</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)list(l)        <span class="comment"># 查看原代码（list-n,从第n行开始查看代码。list+ 函数名：查看具体函数）</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">set</span>            <span class="comment"># 设置变量的值</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)next(n)        <span class="comment"># 单步调试（逐过程，函数直接执行）</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)step(s)        <span class="comment"># 单步调试（逐语句：跳入自定义函数内部执行）</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)backtrace(bt)  <span class="comment"># 查看函数的调用的栈帧和层级关系</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)frame(f)       <span class="comment"># 切换函数的栈帧</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)info(i)        <span class="comment"># 查看函数内部局部变量的数值</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)finish         <span class="comment"># 结束当前函数，返回到函数调用点</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">continue</span>(c)    <span class="comment"># 继续运行</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">print</span>(p)       <span class="comment"># 打印值及地址</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)quit(q)        <span class="comment"># 退出gdb</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">break</span>+num(b)                 <span class="comment"># 在第num行设置断点</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)info breakpoints             <span class="comment"># 查看当前设置的所有断点</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)delete breakpoints num(d)    <span class="comment"># 删除第num个断点</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)display                      <span class="comment"># 追踪查看具体变量值</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)undisplay                    <span class="comment"># 取消追踪观察变量</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)watch                        <span class="comment"># 被设置观察点的变量发生修改时，打印显示</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)i watch                      <span class="comment"># 显示观察点</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">enable</span> breakpoints           <span class="comment"># 启用断点</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">disable</span> breakpoints          <span class="comment"># 禁用断点</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)x                            <span class="comment"># 查看内存x/20xw 显示20个单元，16进制，4字节每单元</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)run argv[1] argv[2]          <span class="comment"># 调试时命令行传参</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">set</span> follow-fork-mode child   <span class="comment"># Makefile项目管理：选择跟踪父子进程（fork()）</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;GCC编译器&quot;&gt;&lt;a href=&quot;#GCC编译器&quot; class=&quot;headerlink&quot; title=&quot;GCC编译器&quot;&gt;&lt;/a&gt;GCC编译器&lt;/h2&gt;&lt;p&gt;GCC 编译器支持编译 Go、Objective-C，Objective-C++，Fortran，Ada，D 和 BRIG（HSAIL）等程序。&lt;/p&gt;
&lt;p&gt;实际使用中，使用 gcc 指令编译 C 代码，使用 g++ 指令编译 C++ 代码。&lt;/p&gt;
&lt;h3 id=&quot;编译过程&quot;&gt;&lt;a href=&quot;#编译过程&quot; class=&quot;headerlink&quot; title=&quot;编译过程&quot;&gt;&lt;/a&gt;编译过程&lt;/h3&gt;&lt;p&gt;例如 &lt;strong&gt;g++ test.cpp -o test&lt;/strong&gt; 可拆解为以下步骤：&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://www.benboby.top/categories/C/"/>
    
    
    <category term="C++基础" scheme="https://www.benboby.top/tags/C-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：区间和的个数</title>
    <link href="https://www.benboby.top/2020/11/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%8C%BA%E9%97%B4%E5%92%8C%E7%9A%84%E4%B8%AA%E6%95%B0.html"/>
    <id>https://www.benboby.top/2020/11/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%8C%BA%E9%97%B4%E5%92%8C%E7%9A%84%E4%B8%AA%E6%95%B0.html</id>
    <published>2020-11-07T15:39:51.000Z</published>
    <updated>2021-01-28T06:02:23.355Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 $a$，返回区间和在 $[lower, upper]$ 之间的个数，包含 $lower$ 和 $upper$。<br>区间和 $S(i, j)$ 表示在 $a$ 中，位置从 $i$ 到 $j$ 的元素之和，包含 $i$ 和 $j$ $(i ≤ j)$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><a id="more"></a> <p>维护前缀和，对于每个前缀和 $sum[i]$，等价于 $sum[0…i-1]$ 里面有多少个数满足差值在 $[lower, upper]$ 之间。</p><p>$sum[i] - sum[j] = [lower, upper]$ 等价于求出现在区间 $sum[j] \in [sum[i] - upper, sum[i] - lower]$ 的数的个数，故可以用树状数组维护。</p><p>遍历前缀和数组，对于当前前缀和 $sum[i]$，满足的个数便为：$query(sum[i] - lower) - query(sum[i] - upper - 1)$，累加答案即可。</p><p>由于数很大，故需要将所有出现的数离散化。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BIT</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span>* c;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        BIT(<span class="keyword">int</span> _n) &#123;</span><br><span class="line">            n = _n;</span><br><span class="line">            c = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) c[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">                c[x]++;</span><br><span class="line">                x += lowbit(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x) &#123;</span><br><span class="line">                sum += c[x];</span><br><span class="line">                x -= lowbit(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countRangeSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> lower, <span class="keyword">int</span> upper)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> m = a.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> *sum = <span class="keyword">new</span> <span class="keyword">long</span> <span class="keyword">long</span>[m + <span class="number">1</span>];</span><br><span class="line">        sum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i) sum[i] = sum[i - <span class="number">1</span>] + a[i - <span class="number">1</span>];</span><br><span class="line">            s.insert(sum[i]);</span><br><span class="line">            s.insert(sum[i] - upper);</span><br><span class="line">            s.insert(sum[i] - lower);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">int</span> n = s.size(), idx = <span class="number">0</span>;</span><br><span class="line">        <span class="function">BIT <span class="title">bit</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : s) mp[x] = ++idx;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = mp[sum[i] - upper], r = mp[sum[i] - lower];</span><br><span class="line">            res += bit.query(r) - bit.query(l - <span class="number">1</span>);</span><br><span class="line">            bit.add(mp[sum[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个整数数组 $a$，返回区间和在 $[lower, upper]$ 之间的个数，包含 $lower$ 和 $upper$。&lt;br&gt;区间和 $S(i, j)$ 表示在 $a$ 中，位置从 $i$ 到 $j$ 的元素之和，包含 $i$ 和 $j$ $(i ≤ j)$。&lt;/p&gt;
&lt;h2 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h2&gt;</summary>
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="树状数组" scheme="https://www.benboby.top/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>C++内存管理</title>
    <link href="https://www.benboby.top/2020/11/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"/>
    <id>https://www.benboby.top/2020/11/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html</id>
    <published>2020-11-02T03:12:51.000Z</published>
    <updated>2021-02-09T09:18:32.314Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="内存管理详解"><a href="#内存管理详解" class="headerlink" title="内存管理详解"></a>内存管理详解</h3><h4 id="内存分配方式"><a href="#内存分配方式" class="headerlink" title="内存分配方式"></a>内存分配方式</h4><h5 id="分配方式简介"><a href="#分配方式简介" class="headerlink" title="分配方式简介"></a>分配方式简介</h5><p>在C++中，内存分为5个区：</p><ol><li>栈：执行函数时，函数内部局部变量存储单元在栈上创建，结束时自动释放。效率很高，但存储容量有限。</li><li>堆：由 <strong>new</strong> 分配的内存块，编译器不会自动释放，需要应用程序对应的 <strong>delete</strong> 进行释放。如果没有释放，则程序运行结束后会由操作系统自动回收。</li><li>自由存储区：由 <strong>malloc</strong> 等分配的内存块，类似堆，由 <strong>free</strong> 结束自己的生命。</li><li>全局/静态存储区：存储全局变量和静态变量。</li><li>常量存储区：存放常量，不允许修改。</li></ol><a id="more"></a> <h5 id="明确区分堆和栈"><a href="#明确区分堆和栈" class="headerlink" title="明确区分堆和栈"></a>明确区分堆和栈</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在栈内存中存放了一个指向一块堆内存的指针 p。程序会先确定在堆中分配内存的大小，然后调用 <strong>operator new</strong> 分配内存，然后返回这块内存的首地址，放入栈中。</p><p>这里并没有释放内存，因此需要 <strong>delete[] p</strong>，告诉编译器删除的是数组，然后编译器根据Cookie信息去释放内存。</p><h5 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h5><ol><li>管理方式：栈由编译器自动管理，无需手动控制；堆的释放工作由程序员控制，容易产生内存泄露。</li><li>空间大小：堆栈的内存都可以自己设定，堆内存一般不超过系统内存都是可以申请，栈内存个人测试默认值为8M。</li><li>碎片问题：对于堆而言，频繁的 <strong>new/delete</strong> 势必会造成内存空间的不连续，造成大量的碎片，使程序的效率降低；对于栈而言，则不会发生这样的情况，先进后出排列有序，以至于永远不可能有一个内存块从非栈顶位置弹出。</li><li>生长方向：对于堆而言，生长方向向上，向着内存地址增加的方向增长；对于栈而言，生长方向向下，向着内存地址减小的方向增长。</li><li>分配方式：堆都是动态分配的，没有静态分配的堆。栈有动态分配和静态分配两种，静态分配由编译器完成，比如局部变量的分配；动态分配由 <strong>alloca</strong> 函数进行分配，都由编译器进行释放。</li><li>分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持，这就决定了栈的效率比较高。堆则是 C/C++ 函数库提供的，机制比较复杂，用到许多算法的实现内存的分配。显然，堆的效率比栈要低得多。</li></ol><p>因此，更推荐尽量使用栈而不是堆。但是栈和堆相比并不灵活。如果需要分配大量内存空间，还是堆好一些。</p><h4 id="控制-C-的内存分配"><a href="#控制-C-的内存分配" class="headerlink" title="控制 C++ 的内存分配"></a>控制 C++ 的内存分配</h4><p>无论如何，一定要保守的使用内存分配。<br>一个防止堆破碎的通用方法是从不同固定大小的内存池中分配不同类型的对象。对每个类重载 <strong>new</strong> 和 <strong>delete</strong> 就提供了这样的控制。</p><h5 id="重载全局的new和delete操作"><a href="#重载全局的new和delete操作" class="headerlink" title="重载全局的new和delete操作"></a>重载全局的new和delete操作</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">void</span> *p = <span class="built_in">malloc</span>(size); </span><br><span class="line">    <span class="keyword">return</span> (p); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *p)</span></span>; </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">free</span>(p); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以对单个类的 new 和 delete 操作符重载。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *p)</span></span>; </span><br><span class="line">    <span class="comment">// .. other members here ... </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">void</span> *TestClass::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">void</span> *p = <span class="built_in">malloc</span>(size); <span class="comment">// Replace this with alternative allocator </span></span><br><span class="line">    <span class="keyword">return</span> (p); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> TestClass::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *p)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">free</span>(p); <span class="comment">// Replace this with alternative de-allocator</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="为单个类重载-new-和-delete"><a href="#为单个类重载-new-和-delete" class="headerlink" title="为单个类重载 new[] 和 delete[]"></a>为单个类重载 new[] 和 delete[]</h5><p>C++将对象数组的内存分配作为一个单独的操作，而不同于单个对象的内存分配。为了改变这种方式，同样需要重载 new[] 和 delete[]操作符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">void</span> * <span class="keyword">operator</span> <span class="keyword">new</span>[ ](<span class="keyword">size_t</span> size); </span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[ ](<span class="keyword">void</span> *p); </span><br><span class="line">    <span class="comment">// .. other members here .. </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">void</span> *TestClass::<span class="keyword">operator</span> <span class="keyword">new</span>[ ](<span class="keyword">size_t</span> size) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">void</span> *p = <span class="built_in">malloc</span>(size); </span><br><span class="line">    <span class="keyword">return</span> (p); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">void</span> TestClass::<span class="keyword">operator</span> <span class="keyword">delete</span>[ ](<span class="keyword">void</span> *p) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">free</span>(p); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    TestClass *p = <span class="keyword">new</span> TestClass[<span class="number">10</span>]; </span><br><span class="line">    <span class="comment">// ... etc ... </span></span><br><span class="line">    <span class="keyword">delete</span>[ ] p; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：对于多数 C++ 的实现，<strong>new[]</strong> 操作符中的个数参数是数组的大小加上额外的存储对象数目的一些字节。因此应该尽量避免分配对象数组，使内存分配策略简单。</p><h4 id="常见的内存错误"><a href="#常见的内存错误" class="headerlink" title="常见的内存错误"></a>常见的内存错误</h4><ol><li>内存分配未成功，却使用了它。<ul><li>如果是用 malloc 或 new 来申请内存，应该用 if(p==NULL) 或 if(p!=NULL)进行防错。</li></ul></li><li>内存分配虽然成功，但未初始化就引用它。<ul><li>无论用何种方式创建数组，都要赋初值，即便是零值。</li></ul></li><li>内存分配成功并且已经初始化，但操作越界。<ul><li>多发生在下标“多1”或“少1”。</li></ul></li><li>忘记了释放内存，造成内存泄漏。<ul><li>动态内存的申请与释放必须配对，程序中 <strong>malloc</strong> 与 <strong>free</strong> 的使用次数一定要相同，否则肯定有错误（new/delete同理）。</li></ul></li><li>释放了内存却继续使用它。<ul><li>程序过于复杂，难以分清是否释放了内存，此时应当重新设计数据结构，解决混乱。</li><li>return语句写错，不要返回指向“栈内存”的指针或引用，因为该内存在函数体结束时被自动销毁。</li><li>free或delete释放内存后，没有将指针设为NULL，导致“野指针”。</li></ul></li></ol><h4 id="指针与数组对比"><a href="#指针与数组对比" class="headerlink" title="指针与数组对比"></a>指针与数组对比</h4><p>数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。数组名对应着（<strong>而不是指向</strong>）一块内存，其地址和容量在生命周期内保持不变，只有数组的内容可以改变。</p><p>指针可以随时指向任何类型的内存块，它的特征是“可变”的，所以常用指针来操作动态内存，指针远比数组灵活，但也更危险。</p><h5 id="修改数组内容"><a href="#修改数组内容" class="headerlink" title="修改数组内容"></a>修改数组内容</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[] = “hello”; </span><br><span class="line">a[<span class="number">0</span>] = ‘X’; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"><span class="comment">// 可以拆分为 char s[] = &quot;world&quot;; char *p = str;</span></span><br><span class="line"><span class="keyword">char</span> *p = “world”; <span class="comment">// 注意 p 指向常量字符串</span></span><br><span class="line">p[<span class="number">0</span>] = ‘X’; <span class="comment">// 编译器不能发现该错误，但运行时产生[Bus error]</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h5 id="内容复制与比较"><a href="#内容复制与比较" class="headerlink" title="内容复制与比较"></a>内容复制与比较</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组… </span></span><br><span class="line"><span class="keyword">char</span> a[] = <span class="string">&quot;hello&quot;</span>; </span><br><span class="line"><span class="keyword">char</span> b[<span class="number">10</span>]; </span><br><span class="line"><span class="built_in">strcpy</span>(b, a); <span class="comment">// 不能用 b = a; </span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(b, a) == <span class="number">0</span>) <span class="comment">// 不能用 if (b == a) </span></span><br><span class="line">… </span><br><span class="line"><span class="comment">// 指针… </span></span><br><span class="line"><span class="comment">// 语句 p = a 并不能把 a 的内容复制给指针 p，而是把 a 的地址赋给了 p。</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(a); </span><br><span class="line"><span class="keyword">char</span> *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*(len+<span class="number">1</span>)); </span><br><span class="line"><span class="built_in">strcpy</span>(p, a); <span class="comment">// 不要用 p = a; </span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(p, a) == <span class="number">0</span>) <span class="comment">// 不要用 if (p == a) </span></span><br></pre></td></tr></table></figure><h5 id="计算内存容量"><a href="#计算内存容量" class="headerlink" title="计算内存容量"></a>计算内存容量</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[] = <span class="string">&quot;hello world&quot;</span>; </span><br><span class="line"><span class="keyword">char</span> *p = a; </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(a) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 12 字节</span></span><br><span class="line"><span class="comment">// sizeof(p) 等价于 sizeof(char *)，没有办法的值指针所指的内存容量，除非申请内存时就记住它</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(p) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 4 字节</span></span><br></pre></td></tr></table></figure><p>注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(<span class="keyword">char</span> a[<span class="number">100</span>])</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// 不论数组 a 的容量是多少，sizeof(a)始终等于 sizeof(char *)。</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(a) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 4 字节而不是 100 字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="指针参数如何传递内存"><a href="#指针参数如何传递内存" class="headerlink" title="指针参数如何传递内存"></a>指针参数如何传递内存</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetMemory</span><span class="params">(<span class="keyword">char</span> *p, <span class="keyword">int</span> num)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    p = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * num); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>; </span><br><span class="line">    GetMemory(str, <span class="number">100</span>); <span class="comment">// str 仍然为 NULL </span></span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello&quot;</span>); <span class="comment">// 运行错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.benboby.top/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%89%AF%E6%9C%AC.png" alt></p><p>如果函数的参数是一个指针，不要指望用该指针去申请动态内存。编译器总是要为函数的每个参数制作临时副本，指针参数 p 的副本是 _p，编译器使 _p = p。如果函数体内的程序修改了_p 的内容，就导致参数 p 的内容作相应的修改。这就是指针可以用作输出参数的原因。_p 申请了新的内存，只是把 _p 所指的内存地址改变了，但是 p 丝毫未变。所以函数 GetMemory 并不能输出任何东西。事实上，每执行一次 GetMemory 就会泄露一块内存，因为没有用 free 释放内存。</p><p>如果非得要用指针参数去申请内存，那么应该改用“指向指针的指针”:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetMemory2</span><span class="params">(<span class="keyword">char</span> **p, <span class="keyword">int</span> num)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * num); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test2</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>; </span><br><span class="line">    GetMemory2(&amp;str, <span class="number">100</span>); <span class="comment">// 注意参数是 &amp;str，而不是 str </span></span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello&quot;</span>); </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; str &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">free</span>(str); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="/2020/11/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.htm/指针的指针.png" alt></p><p>比较好的方法是 <strong>传指针的引用</strong>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetMemory</span><span class="params">(<span class="keyword">char</span> *&amp;p, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    GetMemory(str, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">free</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以用函数返回值来传递动态内存。这种方法更加简单：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">GetMemory3</span><span class="params">(<span class="keyword">int</span> num)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * num); </span><br><span class="line">    <span class="keyword">return</span> p; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test3</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>; </span><br><span class="line">    str = GetMemory3(<span class="number">100</span>); </span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello&quot;</span>); </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; str &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">free</span>(str); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在使用返回值时，千万别返回 <strong>指向“栈内存”</strong> 的指针、引用，因为该内存在函数结束时 <strong>自动消亡</strong> 了，返回的指针是个野指针了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">GetString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> p[] = <span class="string">&quot;hello world&quot;</span>; <span class="comment">//数组内容存储在栈区，函数结束时，会释放掉</span></span><br><span class="line">     <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    str = GetString();      <span class="comment">//因为非配的内存早已释放掉，此时的str是个野指针，内容是垃圾</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在函数中不定义数组，定义指针：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">GetString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> *p = <span class="string">&quot;hello world&quot;</span>; <span class="comment">//数组内容存储在静态区，函数结束时，不会释放掉</span></span><br><span class="line">     <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    str = GetString();      </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h4 id="杜绝“野指针”"><a href="#杜绝“野指针”" class="headerlink" title="杜绝“野指针”"></a>杜绝“野指针”</h4><p>“野指针”不是 NULL 指针，是指向“垃圾”内存的指针。“野指针”是很危险的，if 语句对它不起作用。出现的原因有：</p><ol><li>指针变量没有被初始化。任何指针变量刚被创建时不会自动成为 NULL 指针，它的缺省值是随机的。所以，指针变量在创建的同时应当被初始化，要么将指针设置为 NULL，要么让它指向合法的内存。</li><li>指针 p 被 free 或者 delete 之后，没有置为 NULL，让人误以为 p 是个合法的指针。</li><li>指针操作超越了变量的作用域范围。</li></ol><h4 id="有了-malloc-free-为什么还要-new-delete？"><a href="#有了-malloc-free-为什么还要-new-delete？" class="headerlink" title="有了 malloc/free 为什么还要 new/delete？"></a>有了 malloc/free 为什么还要 new/delete？</h4><p><strong>malloc 与 free</strong> 是 C++/C 语言的标准库函数，<strong>new/delete</strong> 是 C++ 的运算符。它们都可用于申请动态内存和释放内存。<br>对于非内部数据类型的对象而言，光用 <strong>malloc/free</strong> 无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于 <strong>malloc/free</strong> 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于 <strong>malloc/free</strong>。<br>而C++程序经常要调用 C 函数，而 C 程序只能用 <strong>malloc/free</strong> 管理动态内存，因此不能只用 <strong>new/delete</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">public</span> : </span><br><span class="line">    Obj(<span class="keyword">void</span>)&#123; <span class="built_in">cout</span> &lt;&lt; “Initialization” &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">    ~Obj(<span class="keyword">void</span>)&#123; <span class="built_in">cout</span> &lt;&lt; “Destroy” &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Initialize</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; “Initialization” &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Destroy</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; “Destroy” &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UseMallocFree</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Obj *a = (obj *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(obj)); <span class="comment">// 申请动态内存</span></span><br><span class="line">    a-&gt;Initialize(); <span class="comment">// 初始化</span></span><br><span class="line">    <span class="comment">//… </span></span><br><span class="line">    a-&gt;Destroy(); <span class="comment">// 清除工作</span></span><br><span class="line">    <span class="built_in">free</span>(a); <span class="comment">// 释放内存</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UseNewDelete</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Obj *a = <span class="keyword">new</span> Obj; <span class="comment">// 申请动态内存并且初始化</span></span><br><span class="line">    <span class="comment">//… </span></span><br><span class="line">    <span class="keyword">delete</span> a; <span class="comment">// 清除并且释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内存耗尽怎么办？"><a href="#内存耗尽怎么办？" class="headerlink" title="内存耗尽怎么办？"></a>内存耗尽怎么办？</h4><p>如果在申请动态内存时找不到足够大的内存块，<strong>malloc</strong> 和 <strong>new</strong> 将返回 <strong>NULL</strong> 指针，表示内存申请失败。<br>处理“内存耗尽”问题，一般可以通过判断指针是否为 <strong>NULL</strong>，是的话用 <strong>return</strong> 或 <strong>exit(1)</strong> 终止整个程序的运行，也可以自己为 <strong>new 和 molloc</strong> 设置异常处理函数。<br>如果一个函数内有多处需要申请动态内存，那么应该用 <strong>exit(1)</strong> 及时终止程序。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;内存管理&quot;&gt;&lt;a href=&quot;#内存管理&quot; class=&quot;headerlink&quot; title=&quot;内存管理&quot;&gt;&lt;/a&gt;内存管理&lt;/h2&gt;&lt;h3 id=&quot;内存管理详解&quot;&gt;&lt;a href=&quot;#内存管理详解&quot; class=&quot;headerlink&quot; title=&quot;内存管理详解&quot;&gt;&lt;/a&gt;内存管理详解&lt;/h3&gt;&lt;h4 id=&quot;内存分配方式&quot;&gt;&lt;a href=&quot;#内存分配方式&quot; class=&quot;headerlink&quot; title=&quot;内存分配方式&quot;&gt;&lt;/a&gt;内存分配方式&lt;/h4&gt;&lt;h5 id=&quot;分配方式简介&quot;&gt;&lt;a href=&quot;#分配方式简介&quot; class=&quot;headerlink&quot; title=&quot;分配方式简介&quot;&gt;&lt;/a&gt;分配方式简介&lt;/h5&gt;&lt;p&gt;在C++中，内存分为5个区：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;栈：执行函数时，函数内部局部变量存储单元在栈上创建，结束时自动释放。效率很高，但存储容量有限。&lt;/li&gt;
&lt;li&gt;堆：由 &lt;strong&gt;new&lt;/strong&gt; 分配的内存块，编译器不会自动释放，需要应用程序对应的 &lt;strong&gt;delete&lt;/strong&gt; 进行释放。如果没有释放，则程序运行结束后会由操作系统自动回收。&lt;/li&gt;
&lt;li&gt;自由存储区：由 &lt;strong&gt;malloc&lt;/strong&gt; 等分配的内存块，类似堆，由 &lt;strong&gt;free&lt;/strong&gt; 结束自己的生命。&lt;/li&gt;
&lt;li&gt;全局/静态存储区：存储全局变量和静态变量。&lt;/li&gt;
&lt;li&gt;常量存储区：存放常量，不允许修改。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="C++" scheme="https://www.benboby.top/categories/C/"/>
    
    
    <category term="C++内存管理" scheme="https://www.benboby.top/tags/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
</feed>
