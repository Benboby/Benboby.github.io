<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Benboby&#39;s Blog</title>
  
  
  <link href="https://www.benboby.top/atom.xml" rel="self"/>
  
  <link href="https://www.benboby.top/"/>
  <updated>2021-02-03T05:59:56.952Z</updated>
  <id>https://www.benboby.top/</id>
  
  <author>
    <name>Benboby</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>每日一题：滑动窗口中位数</title>
    <link href="https://www.benboby.top/2021/02/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%AD%E4%BD%8D%E6%95%B0.html"/>
    <id>https://www.benboby.top/2021/02/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%AD%E4%BD%8D%E6%95%B0.html</id>
    <published>2021-02-03T05:48:11.000Z</published>
    <updated>2021-02-03T05:59:56.952Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你一个数组 nums，有一个长度为 k 的窗口从最左端滑动到最右端。窗口中有 k 个数，每次窗口向右移动 1 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。$(n, k \in [1, 100000])$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>用优先队列+延迟删除有点麻烦，可以考虑直接用 <strong>multiset</strong> 做，本质都是一样的，维护两个大小相同或差一的集合（自动排序）$l 和 r$，$l$ 维护小于等于中位数的值，$r$ 维护大于等于中位数的值，$multiset$ 的优秀特性可以在 $log$ 时间复杂度内进行增删操作。具体细节较多，时间复杂度 $O(nlog(k))$。</p><a id="more"></a><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">medianSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">double</span>&gt; l, r;</span><br><span class="line">        <span class="keyword">int</span> n = a.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k) &#123;           <span class="comment">// 需要移除之前已经加入滑动窗口的元素</span></span><br><span class="line">                <span class="keyword">if</span> (l.count(a[i - k])) l.erase(l.find(a[i - k]));</span><br><span class="line">                <span class="keyword">else</span> r.erase(r.find(a[i - k]));</span><br><span class="line">            &#125;</span><br><span class="line">            l.insert((<span class="keyword">double</span>)a[i]);</span><br><span class="line">            <span class="keyword">while</span> (l.size() &amp;&amp; r.size() &amp;&amp; *(--l.end()) &gt; *r.begin()) &#123;   <span class="comment">// 左集合的元素不可能大于右集合</span></span><br><span class="line">                l.insert(*r.begin());</span><br><span class="line">                r.insert(*(--l.end()));</span><br><span class="line">                l.erase(*(--l.end()));</span><br><span class="line">                r.erase(*r.begin());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (l.size() - <span class="number">1</span> &gt; r.size()) &#123;            <span class="comment">// 左集合元素最多只会比右集合多一（窗口大小为奇数）</span></span><br><span class="line">                r.insert(*(--l.end()));</span><br><span class="line">                l.erase(--l.end());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;         </span><br><span class="line">                <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res.push_back(*(--l.end()));</span><br><span class="line">                <span class="keyword">else</span> res.push_back((*(--l.end()) + *r.begin()) / <span class="number">2.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给你一个数组 nums，有一个长度为 k 的窗口从最左端滑动到最右端。窗口中有 k 个数，每次窗口向右移动 1 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。$(n, k \in [1, 100000])$&lt;/p&gt;
&lt;h2 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h2&gt;&lt;p&gt;用优先队列+延迟删除有点麻烦，可以考虑直接用 &lt;strong&gt;multiset&lt;/strong&gt; 做，本质都是一样的，维护两个大小相同或差一的集合（自动排序）$l 和 r$，$l$ 维护小于等于中位数的值，$r$ 维护大于等于中位数的值，$multiset$ 的优秀特性可以在 $log$ 时间复杂度内进行增删操作。具体细节较多，时间复杂度 $O(nlog(k))$。&lt;/p&gt;</summary>
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="STL" scheme="https://www.benboby.top/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>C++语言基础</title>
    <link href="https://www.benboby.top/2021/01/C-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80.html"/>
    <id>https://www.benboby.top/2021/01/C-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80.html</id>
    <published>2021-01-31T06:52:21.000Z</published>
    <updated>2021-02-03T03:57:32.355Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="3e531eb1ae2421a6e2aee3be66ef30c4359a43ff0bc253272e0e435957a3006b">88bfb973b5cd9a98289a5356073cb3e561ba3d32e73d841574e69103b5f1f9aa8095f13827f92f3fcd28bd29b56a8b3e29573b2df647ec2fd6f2f057611047827f212ec0efafb1b8479dd8c9283a14d289becee0aef91ea3f7260387a5b1893da4bccc3757d4ed20d0609e0a8df818255e7b1b92cb9e80a95d4737f96ca45a349c70398d102152d6fa3535a62d0174de7b38e6cf920ed01da2a573796c1068cdecb495ba9af6b3240dc941b0c8c471c124b162cd27c5189d4291c1d51c1b28244f4ec5fb517cf1c89c09863904769e6af4258a74f4f6bd276d90bde2e55169d07ed8dcdf1868177a8572968da866f4a727f196e9ea4d90692fa05b833fea4100e50930d670d6c97af03871bb89376dbcac87e9af825c9b9fbe957502ca9696ef36cea1eb2126568944d271608a399e65b5e19e08cbc8a091486b89591a6b38b52f0729ef102d3e1e227dc1fc66ef555581158388e73323ce220986bf974c6913872d25ef4c73dacf99e2c36bc1f6626fba21d4d21cde8cfe3bb999c65f74a82513561262a8e7340f90648afcf3aa5f35590f32467cf3aaa404d51ed49cdabe31592fd617f2645b797641addfd83cccc2cd6f78367fdb27645272d7e1c824333c2818114a512c9c2b6ec7cba4e86fc8d007f6edcadb205246f471d8bfec3efb3a712f5639e353c3498d109c73daef7ac1df9e75c4080d20ff3bf456bafa3fb6b8148037af2735c1a3b621175071b533f3e00f25d3ccc7ac101ebccab823dc14976bcb5fc01ae54e5a410763cc5f621d7ef7282c9801462581866623bddf73a46a944f5ce81326cadc419e4e8ef249f6d0fd794b76492ff11fff5c51dd3c0bbc3f486197ea1a155d29369f112e2f2e8b1fa8efd86c13bb9fa1b2c0fa7b5db242db863b6154b6a8f710882db275ebc1017bb369e16c18e45d4dfbe4d01226ad0e31008020dec94f0e91eb127818701217cefc1db7883340791af35171150701aed9788da1beed4fdf4f734664872cb5fefc86f426dddcf6975796c716d2bd2454cabfa946bd9d7867e76c019cac5950099c2243fe90cbe2386693de549f47360b6d5478814856e725457a5c3b3dddf68f6ecd5b4ba5b1a762e2a1a04da12217c0bbdbc3d7e05a94a6325407188d6bf48e9be556e44c6c2e8a9e5209f16a96c5c39354db24620c8eb23caf286c2a078af8da365de083537c3ea7ac01a8c1c165b7fe149389adc68ef8677de5d232ed2a4ff79c14e605d78e35c1e688b8d8aa2703b9d287195276ad9478394a0efe9b648c2ca57a0c2751b02f7fdbc08f14f962e43e56e386781e7a4b68d9a958b2a8912ea59b9f098d3c67b45be73adee124738a215aa0bf19b1ec605637943dac1afe8e90849adba3820eb244917e572e88e9d1c25c3f4a530b7e37e6dae063ccdcae754916f4608220a7b3e0d4a1d8d88ccd34656937cb171520921abc42d12783b99934998e233f9ddaeeccec9c5902e064ac80bebc2cf6612b7e78126a321952b7069b6c0335b2eaf8661bd93bc3074f9a5797547a5c9d640082553f2a502129b801d76d3ce45480e40401d539524292883da7e59c19ee4b0db8829475cc71ddde488d1faf13eaf78d687e7f8479e0622c48b7ad6f795847cfe3acfeb84d8462a8262dd60e5fd74dd87e7eee50a1740fec37ff65a4c9973ee3c101fdb036f222b8c26c8dc22c6e720fff75b713ff39c8cffdb98051e8179864d4acac03c02f737c37dd1f2a69d39577b520681c9047038e67142455886416266097accde0f01984e9eac4a02c2759bac0d9c0c5d36418e81812fd1779ce76a1a5174ac08f50b977096e338a3ed5f2f46255432aae46a5b376d91414d9f10d5c73ce31599f25f48f7dc32f51553e132591f2bca1d608cc8357fb980b1884b2749154550f9ff387157a37fffa487bef6219ea23eb386930da7730f90c74393f54b987ef3199d8cb1efc94367f3be0f5c10b0fde953d5f9b0670756de43c751a0422493a7318e76714a92dc4d061956957dbe4294aff050b2117b895608f10478754ab5148bbc721c5b82dafc80ffed02268a3bc02f0d7af97df9cf194593544043666ac7923b16e019a387aacba70a0cbb9386e7820157f92ff3a14d4665c2adfa34b2dd8a1bcaad7bed40c5d5f6952a1ddc1554de22d4ea8d12dd9847bb8635891da23a6fdbb1ca66e65df3619a9d9f8fd2727e3dd16ab7a3037fd0536de9deb12b6efac71a4cdc187765c9bf187fdf86bf14f35e9f020ade0bb3ac7f765ba279705628b84dc9dde2f1326d8085a2e88e48c5f8a8742a615118b9c0aa23756a8154012ea60d5c8734c834fffaa9c5a555cad81353af1325a794066fdb18ccb48c6af37460156bba464dee6fdc93b423d0e9abdd9e9fe2f031c784eee0817f14688d2d9ce6581acd8cfc0c51ba9522b03bc8b23cd246aae58e1e411143701bd39b72b4f72ceecb527e89c2859f4692f474243534878799b250608e8258cd900ca83b793e1d96b25ea79490c40589e888f5d23cde332977ab41f0733749bc6a75ff3acb1dc58095af2137e01b854809de38f04b343bad6fba2e9e330838898a6f1dd7b40a0ef968bbaf46e8ae4b0b76e1b27bd95c0e29cc327d854dec4ca4eb88247bf8f4677121cc2c6d5705e2e23d89ae6978d60c4033a96a98a1aa9d6a24d66d6aa6a969c314c7c82ea53586a59578a9166a1ea8eec5b565edbf16e33e1d12bef15c0fd8476e99c2d5822b150489e4fb8ccef429406929d96ead9eb4323ad8ecf718fc4ee1687d220a84088aa1c6836421d47073c04e39114de5a60e887940b1d906561a6c3c23fea5805da819a71c3ad7fcb1c39c927a45a67f34a8469b9a915d0ca17fabe9ffa010e6e35eca68cd7006a6b3147138e9dc2d33e5d9506f46013e579ed7e9c109ae03550a639c36c6fb2318806c29dc76133b57a0210164463da4ff7a0a37d5ee3d0bae0261757ac58b158cc49efe1a0035e97b78be9e4d4a086b4fa8b873cbf847acf4ce2f6bb3a61369bc6a905c6a402244d25ceb813643a584f8ff2188feee079d88638e5af638e1efdd13d4cf756c38d87a77af5807f1392eb6bc877bf21184bd2d313374e29ffd9649a020bca221cd553423bdd223ed2e3fe82f4993e9cb8c4636a27746a68cd9f096e301e63d871eb270e2f5bbfd058dbee7dd37cef6195ee21a2ae49709316004263172ea2b2470a33add1df0125ad42453daf68bf0a4e1023092bb3062897dfe26de8b3246299a60001655cc67c97dab9658a3414b61cc3effead7cba5d9fa74bc28c534869eec647ec2cfe4df4b11654550428f88ae6921e4a91448c793351fe33f614fa77ca7c22366d751e3da163751f220b4112bf9bed1b806382d41b71887a3a5b8ffac8009c3e6373cfef5a7a79ca7f6598df766bcabf38a6112451017f2781f65336d8fc23af6fe14299870b4d5edc0c888f81683ea418913ddb22a49ef22c772658d7b554544abefbf28ad780f972b883ac4416ea0a9cdccb32a13052e696972c2577815d8610e155fcc2a5e0d94d5c82a946d015ec080a810ad6eb84827545d64f192a585f168d5fd66d6487ecfbb64559475056c36faee6149562fccc4a31b92b2282b3e7c4e7e2a8f6d40c549cc16b5ae010dc00ef430689b33419878d81fcd063da579a6f1d73d3f69a59b83607b00caab17184aae7e6d051a6c3e8c0661852db0ad6d1c961e68b4ac2f374dc95d9f138fd77763a42c2031cf3bc86c93bbb7933694e8cf408133b168815f48e73f507d2018d3c0dece03be3674704ece8489322dc3de35a6616a778dd94e373aefc5c75386121be68fc4f9782846d80ec18ac3b40cbba21943e1ff59c306ea494dc5e932f16e839ebc0dcb43d9ff63b62571787681bcd5f52070ac0450ee92344f7f0ea85db7e27cfd4d77a09ba18eda3b12a30e373cfde3b52d92389f8b700ab388a311e9291ced6e85bd491d2fbe0a6046ce5547e0d9f74b6ec9677778dff5a259fe0cb588d3dfcb47d148257ea9bf19d1d1a17ab0da6a509c98e0cbdf46df3062132edbed42a5af5bd44781ff86f1c54dc25e5022f9829ab59c3a65c0f3a4e43e7b574e92c249da61a2c394412233da98aa318ab866e30c7d3ad604ec3a3d7a25e8e16c6446f729459d6b08c68651571c14259e5196027840a03d9ba34c8631ab45e5bd23bcb779403524edff94f3a50d3af0f89a8ebee3254b4f18e3192eb1c5c04cf1f4f83636889aa3a3e5bd1afab95a348db967bed4ff544cc92398ceee609f6ca2bae7d2343aada1f84aef3ffff0dbad21098f5f62bb9f0949661b2d711492759dc56005698eb8d927309cba76cde3bb964c5da3e9339919b907cb240da9fa9836ad89a6e02c88e94b4fa3bdb4232b80d760a5e64970dcbf8b89b35c77e30768cac5329b08966b49a6bbfb5060114b1e2759e16a6a618479a5dcccaf588a785d0a487d23aa8f76fd0e0d130688c33a02bcd4b88ff22acbebe9243bfc3e74f3916b96303e5457303f00f8977eb75b3d6499862874857c30e8d76bf578c3cfa70c2f1ab15674551fe0a6f9f89d6e426144c26dafc7d1c497e7f14bbdb625a947be7f8be6ba21d84c25984c6d8b54a1c4f26c165a82bc9a897924b8f1b780d9d3c67317cf1cfa6c7fb816bc9b3952ea7b233e3e461911021b1039811e0be77f9206a3c9c62aae678f8cb443737959f7ed7d9142be6af4f889506b7acc7fd78fc007781fd3d194e91116af56b70649b7feccb4bc844e417d74bbba8dfa5d47665810bd93cbe68db6bf9cb268bd3ee6db3a6cfd80c5c126f0daa0e422ea9f422aaf784c5fe5de3c91ec2cd93a6643aaabc152cee9ae9e5e469c3cdb17ed35309a49d7c812e6d2dbbe81a6dd72423614be1e48fe41f89bfa2f562b24e313cb99c07893765c23ddd9a6be7c5fe11307cb980786dcf32c24cd65eaecb911a23e978e32b9dd5016ccdacf1c4177b74121950c0611fb0737b494430dd7c0c87946a5ea547668847d270baf4a2ef7ef2e8fbf328d150934866f524ce6f794e38ea18aacd69e7311c19d60c320e98e85c733e70b09b4c077d8bfebf6895161ec3c6ea3d496e7e461475f1d2e4ac25ace293fc6b3ebfcf997c93d64a13b8e871851279461afc8d11a540a2347beeff308e93f1ba8852a919cb4781989eddb006cf9dcded1d39f04f81dec4275c4f2adddf4b8b383ee60893ec1da4c023b9f14bf452924c7a105ecd13a17ebe0f2e2927cec59fea752156579234c4baf99ac70bb5b97c4e6cd8cde45b9848405403e757c2654474b38275c22c946fabe49dfea4b9afeee0162c5c4238b7625129dd8f75a52c844872b538881f904c10db6cc19e03c369f8d70f2c341123d48303f66f89ca52dfe016d7777808e771010058b005627b0e6b809b6c7405d93b3bbdb02ce1bba8f876fb07e929e2cdc94f2b81848165e62a54d14fe63bf45bc304ee7e4999787d890d8b5b5c0eaf97852921a0db49cb268b5f00fbde0d732189534bdb4ce69a08e925ca5641c43f61e4075a2a54d156c778067fd09cb1308e743f5cbc85825d2fe826c3ff600e5744e63d8d43e2bbdb6669ea7f7222d25a0742ab4d65fccaaee67599d18833757099f679c966442912d354271f90ef8d2493564c7da81d3a6aa4eb9f82b1b94a05f24bdcc8cda64e3d2da7bcad4e85cb023632a4ad630d1caa604f047476588cbdb022c814ea890ad4eaef5f32a1c423ed1753efa3026ac4a5aedd5f734a2d501c78e6e8facfc003006c5c67e21122299467750734bc48f715635b92d5dffa8bd980eaa6c8f36c5a2a77483e85bdef14e644139ba658bba399d0c309005e3860c7ef5249e2a5588879fe1d3f12825576e4e54b822de2c87bd2c0eb565e8301b719675a60c32bdb1597033dc5fd83d9e6e51793c989cbcfce081b982cdf5c95f0a10f301e73070606e1bf60fa54e569b7c94ccd9da50d05e15308382b1ae32315f67e37cf26c7d44c7924c14288c803e74ac507c479c450cc05f5187725c833a3757011c99361d070c97b3c5967adc7648b96e7d1b90ef08745a9b41cfe35ba306e513aba10081c701f7e67d1cd1a0f879861f524bd144752c5b1de410be36202b2bba940e9ba44d00e378002e23e1ef3a0dd3e519fd58219be36556d6e5cafcf6dfcb7ae7aa3789b4b06d94f299c9647b6822ad2bb73e4a5f1091063b5ec6445b49de5c74f7f07ee50d85136d91ee54bd80be4af18f3d66d1d80b3d9c8a745a4190977af206f66d3b4b7d28dd67a305fd911a2e8bf0246fc1d9d37f70a07d3e1c221113336d3cb695be14278119e8da696fb89560c506a555fe3fe102007e6aa3476483541d9d08806be36574bdf2a814aa0150d8a526a3ee8e9503d91c2010e90dcd5103f592c6b2b8a35055bcc9a6e7880e86a81e43ef017299a0e6ae86946c72d0d13049fccf2ed07483f446e514a06bb260590931ecfdac14faf6ce48c15a5dfdba9ff27b6e1e452baaba84f986e3b6b3e9aba83872aab48d767f1df1f94b884aa3963fa70a3494fa40cd936beccd7ac0fdfed6bb35f413b1a0cd6e84fcf9128ffae851254c3b46cd194c2529b051bcb795617789fd0d9a0d1d8598b91c3ac982d04806d62cceded08d1f54c0533f0cb29c9df5c6f878813193783074a776720a503802e182f3d140d9ff0b9bf7b4b8fa6252aa6fab0f5ea1ad6b43bf59292ba85841e275bf59380bebdc5462fc16156f5c15220708e9cc009d6c30dd1019c89fd48be7ca575a344649990309a544fab14379fbd3e3cb319917bde5d6350f60fdb23c8191d85270b9cd52309edd7108e50e80057d4c8ede0b87d9fcf578498f276dea768fbf7bcae758649a80a9759051e385c353a80b61fb831ac159f3ebabb69500f22845d5a63960998b71d6b754661361a5220cdb6ad371619967d569e4d94f6cf60192df66710f177b77f33a3cea2320c3fcedf60abed9684e875c8a9277a1ae5e985794a36a529d52c94f199dc7c8bbdeacf34f6accc2aae7d834fa1f9ae2ced0a584345b0f14d4b7983d725e1b7005e4c8f44ec3489ddb8b8afca7d1bf9cbd4b535ea4f47cb3f62ebfa1ccb8a973c301eade97cf7a1142d6f95990bb6421c67397af3c496161cb21c6b79665305508a1ae4740a05878a33a7807404d2e046351a9c7de76b5f6e868780cb19ea69e0ce638a8b3cdfd69cb86943ed874fd78a6ee895eaee3f8018bade93dc2a83d2a073d221a06cb1f95e2cd2bc9ae82448d9fced320e23711cc53f46af7a3c05143e7070ae3e75ef7e64d6eff78c5d6a7c65b09c6b28aa2e2125a086ee9fae88a17c45238ec4f8a2b8cafc55f186561578f3a1b6bd8976a18e2e7c334fe44d41abeffad97d35f0cefdde8dea9e6a52ce678ca6cf885b97dd5f0fd2ef538d8a9038abbec3b2a00da5b3642d63831a12b48fb00899b0c3d188a1413abf970845e9c6bb1192ab1193bd7c91a3391ef77bcf59a58190b0c6d13bfb1b0e21912e8f08def75ec3d54bc09d48a1c1054397e4735012e03d2f6e7d3468f33e85f7a3ca747d98ea7e7a225546386c6ce96dea722f9a121bf9bb9561959c18ade3bf09c08a318ea30b6c24217957080e194bb4a029d3a4c2daf76c3b2fcd805955512f546db77472b00d68c35b140612da7d71aa520116d7588ae18e2675810efc161c86708330790d4a1dc45bfdbfc5803dfa59b730e62ec012f5b6f2f9bdea0d2d4158f276e5b17f3284686260ac05ce669af548ee0fc5bf2509d103f4f2e731183519df678694c0754072773f91403e9c32abbb2cdca5420ea2ad142b20ad01f07a5749fa857231e50e74ff3a67d7f3bd36fc9b7f06b79ed451e39174074d62197814e4d450d4e8b34a0b07dbd56a032a24e1448c8c093e61253725632dd27cc263dce0f482d8ae2a981eb841966bbdb84e2a6eaacbb25dc8e81247aad45758cafc5235d0ff44edf5ea14f26ca58fc92fe6ed835abe3980d1e0c576a294399cea2de1c83538b5322aaaa94e76202e892404d156a4eea9de44668ee4f531eb136fc6b1e4fd061e5c1cabd93f87729066135e5326820d0047447fefeba71274da93263053b4fe27e7fc11c155f6d4ba885a4df4cc631f24896ec7e6fc28afde5d28e152d2f433b0b6caa43ccd9fb2b4d37d015402cf658517af15ad4a5b007e21cab18684daa6bb65375b6ee82dbffa2d3cbe187bad687d951254ad79272c5cce4c4b4abf6c9ef86a9c3157cb89fd4476dee37d37b56cc0c8d29e17c9777049ab9ff0d133a7c5951cb17899b46ccc0d7944bfc52e509d8cf93104d834950a54c64cb2f2f9119abfefb3c47dadc3fde38810118f3d1f0dbad65baadd0d63de3ec63ea685c89df4890bc4473d9718d1a7fbb6beebba19f25eda11ac99905d3041f35cac4a8c16b017aa70e3100385875ed7175d19c4d319dc4b2047f091983995b19df71a0f007ed603c3190cbf6e1c974fd2465ae9c5903e940bd79f72d324157310ce609617ec9dd776d102b30c0ffe4216c2d27fe45ed016ac0d4c1f7c6e5e7dcdb7e776e1307e18afa6e5a8d570de0acae4f8926d57ac0d07e0b62a36c404ed3b495a6cba7a7379487383e22fa39fe3d9af79740fa5119f51fc00134a9f1cc223519f2c79313010f24395839a5861a6564fad183131ff572ed2339dd82e4db4e8cc0f25ede205772731ba3df80c4fcff1e415dab967aee0f3178a2063436d859efa00ef232b17c46b410110eee9e30f07f6eb4b5c581ee6093f61aa9aceb053a208248dfb8cae8aca165e9be01fbe3ea80302cf4121e3b912337b81391987ac0e99f78fc6a4478ee19623ac73dd39729f2a24815042e58ffbc0551230f9ea372bb7a0b17737bd2f61d7b561f0397c17f57608489b372acb92a4396af953c4733c8aadfa12ebaff25bbb410c4610a22590943eca8386657952d1dad6cb59f03a4bb5d7c8605ceaec79ecc359f72f46412fc66afd1a1da8330b8fbb4cdf86bf60a25e0345d3015b03a8b9137d59f53230c8634f53a524cda20bf1de4721d92f5c52bcc3574dc43f4bf9a9550423d4a5c5d096feb49d1fee3966380e8d16b18db26824edcb9e73359e215dcdc422124b778ee9da99ee5885766fe67cb3a8f5d97abd245d76de93a2fec5ab9f2772759061dbb7a47631cb26524f41a00f53fdde346c6a59c3c62408dbdf31a73798d4230603c4c5289a1630133542adb9337420f4fcab267922885d39cf213c494fdf1c355329d544e2393b02e2a8c4a6159ae5cfeaaa15691af46ee1b88eb6a2d2cbc2f8e6ebccad3ee5f6b786b198cd5c2a36698e463bc614e56e5e1b9bbc0b795e7b8e3688819a39b5d89b1ab47e204503ecc49b7376ba1eee64c49561b977020c27edae222ce60940d7df7f7cc11b1720554e00eac0e493d964a0d739db4c0b3846c54001751e34998324660976ad52ed6578e3ed8f15ac1a08d522cd4f8ada682a7180598d34e185c32f5184a741268ca8ee107fc357c02037706fbc08757ec948be2482a11c308e69678ba59f1b32252c57ff92ddb32be1145c4fadd286720628c45cfd54381e79f43a439b9d888b956d8bd2446a1b275a2b303f61c9bfa6cc3df386484aeb41ae5fc2ea6be5793a53705c13736f8bd8d7e251ac68cd027c550c0293fe0d0fe3243509d3d27df3f74f157cb8fd5e9e3dbdc65d120b1c583b00f1c83fa53fad95be70628627a9b451c2b627fb0b0119e80f1411c6824be048be36db313b25e7cabc487b76b7a305b30c77c61ffef5d0aaa2df8e2831150b910af7c260ba981bec5427858fca01d20d93ea91bde25314969e0a91737ff21361bafc3b51fd99f845fc16087550df4b21d2c6b83ef57787104bad12a9f30d422fbb945cdc6ca43d517ea4aa6ecbd384c00f3e179547a241657c158a32fa1e61bb4de998f9bfafe4f120991ed5d6361f652032e81604703d214d26693b1ab403435391bfcb21dc192f4b85940d9cca15a3bd4473d0177de79eae25fe7d0ec48d6825b8d4be1eeb99cb92c50330f9742cd2f63eedf4fa539b675b650558e12d6b5af84a7c759246f89aef57eeef0c055f8237e369b880431bbe6c638d822214b4d36b432302b74d647491fad606b7e234a1690b5f587b1c44f595473848b6f58cbb1b3441110d1611fb2b89f7061fc445bca01e7e8df218234c19c9b01c6e07ffad17647e9f8c1d3fe8fe5df60b2e3466355934f67132bdf24116e307601d49626680966faaa5b3dfaa50759cad8c59cc8d8fabfae958c49fab4d187222b5de358a3856f1c76ba8e6a43fdeb17bd945b8195658ab396371bcc17063ad68e96f4357ed426ab8fde0d31776c97b72c055d422487284ecb9782fc06438db6a8f129e7a31a31302ef2405f39329386cd0f0a0a4d6a9c47246bfe4cb9aa49f365b70e9e788a841104dc05614bb17d7ab8b609cf84dbb0e69f07daaea02ac5380ff1276f392e8110552dcbdbccd483cea0d52b732ed8c3789ccd86634dccefb61257e95c4d174982e5fc086e124de4c749e8c442b2aa1cceeaf8e903f533cd07833c09e78c4a7083031f2334c5edebcca585f786aaa01839eecd96dcf01f4aca2759c7769aeb86cd89d35bc3bfe578d50686428502528ba3db8957f113e8145e660c05ef01fb76a65b4e12c5908c145bce9fb00e366a44f5d715d470cabe3eb774ca633d70f260e3cdc340eb31c4b30b996fd96266ea14b60ff82a5cfe3621f8b2419c10a140116d40840084d231c68ee706f00d9098e7b085e281b16c1240f154710b337a81670c1f3a9ba9f58f007bfe439ff26c53f87f8dfa6e4f2e5b3ec5413103a93b73172195ac5161a4769a62261b024cd87743ad3436e0ebf8af80fc6932c417bd5f2baceba1dbd5be14684ebe1f9189cc237b0036714ee2a9b78dc82b9095f19f78ccbd7b1f6255e27c05fd21e7761f6c8d24cfb10d6fe6dde1ad76f97f4de9a84af95c306c741f46c3c98c6a0cca25c212f94e0fa52331a6e5c3825153d1a9d120f354f7b86a1aa1de6ad658260de50185213cc4f0f9b80672f6f6e1515dfa07dd0bfd31bb9ab96ae60ef582a9071590a32f2b2bc96737cdcb1fddcc0029120aa63580c24c388e739086e3d9f2a83f09372249f23952f5c0ab6aa344ab8ae3a2be33832a3eb25e45fc8760629e99dd7ad7a3ec24130c93e5e7f28d68d9b9d827278c01419443eb0f7d19da365afd7912c1f716bd07c42601c7aacf129803207e8a76a05833d563b0e11e083f5be62898170df5b3ec14247c8cb768e55490216f06c85491f203d8d538754037bb8146d2a013473ff424e7059fe9fca584d0a25cda9ca3b02c1e9051b65f94d3274211fe1f081fe63e257573e9285d49f4b6b9a8ed969b9f755d5d3880f513d28838f7f841e7f105577f7d444071f1d439bc6c78eda910c437ee61dd8aa149ea37d9e3354a9be4d39713120e638db52ea86fd042f98888c6602991e4e9ed8e479548faf3a8beb911f1df08897886f09518b51434fe82eec7adbc54f1d2b76129cca84dcb5a9258ee2bf269ce570ae9bc6f618dbd8c935de8c8291b02ac4befe71dd439f9914a4dad6299377e0769850939e5386e5da05a5f6fd7cb32ed30ea58788f38f2055681bd9e8952aa1b37306287e2184e980559b3282fa2d2905ff68de4f3c8a436e2063cdc3d1457d9eef7b8d7cfb2101eda4365acd05a5b6f0266023f91cc62ede77418aa22e76b03336c7f100727972e48262499c76eba9d83bfcf73ac6db5de8eabccfe152cc8aabc01e1f107303dc561bf843fc8cede11c1a8a3d39f91eb99fbf9ddd95311c96aaa40dfc8953755b6c3f9fbb04f4992b193c476670f4a8e4ad1e9e4799c1607b6691a7ea33655f76eca4b3eea2314b9c11b946af8ccff5bf231e7f9e95fcaf5b884c92f2ae94118ad5cd627212e556aa5815d3370fd00281ae7c5af897eb49b2d275682570d977e0a41e8c601d3730b352cd15ff0f6cd88779ed28f079e4ea4b25d7fef5083d4eb43773cf7e5ecb5c02247981f457b275cd7c9178333a248cee696ce462b53714d49577823b661bcf079d88c50e60ee2163fc9c7f4b006db9486b2bc9a2a6d7669bcc3dc530091f755f95ab213e38bdc2b52fa82588f49834883012ae367c9fc211d3d593d9239edb12064dc38cf37bcd94917ced913fea748cb3af1585312b0c39a1cfa8e0963340e7147604faa64cc65a66be4344b9d11ac4613db9d14c1b0b76b96f295776e226e4e4ac9f52c3a7ec1eae02033664416423e1f3d3c50b7ff4af7572c0725feb3c17ce01549638285c56e96e1680923124d8795556f334142524d378430d2c7387cd5e65c1b98e566f0e7e26eb8ba2217bc5a719584fc7b0d4d1bd44bee52259f033127b3d36470cb6b176685c4f9d05bd4af743c647bf0fb0f96013f62031a2dc1395cfd21bb69134c98886c74b2ee762019ddecbe43f89d24a52b17cfa6955fb7939035c7d99e34d2fdb3ca119d5d3be834aafe1284fbfd303254300c22bca94b0a650f93237336364cd4f91b473c7d651b04d7b03a96c27473093260ae33cf6d199f4185efe0393f58aaac719fc3909c7b37f51749b4d36c1860070a5b6ade92a0d1ad314a985c8baf8c2865bcb94f5d6fe151c7bcb82193a9306dc769f54b5167429cdc6a8c7d7968c7b7336b7583c0d50dce2379e7c44d607d9699fa5a25022e1ed0b3f55f93bfd9ae99bc620a89e91ccf21d38ca9758914e2aefb64163aff2d9b9d62b1f55c4293ce32987f84bde14716b9af988d06847218a3a3e</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="C++" scheme="https://www.benboby.top/categories/C/"/>
    
    
    <category term="C++基础" scheme="https://www.benboby.top/tags/C-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：最小体力消耗路径</title>
    <link href="https://www.benboby.top/2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.html"/>
    <id>https://www.benboby.top/2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.html</id>
    <published>2021-01-29T01:02:03.000Z</published>
    <updated>2021-01-29T01:47:37.414Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个 $nm$ 的权值矩阵，求从左上角走到右下角。$(n, m \in [1, 100], w \in [1, 1e6])$</p><p>一条路径耗费的体力值是路径上相邻格子之间 <strong>高度差绝对值的最大值</strong> 决定的。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ol><li>二分答案：由于答案具有单调性，所以可以二分答案，然后通过 $bfs$ 进行验证。</li><li>并查集：类似于最小生成树，将所有的边都建出来，然后贪心的将当前权值最小的边加入集合，判断起点和终点是否联通即可。</li><li>最短路：将所有的边建出来，做一次起点到终点的最短路径即可。</li></ol><a id="more"></a><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仅给出第二种做法的代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 并查集模板</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; size;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="comment">// 当前连通分量数目</span></span><br><span class="line">        <span class="keyword">int</span> setCount;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        UnionFind(<span class="keyword">int</span> _n): n(_n), setCount(_n), parent(_n), size(_n, <span class="number">1</span>) &#123;</span><br><span class="line">            iota(parent.begin(), parent.end(), <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">findset</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> parent[x] == x ? x : parent[x] = findset(parent[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            x = findset(x);</span><br><span class="line">            y = findset(y);</span><br><span class="line">            <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (size[x] &lt; size[y]) &#123;</span><br><span class="line">                swap(x, y);</span><br><span class="line">            &#125;</span><br><span class="line">            parent[y] = x;</span><br><span class="line">            size[x] += size[y];</span><br><span class="line">            --setCount;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            x = findset(x);</span><br><span class="line">            y = findset(y);</span><br><span class="line">            <span class="keyword">return</span> x == y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> x, y, w;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumEffortPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = h.size(), m = h[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;Node&gt; g;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>) g.push_back(Node&#123;i * m + j, i * m + j - m, <span class="built_in">abs</span>(h[i][j] - h[i - <span class="number">1</span>][j])&#125;);</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) g.push_back(Node&#123;i * m + j, i * m + j - <span class="number">1</span>, <span class="built_in">abs</span>(h[i][j] - h[i][j - <span class="number">1</span>])&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(g.begin(), g.end(), [](Node&amp; a, Node&amp; b) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="function">UnionFind <span class="title">uf</span><span class="params">(n * m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : g) &#123;</span><br><span class="line">            uf.unite(p.x, p.y);</span><br><span class="line">            <span class="keyword">if</span> (uf.connected(<span class="number">0</span>, n * m - <span class="number">1</span>)) <span class="keyword">return</span> p.w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给定一个 $nm$ 的权值矩阵，求从左上角走到右下角。$(n, m \in [1, 100], w \in [1, 1e6])$&lt;/p&gt;
&lt;p&gt;一条路径耗费的体力值是路径上相邻格子之间 &lt;strong&gt;高度差绝对值的最大值&lt;/strong&gt; 决定的。&lt;/p&gt;
&lt;h2 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;二分答案：由于答案具有单调性，所以可以二分答案，然后通过 $bfs$ 进行验证。&lt;/li&gt;
&lt;li&gt;并查集：类似于最小生成树，将所有的边都建出来，然后贪心的将当前权值最小的边加入集合，判断起点和终点是否联通即可。&lt;/li&gt;
&lt;li&gt;最短路：将所有的边建出来，做一次起点到终点的最短路径即可。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="并查集" scheme="https://www.benboby.top/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="图论" scheme="https://www.benboby.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：解码异或后的排列</title>
    <link href="https://www.benboby.top/2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%A7%A3%E7%A0%81%E5%BC%82%E6%88%96%E5%90%8E%E7%9A%84%E6%8E%92%E5%88%97.html"/>
    <id>https://www.benboby.top/2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%A7%A3%E7%A0%81%E5%BC%82%E6%88%96%E5%90%8E%E7%9A%84%E6%8E%92%E5%88%97.html</id>
    <published>2021-01-24T01:10:06.000Z</published>
    <updated>2021-01-28T06:02:23.360Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你一个整数数组 $g$，它是前 $n$ 个正整数的排列，且 $n$ 是个 <strong>奇数</strong> 。</p><p>它被加密成另一个长度为 $n - 1$ 的整数数组 $a$ ，满足 $a[i] = g[i]$ ^ $g[i + 1]$。比方说，如果 $g = [1,3,2]$，那么 $a = [2,1]$。</p><p>给你 $a$ 数组，请你返回原始数组 $g$。题目保证答案存在且唯一。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><a id="more"></a><p>可以发现如果对 $a$ 数组做前缀异或和得到 $sum$ 数组，那么 $sum[i]$ 就表示 $g[0]$ ^ $g[i + 1]$ 的值。$n$ 恰好为奇数，因此如果将数组 $sum$ 全部异或起来，$g[0]$ 刚好为被异或偶数次而抵消，得到的结果为 $g[1]$ ^ $g[2]$ ^ … ^ $g[n]$，恰好只有 $g[0]$ 没有出现。然后将这个结果与 $1-n$ 的所有数异或，得到的就是 $g[0]$ 的值，然后递推即可。时间复杂度 $O(n)$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">decode</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.size(), sum = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">g</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) g[<span class="number">0</span>] ^= (sum ^= a[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++) g[<span class="number">0</span>] ^= i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) g[i + <span class="number">1</span>] = g[i] ^ a[i];</span><br><span class="line">        <span class="keyword">return</span> g;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给你一个整数数组 $g$，它是前 $n$ 个正整数的排列，且 $n$ 是个 &lt;strong&gt;奇数&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;它被加密成另一个长度为 $n - 1$ 的整数数组 $a$ ，满足 $a[i] = g[i]$ ^ $g[i + 1]$。比方说，如果 $g = [1,3,2]$，那么 $a = [2,1]$。&lt;/p&gt;
&lt;p&gt;给你 $a$ 数组，请你返回原始数组 $g$。题目保证答案存在且唯一。&lt;/p&gt;
&lt;h2 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h2&gt;</summary>
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="思维" scheme="https://www.benboby.top/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：最小高度树</title>
    <link href="https://www.benboby.top/2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91.html"/>
    <id>https://www.benboby.top/2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91.html</id>
    <published>2021-01-14T10:32:21.000Z</published>
    <updated>2021-01-28T06:02:23.354Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一颗树，求当树的高度最小时根的编号为多少。$(n \in [1, 2e4])$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给定一颗树，求当树的高度最小时根的编号为多少。$(n \in [1, 2e4])$&lt;/p&gt;
&lt;h2 id=&quot;Solution&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="树" scheme="https://www.benboby.top/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：交换字符串中的元素</title>
    <link href="https://www.benboby.top/2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E4%BA%A4%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0.html"/>
    <id>https://www.benboby.top/2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E4%BA%A4%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0.html</id>
    <published>2021-01-12T10:06:55.000Z</published>
    <updated>2021-01-28T06:02:23.361Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你一个字符串 $s$，以及该字符串中的一些「索引对」数组 $pairs$，其中 $pairs[i] = [a, b]$ 表示字符串中的两个索引（编号从 $0$ 开始）。</p><p>你可以 任意多次交换 在 $pairs$ 中任意一对索引处的字符。</p><p>返回在经过若干次交换后，$s$ 可以变成的按字典序最小的字符串。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><a id="more"></a><p>假设 $i$ 可以和 $j$ 交换，$j$ 可以和 $k$ 交换，那么 $i$ 就可以和 $k$ 交换，因此是具有传递关系的。因此将互相具有传递关系的索引看作一个集合，用并查集维护。然后对于每个集合，将字母从小到大排序放置即可。时间复杂度 $O(nlog(n))$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> fa[<span class="number">100005</span>], v[<span class="number">100005</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fa[x] == x ? x : fa[x] = find(fa[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">smallestStringWithSwaps</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) fa[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : pairs) &#123;</span><br><span class="line">            <span class="keyword">int</span> fx = find(p[<span class="number">0</span>]), fy = find(p[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (fx != fy) fa[fx] = fy;</span><br><span class="line">            v[p[<span class="number">0</span>]] = v[p[<span class="number">1</span>]] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; id[<span class="number">100005</span>];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; ch[<span class="number">100005</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!v[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> fx = find(i);</span><br><span class="line">            <span class="keyword">if</span> (!mp[fx]) mp[fx] = ++cnt;</span><br><span class="line">            id[mp[fx]].push_back(i);</span><br><span class="line">            ch[mp[fx]].push_back(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">            sort(ch[i].begin(), ch[i].end());</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ch[i].size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="keyword">int</span>)id[i].size(); j++) </span><br><span class="line">                s[id[i][j]] = ch[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给你一个字符串 $s$，以及该字符串中的一些「索引对」数组 $pairs$，其中 $pairs[i] = [a, b]$ 表示字符串中的两个索引（编号从 $0$ 开始）。&lt;/p&gt;
&lt;p&gt;你可以 任意多次交换 在 $pairs$ 中任意一对索引处的字符。&lt;/p&gt;
&lt;p&gt;返回在经过若干次交换后，$s$ 可以变成的按字典序最小的字符串。&lt;/p&gt;
&lt;h2 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h2&gt;</summary>
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="并查集" scheme="https://www.benboby.top/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>Nginx学习笔记</title>
    <link href="https://www.benboby.top/2021/01/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
    <id>https://www.benboby.top/2021/01/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</id>
    <published>2021-01-10T10:06:30.000Z</published>
    <updated>2021-02-04T04:42:35.086Z</updated>
    
    <content type="html"><![CDATA[<h2 id="nginx源码包目录结构"><a href="#nginx源码包目录结构" class="headerlink" title="nginx源码包目录结构"></a>nginx源码包目录结构</h2><p>总目录：<br><img src="/2021/01/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.htm/nginx目录.png" alt></p><ol><li>auto/：编译相关脚本，可执行文件configure会用到<br> <img src="/2021/01/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.htm/auto目录.png" alt><ul><li>cc/：检查编译器脚本</li><li>lib/：检查依赖库脚本</li><li>os/：检查操作系统类型的脚本</li><li>type/：检查平台类型的脚本</li></ul></li><li>CHANGES：版本更新，修复功能说明<br> CHANGES.ru：俄语版本</li><li>conf目录：默认的配置文件</li><li>configure：编译nginx之前必须执行该脚本以生成一些必要的中间文件</li><li>contrib/：脚本和工具，典型的是vim高亮工具</li><li>html/：欢迎界面和错误界面相关的html文件</li><li>man/：nginx帮助文档</li><li>src/：源码目录<br> <img src="/2021/01/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.htm/src目录.png" alt><ul><li>core：核心代码</li><li>event：event（事件）模块相关代码</li><li>http：http（web服务）模块相关代码</li><li>mail：邮件模块相关代码</li><li>os：操作系统相关代码</li><li>stream：流处理相关代码</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;nginx源码包目录结构&quot;&gt;&lt;a href=&quot;#nginx源码包目录结构&quot; class=&quot;headerlink&quot; title=&quot;nginx源码包目录结构&quot;&gt;&lt;/a&gt;nginx源码包目录结构&lt;/h2&gt;&lt;p&gt;总目录：&lt;br&gt;&lt;img src=&quot;/2021/01/Ngi</summary>
      
    
    
    
    
    <category term="hide" scheme="https://www.benboby.top/tags/hide/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：货仓选址</title>
    <link href="https://www.benboby.top/2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%B4%A7%E4%BB%93%E9%80%89%E5%9D%80.html"/>
    <id>https://www.benboby.top/2021/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E8%B4%A7%E4%BB%93%E9%80%89%E5%9D%80.html</id>
    <published>2021-01-09T12:09:30.000Z</published>
    <updated>2021-01-28T06:02:23.350Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>在数轴上找到一个点，使得到其余 $n$ 个点距离之和最小。$(n \in [1, 1e5])$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>考虑绝对值不等式：<br><a id="more"></a> </p><p>当只有两个点 $a, b$ 时，有 $|a - x| + |b - x| &gt;= |a - b|$，为了满足 $|a - x| + |b - x| = |a - b|$ 关系，$x$ 必须选在 $a,b$ 两点之间。</p><p>拓展为 $n$ 个点，距离为 $|a[1] - x| + |a[2] - x| + … + |a[n - 1] - x| + |a[n] - x|$，收尾两两分组有 $(|a[1] - x| + |a[n] - x|) + (|a[2] - x| - |a[n - 2] - x| + …)$，两两应用绝对值不等式，$x$ 的位置必须满足在各个对应区间里。</p><p>得出结论：当 $n$ 为奇数时，$x$ 位置为中间那个点（因为刚好分组多出单独一个，满足最小性则必须将 $x$ 的位置选择为那个点，距离刚好为 $0$）；当 $n$ 为偶数时，$x$ 位置为中间两个点之间的任意位置都可。 </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, res, a[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    sort(a, a + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) res += <span class="built_in">abs</span>(a[i] - a[n &gt;&gt; <span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;在数轴上找到一个点，使得到其余 $n$ 个点距离之和最小。$(n \in [1, 1e5])$&lt;/p&gt;
&lt;h2 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h2&gt;&lt;p&gt;考虑绝对值不等式：&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="数学" scheme="https://www.benboby.top/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：按要求补齐数组</title>
    <link href="https://www.benboby.top/2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%8C%89%E8%A6%81%E6%B1%82%E8%A1%A5%E9%BD%90%E6%95%B0%E7%BB%84.html"/>
    <id>https://www.benboby.top/2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%8C%89%E8%A6%81%E6%B1%82%E8%A1%A5%E9%BD%90%E6%95%B0%E7%BB%84.html</id>
    <published>2020-12-29T05:09:57.000Z</published>
    <updated>2021-01-28T06:02:23.357Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个已排序的正整数数组 $nums$，和一个正整数 $n$ 。从 $[1, n]$ 区间内选取任意个数字补充到 $nums$ 中，使得 $[1, n]$ 区间内的任何数字都可以用 $nums$ 中某几个数字的和来表示。请输出满足上述要求的最少需要补充的数字个数。</p><h2 id="Soluiton"><a href="#Soluiton" class="headerlink" title="Soluiton"></a>Soluiton</h2><p>容易证明，对于正整数 $x$，如果区间 $[1,x−1]$ 内的所有数字都已经被覆盖，且 $x$ 在数组中，则区间 $[1,2x−1]$ 内的所有数字也都被覆盖。<br><a id="more"></a> </p><p>由此可以提出一个贪心的方案。每次找到未被数组 $nums$ 覆盖的最小的整数 $x$，在数组中补充 $x$，然后寻找下一个未被覆盖的最小的整数，重复上述步骤直到区间 $[1,n]$ 中的所有数字都被覆盖。</p><p>具体实现：</p><p>$x$ 表示当前能表示出 $[1, x - 1]$ 的所有数字，初始化为 $1$，枚举数组。</p><ul><li>若枚举到的数小等于 $x$，则加上，表示能表示出 $[1, x + num[i] - 1]$ 的所有数字，然后下标加 $1$</li><li>若枚举到的数大于 $x$，则说明 $x$ 无法被表示出来，我们需要增加一个数 $x$，然后$x$ 加上 $x$，表示能表示出 $[1, x + x - 1]$ 的所有数字</li></ul><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPatches</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, i = <span class="number">0</span>, m = a.size();</span><br><span class="line">        <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; m &amp;&amp; a[i] &lt;= x) &#123;</span><br><span class="line">                x += a[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                x *= <span class="number">2</span>;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给定一个已排序的正整数数组 $nums$，和一个正整数 $n$ 。从 $[1, n]$ 区间内选取任意个数字补充到 $nums$ 中，使得 $[1, n]$ 区间内的任何数字都可以用 $nums$ 中某几个数字的和来表示。请输出满足上述要求的最少需要补充的数字个数。&lt;/p&gt;
&lt;h2 id=&quot;Soluiton&quot;&gt;&lt;a href=&quot;#Soluiton&quot; class=&quot;headerlink&quot; title=&quot;Soluiton&quot;&gt;&lt;/a&gt;Soluiton&lt;/h2&gt;&lt;p&gt;容易证明，对于正整数 $x$，如果区间 $[1,x−1]$ 内的所有数字都已经被覆盖，且 $x$ 在数组中，则区间 $[1,2x−1]$ 内的所有数字也都被覆盖。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="贪心" scheme="https://www.benboby.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：最大矩形</title>
    <link href="https://www.benboby.top/2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2.html"/>
    <id>https://www.benboby.top/2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2.html</id>
    <published>2020-12-26T06:52:52.000Z</published>
    <updated>2021-01-28T06:02:23.348Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个仅包含 $0$ 和 $1$ 、大小为 $n * m$ 的二维二进制矩阵，找出只包含 $1$ 的最大矩形，并返回其面积。$(n, m \in [1, 200])$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>有一个子问题，求柱状图最大矩形。预先求出 $1-i$ 层的 $h[i]$ 然后利用套用子问题的模板即可，复杂度 $O(n * m)$.<br><a id="more"></a> </p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; h)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        st.push(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> n = h.size();</span><br><span class="line">        vector&lt;int&gt; l(n), r(n, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (st.top() != <span class="number">-1</span> &amp;&amp; h[st.top()] &gt;= h[i]) &#123;</span><br><span class="line">                r[st.top()] = i;</span><br><span class="line">                st.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            l[i] = st.top();</span><br><span class="line">            st.push(i); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) res = max(res, (r[i] - l[i] - <span class="number">1</span>) * h[i]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = a[<span class="number">0</span>].size(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">h</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) </span><br><span class="line">                h[j] = (a[i][j] == <span class="string">&#x27;1&#x27;</span> ? h[j] + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">            res = max(res, largestRectangleArea(h));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给定一个仅包含 $0$ 和 $1$ 、大小为 $n * m$ 的二维二进制矩阵，找出只包含 $1$ 的最大矩形，并返回其面积。$(n, m \in [1, 200])$&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;p&gt;有一个子问题，求柱状图最大矩形。预先求出 $1-i$ 层的 $h[i]$ 然后利用套用子问题的模板即可，复杂度 $O(n * m)$.&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="思维" scheme="https://www.benboby.top/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：共鸣问题</title>
    <link href="https://www.benboby.top/2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%85%B1%E9%B8%A3%E9%97%AE%E9%A2%98.html"/>
    <id>https://www.benboby.top/2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%85%B1%E9%B8%A3%E9%97%AE%E9%A2%98.html</id>
    <published>2020-12-23T13:46:43.000Z</published>
    <updated>2021-01-28T06:02:23.347Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>现在有 $n$ 个音符和 $m$ 对共鸣关系，编号为 $1-n$，每个音符自己有一个奏响时的优美程度，共鸣关系 $(x,y,z)$ 表示音符 $x$ 和 $y$ 同时奏响的额外优美程度是 $z$，同时不奏响则为 $-z$，其他情况为 $0$，求最大优美程度。$(n,m \in [1,1e5])$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对于一对共鸣关系而言，在不选的情况下收益为 $-z$，则选择一个的话，收益为 $-z + z = 0$，都选择的话为 $-z + 2z = z$。因此可以预先把每对关系的两个数都加上 $z$，刚开始我们是不选任何有联系的音符的，因此初值为 $-z$，那么选择一个数就会加上 $z$，选择两个就会加上 $2z$，满足了之前所讨论的关系。答案初始化为所有关系都不选的情况，即 $-sum(z)$，然后只要贪心的选择对答案有正贡献的值就行了。<br><a id="more"></a> </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param n int整型 </span></span><br><span class="line"><span class="comment">     * @param m int整型 </span></span><br><span class="line"><span class="comment">     * @param a int整型vector </span></span><br><span class="line"><span class="comment">     * @param b int整型vector&lt;vector&lt;&gt;&gt; </span></span><br><span class="line"><span class="comment">     * @return long长整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">wwork</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; c;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : a) c.push_back(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : b) &#123;</span><br><span class="line">            c[v[<span class="number">0</span>] - <span class="number">1</span>] += v[<span class="number">2</span>];</span><br><span class="line">            c[v[<span class="number">1</span>] - <span class="number">1</span>] += v[<span class="number">2</span>];</span><br><span class="line">            res -= v[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : c) res += max(x, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;现在有 $n$ 个音符和 $m$ 对共鸣关系，编号为 $1-n$，每个音符自己有一个奏响时的优美程度，共鸣关系 $(x,y,z)$ 表示音符 $x$ 和 $y$ 同时奏响的额外优美程度是 $z$，同时不奏响则为 $-z$，其他情况为 $0$，求最大优美程度。$(n,m \in [1,1e5])$&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;p&gt;对于一对共鸣关系而言，在不选的情况下收益为 $-z$，则选择一个的话，收益为 $-z + z = 0$，都选择的话为 $-z + 2z = z$。因此可以预先把每对关系的两个数都加上 $z$，刚开始我们是不选任何有联系的音符的，因此初值为 $-z$，那么选择一个数就会加上 $z$，选择两个就会加上 $2z$，满足了之前所讨论的关系。答案初始化为所有关系都不选的情况，即 $-sum(z)$，然后只要贪心的选择对答案有正贡献的值就行了。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="贪心" scheme="https://www.benboby.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：大逃离</title>
    <link href="https://www.benboby.top/2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%A4%A7%E9%80%83%E7%A6%BB.html"/>
    <id>https://www.benboby.top/2020/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%A4%A7%E9%80%83%E7%A6%BB.html</id>
    <published>2020-12-22T14:28:30.000Z</published>
    <updated>2021-01-28T06:02:23.343Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>从 $n$ 个数中任选 $k$ 个数，取得这 $k$ 个数中最大的一个数，求每个数被取得的概率。$(n, k \in [1, 2e5])$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>将数组排序后，枚举每个数被作为最大值的可能性，当第 $i$ 个数作为最大值时，其它 $k - 1$ 个一定从前 $i - 1$ 个里面选，即方案数为 $C(i - 1, k - 1)$，将其除以总方案数 $C(n, k)$ 即为被取得概率。<br><a id="more"></a> </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param n int整型 </span></span><br><span class="line"><span class="comment">     * @param k int整型 </span></span><br><span class="line"><span class="comment">     * @param Point int整型vector </span></span><br><span class="line"><span class="comment">     * @return int整型vector</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> f[<span class="number">200005</span>];</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">qp</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (b) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b &amp; <span class="number">1</span>) sum = sum * a % mod;</span><br><span class="line">            a = a * a % mod;</span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == m || m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> f[n] * qp(f[m], mod - <span class="number">2</span>) % mod * qp(f[n - m], mod - <span class="number">2</span>) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">city</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">auto</span> b = a;</span><br><span class="line">        sort(a.begin(), a.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">long</span> <span class="keyword">long</span>&gt; mp;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= <span class="number">200000</span>; ++i) &#123;</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &gt;= k) </span><br><span class="line">                mp[a[i]] = C(i, k - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = C(n, k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            g.push_back(mp[b[i]] * qp(sum, mod - <span class="number">2</span>) % mod);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> g;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;从 $n$ 个数中任选 $k$ 个数，取得这 $k$ 个数中最大的一个数，求每个数被取得的概率。$(n, k \in [1, 2e5])$&lt;/p&gt;
&lt;h2 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h2&gt;&lt;p&gt;将数组排序后，枚举每个数被作为最大值的可能性，当第 $i$ 个数作为最大值时，其它 $k - 1$ 个一定从前 $i - 1$ 个里面选，即方案数为 $C(i - 1, k - 1)$，将其除以总方案数 $C(n, k)$ 即为被取得概率。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="数学" scheme="https://www.benboby.top/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>GCC编译器和GDB调试器</title>
    <link href="https://www.benboby.top/2020/12/GCC%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8CGDB%E8%B0%83%E8%AF%95%E5%99%A8.html"/>
    <id>https://www.benboby.top/2020/12/GCC%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8CGDB%E8%B0%83%E8%AF%95%E5%99%A8.html</id>
    <published>2020-12-20T06:09:48.000Z</published>
    <updated>2021-01-31T06:51:45.883Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GCC编译器"><a href="#GCC编译器" class="headerlink" title="GCC编译器"></a>GCC编译器</h2><p>GCC 编译器支持编译 Go、Objective-C，Objective-C++，Fortran，Ada，D 和 BRIG（HSAIL）等程序。</p><p>实际使用中，使用 gcc 指令编译 C 代码，使用 g++ 指令编译 C++ 代码。</p><h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p>例如 <strong>g++ test.cpp -o test</strong> 可拆解为以下步骤：</p><a id="more"></a> <ol><li><p>预处理</p> <figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># -E 选项指示编译器仅对输入文件进行预处理</span></span><br><span class="line"><span class="meta"># test.i 文件将头文件及宏定义具体内容全部展开，其余保持不变</span></span><br><span class="line">g++ -E test.cpp -o test.i    <span class="comment">// 生成.i文件</span></span><br></pre></td></tr></table></figure></li><li><p>编译</p> <figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># -S 编译选项告诉 g++ 在为 C++ 代码产生了汇编语言文件后停止编译</span></span><br><span class="line"><span class="meta"># g++ 产生的汇编语言文件缺省拓展名是 .s</span></span><br><span class="line"><span class="meta"># test.s 汇编语言文件内容为汇编指令</span></span><br><span class="line">g++ -S test.i -o test.s</span><br></pre></td></tr></table></figure></li><li><p>汇编</p> <figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># -c 选项告诉 g++ 仅把源代码编译为机器语言的目标代码</span></span><br><span class="line"><span class="meta"># 缺省时 g++ 建立的目标代码文件有一个 .o 的拓展名</span></span><br><span class="line"><span class="meta"># test.o 为机器语言识别的二进制代码</span></span><br><span class="line">g++ -c test.s -o test.o</span><br></pre></td></tr></table></figure></li><li><p>链接</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -o 编译选项来为将产生的可执行文件用指定的文件名</span></span><br><span class="line"><span class="comment"># test 为可执行文件</span></span><br><span class="line">g++ <span class="keyword">test</span>.o -o <span class="keyword">test</span></span><br></pre></td></tr></table></figure><h3 id="g-重要编译参数"><a href="#g-重要编译参数" class="headerlink" title="g++重要编译参数"></a>g++重要编译参数</h3></li><li><p>-g 编译带调试信息的可执行文件</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -g 选项告诉 GCC 产生能被 GNU 调试器 GDB 使用的调试信息，以调试程序。</span></span><br><span class="line"><span class="comment"># 产生带调试信息的可执行文件 test（不加则 test 不包含调试信息）</span></span><br><span class="line">g++ -g <span class="keyword">test</span>.cpp -o <span class="keyword">test</span></span><br></pre></td></tr></table></figure></li><li><p>-O[n] 优化源代码</p> <figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 所谓优化，比如省略代码中从未使用过的变量，直接将常量表达式用结果值来替代等等，这些操作会缩减目标文件所包含的代码量，提高最终生成的可执行文件的运行效率。</span></span><br><span class="line"><span class="meta"># -O 选项告诉 g++ 对源代码进行基本优化。这些操作在大多数情况下都会使程序执行的更快。-O2 选项告诉 g++ 产生尽可能小和尽可能快的代码。</span></span><br><span class="line"><span class="meta"># -O 同时减小代码长度和执行时间，效果等价为 -O1</span></span><br><span class="line"><span class="meta"># -O0 表示不做优化</span></span><br><span class="line"><span class="meta"># -O1 默认优化</span></span><br><span class="line"><span class="meta"># -O2 除了完成 -O1 的优化之外，还进行一些额外的调整工作，如指令调整等</span></span><br><span class="line"><span class="meta"># -O3 包括循环展开和其他一些与处理特性相关的优化操作</span></span><br><span class="line"><span class="meta"># 选项将使编译的速度比使用 -O 时慢，但通常产生的代码执行速度会更快</span></span><br><span class="line"><span class="meta"># 可以用如 &quot;time ./test&quot; 来查看可执行文件的运行效率，比较优化效果</span></span><br><span class="line">g++ -O2 test.cpp</span><br></pre></td></tr></table></figure></li><li><p>-l 和 -L 指定库文件 ｜ 指定库文件路径</p> <figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># -l 参数就是用来指定程序要链接的库，-l 参数紧接着就是库名</span></span><br><span class="line"><span class="meta"># 在 /lib 和 /usr/lib 和 /usr/local/lib 里的库可以直接用 -l 来进行链接</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 链接 glog库</span></span><br><span class="line">g++ -lglog test.cpp</span><br><span class="line"></span><br><span class="line"><span class="meta"># 如果库文件没放在上面三个目录里，需要使用 -L 参数指定库文件所在目录</span></span><br><span class="line"><span class="meta"># -L 参数紧接着的是库文件所在的目录名</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 链接 mytest 库，libmytest.so 在 /home/Test 目录下</span></span><br><span class="line">g++ -L/home/Test -lmytest test.cpp</span><br></pre></td></tr></table></figure></li><li><p>-I 指定头文件搜索目录</p> <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 若头文件在 /usr/<span class="keyword">include</span> 目录下一般是不需要指定的，否则就需要 -I 参数来指定了，比如头文件放在 /myinclude 目录里，否则会报错 “xxxx.<span class="keyword">h</span>: <span class="keyword">No</span> such <span class="keyword">file</span> or directory” 。</span><br><span class="line"><span class="keyword">g</span>++ -I/myinclude <span class="keyword">test</span>.cpp</span><br></pre></td></tr></table></figure></li><li><p>-Wall 打印警告信息 | -w 关闭警告信息</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印出 gcc 的警告信息</span></span><br><span class="line">g++ -Wall <span class="keyword">test</span>.cpp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭所有警告信息</span></span><br><span class="line">g++ -w <span class="keyword">test</span>.cpp</span><br></pre></td></tr></table></figure></li><li><p>-std=c++11 设置编译标准</p> <figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span> <span class="comment">使用</span> <span class="comment">c</span>++<span class="comment">11</span> <span class="comment">标准编译</span> <span class="comment">test</span><span class="string">.</span><span class="comment">cpp</span></span><br><span class="line"><span class="comment">g</span>++ <span class="literal">-</span><span class="comment">std=c</span>++<span class="comment">11</span> <span class="comment">test</span><span class="string">.</span><span class="comment">cpp</span></span><br></pre></td></tr></table></figure></li><li>-o 指定输出文件名 <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定即将产生的文件名</span></span><br><span class="line"><span class="comment"># 指定输出可执行文件名为test</span></span><br><span class="line">g++ <span class="keyword">test</span>.cpp -o <span class="keyword">test</span></span><br></pre></td></tr></table></figure></li><li><p>-D 定义宏</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 在使用gcc/g++编译的时候定义宏</span><br><span class="line"># 常用场景：</span><br><span class="line"># -DDEBUG 定义 DEBUG 宏，可能文件中有DEBUG宏部分的相关信息，用 DDEBUG 来选择开启或关闭 DEBUG</span><br><span class="line"># 举例：</span><br><span class="line"><span class="comment">// -Dname 定义宏 name，默认定义内容为字符串 “1”</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;DEBUG LOG\n&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;in\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1. 在编译的时候，使用g++ -DDEBUG main.cpp</span></span><br><span class="line"><span class="comment">// 2. 第七行代码可以被执行</span></span><br></pre></td></tr></table></figure><h2 id="GDB调试器"><a href="#GDB调试器" class="headerlink" title="GDB调试器"></a>GDB调试器</h2></li></ol><p>GDB(GNU Debugger) 是一个用来调试C/C++程序的功能强大的调试器，是 Linux 系统开发 C/C++ 最常用的调试器。</p><p>GDB主要功能：</p><ul><li>设置断点(断点可以是条件表达式)</li><li>使程序在指定的代码行上暂停执行，便于观察</li><li>单步执行程序，便于调试</li><li>查看程序中变量值的变化</li><li>动态改变程序的执行环境</li><li>分析崩溃程序产生的core文件</li></ul><p>调试开始：执行gdb [filename] ，进入gdb调试程序，其中 filename 为要调试的可执行文件名。</p><p>编译程序时需要加上 -g，之后才能用 gdb 进行调试：g++ -g main.cpp -o main<br>回车键：重复上一命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">help</span>(h)        <span class="comment"># 查看命令帮助，具体命令查询在gdb中输入help + 命令</span></span> </span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)run(r)         <span class="comment"># 重新开始运行文件（run-text：加载文本文件，run-bin：加载二进制文件）</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)start          <span class="comment"># 单步执行，运行程序，停在第一行执行语句</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)list(l)        <span class="comment"># 查看原代码（list-n,从第n行开始查看代码。list+ 函数名：查看具体函数）</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">set</span>            <span class="comment"># 设置变量的值</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)next(n)        <span class="comment"># 单步调试（逐过程，函数直接执行）</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)step(s)        <span class="comment"># 单步调试（逐语句：跳入自定义函数内部执行）</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)backtrace(bt)  <span class="comment"># 查看函数的调用的栈帧和层级关系</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)frame(f)       <span class="comment"># 切换函数的栈帧</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)info(i)        <span class="comment"># 查看函数内部局部变量的数值</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)finish         <span class="comment"># 结束当前函数，返回到函数调用点</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">continue</span>(c)    <span class="comment"># 继续运行</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">print</span>(p)       <span class="comment"># 打印值及地址</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)quit(q)        <span class="comment"># 退出gdb</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">break</span>+num(b)                 <span class="comment"># 在第num行设置断点</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)info breakpoints             <span class="comment"># 查看当前设置的所有断点</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)delete breakpoints num(d)    <span class="comment"># 删除第num个断点</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)display                      <span class="comment"># 追踪查看具体变量值</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)undisplay                    <span class="comment"># 取消追踪观察变量</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)watch                        <span class="comment"># 被设置观察点的变量发生修改时，打印显示</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)i watch                      <span class="comment"># 显示观察点</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">enable</span> breakpoints           <span class="comment"># 启用断点</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">disable</span> breakpoints          <span class="comment"># 禁用断点</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)x                            <span class="comment"># 查看内存x/20xw 显示20个单元，16进制，4字节每单元</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)run argv[1] argv[2]          <span class="comment"># 调试时命令行传参</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(gdb)<span class="built_in">set</span> follow-fork-mode child   <span class="comment"># Makefile项目管理：选择跟踪父子进程（fork()）</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;GCC编译器&quot;&gt;&lt;a href=&quot;#GCC编译器&quot; class=&quot;headerlink&quot; title=&quot;GCC编译器&quot;&gt;&lt;/a&gt;GCC编译器&lt;/h2&gt;&lt;p&gt;GCC 编译器支持编译 Go、Objective-C，Objective-C++，Fortran，Ada，D 和 BRIG（HSAIL）等程序。&lt;/p&gt;
&lt;p&gt;实际使用中，使用 gcc 指令编译 C 代码，使用 g++ 指令编译 C++ 代码。&lt;/p&gt;
&lt;h3 id=&quot;编译过程&quot;&gt;&lt;a href=&quot;#编译过程&quot; class=&quot;headerlink&quot; title=&quot;编译过程&quot;&gt;&lt;/a&gt;编译过程&lt;/h3&gt;&lt;p&gt;例如 &lt;strong&gt;g++ test.cpp -o test&lt;/strong&gt; 可拆解为以下步骤：&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://www.benboby.top/categories/C/"/>
    
    
    <category term="C++基础" scheme="https://www.benboby.top/tags/C-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：区间和的个数</title>
    <link href="https://www.benboby.top/2020/11/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%8C%BA%E9%97%B4%E5%92%8C%E7%9A%84%E4%B8%AA%E6%95%B0.html"/>
    <id>https://www.benboby.top/2020/11/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%8C%BA%E9%97%B4%E5%92%8C%E7%9A%84%E4%B8%AA%E6%95%B0.html</id>
    <published>2020-11-07T15:39:51.000Z</published>
    <updated>2021-01-28T06:02:23.355Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 $a$，返回区间和在 $[lower, upper]$ 之间的个数，包含 $lower$ 和 $upper$。<br>区间和 $S(i, j)$ 表示在 $a$ 中，位置从 $i$ 到 $j$ 的元素之和，包含 $i$ 和 $j$ $(i ≤ j)$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><a id="more"></a> <p>维护前缀和，对于每个前缀和 $sum[i]$，等价于 $sum[0…i-1]$ 里面有多少个数满足差值在 $[lower, upper]$ 之间。</p><p>$sum[i] - sum[j] = [lower, upper]$ 等价于求出现在区间 $sum[j] \in [sum[i] - upper, sum[i] - lower]$ 的数的个数，故可以用树状数组维护。</p><p>遍历前缀和数组，对于当前前缀和 $sum[i]$，满足的个数便为：$query(sum[i] - lower) - query(sum[i] - upper - 1)$，累加答案即可。</p><p>由于数很大，故需要将所有出现的数离散化。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BIT</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span>* c;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        BIT(<span class="keyword">int</span> _n) &#123;</span><br><span class="line">            n = _n;</span><br><span class="line">            c = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) c[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">                c[x]++;</span><br><span class="line">                x += lowbit(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x) &#123;</span><br><span class="line">                sum += c[x];</span><br><span class="line">                x -= lowbit(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countRangeSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> lower, <span class="keyword">int</span> upper)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> m = a.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> *sum = <span class="keyword">new</span> <span class="keyword">long</span> <span class="keyword">long</span>[m + <span class="number">1</span>];</span><br><span class="line">        sum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i) sum[i] = sum[i - <span class="number">1</span>] + a[i - <span class="number">1</span>];</span><br><span class="line">            s.insert(sum[i]);</span><br><span class="line">            s.insert(sum[i] - upper);</span><br><span class="line">            s.insert(sum[i] - lower);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">int</span> n = s.size(), idx = <span class="number">0</span>;</span><br><span class="line">        <span class="function">BIT <span class="title">bit</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : s) mp[x] = ++idx;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = mp[sum[i] - upper], r = mp[sum[i] - lower];</span><br><span class="line">            res += bit.query(r) - bit.query(l - <span class="number">1</span>);</span><br><span class="line">            bit.add(mp[sum[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个整数数组 $a$，返回区间和在 $[lower, upper]$ 之间的个数，包含 $lower$ 和 $upper$。&lt;br&gt;区间和 $S(i, j)$ 表示在 $a$ 中，位置从 $i$ 到 $j$ 的元素之和，包含 $i$ 和 $j$ $(i ≤ j)$。&lt;/p&gt;
&lt;h2 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h2&gt;</summary>
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="树状数组" scheme="https://www.benboby.top/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>C++内存管理</title>
    <link href="https://www.benboby.top/2020/11/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"/>
    <id>https://www.benboby.top/2020/11/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html</id>
    <published>2020-11-02T03:12:51.000Z</published>
    <updated>2021-02-03T03:57:33.635Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="内存管理详解"><a href="#内存管理详解" class="headerlink" title="内存管理详解"></a>内存管理详解</h3><h4 id="内存分配方式"><a href="#内存分配方式" class="headerlink" title="内存分配方式"></a>内存分配方式</h4><h5 id="分配方式简介"><a href="#分配方式简介" class="headerlink" title="分配方式简介"></a>分配方式简介</h5><p>在C++中，内存分为5个区：</p><ol><li>栈：执行函数时，函数内部局部变量存储单元在栈上创建，结束时自动释放。效率很高，但存储容量有限。</li><li>堆：由 <strong>new</strong> 分配的内存块，编译器不会自动释放，需要应用程序对应的 <strong>delete</strong> 进行释放。如果没有释放，则程序运行结束后会由操作系统自动回收。</li><li>自由存储区：由 <strong>malloc</strong> 等分配的内存块，类似堆，由 <strong>free</strong> 结束自己的生命。</li><li>全局/静态存储区：存储全局变量和静态变量。</li><li>常量存储区：存放常量，不允许修改。</li></ol><a id="more"></a> <h5 id="明确区分堆和栈"><a href="#明确区分堆和栈" class="headerlink" title="明确区分堆和栈"></a>明确区分堆和栈</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在栈内存中存放了一个指向一块堆内存的指针 p。程序会先确定在堆中分配内存的大小，然后调用 <strong>operator new</strong> 分配内存，然后返回这块内存的首地址，放入栈中。</p><p>这里并没有释放内存，因此需要 <strong>delete[] p</strong>，告诉编译器删除的是数组，然后编译器根据Cookie信息去释放内存。</p><h5 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h5><ol><li>管理方式：栈由编译器自动管理，无需手动控制；堆的释放工作由程序员控制，容易产生内存泄露。</li><li>空间大小：堆栈的内存都可以自己设定，堆内存一般不超过系统内存都是可以申请，栈内存个人测试默认值为8M。</li><li>碎片问题：对于堆而言，频繁的 <strong>new/delete</strong> 势必会造成内存空间的不连续，造成大量的碎片，使程序的效率降低；对于栈而言，则不会发生这样的情况，先进后出排列有序，以至于永远不可能有一个内存块从非栈顶位置弹出。</li><li>生长方向：对于堆而言，生长方向向上，向着内存地址增加的方向增长；对于栈而言，生长方向向下，向着内存地址减小的方向增长。</li><li>分配方式：堆都是动态分配的，没有静态分配的堆。栈有动态分配和静态分配两种，静态分配由编译器完成，比如局部变量的分配；动态分配由 <strong>alloca</strong> 函数进行分配，都由编译器进行释放。</li><li>分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持，这就决定了栈的效率比较高。堆则是 C/C++ 函数库提供的，机制比较复杂，用到许多算法的实现内存的分配。显然，堆的效率比栈要低得多。</li></ol><p>因此，更推荐尽量使用栈而不是堆。但是栈和堆相比并不灵活。如果需要分配大量内存空间，还是堆好一些。</p><h4 id="控制-C-的内存分配"><a href="#控制-C-的内存分配" class="headerlink" title="控制 C++ 的内存分配"></a>控制 C++ 的内存分配</h4><p>无论如何，一定要保守的使用内存分配。<br>一个防止堆破碎的通用方法是从不同固定大小的内存池中分配不同类型的对象。对每个类重载 <strong>new</strong> 和 <strong>delete</strong> 就提供了这样的控制。</p><h5 id="重载全局的new和delete操作"><a href="#重载全局的new和delete操作" class="headerlink" title="重载全局的new和delete操作"></a>重载全局的new和delete操作</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">void</span> *p = <span class="built_in">malloc</span>(size); </span><br><span class="line">    <span class="keyword">return</span> (p); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *p)</span></span>; </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">free</span>(p); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以对单个类的 new 和 delete 操作符重载。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *p)</span></span>; </span><br><span class="line">    <span class="comment">// .. other members here ... </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">void</span> *TestClass::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">void</span> *p = <span class="built_in">malloc</span>(size); <span class="comment">// Replace this with alternative allocator </span></span><br><span class="line">    <span class="keyword">return</span> (p); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> TestClass::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *p)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">free</span>(p); <span class="comment">// Replace this with alternative de-allocator</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="为单个类重载-new-和-delete"><a href="#为单个类重载-new-和-delete" class="headerlink" title="为单个类重载 new[] 和 delete[]"></a>为单个类重载 new[] 和 delete[]</h5><p>C++将对象数组的内存分配作为一个单独的操作，而不同于单个对象的内存分配。为了改变这种方式，同样需要重载 new[] 和 delete[]操作符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">void</span> * <span class="keyword">operator</span> <span class="keyword">new</span>[ ](<span class="keyword">size_t</span> size); </span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[ ](<span class="keyword">void</span> *p); </span><br><span class="line">    <span class="comment">// .. other members here .. </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">void</span> *TestClass::<span class="keyword">operator</span> <span class="keyword">new</span>[ ](<span class="keyword">size_t</span> size) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">void</span> *p = <span class="built_in">malloc</span>(size); </span><br><span class="line">    <span class="keyword">return</span> (p); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">void</span> TestClass::<span class="keyword">operator</span> <span class="keyword">delete</span>[ ](<span class="keyword">void</span> *p) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">free</span>(p); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    TestClass *p = <span class="keyword">new</span> TestClass[<span class="number">10</span>]; </span><br><span class="line">    <span class="comment">// ... etc ... </span></span><br><span class="line">    <span class="keyword">delete</span>[ ] p; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：对于多数 C++ 的实现，<strong>new[]</strong> 操作符中的个数参数是数组的大小加上额外的存储对象数目的一些字节。因此应该尽量避免分配对象数组，使内存分配策略简单。</p><h4 id="常见的内存错误"><a href="#常见的内存错误" class="headerlink" title="常见的内存错误"></a>常见的内存错误</h4><ol><li>内存分配未成功，却使用了它。<ul><li>如果是用 malloc 或 new 来申请内存，应该用 if(p==NULL) 或 if(p!=NULL)进行防错。</li></ul></li><li>内存分配虽然成功，但未初始化就引用它。<ul><li>无论用何种方式创建数组，都要赋初值，即便是零值。</li></ul></li><li>内存分配成功并且已经初始化，但操作越界。<ul><li>多发生在下标“多1”或“少1”。</li></ul></li><li>忘记了释放内存，造成内存泄漏。<ul><li>动态内存的申请与释放必须配对，程序中 <strong>malloc</strong> 与 <strong>free</strong> 的使用次数一定要相同，否则肯定有错误（new/delete同理）。</li></ul></li><li>释放了内存却继续使用它。<ul><li>程序过于复杂，难以分清是否释放了内存，此时应当重新设计数据结构，解决混乱。</li><li>return语句写错，不要返回指向“栈内存”的指针或引用，因为该内存在函数体结束时被自动销毁。</li><li>free或delete释放内存后，没有将指针设为NULL，导致“野指针”。</li></ul></li></ol><h4 id="指针与数组对比"><a href="#指针与数组对比" class="headerlink" title="指针与数组对比"></a>指针与数组对比</h4><p>数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。数组名对应着（<strong>而不是指向</strong>）一块内存，其地址和容量在生命周期内保持不变，只有数组的内容可以改变。</p><p>指针可以随时指向任何类型的内存块，它的特征是“可变”的，所以常用指针来操作动态内存，指针远比数组灵活，但也更危险。</p><h5 id="修改数组内容"><a href="#修改数组内容" class="headerlink" title="修改数组内容"></a>修改数组内容</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[] = “hello”; </span><br><span class="line">a[<span class="number">0</span>] = ‘X’; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"><span class="comment">// 可以拆分为 char s[] = &quot;world&quot;; char *p = str;</span></span><br><span class="line"><span class="keyword">char</span> *p = “world”; <span class="comment">// 注意 p 指向常量字符串</span></span><br><span class="line">p[<span class="number">0</span>] = ‘X’; <span class="comment">// 编译器不能发现该错误，但运行时产生[Bus error]</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h5 id="内容复制与比较"><a href="#内容复制与比较" class="headerlink" title="内容复制与比较"></a>内容复制与比较</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组… </span></span><br><span class="line"><span class="keyword">char</span> a[] = <span class="string">&quot;hello&quot;</span>; </span><br><span class="line"><span class="keyword">char</span> b[<span class="number">10</span>]; </span><br><span class="line"><span class="built_in">strcpy</span>(b, a); <span class="comment">// 不能用 b = a; </span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(b, a) == <span class="number">0</span>) <span class="comment">// 不能用 if (b == a) </span></span><br><span class="line">… </span><br><span class="line"><span class="comment">// 指针… </span></span><br><span class="line"><span class="comment">// 语句 p = a 并不能把 a 的内容复制给指针 p，而是把 a 的地址赋给了 p。</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(a); </span><br><span class="line"><span class="keyword">char</span> *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*(len+<span class="number">1</span>)); </span><br><span class="line"><span class="built_in">strcpy</span>(p, a); <span class="comment">// 不要用 p = a; </span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(p, a) == <span class="number">0</span>) <span class="comment">// 不要用 if (p == a) </span></span><br></pre></td></tr></table></figure><h5 id="计算内存容量"><a href="#计算内存容量" class="headerlink" title="计算内存容量"></a>计算内存容量</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[] = <span class="string">&quot;hello world&quot;</span>; </span><br><span class="line"><span class="keyword">char</span> *p = a; </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(a) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 12 字节</span></span><br><span class="line"><span class="comment">// sizeof(p) 等价于 sizeof(char *)，没有办法的值指针所指的内存容量，除非申请内存时就记住它</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(p) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 4 字节</span></span><br></pre></td></tr></table></figure><p>注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(<span class="keyword">char</span> a[<span class="number">100</span>])</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// 不论数组 a 的容量是多少，sizeof(a)始终等于 sizeof(char *)。</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(a) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 4 字节而不是 100 字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="指针参数如何传递内存"><a href="#指针参数如何传递内存" class="headerlink" title="指针参数如何传递内存"></a>指针参数如何传递内存</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetMemory</span><span class="params">(<span class="keyword">char</span> *p, <span class="keyword">int</span> num)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    p = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * num); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>; </span><br><span class="line">    GetMemory(str, <span class="number">100</span>); <span class="comment">// str 仍然为 NULL </span></span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello&quot;</span>); <span class="comment">// 运行错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/11/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.htm/函数参数副本.png" alt></p><p>如果函数的参数是一个指针，不要指望用该指针去申请动态内存。编译器总是要为函数的每个参数制作临时副本，指针参数 p 的副本是 _p，编译器使 _p = p。如果函数体内的程序修改了_p 的内容，就导致参数 p 的内容作相应的修改。这就是指针可以用作输出参数的原因。_p 申请了新的内存，只是把 _p 所指的内存地址改变了，但是 p 丝毫未变。所以函数 GetMemory 并不能输出任何东西。事实上，每执行一次 GetMemory 就会泄露一块内存，因为没有用 free 释放内存。</p><p>如果非得要用指针参数去申请内存，那么应该改用“指向指针的指针”:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetMemory2</span><span class="params">(<span class="keyword">char</span> **p, <span class="keyword">int</span> num)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * num); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test2</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>; </span><br><span class="line">    GetMemory2(&amp;str, <span class="number">100</span>); <span class="comment">// 注意参数是 &amp;str，而不是 str </span></span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello&quot;</span>); </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; str &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">free</span>(str); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="/2020/11/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.htm/指针的指针.png" alt></p><p>比较好的方法是 <strong>传指针的引用</strong>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetMemory</span><span class="params">(<span class="keyword">char</span> *&amp;p, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    GetMemory(str, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">free</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以用函数返回值来传递动态内存。这种方法更加简单：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">GetMemory3</span><span class="params">(<span class="keyword">int</span> num)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * num); </span><br><span class="line">    <span class="keyword">return</span> p; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test3</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>; </span><br><span class="line">    str = GetMemory3(<span class="number">100</span>); </span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello&quot;</span>); </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; str &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">free</span>(str); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在使用返回值时，千万别返回 <strong>指向“栈内存”</strong> 的指针、引用，因为该内存在函数结束时 <strong>自动消亡</strong> 了，返回的指针是个野指针了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">GetString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> p[] = <span class="string">&quot;hello world&quot;</span>; <span class="comment">//数组内容存储在栈区，函数结束时，会释放掉</span></span><br><span class="line">     <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    str = GetString();      <span class="comment">//因为非配的内存早已释放掉，此时的str是个野指针，内容是垃圾</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在函数中不定义数组，定义指针：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">GetString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> *p = <span class="string">&quot;hello world&quot;</span>; <span class="comment">//数组内容存储在静态区，函数结束时，不会释放掉</span></span><br><span class="line">     <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    str = GetString();      </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h4 id="杜绝“野指针”"><a href="#杜绝“野指针”" class="headerlink" title="杜绝“野指针”"></a>杜绝“野指针”</h4><p>“野指针”不是 NULL 指针，是指向“垃圾”内存的指针。“野指针”是很危险的，if 语句对它不起作用。出现的原因有：</p><ol><li>指针变量没有被初始化。任何指针变量刚被创建时不会自动成为 NULL 指针，它的缺省值是随机的。所以，指针变量在创建的同时应当被初始化，要么将指针设置为 NULL，要么让它指向合法的内存。</li><li>指针 p 被 free 或者 delete 之后，没有置为 NULL，让人误以为 p 是个合法的指针。</li><li>指针操作超越了变量的作用域范围。</li></ol><h4 id="有了-malloc-free-为什么还要-new-delete？"><a href="#有了-malloc-free-为什么还要-new-delete？" class="headerlink" title="有了 malloc/free 为什么还要 new/delete？"></a>有了 malloc/free 为什么还要 new/delete？</h4><p><strong>malloc 与 free</strong> 是 C++/C 语言的标准库函数，<strong>new/delete</strong> 是 C++ 的运算符。它们都可用于申请动态内存和释放内存。<br>对于非内部数据类型的对象而言，光用 <strong>malloc/free</strong> 无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于 <strong>malloc/free</strong> 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于 <strong>malloc/free</strong>。<br>而C++程序经常要调用 C 函数，而 C 程序只能用 <strong>malloc/free</strong> 管理动态内存，因此不能只用 <strong>new/delete</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">public</span> : </span><br><span class="line">    Obj(<span class="keyword">void</span>)&#123; <span class="built_in">cout</span> &lt;&lt; “Initialization” &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">    ~Obj(<span class="keyword">void</span>)&#123; <span class="built_in">cout</span> &lt;&lt; “Destroy” &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Initialize</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; “Initialization” &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Destroy</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; “Destroy” &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UseMallocFree</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Obj *a = (obj *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(obj)); <span class="comment">// 申请动态内存</span></span><br><span class="line">    a-&gt;Initialize(); <span class="comment">// 初始化</span></span><br><span class="line">    <span class="comment">//… </span></span><br><span class="line">    a-&gt;Destroy(); <span class="comment">// 清除工作</span></span><br><span class="line">    <span class="built_in">free</span>(a); <span class="comment">// 释放内存</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UseNewDelete</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Obj *a = <span class="keyword">new</span> Obj; <span class="comment">// 申请动态内存并且初始化</span></span><br><span class="line">    <span class="comment">//… </span></span><br><span class="line">    <span class="keyword">delete</span> a; <span class="comment">// 清除并且释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内存耗尽怎么办？"><a href="#内存耗尽怎么办？" class="headerlink" title="内存耗尽怎么办？"></a>内存耗尽怎么办？</h4><p>如果在申请动态内存时找不到足够大的内存块，<strong>malloc</strong> 和 <strong>new</strong> 将返回 <strong>NULL</strong> 指针，表示内存申请失败。<br>处理“内存耗尽”问题，一般可以通过判断指针是否为 <strong>NULL</strong>，是的话用 <strong>return</strong> 或 <strong>exit(1)</strong> 终止整个程序的运行，也可以自己为 <strong>new 和 molloc</strong> 设置异常处理函数。<br>如果一个函数内有多处需要申请动态内存，那么应该用 <strong>exit(1)</strong> 及时终止程序。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;内存管理&quot;&gt;&lt;a href=&quot;#内存管理&quot; class=&quot;headerlink&quot; title=&quot;内存管理&quot;&gt;&lt;/a&gt;内存管理&lt;/h2&gt;&lt;h3 id=&quot;内存管理详解&quot;&gt;&lt;a href=&quot;#内存管理详解&quot; class=&quot;headerlink&quot; title=&quot;内存管理详解&quot;&gt;&lt;/a&gt;内存管理详解&lt;/h3&gt;&lt;h4 id=&quot;内存分配方式&quot;&gt;&lt;a href=&quot;#内存分配方式&quot; class=&quot;headerlink&quot; title=&quot;内存分配方式&quot;&gt;&lt;/a&gt;内存分配方式&lt;/h4&gt;&lt;h5 id=&quot;分配方式简介&quot;&gt;&lt;a href=&quot;#分配方式简介&quot; class=&quot;headerlink&quot; title=&quot;分配方式简介&quot;&gt;&lt;/a&gt;分配方式简介&lt;/h5&gt;&lt;p&gt;在C++中，内存分为5个区：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;栈：执行函数时，函数内部局部变量存储单元在栈上创建，结束时自动释放。效率很高，但存储容量有限。&lt;/li&gt;
&lt;li&gt;堆：由 &lt;strong&gt;new&lt;/strong&gt; 分配的内存块，编译器不会自动释放，需要应用程序对应的 &lt;strong&gt;delete&lt;/strong&gt; 进行释放。如果没有释放，则程序运行结束后会由操作系统自动回收。&lt;/li&gt;
&lt;li&gt;自由存储区：由 &lt;strong&gt;malloc&lt;/strong&gt; 等分配的内存块，类似堆，由 &lt;strong&gt;free&lt;/strong&gt; 结束自己的生命。&lt;/li&gt;
&lt;li&gt;全局/静态存储区：存储全局变量和静态变量。&lt;/li&gt;
&lt;li&gt;常量存储区：存放常量，不允许修改。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="C++" scheme="https://www.benboby.top/categories/C/"/>
    
    
    <category term="C++内存管理" scheme="https://www.benboby.top/tags/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>树状数组经典题</title>
    <link href="https://www.benboby.top/2020/10/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%BB%8F%E5%85%B8%E9%A2%98.html"/>
    <id>https://www.benboby.top/2020/10/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%BB%8F%E5%85%B8%E9%A2%98.html</id>
    <published>2020-10-30T14:31:09.000Z</published>
    <updated>2021-01-28T06:02:23.341Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一个简单的整数问题"><a href="#一个简单的整数问题" class="headerlink" title="一个简单的整数问题"></a>一个简单的整数问题</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>第一类指令形如 “C-l-r-d”，表示把数列中第 $l-r$ 个数都加 $d$。</p><p>第二类指令形如 “Q-X”，表示询问数列中第 $x$ 个数的值。<br><a id="more"></a> </p><p>对于每个询问，输出一个整数表示答案。</p><p>数据范围：$(n, m \in [1, 100000])$</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>用树状数组解决动态差分问题。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">ll c[N], a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">        c[x] += y;</span><br><span class="line">        x += lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        sum += c[x];</span><br><span class="line">        x -= lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">int</span> x, y, z;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">&quot;Q&quot;</span>) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; query(x) + a[x] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">            add(x, z);</span><br><span class="line">            add(y + <span class="number">1</span>, -z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="谜一样的牛"><a href="#谜一样的牛" class="headerlink" title="谜一样的牛"></a>谜一样的牛</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定序列长度 $n$ 和 数组 $a$，$a[i]$ 表示第 $i$ 个数前面有多少个数比它小，复原原序列，原序列为 $1-n$ 的排列。$(n \in [1, 100000])$</p><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>最后一个数的大小明显是一开始就可以推断出来的，假设其大小是 $x$，接着从 $1-n$ 这 $n$ 个数字中把 $x$ 删掉，然后再看倒数第二个数，假设其前面有 $y$ 个数比它小，说明这个数是剩下的数里面第 $y + 1$ 大的数。</p><p>由此可以发现，我们可以倒推过来，第 $i$ 个数的大小便是当前还没有被选的数中第 $a[i] + 1$ 小的数。</p><p>可以使用树状数组解决，将每个位置置为 $1$ 表示未被选，$0$ 表示已被选，得到的前缀和是单调递增的，因此每次只需要二分查找满足前缀和刚好等于 $a[i] + 1$ 的位置即为当前数的大小。</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, c[N], a[N], res[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">        c[x] += y;</span><br><span class="line">        x += lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        sum += c[x];</span><br><span class="line">        x -= lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    add(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        add(i, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n + <span class="number">1</span>, mid;</span><br><span class="line">        <span class="keyword">while</span> (l + <span class="number">1</span> &lt; r) &#123;</span><br><span class="line">            mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (query(mid) &lt; a[i] + <span class="number">1</span>) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        res[i] = r;</span><br><span class="line">        add(r, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cout</span> &lt;&lt; res[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一个简单的整数问题&quot;&gt;&lt;a href=&quot;#一个简单的整数问题&quot; class=&quot;headerlink&quot; title=&quot;一个简单的整数问题&quot;&gt;&lt;/a&gt;一个简单的整数问题&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;第一类指令形如 “C-l-r-d”，表示把数列中第 $l-r$ 个数都加 $d$。&lt;/p&gt;
&lt;p&gt;第二类指令形如 “Q-X”，表示询问数列中第 $x$ 个数的值。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://www.benboby.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="树状数组" scheme="https://www.benboby.top/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>并查集拓展</title>
    <link href="https://www.benboby.top/2020/10/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%8B%93%E5%B1%95.html"/>
    <id>https://www.benboby.top/2020/10/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%8B%93%E5%B1%95.html</id>
    <published>2020-10-29T10:45:57.000Z</published>
    <updated>2021-01-28T06:02:23.325Z</updated>
    
    <content type="html"><![CDATA[<h2 id="边带权"><a href="#边带权" class="headerlink" title="边带权"></a>边带权</h2><h3 id="银河英雄传说"><a href="#银河英雄传说" class="headerlink" title="银河英雄传说"></a>银河英雄传说</h3><p>有 $T$ 条指令，每条指令格式为以下两种之一：</p><ol><li><p>$M-i-j$，表示让第 $i$ 号战舰所在列的全部战舰保持原有顺序，接在第 $j$ 号战舰所在列的尾部。</p><a id="more"></a> </li><li><p>$C-i-j$，表示询问第 $i$ 号战舰与第 $j$ 号战舰当前是否处于同一列中，如果在同一列中，它们之间间隔了多少艘战舰。</p></li></ol><p>数据范围：$N≤30000, T≤500000$</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>维护数组 $dp$ 表示 $i$ 到 $root$ 的距离，那么查询的答案便是 $abs(dp[a] - dp[b]) - 1$。</p><p>当 $a$ 向 $b$ 连一条边时，有 $fa[a] = b$，此时根结点 $a$ 的深度会增加 $b$ 的集合大小，因此我们需要一个 $sz$ 数组维护集合大小。</p><p>同时在进行路径压缩时，对于未更新的结点也要一同更新深度。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[N], sz[N], fa[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != fa[x]) &#123;</span><br><span class="line">        <span class="keyword">int</span> root = find(fa[x]);</span><br><span class="line">        dp[x] += dp[fa[x]];</span><br><span class="line">        fa[x] = root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t, a, b;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">30000</span>; i++) &#123;</span><br><span class="line">        dp[i] = <span class="number">0</span>;</span><br><span class="line">        sz[i] = <span class="number">1</span>;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">int</span> pa = find(a), pb = find(b);</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">&quot;M&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pa != pb) &#123;</span><br><span class="line">                fa[pa] = pb;</span><br><span class="line">                dp[pa] = sz[pb];</span><br><span class="line">                sz[pb] += sz[pa];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (pa != pb) <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; max(<span class="built_in">abs</span>(dp[a] - dp[b]) - <span class="number">1</span>, <span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓展域"><a href="#拓展域" class="headerlink" title="拓展域"></a>拓展域</h2><h3 id="食物链"><a href="#食物链" class="headerlink" title="食物链"></a>食物链</h3><p>动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。</p><ol><li><p>$1-X-Y$，表示 $X$ 和 $Y$ 是同类。</p></li><li><p>$2-X-Y$，表示 $X$ 吃 $Y$。</p></li></ol><p>判断有多少句假话。$(1≤N≤50000,0≤K≤100000)$</p><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>$1-n$ 表示动物 $i$ 的同类，$n+1-2n$ 表示动物 $i$ 的猎物，$2n+1 - 3n$ 表示动物 $i$ 的天敌。</p><p>对于操作1: 查询 $x$ 和 $y$ 的天敌域，猎物域是不是在一个集合，是则累加答案，否则进行合并。</p><p>对于操作2: 查询 $x$ 和 $y$ 的同类域，猎物域是不是在一个集合，是则累加答案，否则进行合并。</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">1000005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != fa[x]) </span><br><span class="line">        fa[x] = find(fa[x]);</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    a = find(a), b = find(b);</span><br><span class="line">    <span class="keyword">if</span> (a != b) fa[a] = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k, a, b, c, res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;  i &lt;= n * <span class="number">3</span>; i++) fa[i] = i;</span><br><span class="line">    <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; c &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; n || b &gt; n) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (find(a) == find(b + n) || find(a) == find(b + <span class="number">2</span> * n)) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/// a和b是同类，a和b的猎物也是同类，a和b的天敌也是同类</span></span><br><span class="line">                join(a, b);</span><br><span class="line">                join(a + n, b + n);</span><br><span class="line">                join(a + <span class="number">2</span> * n, b + <span class="number">2</span> * n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (a == b || find(a) == find(b) || find(a) == find(b + n)) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/// a的猎物是b， b的天敌是a，b的猎物是a的天敌</span></span><br><span class="line">                join(a, b + <span class="number">2</span> * n);</span><br><span class="line">                join(a + n, b);</span><br><span class="line">                join(a + <span class="number">2</span> * n, b + n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="奇偶游戏"><a href="#奇偶游戏" class="headerlink" title="奇偶游戏"></a>奇偶游戏</h3><p>给你 $m$ 个询问，每一个询问给出一个区间的左右端点和区间中的 $1$ 的数量的奇偶性，输出不出现矛盾的最大的 $k$ 值，即 $1-k$ 无矛盾，$1- k + 1$ 矛盾。$(N≤10^9,M≤10000)$</p><h3 id="Solution1（边带权）"><a href="#Solution1（边带权）" class="headerlink" title="Solution1（边带权）"></a>Solution1（边带权）</h3><ol><li>我们可以用 $sum$ 数组表示序列 S 的前缀和,那么会得到以下性质.</li></ol><p>$s[l~r]$ 有偶数个 $1$，等价于 $sum[l-1]$ 与 $sum[r]$ 奇偶性相同 $(1+0=1,0+0=0,1是奇数,0是偶数)$<br>$s[l~r]$ 有奇数个 $1$，等价于 $sum[l-1]$ 与 $sum[r]$ 奇偶性不同 $(1+1=0,0+1=0,1是奇数,0是偶数)$</p><ol><li><p>根据传递性，可以使用边带权，边权 $d[x] = 0$，表示 $x$ 与 $f[x]$ 的奇偶性相同; 为 $1$，表示 $x$ 与 $fa[x]$ 的奇偶性不同,在路径压缩的过程中,对 $x$ 到树根路径的所有边权做异或$(xor)$。</p></li><li><p>对于每个问题, 设离散化后 $l - 1$ 和 $r$ 的值分别是 $x$ 和 $y$ , 设 $c$ 表示当前问题的回答($c = 0$ 表示偶数个, $c = 1$ 表示奇数个)</p></li></ol><p>若 $x$ 和 $y$ 在一个集合中, 直接判断 $d[x] xor d[y]$ 是否等于 $c$，若不等于,则矛盾，直接输出结果。</p><p>若 $x$ 和 $y$ 不在一个集合中，说明无法判断，此时合并两个集合，得到俩个的树根 $p$ 和 $q$, $d[x]$ 与 $d[y]$ 分别表示 $x - p$ 与 $y - q$ 之间所有边权的 “xor” 和，$p - q$ 之间的边权为 $d[p]$, 显然, 路径 $x - y$ 由 $x - p$, $p - q$, $q - y$ 组成，所以 $x$ 与 $y$ 的奇偶性关系 $c = d[x] (xor) d[y] (xor) d[p]$，得到 $d[p] = d[x] (xor) d[y] (xor) c$。</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[N], d[N];</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">&#125; q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != fa[x]) &#123;</span><br><span class="line">        <span class="keyword">int</span> root = find(fa[x]);</span><br><span class="line">        d[x] ^= d[fa[x]];</span><br><span class="line">        fa[x] = root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L, n, a, b, pa, pb;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; L &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; q[i].a &gt;&gt; q[i].b &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;e&#x27;</span>) q[i].c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> q[i].c = <span class="number">1</span>;</span><br><span class="line">        g.push_back(q[i].a - <span class="number">1</span>);</span><br><span class="line">        g.push_back(q[i].b);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(g.begin(), g.end());</span><br><span class="line">    g.erase(unique(g.begin(), g.end()), g.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= (<span class="keyword">int</span>)g.size(); i++) &#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">        mp[g[i - <span class="number">1</span>]] = i;</span><br><span class="line">        d[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= n; i++) &#123;</span><br><span class="line">        a = mp[q[i].a - <span class="number">1</span>], b = mp[q[i].b];</span><br><span class="line">        pa = find(a), pb = find(b);</span><br><span class="line">        <span class="keyword">if</span> (pa != pb) &#123;</span><br><span class="line">            fa[pa] = pb;</span><br><span class="line">            d[pa] ^= d[a] ^ d[b] ^ q[i].c;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (d[a] ^ d[b] != q[i].c) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i - <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Solution2（拓展域）"><a href="#Solution2（拓展域）" class="headerlink" title="Solution2（拓展域）"></a>Solution2（拓展域）</h3><p>$1 - n$ 表示 $sum[i]$ 为奇，$n + 1 - 2 * n$ 表示 $sum[i]$ 为偶。</p><p>当查询区间为奇数时：判断 $a$ 的奇数域是否与 $b$ 的奇数域同在一个集合，是则矛盾，否则合并 $a$ 的奇数域与 $b$ 的偶数域，$a$ 的偶数域与 $b$ 的奇数域。</p><p>当查询区间为偶数时：判断 $a$ 的奇数域是否与 $b$ 的偶数域同在一个集合，是则矛盾，否则合并 $a,b$ 的奇数域和偶数域。</p><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">&#125; q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != fa[x]) </span><br><span class="line">        fa[x] = find(fa[x]);</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x = find(x), y = find(y);</span><br><span class="line">    <span class="keyword">if</span> (x != y) fa[x] = y;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L, m, n, a, b;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; L &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; q[i].a &gt;&gt; q[i].b &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">&quot;even&quot;</span>) q[i].c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> q[i].c = <span class="number">1</span>;</span><br><span class="line">        g.push_back(q[i].a - <span class="number">1</span>);</span><br><span class="line">        g.push_back(q[i].b);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(g.begin(), g.end());</span><br><span class="line">    g.erase(unique(g.begin(), g.end()), g.end());</span><br><span class="line">    n = g.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        mp[g[i - <span class="number">1</span>]] = i;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">        fa[i + n] = i + n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= m; i++) &#123;</span><br><span class="line">        a = mp[q[i].a - <span class="number">1</span>], b = mp[q[i].b];</span><br><span class="line">        <span class="keyword">if</span> (q[i].c) &#123;</span><br><span class="line">            <span class="keyword">if</span> (find(a) == find(b) || find(a + n) == find(b + n)) <span class="keyword">break</span>;</span><br><span class="line">            join(a, b + n); <span class="comment">// 合并a的奇数域和b的偶数域</span></span><br><span class="line">            join(a + n, b); <span class="comment">// 合并a的偶数域和a的奇数域</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (find(a) == find(b + n) || find(a + n) == find(b)) <span class="keyword">break</span>;</span><br><span class="line">            join(a, b);     <span class="comment">// 合并a的奇数域和b的奇数域</span></span><br><span class="line">            join(a + n, b + n);  <span class="comment">// 合并a的偶数域和b的偶数域</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i - <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反向并查集"><a href="#反向并查集" class="headerlink" title="反向并查集"></a>反向并查集</h2><h3 id="星球大战"><a href="#星球大战" class="headerlink" title="星球大战"></a>星球大战</h3><p>求每次拆边后的连通块个数。$(m \in [1, 2e5], n \in [1, 2*m])$</p><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>拆边很难维护集合数量，考虑离线后反过来建图。这样便相当于每次增加增加一条边，查询两个点是否为同一个集合即可知道集合数量是否减少。</p><h3 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k, pre[N], b[N], vis[N];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = x, j = x;</span><br><span class="line">  <span class="keyword">while</span> (i != pre[i])</span><br><span class="line">    i = pre[i];</span><br><span class="line">  <span class="keyword">while</span> (i != j) &#123;</span><br><span class="line">    <span class="keyword">int</span> temp = pre[j];</span><br><span class="line">    pre[j] = i;</span><br><span class="line">    j = temp;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> fx = find(x), fy = find(y);</span><br><span class="line">  <span class="keyword">if</span> (fx != fy) &#123;</span><br><span class="line">    pre[fx] = fy;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    pre[i] = i;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    g[x].push_back(y);</span><br><span class="line">    g[y].push_back(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">    vis[b[i]] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> res = n - k;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; g[i].size(); j++) &#123;</span><br><span class="line">      <span class="keyword">int</span> x = g[i][j];</span><br><span class="line">      <span class="keyword">if</span> (!vis[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (join(i, x)) res--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  b[k + <span class="number">1</span>] = res;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">    res++;</span><br><span class="line">    vis[b[i]] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; g[b[i]].size(); j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!vis[g[b[i]][j]] &amp;&amp; join(b[i], g[b[i]][j])) </span><br><span class="line">        res--;</span><br><span class="line">    &#125;</span><br><span class="line">    b[i] = res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k + <span class="number">1</span>; i++) </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Total-Eclipse"><a href="#Total-Eclipse" class="headerlink" title="Total Eclipse"></a>Total Eclipse</h3><p>给你 $n$ 个节点 $m$ 条边的图，每个点有一个权值，你现在要做的操作是选择一个连通图，并将其中的每一个点的权值都减一，问你最少需要多少次才能将所有的点都变为0。$(1≤n≤100000, 1≤m≤200000)$</p><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>贪心地想，每次必然是选择权值最小的点，然后联通的边都减少该权值，但这样很难维护，因此可以考虑反向。</p><p>每次选择权值最大的点，然后这个点需要减少到和次小的点一样的权值，即减少的权值为和次小点权值之差。由于一次可以减少一个联通块，因此我们只需要乘以当前点联通块个数即可。</p><h3 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, n, m, pre[N], vis[N];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> w;</span><br><span class="line">  <span class="keyword">int</span> id;</span><br><span class="line">&#125; q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node x, Node y)</span> </span>&#123; <span class="keyword">return</span> x.w &gt; y.w; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = x, j = x;</span><br><span class="line">  <span class="keyword">while</span> (i != pre[i]) i = pre[i];</span><br><span class="line">  <span class="keyword">while</span> (j != i) &#123;</span><br><span class="line">    <span class="keyword">int</span> temp = pre[j];</span><br><span class="line">    pre[j] = i;</span><br><span class="line">    j = temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> fx = find(x), fy = find(y);</span><br><span class="line">  <span class="keyword">if</span> (fx != fy) &#123;</span><br><span class="line">    pre[fx] = fy;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">  <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;q[i].w);</span><br><span class="line">      q[i].id = i;</span><br><span class="line">      pre[i] = i;</span><br><span class="line">      g[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> u, v;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">      g[u].push_back(v);</span><br><span class="line">      g[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> cnt = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + n + <span class="number">1</span>, cmp);</span><br><span class="line">    q[n + <span class="number">1</span>].w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      cnt++;</span><br><span class="line">      vis[q[i].id] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> x : g[q[i].id]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[x] &amp;&amp; join(x, q[i].id)) cnt--;</span><br><span class="line">      &#125;</span><br><span class="line">      res += cnt * (q[i].w - q[i + <span class="number">1</span>].w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;边带权&quot;&gt;&lt;a href=&quot;#边带权&quot; class=&quot;headerlink&quot; title=&quot;边带权&quot;&gt;&lt;/a&gt;边带权&lt;/h2&gt;&lt;h3 id=&quot;银河英雄传说&quot;&gt;&lt;a href=&quot;#银河英雄传说&quot; class=&quot;headerlink&quot; title=&quot;银河英雄传说&quot;&gt;&lt;/a&gt;银河英雄传说&lt;/h3&gt;&lt;p&gt;有 $T$ 条指令，每条指令格式为以下两种之一：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;$M-i-j$，表示让第 $i$ 号战舰所在列的全部战舰保持原有顺序，接在第 $j$ 号战舰所在列的尾部。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://www.benboby.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="并查集" scheme="https://www.benboby.top/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：编辑距离</title>
    <link href="https://www.benboby.top/2020/10/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.html"/>
    <id>https://www.benboby.top/2020/10/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.html</id>
    <published>2020-10-12T04:56:27.000Z</published>
    <updated>2021-01-28T06:02:23.349Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两个单词 $a$ 和 $b$，请你计算出将 $a$ 转换成 $b$ 所使用的最少操作数。</p><p>你可以对一个单词进行如下三种操作：</p><ol><li>插入一个字符<a id="more"></a> </li><li>删除一个字符</li><li>替换一个字符</li></ol><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>$dp[i][j]$ 表示 $a$ 的前 $i$ 个字母和 $b$ 的前 $j$ 个字母匹配的最少操作次数。</p><p>可以从三种状态转移过来：</p><p>$dp[i][j] = dp[i - 1][j] + 1$    在 $b[j]$ 后面插入一个字符 $a[i]$</p><p>$dp[i][j] = dp[i][j - 1] + 1$    在 $a[i]$ 后面插入一个字符 $b[j]$</p><p>$dp[i][j] = dp[i - 1][j - 1] + (a[i - 1] != b[j - 1])$    修改一个字符</p><p>选择最小的操作步数进行转移即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.size();</span><br><span class="line">        <span class="keyword">int</span> m = b.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">            dp[<span class="number">0</span>][i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = dp[i - <span class="number">1</span>][j] + <span class="number">1</span>;   <span class="comment">// 在 b[j] 后面插入一个字符 a[i]</span></span><br><span class="line">                <span class="keyword">int</span> y = dp[i][j - <span class="number">1</span>] + <span class="number">1</span>;   <span class="comment">// 在 a[i] 后面插入一个字符 b[j]</span></span><br><span class="line">                <span class="keyword">int</span> z = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + (a[i - <span class="number">1</span>] != b[j - <span class="number">1</span>]);   <span class="comment">// 修改一个字符</span></span><br><span class="line">                dp[i][j] = min(&#123;x, y, z&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你两个单词 $a$ 和 $b$，请你计算出将 $a$ 转换成 $b$ 所使用的最少操作数。&lt;/p&gt;
&lt;p&gt;你可以对一个单词进行如下三种操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;插入一个字符&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="每日一题" scheme="https://www.benboby.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="动态规划" scheme="https://www.benboby.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>二维差分</title>
    <link href="https://www.benboby.top/2020/10/%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86.html"/>
    <id>https://www.benboby.top/2020/10/%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86.html</id>
    <published>2020-10-11T14:14:07.000Z</published>
    <updated>2021-01-28T06:02:23.322Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="/2020/10/%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86.htm/二维差分.png" alt="avatar"></p><p>紫色部分为所求区域，黄色区域为当前覆盖的区域。</p><p>$d[x1][y1] += w$ 表示将 $[x1, y1]$ 右下部分全部加上增量 $w$。<br><a id="more"></a> </p><p>$d[x1][y2 + 1] -= w$ 用于抵消对 $y2$ 右边元素的影响，即图三蓝色区域。</p><p>$d[x2 + 1][y1] -= w$ 用于抵消对 $x2$ 下边元素的影响，即图四蓝色区域。</p><p>$d[x2 + 1][y2 + 1] += w$ 由于绿色区域被抵消了两次，因此需要加回增量 $w$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1005</span>][<span class="number">1005</span>], d[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, m, q, x1, y1, x2, y2, w;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) <span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">  <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; w;</span><br><span class="line">    d[x1][y1] += w;</span><br><span class="line">    d[x1][y2 + <span class="number">1</span>] -= w;</span><br><span class="line">    d[x2 + <span class="number">1</span>][y1] -= w;</span><br><span class="line">    d[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += w;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">      d[i][j] -= d[i - <span class="number">1</span>][j - <span class="number">1</span>] - d[i - <span class="number">1</span>][j] - d[i][j - <span class="number">1</span>];</span><br><span class="line">      a[i][j] += d[i][j];</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2020/10/%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86.htm/二维差分.png&quot; alt=&quot;avatar&quot;&gt;&lt;/p&gt;
&lt;p&gt;紫色部分为所求区域，黄色区域为当前覆盖的区域。&lt;/p&gt;
&lt;p&gt;$d[x1][y1] += w$ 表示将 $[x1, y1]$ 右下部分全部加上增量 $w$。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://www.benboby.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>RMQ算法原理及实现</title>
    <link href="https://www.benboby.top/2020/10/RMQ%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0.html"/>
    <id>https://www.benboby.top/2020/10/RMQ%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0.html</id>
    <published>2020-10-10T10:15:34.000Z</published>
    <updated>2021-01-28T06:02:23.318Z</updated>
    
    <content type="html"><![CDATA[<p>RMQ（Range Minimum/Maximum Query），区间最值查询问题，是指：对于长度为 $n$ 的数列A，回答若干次询问 $RMQ(i,j)$，返回数列A中下标在区间 $[i,j]$ 中的最小/大值。</p><p>这里介绍Tarjan的Sparse-Table算法，预处理时间为 $O(nlogn)$，但查询只需要 $O(1)$，并且常数很小，算法也很容易写出。</p><p>1）预处理：</p><p>　设 $A[i]$ 是要求区间最值的数列，$d[i, j]$ 表示从第i个数起连续 $2^j$ 个数中的最小值。(DP的状态)<br><a id="more"></a> </p><p>　显然 $d[i][0]$ 的值就是 $A[i]$ (DP初值)，我们把 $d[i，j]$ 平均分成两段(因为 $d[i，j]$ 一定是偶数个数字)，从 $i$ 到 $i + 2 ^ (j - 1) - 1$ 为一段，$i + 2 ^ (j - 1)$ 到 $i + 2 ^ j - 1$ 为一段(长度都为 $2 ^ (j - 1)$)。于是我们得到了状态转移方程 $d[i, j] = min(d[i，j-1], d[i + 2^(j-1)，j-1])$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RMQ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) d[i][<span class="number">0</span>] = a[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) &lt;= n; ++j)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt; n; ++i)</span><br><span class="line">      d[i][j] = min(d[i][j - <span class="number">1</span>], d[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）查询：</p><p>　假如我们需要查询的区间为 $(i,j)$ ，那么我们需要找到覆盖这个闭区间(左边界取 $i$，右边界取 $j$)的最小幂（可以重复，比如查询1，2，3，4，5，5不是2的任意次方，但我们可以查询1234和2345）。</p><p>　这个查询长度我们取范围小于等于区间长度的最大 $(2^k)$，这样我们查询 $i$ 到 $i + (2^k)$ 与 $j - (2^k) + 1$ 到 $j$ 的值，取二者最小值即可，代码实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; (k + <span class="number">1</span>)) &lt;= R - L + <span class="number">1</span>) ++k;</span><br><span class="line">  <span class="keyword">return</span> min(d[L][k], d[R - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;RMQ（Range Minimum/Maximum Query），区间最值查询问题，是指：对于长度为 $n$ 的数列A，回答若干次询问 $RMQ(i,j)$，返回数列A中下标在区间 $[i,j]$ 中的最小/大值。&lt;/p&gt;
&lt;p&gt;这里介绍Tarjan的Sparse-Table算法，预处理时间为 $O(nlogn)$，但查询只需要 $O(1)$，并且常数很小，算法也很容易写出。&lt;/p&gt;
&lt;p&gt;1）预处理：&lt;/p&gt;
&lt;p&gt;　设 $A[i]$ 是要求区间最值的数列，$d[i, j]$ 表示从第i个数起连续 $2^j$ 个数中的最小值。(DP的状态)&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://www.benboby.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="RMQ" scheme="https://www.benboby.top/tags/RMQ/"/>
    
  </entry>
  
</feed>
